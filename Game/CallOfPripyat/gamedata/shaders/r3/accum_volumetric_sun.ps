#include "common.h"

/*
	Basic volumetric lighting for directional light sources

    Author:
        @LVutner

	Credits:
		@iryoku - IGN
		@MJP - Cheap PCF filter for shadowmaps

    Info:
        Name is self explanatory.
*/

//Quality tokens
#ifdef SUN_SHAFTS_QUALITY
	#if SUN_SHAFTS_QUALITY==1
		#define VL_SAMPLES 16
	#elif SUN_SHAFTS_QUALITY==2
		#define VL_SAMPLES 24
	#elif SUN_SHAFTS_QUALITY==3
		#define VL_SAMPLES 32
	#endif
#endif

#include "shadow.h"

float4 sun_shafts_intensity; //Sun shafts intensity from weather configs and commands

//http://the-witness.net/news/2013/09/shadow-mapping-summary-part-1/
//https://github.com/TheRealMJP
float sample_vl_shadows(float3 tc)
{
	tc.z -= 0.00035; 
    float2 shadow_res = float2(SMAP_size, 1.0 / SMAP_size);

	float2 uv = tc.xy * shadow_res.x;

    float2 base_uv = floor(uv.xy + 0.5);
    float2 st = (uv.xy + 0.5 - base_uv.xy);

    base_uv -= float2(0.5, 0.5);
    base_uv *= shadow_res.y;
	
	//1st weight
	float2 u_weight = float2(3.0 - 2.0 * st.x, 1.0 + 2.0 * st.x);
	float2 u_coord = float2((2.0 - st.x) / u_weight.x - 1.0, st.x / u_weight.y + 1.0);

	//2nd weight
	float2 v_weight = float2(3.0 - 2.0 * st.y, 1.0 + 2.0 * st.y);
	float2 v_coord = float2((2.0 - st.y) / v_weight.x - 1.0, st.y / v_weight.y + 1.0);

	float sum = 0.0;
	sum += u_weight.x * v_weight.x * s_smap.SampleCmpLevelZero(smp_smap, shadow_res.y * float2(u_coord.x, v_coord.x) + base_uv, tc.z).x;
	sum += u_weight.y * v_weight.x * s_smap.SampleCmpLevelZero(smp_smap, shadow_res.y * float2(u_coord.y, v_coord.x) + base_uv, tc.z).x;
	sum += u_weight.x * v_weight.y * s_smap.SampleCmpLevelZero(smp_smap, shadow_res.y * float2(u_coord.x, v_coord.y) + base_uv, tc.z).x;
	sum += u_weight.y * v_weight.y * s_smap.SampleCmpLevelZero(smp_smap, shadow_res.y * float2(u_coord.y, v_coord.y) + base_uv, tc.z).x;

	return sum * 0.0625; //16
}

#ifdef MSAA_OPTIMIZATION
float4 main (v2p_volume I, uint iSample : SV_SAMPLEINDEX) : SV_Target
#else
float4 main (v2p_volume I) : SV_Target
#endif
{
#ifndef	SUN_SHAFTS_QUALITY
	return float4(0.0, 0.0, 0.0, 0.0);
#else

	//Sample depth buffer
#ifndef USE_MSAA
	float depth = s_position.Load(int3(I.hpos.xy, 0)).z;
#else
	float depth = s_position.Load(int3(I.hpos.xy, 0), ISAMPLE).z;
#endif

	//We don't know depth of the sky, so we have to output some constant
	if(depth < 0.0001)
		return sun_shafts_intensity * Ldynamic_color;

	//Reconstruct view space position
	float3 view_position = depth * float3((I.hpos.xy * pos_decompression_params.zw - pos_decompression_params.xy), 1.0);

    //rcp(sample count)
    float rcp_samples = 1.0 / float(VL_SAMPLES);

    //Start and end positions, shadow projection space
    float4 start_position = mul(m_shadow, float4(0.0, 0.0, 0.0, 1.0));
	start_position.xyz *= 1.0 / start_position.w; //Perspective

    float4 end_position = mul(m_shadow, float4(view_position, 1.0));
	end_position.xyz *= 1.0 / end_position.w; //Perspective

	//Dither - IGN by @iryoku (Remap it a tiny bit)
	float dither = frac(52.9829189 * frac(0.06711056 * float(I.hpos.x) + 0.00583715 * float(I.hpos.y))) * 0.5 + 0.5;

    //Ray increment
    float3 ray_increment = rcp_samples * (end_position - start_position);

	//Initial ray position. The first ray is dithered to counteract banding artifacts
    float3 ray_position = start_position.xyz + ray_increment.xyz * dither;

	//Exposure compensation
	float exp_comp = sun_shafts_intensity * rcp_samples;

	//Accumulated samples
    float accum_smap = 0.0;

	//Raymarch
    for(int i = 0; i < VL_SAMPLES; i++)
	{
		//Accumulate shadowmap
		accum_smap += sample_vl_shadows(ray_position);

		//March the ray
		ray_position += ray_increment;
	}

	//Scale it with sun_intensity uniform
	accum_smap *= exp_comp;

	//GSC stuff start
	float fSturation = -Ldynamic_dir.z;
	fSturation = 0.5 * fSturation + 0.5;
	fSturation = 0.80 * fSturation + 0.20;
	accum_smap *= fSturation; //Seems like its sort of attenuation lmao
	//GSC stuff end
	
	//Multiply by sun color and output
	return accum_smap * Ldynamic_color;
#endif //OnOff
}

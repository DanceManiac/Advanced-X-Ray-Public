#include "common.h"
#include "anomaly_shaders.h"

// Check Screen Space Shaders modules
#include "check_screenspace.h"

#ifdef SSFX_DEBAND
	#include "screenspace_debanding.h"
#endif

// Used by FOG and IL. Keep it here for the moment...
uniform float4 fakescope_params3;

#ifdef SSFX_FOG
	#include "screenspace_fog.h"
	#include "settings_screenspace_FOG.h"
#endif

#ifdef SSFX_LUT_INUSE
	#include "screenspace_lut.h"
#endif

//////////////////////////////////////////////////////////////////////////////////////////
#ifndef USE_MSAA
Texture2D 			s_distort;
Texture2D 			s_flares;
#define	EPSDEPTH	0.001
#else
	#ifndef SM_5
		Texture2DMS<float4,MSAA_SAMPLES> s_distort;
		Texture2DMS<float4,MSAA_SAMPLES> s_flares;
	#else
		Texture2DMS<float4>	s_distort;
		Texture2DMS<float4>	s_flares;
	#endif
#define	EPSDEPTH	0.001
#endif
//////////////////////////////////////////////////////////////////////////////////////////
float4 e_barrier;	// x=norm(.8f), y=depth(.1f), z=clr
float4 e_weights;	// x=norm, y=depth, z=clr
float4 e_kernel;	// x=norm, y=depth, z=clr

//////////////////////////////////////////////////////////////////////////////////////////
#include "mblur.h"
#include "img_corrections.h"
#include "tonemapping.h"
//////////////////////////////////////////////////////////////////////////////////////////
// Pixel

struct c2_out
{
	float4	Color : SV_Target;
#ifdef USE_MSAA
	float	Depth : SV_Depth;
#endif
};

c2_out main( v2p_aa_AA I )
{
	c2_out	res;
	res.Color = float4(0,0,0,0);

	int iSample = 0;

	gbuffer_data gbd	= gbuffer_load_data(I.Tex0, I.HPos, iSample );
	
  	float 	depth 	= gbd.P.z;
#ifdef 	USE_DISTORT
#ifndef USE_MSAA
	float4 	distort	= s_distort.Sample(smp_nofilter, I.Tex0);
#else // USE_MSAA
	float4 	distort	= s_distort.Load( int3( I.Tex0 * screen_res.xy, 0 ), iSample );
#endif // USE_MSAA
	float2	offset	= (distort.xy-(127.0h/255.0h))*def_distort;  // fix newtral offset
	float2	center	= I.Tex0 + offset;

	gbuffer_data gbdx	= gbuffer_load_data_offset(I.Tex0, center, I.HPos, iSample);

	float 	depth_x	= gbdx.P.z;
	if ((depth_x+EPSDEPTH)<depth)	center	= I.Tex0;	// discard new sample
#else // USE_DISTORT
	float2	center 	= I.Tex0;
#endif

	float3 img = s_image.Load(int3(center.xy * screen_res.xy, 0),0);

	float4 bloom = s_bloom.Sample(smp_rtlinear,center);

	if (!isSecondVPActive())
		img = mblur( center, ( gbd ).P, img.rgb);

#ifdef SSFX_FOG

	// Calc Fog
	float fogresult = SSFX_CALC_FOG(gbd.P);
	fogresult *= fogresult;

	// Fog Scattering -----------------------
	#ifdef G_FOG_USE_SCATTERING
		// Blur sample
		float3 foggg = s_blur_2.Sample(smp_rtlinear, center);

		// Scopes
		int disablefog = (fakescope_params3.x > 0 ? 0 : 1);

		// NVGs
		#ifdef SSFX_BEEFS_NVG
			disablefog *= (shader_param_8.x > 0 ? 0 : 1);
		#endif

		// Blend
		img = lerp(img, max(img, foggg), smoothstep(0.2f, 0.8f, fogresult) * disablefog);
	#endif
	// --------------------------------------
#endif
	
#ifdef SSFX_DEBAND
	#ifdef SSFX_FOG
		float Debanding = depth <= SKY_EPS ? 1.0 : fogresult;
	#else
		float Debanding = depth <= SKY_EPS ? 1.0 : 0;
	#endif

	// Debanding  - SCREEN SPACE SHADERS - UPDATE 12.5
	img = lerp(img, ssfx_debanding(img, I.Tex0.xy), Debanding);
#endif

	img = blend_soft(img, bloom.xyz*bloom.w);

// Color grading --------------------------------
#ifndef SSFX_ENHANCED_SHADERS
	if (tnmp_onoff == 1.0)
	{		
		img = Uncharted2ToneMapping(img);
	}
#endif

#ifndef USE_MSAA
	float4 	flares	= s_flares.Sample(smp_nofilter, center);
#else // USE_MSAA
	float4 	flares	= s_flares.Load( int3( center * screen_res.xy, 0 ), iSample );
#endif // USE_MSAA
	
    img += flares.xyz * flares.a;

	// Vanilla color grading ( Exposure, saturation and gamma )
	img = img_corrections(img);
	
#ifdef SSFX_LUT_INUSE
	img = ssfx_lut_pp(img);
#endif
// ----------------------------------------------
		
#ifdef 	USE_DISTORT
 	float3	blurred	= bloom*def_hdr	;
			img		= lerp	(img,blurred,distort.z);
#endif
	
		res.Color = float4(img,1.0);
#ifdef USE_MSAA
	float4 ptp = mul(m_P, float4(gbd.P, 1));
	res.Depth = ptp.w==0?1:ptp.z/ptp.w;
#endif
	
	float oluma = dot(res.Color.xyz, LUMINANCE_VECTOR);
	res.Color.xyz = lerp(res.Color.xyz, oluma, -r_color_drag.w) * r_color_drag.xyz;
		
	return res;
}

#if defined(USE_TDETAIL) && defined(USE_4_DETAIL)
#define DEFFER_TERRAIN
#endif
#include "common.h"
#include "sload.h"
#include "settings_screenspace_PUDDLES.h"
#define lerp(a, b, t) mix(a, b, t)

Texture2D s_puddles_normal;
Texture2D s_puddles_perlin;
Texture2D s_puddles_mask;

//Texture2D s_pmask;
	//uniform_sampler2D (s_mask, smp_base);
//uniform sampler2D 	s_mask	: register(s1);

#define	USE_4_DETAIL

#if defined(USE_TDETAIL) && defined(USE_4_DETAIL)
#	define	USE_4_BUMP
float2 UpdateTerrainTC(in p_bumped I, in Texture2D s_dp)
{
	float3	 eye = mul (float3x3(I.M1.x, I.M2.x, I.M3.x,
								 I.M1.y, I.M2.y, I.M3.y,
								 I.M1.z, I.M2.z, I.M3.z), -I.position.xyz);
								 
	float	height	= s_dp.Sample( smp_base, I.tcdbump).w;	//
			height	= height*(parallax.x) + (parallax.y);	//
	float2	new_tc  = I.tcdbump + height * normalize(eye);	//

	return new_tc;
}
#endif

#ifdef USE_4_BUMP
f_deffer 	main	( p_bumped I 	)
#else
f_deffer 	main	( p_flat I 		)
#endif
{
	f_deffer	O;

 	// diffuse
	float4 D		= tbase		(I.tcdh);			// IN:  rgb.a
//	float4 L 	= tex2D		(s_lmap, I.tcdh);
	float4 L 	= s_lmap.Sample( smp_base, I.tcdh);

	float G 	= def_gloss;

# ifdef	USE_TDETAIL
 # ifdef USE_4_DETAIL
//	float4	mask= tex2D		(s_mask, I.tcdh);
	float4	mask= s_mask.Sample ( smp_base, I.tcdh);
	
	float2 tc_r = UpdateTerrainTC(I, s_dp_r);
	float2 tc_g = UpdateTerrainTC(I, s_dp_g);
	float2 tc_b = UpdateTerrainTC(I, s_dp_b);
	float2 tc_a = UpdateTerrainTC(I, s_dp_a);
	
	float 	mag	= dot 		(mask,1);
			mask= mask/mag	;

//	float3	d_R	= tex2D		(s_dt_r, I.tcdbump)*mask.r;
//	float3	d_G	= tex2D		(s_dt_g, I.tcdbump)*mask.g;
//	float3	d_B	= tex2D		(s_dt_b, I.tcdbump)*mask.b;
//	float3	d_A	= tex2D		(s_dt_a, I.tcdbump)*mask.a;
	float3	d_R	= s_dt_r.Sample ( smp_base, tc_r)*mask.r;
	float3	d_G	= s_dt_g.Sample ( smp_base, tc_g)*mask.g;
	float3	d_B	= s_dt_b.Sample ( smp_base, tc_b)*mask.b;
	float3	d_A	= s_dt_a.Sample ( smp_base, tc_a)*mask.a;
	float3	dt	= d_R+d_G+d_B+d_A;
		D.rgb	= 2*D.rgb*dt	 ;

  # ifdef USE_4_BUMP

// 	 float4	n_Rt = tex2D	(s_dn_r, I.tcdbump).wzyx;
//	 float4	n_Gt = tex2D	(s_dn_g, I.tcdbump).wzyx;
//	 float4	n_Bt = tex2D	(s_dn_b, I.tcdbump).wzyx;
//	 float4	n_At = tex2D	(s_dn_a, I.tcdbump).wzyx;
 	 float4	n_Rt = s_dn_r.Sample ( smp_linear, tc_r).wzyx;
	 float4	n_Gt = s_dn_g.Sample ( smp_linear, tc_g).wzyx;
	 float4	n_Bt = s_dn_b.Sample ( smp_linear, tc_b).wzyx;
	 float4	n_At = s_dn_a.Sample ( smp_linear, tc_a).wzyx;
	 
 	 float3	n_R = (n_Rt-0.5)*mask.r; float g_R=n_Rt.w*mask.r;
	 float3	n_G = (n_Gt-0.5)*mask.g; float g_G=n_Gt.w*mask.g;
	 float3	n_B = (n_Bt-0.5)*mask.b; float g_B=n_Bt.w*mask.b;
	 float3	n_A = (n_At-0.5)*mask.a; float g_A=n_At.w*mask.a;

	 float3	mix		= 	n_R+n_G+n_B+n_A;
			mix.z	*=	0.5;		//. make bump twice as contrast (fake, remove me if possible)
			//mix	*=	float3(0.6f, 0.6f, 1); // Adjust bump strength
	 float3	N		= 	mul     	(float3x3(I.M1, I.M2, I.M3), mix.xyz);

	// Wetness factor
	float wetness_f = rain_params.y;

	// Always render puddles if G_PUDDLES_ALLWAYS is defined
	#ifdef G_PUDDLES_ALLWAYS
		wetness_f = 1.0f;
	#endif

	// Intensity factor.
	float puddles_f = wetness_f;

	// Size factor. Convert 0 ~ 1 to 1 ~ -0.1f
	float size_f = (1.0f - (rain_params.y-0.1) * 1.1f);

	// Texture mask
	float puddles_mask = 1.0f - s_puddles_mask.Sample(smp_base, I.tcdh).r * mask.g;

	// Puddles perlin
	float puddles = saturate((s_puddles_perlin.Sample(smp_base, I.tcdh * 15.0f / G_PUDDLES_GLOBAL_SIZE).r - size_f) * puddles_f);

	// Get normals and transform space to create a slope mask
	float3 N1 = mul(float3x3(I.M1, I.M2, I.M3), float3(0,0,1));
	float3 N2 = mul(m_inv_V, normalize(N1));

	// Slope mask
	float slope = max(N2.x, N2.y);

	// Slope adjustements... Some magic numbers
	slope = saturate((slope - 0.997f) * (102.0f + 0.997f));

	// Slope & texture mask defines final puddles intensity
	puddles *= slope * puddles_mask;

	// Puddles border hardness
	puddles = smoothstep(0, saturate(0.3f - G_PUDDLES_BORDER_HARDNESS * 0.3f), puddles);

#ifdef G_PUDDLES_RIPPLES

	float rain_int = saturate(rain_params.x * 1.5f);

	// Ripples movement speed
	float ripples_anim =  timers.x * ((0.01f + (rain_int * 0.008f)) * G_PUDDLES_RIPPLES_SPEED );
	
	// Ripples scale
	float ripples_scale = 140 / G_PUDDLES_RIPPLES_SCALE;

	// Ripples Normal
	float3 WN0 = s_puddles_normal.Sample(smp_base, I.tcdh * ripples_scale + float2(0, ripples_anim));
	float3 WN1 = s_puddles_normal.Sample(smp_base, I.tcdh * ripples_scale - float2(0.33f, ripples_anim));
	float3 ripplesNormal = ((WN0 * 2 - 1) + (WN1 * 2 - 1)) / 2.0f;

	// Ripples Intensity
	ripplesNormal *= (0.05f + rain_int * G_PUDDLES_RIPPLES_RAINING_INT) * G_PUDDLES_RIPPLES_INTENSITY;
#else
	float3 ripplesNormal = 0;
#endif

	// Normal Up and ripples for puddles
	float3 MirrorUp	= mul(m_V,  float3(ripplesNormal.x, 1.0f, ripplesNormal.y));
	N = lerp(N, MirrorUp, puddles);

	// Apply tint
	D.rgb = lerp(D.rgb, D.rgb * G_PUDDLES_TINT, puddles);

	// Limit pudddle reflection.
	puddles = clamp(puddles, 0, G_PUDDLES_REFLECTIVITY);

	// Add at the end the extra wetness. Full intensity at 50% of wetness ( rain_params.y )
	puddles = puddles + saturate(wetness_f * 2.0f) * G_PUDDLES_TERRAIN_EXTRA_WETNESS;

	// Add gloss and puddles to the final gloss result
	G = max(g_R + g_G + g_B + g_A, puddles);
//			G 	= 0			;
//			G 	= mix.w		;		// gloss
  # else
	float3	N 	= I.N.xyz	;
  # endif

 # else
//	D.rgb	= 2*D.rgb*tex2D	(s_detail, I.tcdbump).rgb;
	D.rgb	= 2*D.rgb*s_detail.Sample( smp_base, I.tcdbump).rgb;
 # endif
# else
	float3	N 	= I.N.xyz	;
# endif

	// hemi, sun, material
	float 	ms	= xmaterial	;
# ifdef USE_R2_STATIC_SUN
		 	ms 	= L.w		;
# endif

  // 2. Standart output
  float4     Ne = float4	(normalize(N), 									D.w			);
  O				= pack_gbuffer( 
								Ne,	// hemi
								float4 	(I.position.xyz + Ne.xyz*def_virtualh/2.h, 	0.95f			),	//
								float4	(D.x,	D.y,	D.z,						G			) );	// OUT: rgb.gloss
								
#if defined(USE_TDETAIL) && defined(USE_4_DETAIL)
    O.DWM.x = puddles.r * mask.g;
#endif

  return O;
}

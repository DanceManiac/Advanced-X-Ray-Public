; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	D:\CLEARSKY\sources\engine\xrEngine\Envelope.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_ECEnvelope@@UAEPAXI@Z			; CEnvelope::`vector deleting destructor'
PUBLIC	??_R4CEnvelope@@6B@				; CEnvelope::`RTTI Complete Object Locator'
PUBLIC	??_R3CEnvelope@@8				; CEnvelope::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CEnvelope@@8				; CEnvelope::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CEnvelope@@8			; CEnvelope::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCEnvelope@@@8				; CEnvelope `RTTI Type Descriptor'
PUBLIC	?clear@?$xr_vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@@QAEXXZ ; xr_vector<st_Key *,xalloc<st_Key *> >::clear
PUBLIC	?insert@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEPAPAXPAPAXABQAX@Z ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::insert
PUBLIC	?insert@?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAEPAPAUst_Key@@PAPAU3@ABQAU3@@Z ; stlp_std::vector<st_Key *,xalloc<st_Key *> >::insert
PUBLIC	?to_storage_type_ptr@?$_CastTraits@PAXPAUst_Key@@@priv@stlp_std@@SAPAPAXPAPAUst_Key@@@Z ; stlp_std::priv::_CastTraits<void *,st_Key *>::to_storage_type_ptr
PUBLIC	?erase@?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAEPAPAUst_Key@@PAPAU3@@Z ; stlp_std::vector<st_Key *,xalloc<st_Key *> >::erase
PUBLIC	?Save@st_Key@@QAEXAAVIWriter@@@Z		; st_Key::Save
PUBLIC	?Load_1@st_Key@@QAEXAAVIReader@@@Z		; st_Key::Load_1
PUBLIC	?Load_2@st_Key@@QAEXAAVIReader@@@Z		; st_Key::Load_2
PUBLIC	?resize@?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAEXIABQAUst_Key@@@Z ; stlp_std::vector<st_Key *,xalloc<st_Key *> >::resize
PUBLIC	??A?$xr_vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@@QAEAAPAUst_Key@@I@Z ; xr_vector<st_Key *,xalloc<st_Key *> >::operator[]
PUBLIC	??0st_Key@@QAE@XZ				; st_Key::st_Key
PUBLIC	??$xr_new@Ust_Key@@@@YAPAUst_Key@@XZ		; xr_new<st_Key>
PUBLIC	?equal@st_Key@@QAE_NABU1@@Z			; st_Key::equal
PUBLIC	?begin@?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAEPAPAUst_Key@@XZ ; stlp_std::vector<st_Key *,xalloc<st_Key *> >::begin
PUBLIC	?to_value_type_ptr@?$_CastTraits@PAXPAUst_Key@@@priv@stlp_std@@SAPAPAUst_Key@@PAPAX@Z ; stlp_std::priv::_CastTraits<void *,st_Key *>::to_value_type_ptr
PUBLIC	?end@?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAEPAPAUst_Key@@XZ ; stlp_std::vector<st_Key *,xalloc<st_Key *> >::end
PUBLIC	?empty@?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QBE_NXZ ; stlp_std::vector<st_Key *,xalloc<st_Key *> >::empty
PUBLIC	?front@?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAEAAPAUst_Key@@XZ ; stlp_std::vector<st_Key *,xalloc<st_Key *> >::front
PUBLIC	?to_value_type_ref@?$_CastTraits@PAXPAUst_Key@@@priv@stlp_std@@SAAAPAUst_Key@@AAPAX@Z ; stlp_std::priv::_CastTraits<void *,st_Key *>::to_value_type_ref
PUBLIC	?back@?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAEAAPAUst_Key@@XZ ; stlp_std::vector<st_Key *,xalloc<st_Key *> >::back
PUBLIC	?to_storage_type_cref@?$_CastTraits@PAXPAUst_Key@@@priv@stlp_std@@SAABQAXABQAUst_Key@@@Z ; stlp_std::priv::_CastTraits<void *,st_Key *>::to_storage_type_cref
PUBLIC	?push_back@?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAEXABQAUst_Key@@@Z ; stlp_std::vector<st_Key *,xalloc<st_Key *> >::push_back
PUBLIC	?size@?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QBEIXZ ; stlp_std::vector<st_Key *,xalloc<st_Key *> >::size
PUBLIC	?size@?$xr_vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@@QBEIXZ ; xr_vector<st_Key *,xalloc<st_Key *> >::size
PUBLIC	?clear@?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAEXXZ ; stlp_std::vector<st_Key *,xalloc<st_Key *> >::clear
PUBLIC	?clear_and_free@?$xr_vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@@QAEXXZ ; xr_vector<st_Key *,xalloc<st_Key *> >::clear_and_free
PUBLIC	??$xr_new@Ust_Key@@U1@@@YAPAUst_Key@@ABU0@@Z	; xr_new<st_Key,st_Key>
PUBLIC	??R?$xr_special_free@$0A@Ust_Key@@@@QAEXAAPAUst_Key@@@Z ; xr_special_free<0,st_Key>::operator()
PUBLIC	??$xr_delete@Ust_Key@@@@YAXAAPAUst_Key@@@Z	; xr_delete<st_Key>
PUBLIC	??0?$xalloc@PAUst_Key@@@@QAE@XZ			; xalloc<st_Key *>::xalloc<st_Key *>
PUBLIC	??$?0PAUst_Key@@@?$xalloc@PAX@@QAE@ABV?$xalloc@PAUst_Key@@@@@Z ; xalloc<void *>::xalloc<void *><st_Key *>
PUBLIC	??0?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAE@ABV?$xalloc@PAUst_Key@@@@@Z ; stlp_std::vector<st_Key *,xalloc<st_Key *> >::vector<st_Key *,xalloc<st_Key *> >
PUBLIC	??0?$xr_vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@@QAE@XZ ; xr_vector<st_Key *,xalloc<st_Key *> >::xr_vector<st_Key *,xalloc<st_Key *> >
PUBLIC	??1?$xr_vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@@QAE@XZ ; xr_vector<st_Key *,xalloc<st_Key *> >::~xr_vector<st_Key *,xalloc<st_Key *> >
PUBLIC	??0?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAE@ABV01@@Z ; stlp_std::vector<st_Key *,xalloc<st_Key *> >::vector<st_Key *,xalloc<st_Key *> >
PUBLIC	??1?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAE@XZ ; stlp_std::vector<st_Key *,xalloc<st_Key *> >::~vector<st_Key *,xalloc<st_Key *> >
PUBLIC	??0?$xr_vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@@QAE@ABV0@@Z ; xr_vector<st_Key *,xalloc<st_Key *> >::xr_vector<st_Key *,xalloc<st_Key *> >
PUBLIC	??4?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAEAAV01@ABV01@@Z ; stlp_std::vector<st_Key *,xalloc<st_Key *> >::operator=
PUBLIC	??4?$xr_vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@@QAEAAV0@ABV0@@Z ; xr_vector<st_Key *,xalloc<st_Key *> >::operator=
PUBLIC	??_C@_0L@PDDPJNOG@?$HL?5Envelope?$AA@		; `string'
PUBLIC	??_C@_0BP@MGCNGGP@Key?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?$AA@ ; `string'
PUBLIC	??_C@_0BB@JCNOMHAO@CEnvelope?3?3LoadA?$AA@	; `string'
PUBLIC	??_C@_0DB@FKACCOIF@D?3?2CLEARSKY?2sources?2engine?2xrEng@ ; `string'
PUBLIC	??_C@_06MGBHIFNJ@cnt?$DN?$DN9?$AA@		; `string'
PUBLIC	??_C@_0BA@PAABFJOJ@Behaviors?5?$CFd?5?$CFd?$AA@	; `string'
PUBLIC	??_C@_06CFODFMBC@cnt?$DN?$DN2?$AA@		; `string'
PUBLIC	??_7CEnvelope@@6B@				; CEnvelope::`vftable'
EXTRN	__imp_?w_u16@IWriter@@QAEXG@Z:PROC
EXTRN	__imp_?w_u8@IWriter@@QAEXE@Z:PROC
EXTRN	__imp_?w_float@IWriter@@QAEXM@Z:PROC
EXTRN	__imp_?w_float_q16@IWriter@@QAEXMMM@Z:PROC
EXTRN	__imp_?r@IReader@@QAEXPAXH@Z:PROC
EXTRN	__imp_?r_u8@?$IReaderBase@VIReader@@@@QAEEXZ:PROC
EXTRN	__imp_?r_float_q16@?$IReaderBase@VIReader@@@@QAEMMM@Z:PROC
EXTRN	__imp_?r_string@IReader@@QAEXPADI@Z:PROC
;	COMDAT ?ignore_always@?8??LoadA@CEnvelope@@QAEXAAVIReader@@@Z@4_NA
_BSS	SEGMENT
?ignore_always@?8??LoadA@CEnvelope@@QAEXAAVIReader@@@Z@4_NA DB 01H DUP (?) ; `CEnvelope::LoadA'::`9'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?BF@??LoadA@CEnvelope@@QAEXAAVIReader@@@Z@4_NA
_BSS	SEGMENT
?ignore_always@?BF@??LoadA@CEnvelope@@QAEXAAVIReader@@@Z@4_NA DB 01H DUP (?) ; `CEnvelope::LoadA'::`21'::ignore_always
;	COMDAT ??_7CEnvelope@@6B@
CONST	SEGMENT
??_7CEnvelope@@6B@ DD FLAT:??_R4CEnvelope@@6B@		; CEnvelope::`vftable'
	DD	FLAT:??_ECEnvelope@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4CEnvelope@@6B@
rdata$r	SEGMENT
??_R4CEnvelope@@6B@ DD 00H				; CEnvelope::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCEnvelope@@@8
	DD	FLAT:??_R3CEnvelope@@8
rdata$r	ENDS
;	COMDAT ??_R3CEnvelope@@8
rdata$r	SEGMENT
??_R3CEnvelope@@8 DD 00H				; CEnvelope::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CEnvelope@@8
rdata$r	ENDS
;	COMDAT ??_R2CEnvelope@@8
rdata$r	SEGMENT
??_R2CEnvelope@@8 DD FLAT:??_R1A@?0A@EA@CEnvelope@@8	; CEnvelope::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CEnvelope@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CEnvelope@@8 DD FLAT:??_R0?AVCEnvelope@@@8 ; CEnvelope::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CEnvelope@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCEnvelope@@@8
_DATA	SEGMENT
??_R0?AVCEnvelope@@@8 DD FLAT:??_7type_info@@6B@	; CEnvelope `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCEnvelope@@', 00H
_DATA	ENDS
;	COMDAT ??_C@_06CFODFMBC@cnt?$DN?$DN2?$AA@
CONST	SEGMENT
??_C@_06CFODFMBC@cnt?$DN?$DN2?$AA@ DB 'cnt==2', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PAABFJOJ@Behaviors?5?$CFd?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BA@PAABFJOJ@Behaviors?5?$CFd?5?$CFd?$AA@ DB 'Behaviors %d %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06MGBHIFNJ@cnt?$DN?$DN9?$AA@
CONST	SEGMENT
??_C@_06MGBHIFNJ@cnt?$DN?$DN9?$AA@ DB 'cnt==9', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@FKACCOIF@D?3?2CLEARSKY?2sources?2engine?2xrEng@
CONST	SEGMENT
??_C@_0DB@FKACCOIF@D?3?2CLEARSKY?2sources?2engine?2xrEng@ DB 'D:\CLEARSKY'
	DB	'\sources\engine\xrEngine\Envelope.cpp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JCNOMHAO@CEnvelope?3?3LoadA?$AA@
CONST	SEGMENT
??_C@_0BB@JCNOMHAO@CEnvelope?3?3LoadA?$AA@ DB 'CEnvelope::LoadA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@MGCNGGP@Key?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?$AA@
CONST	SEGMENT
??_C@_0BP@MGCNGGP@Key?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?$AA@ DB 'K'
	DB	'ey %f %f %f %f %f %f %f %f %f', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PDDPJNOG@?$HL?5Envelope?$AA@
CONST	SEGMENT
??_C@_0L@PDDPJNOG@?$HL?5Envelope?$AA@ DB '{ Envelope', 00H ; `string'
_EPS	DD	03727c5acr			; 1e-005
_EPS_L	DD	03a83126fr			; 0.001
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\xrmemory_subst_msvc.h
;	COMDAT ??R?$xr_special_free@$0A@Ust_Key@@@@QAEXAAPAUst_Key@@@Z
_TEXT	SEGMENT
??R?$xr_special_free@$0A@Ust_Key@@@@QAEXAAPAUst_Key@@@Z PROC ; xr_special_free<0,st_Key>::operator(), COMDAT
; _ptr$ = eax

; 143  : 		ptr->~T			();
; 144  : 		Memory.mem_free	(ptr);

	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 145  : 	}

	ret	0
??R?$xr_special_free@$0A@Ust_Key@@@@QAEXAAPAUst_Key@@@Z ENDP ; xr_special_free<0,st_Key>::operator()
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ??$?0PAUst_Key@@@?$xalloc@PAX@@QAE@ABV?$xalloc@PAUst_Key@@@@@Z
_TEXT	SEGMENT
??$?0PAUst_Key@@@?$xalloc@PAX@@QAE@ABV?$xalloc@PAUst_Key@@@@@Z PROC ; xalloc<void *>::xalloc<void *><st_Key *>, COMDAT
; _this$ = eax

; 79   : 	template<class _Other>							xalloc			(const xalloc<_Other>&)					{	}

	ret	0
??$?0PAUst_Key@@@?$xalloc@PAX@@QAE@ABV?$xalloc@PAUst_Key@@@@@Z ENDP ; xalloc<void *>::xalloc<void *><st_Key *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\xrmemory_subst_msvc.h
_TEXT	ENDS
;	COMDAT ??$xr_delete@Ust_Key@@@@YAXAAPAUst_Key@@@Z
_TEXT	SEGMENT
??$xr_delete@Ust_Key@@@@YAXAAPAUst_Key@@@Z PROC		; xr_delete<st_Key>, COMDAT
; _ptr$ = esi

; 151  : 	if (ptr) 

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN1@xr_delete@10

; 152  : 	{
; 153  : 		xr_special_free<is_polymorphic<T>::result,T>()(ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 154  : 		ptr = NULL;

	mov	DWORD PTR [esi], 0
$LN1@xr_delete@10:

; 155  : 	}
; 156  : }

	ret	0
??$xr_delete@Ust_Key@@@@YAXAAPAUst_Key@@@Z ENDP		; xr_delete<st_Key>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ??0?$xalloc@PAUst_Key@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@PAUst_Key@@@@QAE@XZ PROC			; xalloc<st_Key *>::xalloc<st_Key *>, COMDAT
; _this$ = eax

; 77   : 													xalloc			()										{	}

	ret	0
??0?$xalloc@PAUst_Key@@@@QAE@XZ ENDP			; xalloc<st_Key *>::xalloc<st_Key *>
_TEXT	ENDS
PUBLIC	?SaveA@CEnvelope@@QAEXAAVIWriter@@@Z		; CEnvelope::SaveA
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\envelope.cpp
;	COMDAT ?SaveA@CEnvelope@@QAEXAAVIWriter@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?SaveA@CEnvelope@@QAEXAAVIWriter@@@Z PROC		; CEnvelope::SaveA, COMDAT
; _this$ = ecx

; 178  : }

	ret	4
?SaveA@CEnvelope@@QAEXAAVIWriter@@@Z ENDP		; CEnvelope::SaveA
_TEXT	ENDS
PUBLIC	__real@c2000000
PUBLIC	__real@42000000
;	COMDAT __real@c2000000
; File d:\clearsky\sources\engine\xrengine\envelope.h
CONST	SEGMENT
__real@c2000000 DD 0c2000000r			; -32
CONST	ENDS
;	COMDAT __real@42000000
CONST	SEGMENT
__real@42000000 DD 042000000r			; 32
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?Load_2@st_Key@@QAEXAAVIReader@@@Z
_TEXT	SEGMENT
?Load_2@st_Key@@QAEXAAVIReader@@@Z PROC			; st_Key::Load_2, COMDAT
; _this$ = edi
; _F$ = esi

; 90   :         value		= F.r_float();

	mov	ecx, esi
	call	DWORD PTR __imp_?r_float@?$IReaderBase@VIReader@@@@QAEMXZ
	fstp	DWORD PTR [edi]

; 91   :         time		= F.r_float();

	mov	ecx, esi
	call	DWORD PTR __imp_?r_float@?$IReaderBase@VIReader@@@@QAEMXZ
	fstp	DWORD PTR [edi+4]

; 92   :         shape		= F.r_u8();

	mov	ecx, esi
	call	DWORD PTR __imp_?r_u8@?$IReaderBase@VIReader@@@@QAEEXZ

; 93   :         if (shape!=4){ // ! Stepped

	cmp	al, 4
	mov	BYTE PTR [edi+8], al
	je	$LN1@Load_2

; 94   :             tension		= F.r_float_q16(-32.f,32.f);

	fld	DWORD PTR __real@42000000
	sub	esp, 8
	fstp	DWORD PTR [esp+4]
	mov	ecx, esi
	fld	DWORD PTR __real@c2000000
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp_?r_float_q16@?$IReaderBase@VIReader@@@@QAEMMM@Z
	fstp	DWORD PTR [edi+9]

; 95   :             continuity	= F.r_float_q16(-32.f,32.f);

	sub	esp, 8
	fld	DWORD PTR __real@42000000
	mov	ecx, esi
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR __real@c2000000
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp_?r_float_q16@?$IReaderBase@VIReader@@@@QAEMMM@Z
	fstp	DWORD PTR [edi+13]

; 96   :             bias		= F.r_float_q16(-32.f,32.f);

	sub	esp, 8
	fld	DWORD PTR __real@42000000
	mov	ecx, esi
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR __real@c2000000
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp_?r_float_q16@?$IReaderBase@VIReader@@@@QAEMMM@Z
	fstp	DWORD PTR [edi+17]

; 97   :             param[0]	= F.r_float_q16(-32.f,32.f);

	sub	esp, 8
	fld	DWORD PTR __real@42000000
	mov	ecx, esi
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR __real@c2000000
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp_?r_float_q16@?$IReaderBase@VIReader@@@@QAEMMM@Z
	fstp	DWORD PTR [edi+21]

; 98   :             param[1]	= F.r_float_q16(-32.f,32.f);

	sub	esp, 8
	fld	DWORD PTR __real@42000000
	mov	ecx, esi
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR __real@c2000000
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp_?r_float_q16@?$IReaderBase@VIReader@@@@QAEMMM@Z
	fstp	DWORD PTR [edi+25]

; 99   :             param[2]	= F.r_float_q16(-32.f,32.f);

	sub	esp, 8
	fld	DWORD PTR __real@42000000
	mov	ecx, esi
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR __real@c2000000
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp_?r_float_q16@?$IReaderBase@VIReader@@@@QAEMMM@Z
	fstp	DWORD PTR [edi+29]

; 100  :             param[3]	= F.r_float_q16(-32.f,32.f);

	sub	esp, 8
	fld	DWORD PTR __real@42000000
	mov	ecx, esi
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR __real@c2000000
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp_?r_float_q16@?$IReaderBase@VIReader@@@@QAEMMM@Z
	fstp	DWORD PTR [edi+33]
$LN1@Load_2:

; 101  :         }
; 102  :     }

	ret	0
?Load_2@st_Key@@QAEXAAVIReader@@@Z ENDP			; st_Key::Load_2
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Load_1@st_Key@@QAEXAAVIReader@@@Z
_TEXT	SEGMENT
?Load_1@st_Key@@QAEXAAVIReader@@@Z PROC			; st_Key::Load_1, COMDAT
; _this$ = eax
; _F$ = esi

; 79   :     {

	push	edi

; 80   :         value		= F.r_float();

	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_?r_float@?$IReaderBase@VIReader@@@@QAEMXZ
	fstp	DWORD PTR [edi]

; 81   :         time		= F.r_float();

	mov	ecx, esi
	call	DWORD PTR __imp_?r_float@?$IReaderBase@VIReader@@@@QAEMXZ
	fstp	DWORD PTR [edi+4]

; 82   :         shape		= u8((u8)F.r_u32()&0xff);

	mov	ecx, esi
	call	DWORD PTR __imp_?r_u32@?$IReaderBase@VIReader@@@@QAEIXZ

; 83   :         tension		= F.r_float();

	mov	ecx, esi
	mov	BYTE PTR [edi+8], al
	call	DWORD PTR __imp_?r_float@?$IReaderBase@VIReader@@@@QAEMXZ
	fstp	DWORD PTR [edi+9]

; 84   :         continuity	= F.r_float();

	mov	ecx, esi
	call	DWORD PTR __imp_?r_float@?$IReaderBase@VIReader@@@@QAEMXZ
	fstp	DWORD PTR [edi+13]

; 85   :         bias		= F.r_float();

	mov	ecx, esi
	call	DWORD PTR __imp_?r_float@?$IReaderBase@VIReader@@@@QAEMXZ
	fstp	DWORD PTR [edi+17]

; 86   :         F.r			(&param,sizeof(float)*4);

	push	16					; 00000010H
	add	edi, 21					; 00000015H
	push	edi
	mov	ecx, esi
	call	DWORD PTR __imp_?r@IReader@@QAEXPAXH@Z
	pop	edi

; 87   :     }

	ret	0
?Load_1@st_Key@@QAEXAAVIReader@@@Z ENDP			; st_Key::Load_1
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Save@st_Key@@QAEXAAVIWriter@@@Z
_TEXT	SEGMENT
?Save@st_Key@@QAEXAAVIWriter@@@Z PROC			; st_Key::Save, COMDAT
; _this$ = esi
; _F$ = edi

; 65   :         F.w_float	(value);

	fld	DWORD PTR [esi]
	push	ecx
	mov	ecx, edi
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp_?w_float@IWriter@@QAEXM@Z

; 66   :         F.w_float	(time);

	fld	DWORD PTR [esi+4]
	push	ecx
	mov	ecx, edi
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp_?w_float@IWriter@@QAEXM@Z

; 67   :         F.w_u8		(shape);

	movzx	eax, BYTE PTR [esi+8]
	push	eax
	mov	ecx, edi
	call	DWORD PTR __imp_?w_u8@IWriter@@QAEXE@Z

; 68   :         if (shape!=4){ // ! Stepped

	cmp	BYTE PTR [esi+8], 4
	je	$LN1@Save

; 69   :             F.w_float_q16(tension,-32.f,32.f);

	fld	DWORD PTR __real@42000000
	sub	esp, 12					; 0000000cH
	fstp	DWORD PTR [esp+8]
	mov	ecx, edi
	fld	DWORD PTR __real@c2000000
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR [esi+9]
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp_?w_float_q16@IWriter@@QAEXMMM@Z

; 70   :             F.w_float_q16(continuity,-32.f,32.f);

	fld	DWORD PTR __real@42000000
	sub	esp, 12					; 0000000cH
	fstp	DWORD PTR [esp+8]
	mov	ecx, edi
	fld	DWORD PTR __real@c2000000
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR [esi+13]
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp_?w_float_q16@IWriter@@QAEXMMM@Z

; 71   :             F.w_float_q16(bias,-32.f,32.f);

	fld	DWORD PTR __real@42000000
	sub	esp, 12					; 0000000cH
	fstp	DWORD PTR [esp+8]
	mov	ecx, edi
	fld	DWORD PTR __real@c2000000
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR [esi+17]
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp_?w_float_q16@IWriter@@QAEXMMM@Z

; 72   :             F.w_float_q16(param[0],-32.f,32.f);

	fld	DWORD PTR __real@42000000
	sub	esp, 12					; 0000000cH
	fstp	DWORD PTR [esp+8]
	mov	ecx, edi
	fld	DWORD PTR __real@c2000000
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR [esi+21]
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp_?w_float_q16@IWriter@@QAEXMMM@Z

; 73   :             F.w_float_q16(param[1],-32.f,32.f);

	fld	DWORD PTR __real@42000000
	sub	esp, 12					; 0000000cH
	fstp	DWORD PTR [esp+8]
	mov	ecx, edi
	fld	DWORD PTR __real@c2000000
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR [esi+25]
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp_?w_float_q16@IWriter@@QAEXMMM@Z

; 74   :             F.w_float_q16(param[2],-32.f,32.f);

	fld	DWORD PTR __real@42000000
	sub	esp, 12					; 0000000cH
	fstp	DWORD PTR [esp+8]
	mov	ecx, edi
	fld	DWORD PTR __real@c2000000
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR [esi+29]
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp_?w_float_q16@IWriter@@QAEXMMM@Z

; 75   :             F.w_float_q16(param[3],-32.f,32.f);

	fld	DWORD PTR __real@42000000
	sub	esp, 12					; 0000000cH
	fstp	DWORD PTR [esp+8]
	mov	ecx, edi
	fld	DWORD PTR __real@c2000000
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR [esi+33]
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp_?w_float_q16@IWriter@@QAEXMMM@Z
$LN1@Save:

; 76   :         }
; 77   :     }

	ret	0
?Save@st_Key@@QAEXAAVIWriter@@@Z ENDP			; st_Key::Save
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0st_Key@@QAE@XZ
_TEXT	SEGMENT
??0st_Key@@QAE@XZ PROC					; st_Key::st_Key, COMDAT
; _this$ = esi

; 49   : 				st_Key		(){ZeroMemory(this,sizeof(st_Key));}

	mov	eax, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ecx, DWORD PTR [eax+12]
	push	37					; 00000025H
	push	0
	push	esi
	call	ecx
	mov	eax, esi
	ret	0
??0st_Key@@QAE@XZ ENDP					; st_Key::st_Key
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\xrmemory_subst_msvc.h
;	COMDAT ??$xr_new@Ust_Key@@@@YAPAUst_Key@@XZ
_TEXT	SEGMENT
??$xr_new@Ust_Key@@@@YAPAUst_Key@@XZ PROC		; xr_new<st_Key>, COMDAT

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	push	37					; 00000025H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 69   : 	return new (ptr) T();

	mov	esi, eax
	test	esi, esi
	je	SHORT $LN3@xr_new@5
	mov	eax, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ecx, DWORD PTR [eax+12]
	push	37					; 00000025H
	push	0
	push	esi
	call	ecx
	mov	eax, esi
	pop	esi

; 70   : }

	ret	0
$LN3@xr_new@5:

; 69   : 	return new (ptr) T();

	xor	eax, eax
	pop	esi

; 70   : }

	ret	0
??$xr_new@Ust_Key@@@@YAPAUst_Key@@XZ ENDP		; xr_new<st_Key>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$xr_new@Ust_Key@@U1@@@YAPAUst_Key@@ABU0@@Z
_TEXT	SEGMENT
_p1$ = 8						; size = 4
??$xr_new@Ust_Key@@U1@@@YAPAUst_Key@@ABU0@@Z PROC	; xr_new<st_Key,st_Key>, COMDAT

; 74   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	37					; 00000025H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 75   : 	return new (ptr) T(p1);

	test	eax, eax
	je	SHORT $LN3@xr_new@6
	push	esi
	mov	esi, DWORD PTR _p1$[esp]
	push	edi
	mov	ecx, 9
	mov	edi, eax
	rep movsd
	movsb
	pop	edi
	pop	esi

; 76   : }

	ret	0
$LN3@xr_new@6:

; 75   : 	return new (ptr) T(p1);

	xor	eax, eax

; 76   : }

	ret	0
??$xr_new@Ust_Key@@U1@@@YAPAUst_Key@@ABU0@@Z ENDP	; xr_new<st_Key,st_Key>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_tools.h
_TEXT	ENDS
;	COMDAT ?to_storage_type_cref@?$_CastTraits@PAXPAUst_Key@@@priv@stlp_std@@SAABQAXABQAUst_Key@@@Z
_TEXT	SEGMENT
?to_storage_type_cref@?$_CastTraits@PAXPAUst_Key@@@priv@stlp_std@@SAABQAXABQAUst_Key@@@Z PROC ; stlp_std::priv::_CastTraits<void *,st_Key *>::to_storage_type_cref, COMDAT
; ___ref$ = eax

; 224  :   { return cv_traits::uncv_cref(__REINTERPRET_CAST(void_cv_type const&, __ref)); }

	ret	0
?to_storage_type_cref@?$_CastTraits@PAXPAUst_Key@@@priv@stlp_std@@SAABQAXABQAUst_Key@@@Z ENDP ; stlp_std::priv::_CastTraits<void *,st_Key *>::to_storage_type_cref
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?to_storage_type_ptr@?$_CastTraits@PAXPAUst_Key@@@priv@stlp_std@@SAPAPAXPAPAUst_Key@@@Z
_TEXT	SEGMENT
?to_storage_type_ptr@?$_CastTraits@PAXPAUst_Key@@@priv@stlp_std@@SAPAPAXPAPAUst_Key@@@Z PROC ; stlp_std::priv::_CastTraits<void *,st_Key *>::to_storage_type_ptr, COMDAT
; ___ptr$ = eax

; 218  :   { return cv_traits::uncv_ptr(__REINTERPRET_CAST(void_cv_type *, __ptr)); }

	ret	0
?to_storage_type_ptr@?$_CastTraits@PAXPAUst_Key@@@priv@stlp_std@@SAPAPAXPAPAUst_Key@@@Z ENDP ; stlp_std::priv::_CastTraits<void *,st_Key *>::to_storage_type_ptr
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?to_value_type_ref@?$_CastTraits@PAXPAUst_Key@@@priv@stlp_std@@SAAAPAUst_Key@@AAPAX@Z
_TEXT	SEGMENT
?to_value_type_ref@?$_CastTraits@PAXPAUst_Key@@@priv@stlp_std@@SAAAPAUst_Key@@AAPAX@Z PROC ; stlp_std::priv::_CastTraits<void *,st_Key *>::to_value_type_ref, COMDAT
; ___ref$ = eax

; 213  :   { return __REINTERPRET_CAST(value_type &, cv_traits::cv_ref(__ref)); }

	ret	0
?to_value_type_ref@?$_CastTraits@PAXPAUst_Key@@@priv@stlp_std@@SAAAPAUst_Key@@AAPAX@Z ENDP ; stlp_std::priv::_CastTraits<void *,st_Key *>::to_value_type_ref
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?to_value_type_ptr@?$_CastTraits@PAXPAUst_Key@@@priv@stlp_std@@SAPAPAUst_Key@@PAPAX@Z
_TEXT	SEGMENT
?to_value_type_ptr@?$_CastTraits@PAXPAUst_Key@@@priv@stlp_std@@SAPAPAUst_Key@@PAPAX@Z PROC ; stlp_std::priv::_CastTraits<void *,st_Key *>::to_value_type_ptr, COMDAT
; ___ptr$ = eax

; 207  :   { return __REINTERPRET_CAST(value_type *, cv_traits::cv_ptr(__ptr)); }

	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 4
	ret	0
?to_value_type_ptr@?$_CastTraits@PAXPAUst_Key@@@priv@stlp_std@@SAPAPAUst_Key@@PAPAX@Z ENDP ; stlp_std::priv::_CastTraits<void *,st_Key *>::to_value_type_ptr
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QBEIXZ PROC ; stlp_std::vector<st_Key *,xalloc<st_Key *> >::size, COMDAT
; _this$ = ecx

; 89   :   size_type size() const        { return _M_impl.size(); }

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	ret	0
?size@?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QBEIXZ ENDP ; stlp_std::vector<st_Key *,xalloc<st_Key *> >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?empty@?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QBE_NXZ PROC ; stlp_std::vector<st_Key *,xalloc<st_Key *> >::empty, COMDAT
; _this$ = ecx

; 93   :   bool empty() const            { return _M_impl.empty(); }

	jmp	?empty@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QBE_NXZ ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::empty
?empty@?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QBE_NXZ ENDP ; stlp_std::vector<st_Key *,xalloc<st_Key *> >::empty
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAEPAPAUst_Key@@XZ
_TEXT	SEGMENT
?end@?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAEPAPAUst_Key@@XZ PROC ; stlp_std::vector<st_Key *,xalloc<st_Key *> >::end, COMDAT
; _this$ = eax

; 81   :   iterator end()               { return cast_traits::to_value_type_ptr(_M_impl.end()); }

	mov	eax, DWORD PTR [eax+4]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 4
	ret	0
?end@?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAEPAPAUst_Key@@XZ ENDP ; stlp_std::vector<st_Key *,xalloc<st_Key *> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAEPAPAUst_Key@@XZ
_TEXT	SEGMENT
?begin@?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAEPAPAUst_Key@@XZ PROC ; stlp_std::vector<st_Key *,xalloc<st_Key *> >::begin, COMDAT
; _this$ = eax

; 79   :   iterator begin()             { return cast_traits::to_value_type_ptr(_M_impl.begin()); }

	mov	eax, DWORD PTR [eax]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 4
	ret	0
?begin@?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAEPAPAUst_Key@@XZ ENDP ; stlp_std::vector<st_Key *,xalloc<st_Key *> >::begin
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ??A?$xr_vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@@QAEAAPAUst_Key@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$xr_vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@@QAEAAPAUst_Key@@I@Z PROC ; xr_vector<st_Key *,xalloc<st_Key *> >::operator[], COMDAT
; _this$ = eax

; 139  : 	reference operator[]		(size_type _Pos)					{ {VERIFY2(_Pos<size(),make_string("index is out of range: index requested[%d], size of container[%d]", _Pos, size()).c_str());} return (*(begin() + _Pos)); }

	mov	eax, DWORD PTR [eax]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	mov	ecx, DWORD PTR __Pos$[esp]
	add	esp, 4
	lea	eax, DWORD PTR [eax+ecx*4]
	ret	4
??A?$xr_vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@@QAEAAPAUst_Key@@I@Z ENDP ; xr_vector<st_Key *,xalloc<st_Key *> >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$xr_vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@@QBEIXZ
_TEXT	SEGMENT
?size@?$xr_vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@@QBEIXZ PROC ; xr_vector<st_Key *,xalloc<st_Key *> >::size, COMDAT
; _this$ = ecx

; 126  : 	u32		size				() const							{ return (u32)inherited::size();} 

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	ret	0
?size@?$xr_vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@@QBEIXZ ENDP ; xr_vector<st_Key *,xalloc<st_Key *> >::size
_TEXT	ENDS
PUBLIC	?Save@CEnvelope@@QAEXAAVIWriter@@@Z		; CEnvelope::Save
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\envelope.cpp
;	COMDAT ?Save@CEnvelope@@QAEXAAVIWriter@@@Z
_TEXT	SEGMENT
_F$ = 8							; size = 4
?Save@CEnvelope@@QAEXAAVIWriter@@@Z PROC		; CEnvelope::Save, COMDAT
; _this$ = ecx

; 145  : {

	push	ebx
	mov	ebx, ecx

; 146  : 	F.w_u8		((u8)behavior[0]);

	movzx	eax, BYTE PTR [ebx+16]
	push	ebp
	push	edi
	mov	edi, DWORD PTR _F$[esp+8]
	push	eax
	mov	ecx, edi
	call	DWORD PTR __imp_?w_u8@IWriter@@QAEXE@Z

; 147  : 	F.w_u8		((u8)behavior[1]);

	movzx	ecx, BYTE PTR [ebx+20]
	push	ecx
	mov	ecx, edi
	call	DWORD PTR __imp_?w_u8@IWriter@@QAEXE@Z

; 148  : 	F.w_u16		((u16)keys.size());

	mov	edx, DWORD PTR [ebx+8]
	sub	edx, DWORD PTR [ebx+4]
	mov	ecx, edi
	sar	edx, 2
	push	edx
	call	DWORD PTR __imp_?w_u16@IWriter@@QAEXG@Z

; 149  : 	for (KeyIt k_it=keys.begin(); k_it!=keys.end(); k_it++)

	mov	eax, DWORD PTR [ebx+4]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	mov	ebp, eax
	mov	eax, DWORD PTR [ebx+8]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 8
	cmp	ebp, eax
	je	SHORT $LN1@Save@5
	push	esi
$LL3@Save@5:

; 150  :     	(*k_it)->Save(F);

	mov	esi, DWORD PTR [ebp]
	call	?Save@st_Key@@QAEXAAVIWriter@@@Z	; st_Key::Save
	mov	eax, DWORD PTR [ebx+8]
	push	eax
	add	ebp, 4
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 4
	cmp	ebp, eax
	jne	SHORT $LL3@Save@5
	pop	esi
$LN1@Save@5:
	pop	edi
	pop	ebp
	pop	ebx

; 151  : }

	ret	4
?Save@CEnvelope@@QAEXAAVIWriter@@@Z ENDP		; CEnvelope::Save
_TEXT	ENDS
PUBLIC	?RotateKeys@CEnvelope@@QAEXM@Z			; CEnvelope::RotateKeys
; Function compile flags: /Ogtpy
;	COMDAT ?RotateKeys@CEnvelope@@QAEXM@Z
_TEXT	SEGMENT
_angle$ = 8						; size = 4
?RotateKeys@CEnvelope@@QAEXM@Z PROC			; CEnvelope::RotateKeys, COMDAT
; _this$ = ecx

; 133  : {

	push	esi
	mov	esi, ecx

; 134  : 	for (u32 i=0; i<keys.size(); i++)

	mov	eax, DWORD PTR [esi+8]
	sub	eax, DWORD PTR [esi+4]
	push	edi
	xor	edi, edi
	sar	eax, 2
	je	SHORT $LN1@RotateKeys
$LL3@RotateKeys:

; 135  :     	keys[i]->value += angle;

	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	mov	eax, DWORD PTR [eax+edi*4]
	movss	xmm0, DWORD PTR [eax]
	addss	xmm0, DWORD PTR _angle$[esp+8]
	movss	DWORD PTR [eax], xmm0
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, DWORD PTR [esi+4]
	add	edi, 1
	sar	ecx, 2
	add	esp, 4
	cmp	edi, ecx
	jb	SHORT $LL3@RotateKeys
$LN1@RotateKeys:
	pop	edi
	pop	esi

; 136  : }

	ret	4
?RotateKeys@CEnvelope@@QAEXM@Z ENDP			; CEnvelope::RotateKeys
_TEXT	ENDS
PUBLIC	?Clear@CEnvelope@@QAEXXZ			; CEnvelope::Clear
; Function compile flags: /Ogtpy
;	COMDAT ?Clear@CEnvelope@@QAEXXZ
_TEXT	SEGMENT
?Clear@CEnvelope@@QAEXXZ PROC				; CEnvelope::Clear, COMDAT
; _this$ = ecx

; 25   : {

	push	esi
	push	edi
	mov	edi, ecx

; 26   : 	for (KeyIt k_it=keys.begin(); k_it!=keys.end(); k_it++)

	mov	eax, DWORD PTR [edi+4]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	mov	esi, eax
	mov	eax, DWORD PTR [edi+8]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 8
	cmp	esi, eax
	je	SHORT $LN1@Clear@2
	push	ebx
	mov	ebx, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LL3@Clear@2:

; 27   : 		xr_delete(*k_it);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Clear@2
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebx
	mov	DWORD PTR [esi], 0
$LN2@Clear@2:
	mov	eax, DWORD PTR [edi+8]
	push	eax
	add	esi, 4
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 4
	cmp	esi, eax
	jne	SHORT $LL3@Clear@2
	pop	ebx
$LN1@Clear@2:
	pop	edi
	pop	esi

; 28   : }

	ret	0
?Clear@CEnvelope@@QAEXXZ ENDP				; CEnvelope::Clear
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
;	COMDAT ??0?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAE@ABV?$xalloc@PAUst_Key@@@@@Z
_TEXT	SEGMENT
??0?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAE@ABV?$xalloc@PAUst_Key@@@@@Z PROC ; stlp_std::vector<st_Key *,xalloc<st_Key *> >::vector<st_Key *,xalloc<st_Key *> >, COMDAT
; _this$ = eax

; 106  :   explicit vector(const allocator_type& __a = allocator_type())

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAE@ABV?$xalloc@PAUst_Key@@@@@Z ENDP ; stlp_std::vector<st_Key *,xalloc<st_Key *> >::vector<st_Key *,xalloc<st_Key *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?erase@?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAEPAPAUst_Key@@PAPAU3@@Z
_TEXT	SEGMENT
?erase@?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAEPAPAUst_Key@@PAPAU3@@Z PROC ; stlp_std::vector<st_Key *,xalloc<st_Key *> >::erase, COMDAT
; _this$ = eax
; ___pos$ = edi

; 206  :   {return cast_traits::to_value_type_ptr(_M_impl.erase(cast_traits::to_storage_type_ptr(__pos)));}

	push	esi
	mov	esi, eax
	mov	eax, DWORD PTR [esi+4]
	lea	ecx, DWORD PTR [edi+4]
	cmp	ecx, eax
	je	SHORT $LN18@erase@38
	sub	eax, ecx
	je	SHORT $LN18@erase@38
	push	eax
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
$LN18@erase@38:
	add	DWORD PTR [esi+4], -4			; fffffffcH
	mov	esi, DWORD PTR [esi+4]
	push	esi
	call	??$_Destroy@PAX@stlp_std@@YAXPAPAX@Z	; stlp_std::_Destroy<void *>
	push	edi
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 8
	pop	esi
	ret	0
?erase@?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAEPAPAUst_Key@@PAPAU3@@Z ENDP ; stlp_std::vector<st_Key *,xalloc<st_Key *> >::erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?back@?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAEAAPAUst_Key@@XZ
_TEXT	SEGMENT
?back@?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAEAAPAUst_Key@@XZ PROC ; stlp_std::vector<st_Key *,xalloc<st_Key *> >::back, COMDAT
; _this$ = eax

; 100  :   reference back()              { return cast_traits::to_value_type_ref(_M_impl.back()); }

	mov	eax, DWORD PTR [eax+4]
	sub	eax, 4
	ret	0
?back@?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAEAAPAUst_Key@@XZ ENDP ; stlp_std::vector<st_Key *,xalloc<st_Key *> >::back
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?front@?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAEAAPAUst_Key@@XZ
_TEXT	SEGMENT
?front@?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAEAAPAUst_Key@@XZ PROC ; stlp_std::vector<st_Key *,xalloc<st_Key *> >::front, COMDAT
; _this$ = eax

; 98   :   reference front()             { return cast_traits::to_value_type_ref(_M_impl.front()); }

	mov	eax, DWORD PTR [eax]
	ret	0
?front@?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAEAAPAUst_Key@@XZ ENDP ; stlp_std::vector<st_Key *,xalloc<st_Key *> >::front
_TEXT	ENDS
PUBLIC	?GetLength@CEnvelope@@QAEMPAM0@Z		; CEnvelope::GetLength
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\envelope.cpp
;	COMDAT ?GetLength@CEnvelope@@QAEMPAM0@Z
_TEXT	SEGMENT
_mn$ = 8						; size = 4
_mx$ = 12						; size = 4
?GetLength@CEnvelope@@QAEMPAM0@Z PROC			; CEnvelope::GetLength, COMDAT
; _this$ = ecx

; 121  : {

	push	esi
	mov	esi, ecx
	push	edi

; 122  : 	if (!keys.empty()){

	lea	edi, DWORD PTR [esi+4]
	mov	ecx, edi
	call	?empty@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QBE_NXZ ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::empty
	test	al, al

; 123  :     	if (mn) *mn = keys.front()->time;

	mov	eax, DWORD PTR _mn$[esp+4]
	jne	SHORT $LN5@GetLength@3
	test	eax, eax
	je	SHORT $LN4@GetLength@3
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx]
	fld	DWORD PTR [edx+4]
	fstp	DWORD PTR [eax]
$LN4@GetLength@3:

; 124  :     	if (mx) *mx = keys.back()->time;

	mov	eax, DWORD PTR _mx$[esp+4]
	test	eax, eax
	je	SHORT $LN3@GetLength@3
	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [ecx-4]
	fld	DWORD PTR [edx+4]
	fstp	DWORD PTR [eax]
$LN3@GetLength@3:

; 125  :     	return keys.back()->time-keys.front()->time;

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [eax-4]
	mov	edx, DWORD PTR [edi]
	fld	DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx]
	fsub	DWORD PTR [eax+4]
	pop	edi
	pop	esi

; 130  : }

	ret	8
$LN5@GetLength@3:

; 126  :     }
; 127  :     if (mn) *mn = 0.f;

	test	eax, eax
	xorps	xmm0, xmm0
	je	SHORT $LN2@GetLength@3
	movss	DWORD PTR [eax], xmm0
$LN2@GetLength@3:

; 128  :     if (mx) *mx = 0.f;

	mov	eax, DWORD PTR _mx$[esp+4]
	test	eax, eax
	je	SHORT $LN1@GetLength@3
	movss	DWORD PTR [eax], xmm0
$LN1@GetLength@3:

; 129  :     return 0.f;

	fldz
	pop	edi
	pop	esi

; 130  : }

	ret	8
?GetLength@CEnvelope@@QAEMPAM0@Z ENDP			; CEnvelope::GetLength
_TEXT	ENDS
PUBLIC	?DeleteKey@CEnvelope@@QAEXM@Z			; CEnvelope::DeleteKey
; Function compile flags: /Ogtpy
;	COMDAT ?DeleteKey@CEnvelope@@QAEXM@Z
_TEXT	SEGMENT
_t$ = 8							; size = 4
?DeleteKey@CEnvelope@@QAEXM@Z PROC			; CEnvelope::DeleteKey, COMDAT
; _this$ = ecx

; 78   : {	

	push	esi
	push	edi
	mov	edi, ecx

; 79   : 	for (KeyIt k_it=keys.begin(); k_it!=keys.end(); k_it++){

	mov	eax, DWORD PTR [edi+4]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	mov	esi, eax
	mov	eax, DWORD PTR [edi+8]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 8
	cmp	esi, eax
	je	$LN2@DeleteKey@2
$LL4@DeleteKey@2:

; 80   :     	if (fsimilar((*k_it)->time,t,EPS_L)){ 

	mov	eax, DWORD PTR [esi]
	movss	xmm0, DWORD PTR [eax+4]
	subss	xmm0, DWORD PTR _t$[esp+4]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_fabsf
	fld	DWORD PTR _EPS_L
	add	esp, 4
	fcomip	ST(1)
	fstp	ST(0)
	ja	SHORT $LN64@DeleteKey@2
	mov	eax, DWORD PTR [edi+8]
	push	eax
	add	esi, 4
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 4
	cmp	esi, eax
	jne	SHORT $LL4@DeleteKey@2
	pop	edi
	pop	esi

; 83   :             return;
; 84   :         }
; 85   :     }
; 86   : }

	ret	4
$LN64@DeleteKey@2:

; 81   :         	xr_delete(*k_it);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN31@DeleteKey@2
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN31@DeleteKey@2:

; 82   :             keys.erase(k_it);

	mov	eax, DWORD PTR [edi+8]
	lea	ecx, DWORD PTR [esi+4]
	cmp	ecx, eax
	je	SHORT $LN53@DeleteKey@2
	sub	eax, ecx
	je	SHORT $LN53@DeleteKey@2
	push	eax
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
$LN53@DeleteKey@2:
	add	DWORD PTR [edi+8], -4			; fffffffcH
	mov	edi, DWORD PTR [edi+8]
	push	edi
	call	??$_Destroy@PAX@stlp_std@@YAXPAPAX@Z	; stlp_std::_Destroy<void *>
	push	esi
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 8
$LN2@DeleteKey@2:
	pop	edi
	pop	esi

; 83   :             return;
; 84   :         }
; 85   :     }
; 86   : }

	ret	4
?DeleteKey@CEnvelope@@QAEXM@Z ENDP			; CEnvelope::DeleteKey
_TEXT	ENDS
PUBLIC	?FindKey@CEnvelope@@QAEPAPAUst_Key@@MM@Z	; CEnvelope::FindKey
; Function compile flags: /Ogtpy
;	COMDAT ?FindKey@CEnvelope@@QAEPAPAUst_Key@@MM@Z
_TEXT	SEGMENT
tv171 = -4						; size = 4
_t$ = 8							; size = 4
_eps$ = 12						; size = 4
?FindKey@CEnvelope@@QAEPAPAUst_Key@@MM@Z PROC		; CEnvelope::FindKey, COMDAT
; _this$ = ecx

; 49   : {

	push	ecx
	push	esi
	push	edi
	mov	edi, ecx

; 50   : 	for (KeyIt k_it=keys.begin(); k_it!=keys.end(); k_it++){

	mov	eax, DWORD PTR [edi+4]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	mov	esi, eax
	mov	eax, DWORD PTR [edi+8]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 8
	cmp	esi, eax
	je	SHORT $LN3@FindKey
$LL5@FindKey:

; 51   :     	if (fsimilar((*k_it)->time,t,eps)) return k_it;

	mov	eax, DWORD PTR [esi]
	movss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR tv171[esp+12], xmm0
	subss	xmm0, DWORD PTR _t$[esp+8]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_fabsf
	fld	DWORD PTR _eps$[esp+12]
	add	esp, 4
	fcomip	ST(1)
	fstp	ST(0)
	ja	SHORT $LN49@FindKey

; 52   :     	if ((*k_it)->time>t) return keys.end();

	movss	xmm0, DWORD PTR tv171[esp+12]
	comiss	xmm0, DWORD PTR _t$[esp+8]
	ja	SHORT $LN3@FindKey
	mov	eax, DWORD PTR [edi+8]
	push	eax
	add	esi, 4
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 4
	cmp	esi, eax
	jne	SHORT $LL5@FindKey
$LN3@FindKey:

; 53   :     }
; 54   :     return keys.end();

	mov	edi, DWORD PTR [edi+8]
	push	edi
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 4
	pop	edi
	pop	esi

; 55   : }

	pop	ecx
	ret	8
$LN49@FindKey:
	pop	edi

; 51   :     	if (fsimilar((*k_it)->time,t,eps)) return k_it;

	mov	eax, esi
	pop	esi

; 55   : }

	pop	ecx
	ret	8
?FindKey@CEnvelope@@QAEPAPAUst_Key@@MM@Z ENDP		; CEnvelope::FindKey
_TEXT	ENDS
PUBLIC	?FindNearestKey@CEnvelope@@QAEXMAAPAPAUst_Key@@0M@Z ; CEnvelope::FindNearestKey
; Function compile flags: /Ogtpy
;	COMDAT ?FindNearestKey@CEnvelope@@QAEXMAAPAPAUst_Key@@0M@Z
_TEXT	SEGMENT
tv203 = -4						; size = 4
_t$ = 8							; size = 4
_min_k$ = 12						; size = 4
_max_k$ = 16						; size = 4
_eps$ = 20						; size = 4
?FindNearestKey@CEnvelope@@QAEXMAAPAPAUst_Key@@0M@Z PROC ; CEnvelope::FindNearestKey, COMDAT
; _this$ = ecx

; 31   : {

	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 32   : 	for (KeyIt k_it=keys.begin(); k_it!=keys.end(); k_it++){

	mov	eax, DWORD PTR [edi+4]
	lea	ebx, DWORD PTR [edi+4]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	mov	esi, eax
	mov	eax, DWORD PTR [edi+8]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 8
	cmp	esi, eax
	je	SHORT $LN3@FindNeares
	npad	12
$LL5@FindNeares:

; 33   :     	if (fsimilar((*k_it)->time,t,eps)){

	mov	eax, DWORD PTR [esi]
	movss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR tv203[esp+16], xmm0
	subss	xmm0, DWORD PTR _t$[esp+12]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_fabsf
	fld	DWORD PTR _eps$[esp+16]
	add	esp, 4
	fcomip	ST(1)
	fstp	ST(0)
	ja	SHORT $LN83@FindNeares

; 36   :         	return;
; 37   :         }
; 38   :     	if ((*k_it)->time>t){ 

	movss	xmm0, DWORD PTR tv203[esp+16]
	comiss	xmm0, DWORD PTR _t$[esp+12]
	ja	SHORT $LN84@FindNeares
	mov	eax, DWORD PTR [edi+8]
	push	eax
	add	esi, 4
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 4
	cmp	esi, eax
	jne	SHORT $LL5@FindNeares
$LN3@FindNeares:

; 41   :             return;
; 42   :         }
; 43   :     }
; 44   :     min_k=keys.empty()?keys.end():keys.end()-1;

	mov	ecx, ebx
	call	?empty@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QBE_NXZ ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::empty
	test	al, al
	mov	eax, DWORD PTR [edi+8]
	push	eax
	je	SHORT $LN12@FindNeares
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 4
	jmp	SHORT $LN13@FindNeares
$LN83@FindNeares:

; 34   :         	max_k = k_it+1;

	mov	edx, DWORD PTR _max_k$[esp+12]
	lea	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [edx], ecx

; 35   :         	min_k = (k_it==keys.begin())?k_it:k_it-1;

	mov	ebx, DWORD PTR [ebx]
	push	ebx
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 4
	cmp	esi, eax
	je	SHORT $LN9@FindNeares
	add	esi, -4					; fffffffcH
$LN9@FindNeares:
	mov	eax, DWORD PTR _min_k$[esp+12]
	pop	edi
	mov	DWORD PTR [eax], esi
	pop	esi
	pop	ebx

; 46   : }

	pop	ecx
	ret	16					; 00000010H
$LN84@FindNeares:

; 39   :         	max_k = k_it;

	mov	ecx, DWORD PTR _max_k$[esp+12]
	mov	DWORD PTR [ecx], esi

; 40   :         	min_k = (k_it==keys.begin())?k_it:k_it-1;

	mov	ebx, DWORD PTR [ebx]
	push	ebx
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 4
	cmp	esi, eax
	je	SHORT $LN11@FindNeares
	add	esi, -4					; fffffffcH
$LN11@FindNeares:
	mov	edx, DWORD PTR _min_k$[esp+12]
	pop	edi
	mov	DWORD PTR [edx], esi
	pop	esi
	pop	ebx

; 46   : }

	pop	ecx
	ret	16					; 00000010H
$LN12@FindNeares:

; 41   :             return;
; 42   :         }
; 43   :     }
; 44   :     min_k=keys.empty()?keys.end():keys.end()-1;

	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 4
	sub	eax, 4
$LN13@FindNeares:
	mov	ecx, DWORD PTR _min_k$[esp+12]
	mov	DWORD PTR [ecx], eax

; 45   :     max_k=keys.end();

	mov	edi, DWORD PTR [edi+8]
	push	edi
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	mov	edx, DWORD PTR _max_k$[esp+16]
	add	esp, 4
	pop	edi
	pop	esi
	mov	DWORD PTR [edx], eax
	pop	ebx

; 46   : }

	pop	ecx
	ret	16					; 00000010H
?FindNearestKey@CEnvelope@@QAEXMAAPAPAUst_Key@@0M@Z ENDP ; CEnvelope::FindNearestKey
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAE@XZ PROC ; stlp_std::vector<st_Key *,xalloc<st_Key *> >::~vector<st_Key *,xalloc<st_Key *> >, COMDAT
; _this$ = eax
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN36@vector@27
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN36@vector@27:
	ret	0
??1?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAE@XZ ENDP ; stlp_std::vector<st_Key *,xalloc<st_Key *> >::~vector<st_Key *,xalloc<st_Key *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$xr_vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@@QAE@XZ PROC ; xr_vector<st_Key *,xalloc<st_Key *> >::~xr_vector<st_Key *,xalloc<st_Key *> >, COMDAT
; _this$ = eax
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN38@xr_vector@21
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN38@xr_vector@21:
	ret	0
??1?$xr_vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@@QAE@XZ ENDP ; xr_vector<st_Key *,xalloc<st_Key *> >::~xr_vector<st_Key *,xalloc<st_Key *> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\envelope.h
_TEXT	ENDS
;	COMDAT ?equal@st_Key@@QAE_NABU1@@Z
_TEXT	SEGMENT
?equal@st_Key@@QAE_NABU1@@Z PROC			; st_Key::equal, COMDAT
; _this$ = edi
; _tgt$ = esi

; 52   :     	if (!fsimilar(value,tgt.value)) 			return false;

	movss	xmm0, DWORD PTR [edi]
	subss	xmm0, DWORD PTR [esi]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_fabsf
	fld	DWORD PTR _EPS
	add	esp, 4
	fcomip	ST(1)
	fstp	ST(0)
	jbe	$LN60@equal

; 53   :     	if (!fsimilar(shape,tgt.shape)) 			return false;

	movzx	ecx, BYTE PTR [esi+8]
	movzx	eax, BYTE PTR [edi+8]
	cvtsi2ss xmm0, eax
	cvtsi2ss xmm1, ecx
	push	ecx
	subss	xmm0, xmm1
	movss	DWORD PTR [esp], xmm0
	call	_fabsf
	fld	DWORD PTR _EPS
	add	esp, 4
	fcomip	ST(1)
	fstp	ST(0)
	jbe	SHORT $LN60@equal

; 54   :     	if (!fsimilar(tension,tgt.tension)) 		return false;

	movss	xmm0, DWORD PTR [edi+9]
	subss	xmm0, DWORD PTR [esi+9]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_fabsf
	fld	DWORD PTR _EPS
	add	esp, 4
	fcomip	ST(1)
	fstp	ST(0)
	jbe	SHORT $LN60@equal

; 55   :     	if (!fsimilar(continuity,tgt.continuity)) 	return false;

	movss	xmm0, DWORD PTR [edi+13]
	subss	xmm0, DWORD PTR [esi+13]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_fabsf
	fld	DWORD PTR _EPS
	add	esp, 4
	fcomip	ST(1)
	fstp	ST(0)
	jbe	SHORT $LN60@equal

; 56   :     	if (!fsimilar(bias,tgt.bias)) 				return false;

	movss	xmm0, DWORD PTR [edi+17]
	subss	xmm0, DWORD PTR [esi+17]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_fabsf
	fld	DWORD PTR _EPS
	add	esp, 4
	fcomi	ST(1)
	fstp	ST(1)
	ja	SHORT $LN5@equal
	fstp	ST(0)
$LN60@equal:
	xor	al, al

; 61   :         return true;
; 62   :     }

	ret	0
$LN5@equal:

; 57   :     	if (!fsimilar(param[0],tgt.param[0])) 		return false;

	movss	xmm0, DWORD PTR [edi+21]
	sub	esp, 8
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR [esi+21]
	fstp	DWORD PTR [esp]
	call	?fsimilar@@YAHMMM@Z			; fsimilar
	add	esp, 8
	test	eax, eax
	je	SHORT $LN60@equal

; 58   :     	if (!fsimilar(param[1],tgt.param[1]))	 	return false;

	fld	DWORD PTR _EPS
	movss	xmm0, DWORD PTR [edi+25]
	sub	esp, 8
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR [esi+25]
	fstp	DWORD PTR [esp]
	call	?fsimilar@@YAHMMM@Z			; fsimilar
	add	esp, 8
	test	eax, eax
	je	SHORT $LN60@equal

; 59   :     	if (!fsimilar(param[2],tgt.param[2])) 		return false;

	fld	DWORD PTR _EPS
	movss	xmm0, DWORD PTR [edi+29]
	sub	esp, 8
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR [esi+29]
	fstp	DWORD PTR [esp]
	call	?fsimilar@@YAHMMM@Z			; fsimilar
	add	esp, 8
	test	eax, eax
	je	SHORT $LN60@equal

; 60   :     	if (!fsimilar(param[3],tgt.param[3])) 		return false;

	fld	DWORD PTR _EPS
	movss	xmm0, DWORD PTR [edi+33]
	sub	esp, 8
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR [esi+33]
	fstp	DWORD PTR [esp]
	call	?fsimilar@@YAHMMM@Z			; fsimilar
	add	esp, 8
	test	eax, eax
	setne	al

; 61   :         return true;
; 62   :     }

	ret	0
?equal@st_Key@@QAE_NABU1@@Z ENDP			; st_Key::equal
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
;	COMDAT ??4?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
??4?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAEAAV01@ABV01@@Z PROC ; stlp_std::vector<st_Key *,xalloc<st_Key *> >::operator=, COMDAT
; _this$ = ecx
; ___x$ = eax

; 149  :   _Self& operator=(const _Self& __x) { _M_impl = __x._M_impl; return *this; }

	push	ebx
	mov	ebx, ecx
	push	eax
	call	??4?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::operator=
	mov	eax, ebx
	pop	ebx
	ret	0
??4?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAEAAV01@ABV01@@Z ENDP ; stlp_std::vector<st_Key *,xalloc<st_Key *> >::operator=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAE@ABV01@@Z PROC ; stlp_std::vector<st_Key *,xalloc<st_Key *> >::vector<st_Key *,xalloc<st_Key *> >, COMDAT
; _this$ = esi
; ___x$ = eax

; 123  :   vector(const _Self& __x)

	push	eax
	mov	ecx, esi
	call	??0?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAE@ABV012@@Z ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::_Impl_vector<void *,xalloc<void *> >
	mov	eax, esi
	ret	0
??0?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAE@ABV01@@Z ENDP ; stlp_std::vector<st_Key *,xalloc<st_Key *> >::vector<st_Key *,xalloc<st_Key *> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ??0?$xr_vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@@QAE@XZ PROC ; xr_vector<st_Key *,xalloc<st_Key *> >::xr_vector<st_Key *,xalloc<st_Key *> >, COMDAT
; _this$ = eax

; 123  : 			xr_vector			()									: inherited	()					{}

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$xr_vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@@QAE@XZ ENDP ; xr_vector<st_Key *,xalloc<st_Key *> >::xr_vector<st_Key *,xalloc<st_Key *> >
_TEXT	ENDS
PUBLIC	?Evaluate@CEnvelope@@QAEMM@Z			; CEnvelope::Evaluate
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\envelope.cpp
;	COMDAT ?Evaluate@CEnvelope@@QAEMM@Z
_TEXT	SEGMENT
tv70 = 8						; size = 4
_time$ = 8						; size = 4
?Evaluate@CEnvelope@@QAEMM@Z PROC			; CEnvelope::Evaluate, COMDAT
; _this$ = ecx

; 141  : 	return evalEnvelope(this, time);

	fld	DWORD PTR _time$[esp-4]
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	call	?evalEnvelope@@YAMPAVCEnvelope@@M@Z	; evalEnvelope
	movss	DWORD PTR tv70[esp+4], xmm0
	fld	DWORD PTR tv70[esp+4]
	add	esp, 8

; 142  : }

	ret	4
?Evaluate@CEnvelope@@QAEMM@Z ENDP			; CEnvelope::Evaluate
_TEXT	ENDS
PUBLIC	?ScaleKeys@CEnvelope@@QAEHMMMM@Z		; CEnvelope::ScaleKeys
; Function compile flags: /Ogtpy
;	COMDAT ?ScaleKeys@CEnvelope@@QAEHMMMM@Z
_TEXT	SEGMENT
_min_k$ = -4						; size = 4
_t0$115443 = 8						; size = 4
_max_k$ = 8						; size = 4
_k0$115437 = 8						; size = 4
_from_time$ = 8						; size = 4
_to_time$ = 12						; size = 4
_scale_factor$ = 16					; size = 4
_offset$115444 = 20					; size = 4
_k1$115440 = 20						; size = 4
_eps$ = 20						; size = 4
?ScaleKeys@CEnvelope@@QAEHMMMM@Z PROC			; CEnvelope::ScaleKeys, COMDAT
; _this$ = ecx

; 89   : {

	push	ecx

; 90   : 	KeyIt min_k	= FindKey(from_time,eps);

	fld	DWORD PTR _eps$[esp]
	push	ebx
	push	esi
	push	edi
	sub	esp, 8
	fstp	DWORD PTR [esp+4]
	mov	edi, ecx
	fld	DWORD PTR _from_time$[esp+20]
	fstp	DWORD PTR [esp]
	call	?FindKey@CEnvelope@@QAEPAPAUst_Key@@MM@Z ; CEnvelope::FindKey
	mov	esi, eax

; 91   :     if (min_k==keys.end()){

	mov	eax, DWORD PTR [edi+8]
	push	eax
	mov	DWORD PTR _min_k$[esp+20], esi
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 4
	cmp	esi, eax
	jne	SHORT $LN10@ScaleKeys

; 92   : 	    KeyIt k0;
; 93   : 		FindNearestKey(from_time, k0, min_k, eps);

	fld	DWORD PTR _eps$[esp+12]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	eax, DWORD PTR _min_k$[esp+20]
	fld	DWORD PTR _from_time$[esp+16]
	push	eax
	lea	ecx, DWORD PTR _k0$115437[esp+20]
	push	ecx
	push	ecx
	mov	ecx, edi
	fstp	DWORD PTR [esp]
	call	?FindNearestKey@CEnvelope@@QAEXMAAPAPAUst_Key@@0M@Z ; CEnvelope::FindNearestKey
	mov	esi, DWORD PTR _min_k$[esp+16]
$LN10@ScaleKeys:

; 94   :     }
; 95   :     KeyIt max_k	= FindKey(to_time,eps);

	fld	DWORD PTR _eps$[esp+12]
	sub	esp, 8
	fstp	DWORD PTR [esp+4]
	mov	ecx, edi
	fld	DWORD PTR _to_time$[esp+20]
	fstp	DWORD PTR [esp]
	call	?FindKey@CEnvelope@@QAEPAPAUst_Key@@MM@Z ; CEnvelope::FindKey
	mov	ebx, eax

; 96   :     if (max_k==keys.end()){

	mov	eax, DWORD PTR [edi+8]
	push	eax
	mov	DWORD PTR _max_k$[esp+16], ebx
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 4
	cmp	ebx, eax
	jne	SHORT $LN9@ScaleKeys

; 97   : 	    KeyIt k1;
; 98   : 		FindNearestKey(to_time, max_k, k1, eps);

	fld	DWORD PTR _eps$[esp+12]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	edx, DWORD PTR _k1$115440[esp+16]
	fld	DWORD PTR _to_time$[esp+16]
	push	edx
	lea	eax, DWORD PTR _max_k$[esp+20]
	push	eax
	push	ecx
	mov	ecx, edi
	fstp	DWORD PTR [esp]
	call	?FindNearestKey@CEnvelope@@QAEXMAAPAPAUst_Key@@0M@Z ; CEnvelope::FindNearestKey
	mov	ebx, DWORD PTR _max_k$[esp+12]
$LN9@ScaleKeys:

; 99   :     }
; 100  :     if (min_k!=keys.end()&&min_k!=max_k){

	mov	eax, DWORD PTR [edi+8]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 4
	cmp	esi, eax
	je	$LN8@ScaleKeys
	cmp	esi, ebx
	je	$LN8@ScaleKeys

; 101  :     	if (max_k!=keys.end()) max_k++;

	mov	eax, DWORD PTR [edi+8]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 4
	cmp	ebx, eax
	je	SHORT $LN7@ScaleKeys
	add	ebx, 4
$LN7@ScaleKeys:

; 102  :         float t0		= (*min_k)->time;

	mov	ecx, DWORD PTR [esi]
	movss	xmm3, DWORD PTR [ecx+4]

; 103  : 		float offset	= 0;

	xorps	xmm2, xmm2

; 104  :     	for (KeyIt it=min_k+1; it!=max_k; it++){

	add	esi, 4
	cmp	esi, ebx
	movss	DWORD PTR _t0$115443[esp+12], xmm3
	movss	DWORD PTR _offset$115444[esp+12], xmm2
	je	SHORT $LN4@ScaleKeys
	movss	xmm5, DWORD PTR _scale_factor$[esp+12]
	npad	2
$LL6@ScaleKeys:

; 105  :         	float new_time = offset+t0+((*it)->time-t0)*scale_factor;

	mov	eax, DWORD PTR [esi]
	movss	xmm4, DWORD PTR [eax+4]

; 106  :             offset		+= ((new_time-(*(it-1))->time)-((*it)->time-t0));

	mov	edx, DWORD PTR [esi-4]
	movaps	xmm1, xmm4
	subss	xmm1, xmm3
	movaps	xmm0, xmm1
	mulss	xmm0, xmm5
	addss	xmm0, xmm2
	addss	xmm0, xmm3
	movaps	xmm3, xmm0
	subss	xmm3, DWORD PTR [edx+4]
	subss	xmm3, xmm1
	addss	xmm3, xmm2
	add	esi, 4
	cmp	esi, ebx
	movaps	xmm2, xmm3

; 107  :             t0			= (*it)->time;

	movaps	xmm3, xmm4

; 108  :         	(*it)->time = new_time;

	movss	DWORD PTR [eax+4], xmm0
	jne	SHORT $LL6@ScaleKeys
	movss	DWORD PTR _t0$115443[esp+12], xmm3
	movss	DWORD PTR _offset$115444[esp+12], xmm2
$LN4@ScaleKeys:

; 109  :         }
; 110  :     	for (; it!=keys.end(); it++){

	mov	eax, DWORD PTR [edi+8]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 4
	cmp	esi, eax
	je	SHORT $LN1@ScaleKeys
	npad	2
$LL3@ScaleKeys:

; 111  :         	float new_time = offset+(*it)->time;

	mov	eax, DWORD PTR [esi]
	movss	xmm0, DWORD PTR [eax+4]
	movss	xmm2, DWORD PTR _offset$115444[esp+12]

; 112  :             offset		+= ((new_time-(*(it-1))->time)-((*it)->time-t0));

	mov	ecx, DWORD PTR [esi-4]
	movaps	xmm1, xmm0
	subss	xmm0, DWORD PTR _t0$115443[esp+12]
	addss	xmm1, xmm2
	movaps	xmm3, xmm1
	subss	xmm3, DWORD PTR [ecx+4]

; 113  :         	(*it)->time = new_time;

	movss	DWORD PTR [eax+4], xmm1
	mov	eax, DWORD PTR [edi+8]
	subss	xmm3, xmm0
	addss	xmm3, xmm2
	push	eax
	movss	DWORD PTR _offset$115444[esp+16], xmm3
	add	esi, 4
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 4
	cmp	esi, eax
	jne	SHORT $LL3@ScaleKeys
$LN1@ScaleKeys:
	pop	edi
	pop	esi

; 114  :         }
; 115  : 	    return TRUE;

	mov	eax, 1
	pop	ebx

; 118  : }

	pop	ecx
	ret	16					; 00000010H
$LN8@ScaleKeys:
	pop	edi
	pop	esi

; 116  :     }
; 117  :     return FALSE;

	xor	eax, eax
	pop	ebx

; 118  : }

	pop	ecx
	ret	16					; 00000010H
?ScaleKeys@CEnvelope@@QAEHMMMM@Z ENDP			; CEnvelope::ScaleKeys
_TEXT	ENDS
PUBLIC	??1CEnvelope@@UAE@XZ				; CEnvelope::~CEnvelope
; Function compile flags: /Ogtpy
;	COMDAT ??1CEnvelope@@UAE@XZ
_TEXT	SEGMENT
??1CEnvelope@@UAE@XZ PROC				; CEnvelope::~CEnvelope, COMDAT
; _this$ = ecx

; 7    : {

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CEnvelope@@6B@

; 8    : 	Clear();

	call	?Clear@CEnvelope@@QAEXXZ		; CEnvelope::Clear

; 9    : }

	mov	esi, DWORD PTR [esi+4]
	test	esi, esi
	je	SHORT $LN40@CEnvelope
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN40@CEnvelope:
	pop	esi
	ret	0
??1CEnvelope@@UAE@XZ ENDP				; CEnvelope::~CEnvelope
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4?$xr_vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
??4?$xr_vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@@QAEAAV0@ABV0@@Z PROC ; xr_vector<st_Key *,xalloc<st_Key *> >::operator=, COMDAT
; _this$ = ecx
; ___that$ = eax
	push	ebx
	mov	ebx, ecx
	push	eax
	call	??4?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::operator=
	mov	eax, ebx
	pop	ebx
	ret	0
??4?$xr_vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@@QAEAAV0@ABV0@@Z ENDP ; xr_vector<st_Key *,xalloc<st_Key *> >::operator=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$xr_vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
??0?$xr_vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@@QAE@ABV0@@Z PROC ; xr_vector<st_Key *,xalloc<st_Key *> >::xr_vector<st_Key *,xalloc<st_Key *> >, COMDAT
; _this$ = esi
; ___that$ = eax
	push	eax
	mov	ecx, esi
	call	??0?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAE@ABV012@@Z ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::_Impl_vector<void *,xalloc<void *> >
	mov	eax, esi
	ret	0
??0?$xr_vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@@QAE@ABV0@@Z ENDP ; xr_vector<st_Key *,xalloc<st_Key *> >::xr_vector<st_Key *,xalloc<st_Key *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_ECEnvelope@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_ECEnvelope@@UAEPAXI@Z PROC				; CEnvelope::`vector deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 2
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	esi, ecx
	je	SHORT $LN3@vector@70
	mov	edi, DWORD PTR [esi-4]
	mov	ebx, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	lea	ebp, DWORD PTR [esi-4]
	lea	eax, DWORD PTR [edi+edi*2]
	sub	edi, 1
	lea	esi, DWORD PTR [esi+eax*8]
	js	SHORT $LN6@vector@70
$LL7@vector@70:
	sub	esi, 24					; 00000018H
	mov	ecx, esi
	mov	DWORD PTR [esi], OFFSET ??_7CEnvelope@@6B@
	call	?Clear@CEnvelope@@QAEXXZ		; CEnvelope::Clear
	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN49@vector@70
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebx
$LN49@vector@70:
	sub	edi, 1
	jns	SHORT $LL7@vector@70
$LN6@vector@70:
	test	BYTE PTR ___flags$[esp+12], 1
	je	SHORT $LN54@vector@70
	test	ebp, ebp
	je	SHORT $LN54@vector@70
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	ebp
	call	ebx
$LN54@vector@70:
	mov	eax, ebp
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
$LN3@vector@70:
	mov	DWORD PTR [esi], OFFSET ??_7CEnvelope@@6B@
	call	?Clear@CEnvelope@@QAEXXZ		; CEnvelope::Clear
	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	mov	edi, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	je	SHORT $LN96@vector@70
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
$LN96@vector@70:
	test	BYTE PTR ___flags$[esp+12], 1
	je	SHORT $LN101@vector@70
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	edi
$LN101@vector@70:
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
??_ECEnvelope@@UAEPAXI@Z ENDP				; CEnvelope::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_GCEnvelope@@UAEPAXI@Z			; CEnvelope::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GCEnvelope@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCEnvelope@@UAEPAXI@Z PROC				; CEnvelope::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR [esi], OFFSET ??_7CEnvelope@@6B@
	call	?Clear@CEnvelope@@QAEXXZ		; CEnvelope::Clear
	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	mov	edi, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	je	SHORT $LN43@scalar@43
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
$LN43@scalar@43:
	test	BYTE PTR ___flags$[esp+4], 1
	je	SHORT $LN51@scalar@43
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	edi
$LN51@scalar@43:
	pop	edi
	mov	eax, esi
	pop	esi
	ret	4
??_GCEnvelope@@UAEPAXI@Z ENDP				; CEnvelope::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??4CEnvelope@@QAEAAV0@ABV0@@Z			; CEnvelope::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4CEnvelope@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4CEnvelope@@QAEAAV0@ABV0@@Z PROC			; CEnvelope::operator=, COMDAT
; _this$ = ecx
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+8]
	mov	esi, ecx
	lea	eax, DWORD PTR [edi+4]
	push	eax
	lea	ebx, DWORD PTR [esi+4]
	call	??4?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::operator=
	mov	ecx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi+16], ecx
	mov	edx, DWORD PTR [edi+20]
	pop	edi
	mov	DWORD PTR [esi+20], edx
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??4CEnvelope@@QAEAAV0@ABV0@@Z ENDP			; CEnvelope::operator=
_TEXT	ENDS
PUBLIC	??0CEnvelope@@QAE@ABV0@@Z			; CEnvelope::CEnvelope
; Function compile flags: /Ogtpy
;	COMDAT ??0CEnvelope@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0CEnvelope@@QAE@ABV0@@Z PROC				; CEnvelope::CEnvelope, COMDAT
; _this$ = ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+4]
	mov	esi, ecx
	lea	eax, DWORD PTR [edi+4]
	push	eax
	lea	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7CEnvelope@@6B@
	call	??0?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAE@ABV012@@Z ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::_Impl_vector<void *,xalloc<void *> >
	mov	ecx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi+16], ecx
	mov	edx, DWORD PTR [edi+20]
	pop	edi
	mov	DWORD PTR [esi+20], edx
	mov	eax, esi
	pop	esi
	ret	4
??0CEnvelope@@QAE@ABV0@@Z ENDP				; CEnvelope::CEnvelope
_TEXT	ENDS
PUBLIC	??0CEnvelope@@QAE@XZ				; CEnvelope::CEnvelope
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\envelope.h
;	COMDAT ??0CEnvelope@@QAE@XZ
_TEXT	SEGMENT
??0CEnvelope@@QAE@XZ PROC				; CEnvelope::CEnvelope, COMDAT
; _this$ = ecx

; 116  : 				CEnvelope	(){behavior[0]=1;behavior[1]=1;}

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], OFFSET ??_7CEnvelope@@6B@
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	ecx, 1
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], ecx
	ret	0
??0CEnvelope@@QAE@XZ ENDP				; CEnvelope::CEnvelope
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
;	COMDAT ?clear@?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAEXXZ PROC ; stlp_std::vector<st_Key *,xalloc<st_Key *> >::clear, COMDAT
; _this$ = edi

; 223  :   void clear() { _M_impl.clear(); }

	mov	ecx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edi]
	cmp	eax, ecx
	je	SHORT $LN12@clear@46
	push	esi
	mov	esi, ecx
	sub	esi, ecx
	je	SHORT $LN18@clear@46
	push	esi
	push	ecx
	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	add	eax, esi
$LN18@clear@46:
	mov	DWORD PTR [edi+4], eax
	pop	esi
$LN12@clear@46:
	ret	0
?clear@?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAEXXZ ENDP ; stlp_std::vector<st_Key *,xalloc<st_Key *> >::clear
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAEXABQAUst_Key@@@Z
_TEXT	SEGMENT
?push_back@?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAEXABQAUst_Key@@@Z PROC ; stlp_std::vector<st_Key *,xalloc<st_Key *> >::push_back, COMDAT
; _this$ = ecx
; ___x$ = eax

; 171  :   { _M_impl.push_back(cast_traits::to_storage_type_cref(__x)); }

	push	edi
	mov	edi, ecx
	mov	ecx, DWORD PTR [edi+4]
	cmp	ecx, DWORD PTR [edi+8]
	je	SHORT $LN8@push_back@48
	push	eax
	push	ecx
	call	??$_Copy_Construct@PAX@stlp_std@@YAXPAPAXABQAX@Z ; stlp_std::_Copy_Construct<void *>
	add	esp, 8
	add	DWORD PTR [edi+4], 4
	pop	edi
	ret	0
$LN8@push_back@48:
	push	1
	push	1
	push	ecx
	call	?_M_insert_overflow@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@AAEXPAPAXABQAXABU__true_type@3@I_N@Z ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::_M_insert_overflow
	pop	edi
	ret	0
?push_back@?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAEXABQAUst_Key@@@Z ENDP ; stlp_std::vector<st_Key *,xalloc<st_Key *> >::push_back
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ?clear_and_free@?$xr_vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear_and_free@?$xr_vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@@QAEXXZ PROC ; xr_vector<st_Key *,xalloc<st_Key *> >::clear_and_free, COMDAT
; _this$ = edi

; 128  : 	void	clear_and_free		()									{ inherited::clear();			}

	mov	ecx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edi]
	cmp	eax, ecx
	je	SHORT $LN14@clear_and_@14
	push	esi
	mov	esi, ecx
	sub	esi, ecx
	je	SHORT $LN20@clear_and_@14
	push	esi
	push	ecx
	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	add	eax, esi
$LN20@clear_and_@14:
	mov	DWORD PTR [edi+4], eax
	pop	esi
$LN14@clear_and_@14:
	ret	0
?clear_and_free@?$xr_vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@@QAEXXZ ENDP ; xr_vector<st_Key *,xalloc<st_Key *> >::clear_and_free
_TEXT	ENDS
PUBLIC	?Optimize@CEnvelope@@QAEXXZ			; CEnvelope::Optimize
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\envelope.cpp
;	COMDAT ?Optimize@CEnvelope@@QAEXXZ
_TEXT	SEGMENT
$T446265 = -60						; size = 4
$T446264 = -60						; size = 4
tv416 = -56						; size = 4
_new_keys$115569 = -52					; size = 12
_K$ = -40						; size = 37
?Optimize@CEnvelope@@QAEXXZ PROC			; CEnvelope::Optimize, COMDAT
; _this$ = ecx

; 222  : {

	sub	esp, 60					; 0000003cH
	push	ebx
	push	ebp
	mov	ebx, ecx
	push	esi

; 223  : 	if (keys.empty())

	lea	esi, DWORD PTR [ebx+4]
	push	edi
	mov	ecx, esi
	mov	DWORD PTR tv416[esp+76], esi
	call	?empty@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QBE_NXZ ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::empty
	test	al, al
	jne	$LN201@Optimize

; 224  : 		return;
; 225  : 
; 226  : 	KeyIt it 		= keys.begin();

	mov	eax, DWORD PTR [esi]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	mov	ebp, eax

; 227  :     st_Key K 		= **it;	it++;

	mov	esi, DWORD PTR [ebp]

; 228  :     bool equal		= true;
; 229  : 	for (;it!=keys.end();it++){

	mov	eax, DWORD PTR [ebx+8]
	mov	ecx, 9
	lea	edi, DWORD PTR _K$[esp+80]
	rep movsd
	push	eax
	movsb
	add	ebp, 4
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 8
	cmp	ebp, eax
	je	SHORT $LN209@Optimize
	npad	5
$LL8@Optimize:

; 230  :     	if (!(*it)->equal(K)){

	mov	edi, DWORD PTR [ebp]
	lea	esi, DWORD PTR _K$[esp+76]
	call	?equal@st_Key@@QAE_NABU1@@Z		; st_Key::equal
	test	al, al
	je	$LN201@Optimize
	mov	eax, DWORD PTR [ebx+8]
	push	eax
	add	ebp, 4
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 4
	cmp	ebp, eax
	jne	SHORT $LL8@Optimize
$LN209@Optimize:

; 231  :         	equal	= false;
; 232  :             break;
; 233  :         }
; 234  :     }
; 235  :     if (equal&&(keys.size()>2)){

	mov	eax, DWORD PTR tv416[esp+76]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR [eax]
	sar	ecx, 2
	cmp	ecx, 2
	jbe	$LN201@Optimize

; 236  :         KeyVec		new_keys;
; 237  : 		new_keys.push_back(xr_new<st_Key>(*keys.front()));

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ebp, DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	mov	edi, DWORD PTR [edx]
	xor	esi, esi
	push	37					; 00000025H
	mov	DWORD PTR _new_keys$115569[esp+80], esi
	mov	DWORD PTR _new_keys$115569[esp+84], esi
	mov	DWORD PTR _new_keys$115569[esp+88], esi
	call	ebp
	cmp	eax, esi
	je	SHORT $LN66@Optimize
	mov	esi, edi
	mov	ecx, 9
	mov	edi, eax
	rep movsd
	movsb
	mov	DWORD PTR $T446264[esp+76], eax
	xor	esi, esi
	jmp	SHORT $LN77@Optimize
$LN66@Optimize:
	mov	DWORD PTR $T446264[esp+76], esi
$LN77@Optimize:
	push	1
	push	1
	push	esi
	lea	eax, DWORD PTR $T446264[esp+88]
	lea	edi, DWORD PTR _new_keys$115569[esp+88]
	call	?_M_insert_overflow@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@AAEXPAPAXABQAXABU__true_type@3@I_N@Z ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::_M_insert_overflow

; 238  : 		new_keys.push_back(xr_new<st_Key>(*keys.back()));

	mov	eax, DWORD PTR [ebx+8]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	edi, DWORD PTR [eax-4]
	push	37					; 00000025H
	call	ebp
	cmp	eax, esi
	je	SHORT $LN98@Optimize
	mov	esi, edi
	mov	ecx, 9
	mov	edi, eax
	rep movsd
	movsb
	mov	DWORD PTR $T446265[esp+76], eax
	jmp	SHORT $LN99@Optimize
$LN98@Optimize:
	mov	DWORD PTR $T446265[esp+76], esi
$LN99@Optimize:
	mov	esi, DWORD PTR _new_keys$115569[esp+80]
	cmp	esi, DWORD PTR _new_keys$115569[esp+84]
	je	SHORT $LN109@Optimize
	lea	ecx, DWORD PTR $T446265[esp+76]
	push	ecx
	push	esi
	call	??$_Copy_Construct@PAX@stlp_std@@YAXPAPAXABQAX@Z ; stlp_std::_Copy_Construct<void *>
	add	esp, 8
	add	esi, 4
	mov	DWORD PTR _new_keys$115569[esp+80], esi
	jmp	SHORT $LN108@Optimize
$LN109@Optimize:
	push	1
	push	1
	push	esi
	lea	eax, DWORD PTR $T446265[esp+88]
	lea	edi, DWORD PTR _new_keys$115569[esp+88]
	call	?_M_insert_overflow@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@AAEXPAPAXABQAXABU__true_type@3@I_N@Z ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::_M_insert_overflow
$LN108@Optimize:

; 239  :         for (KeyIt k_it=keys.begin(); k_it!=keys.end(); k_it++)

	mov	edx, DWORD PTR tv416[esp+76]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	mov	esi, eax
	mov	eax, DWORD PTR [ebx+8]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	mov	edi, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	add	esp, 8
	cmp	esi, eax
	je	SHORT $LN1@Optimize
	npad	3
$LL3@Optimize:

; 240  :             xr_delete(*k_it);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Optimize
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
	mov	DWORD PTR [esi], 0
$LN2@Optimize:
	mov	eax, DWORD PTR [ebx+8]
	push	eax
	add	esi, 4
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 4
	cmp	esi, eax
	jne	SHORT $LL3@Optimize
$LN1@Optimize:

; 241  : 		keys.clear_and_free	();

	mov	ebx, DWORD PTR tv416[esp+76]
	mov	ecx, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [ebx]
	cmp	eax, ecx
	je	SHORT $LN152@Optimize
	mov	esi, ecx
	sub	esi, ecx
	je	SHORT $LN158@Optimize
	push	esi
	push	ecx
	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	add	eax, esi
$LN158@Optimize:
	mov	DWORD PTR [ebx+4], eax
$LN152@Optimize:

; 242  :         keys				= new_keys;

	lea	eax, DWORD PTR _new_keys$115569[esp+76]
	push	eax
	call	??4?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::operator=

; 243  :     }

	mov	eax, DWORD PTR _new_keys$115569[esp+76]
	test	eax, eax
	je	SHORT $LN201@Optimize
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
$LN201@Optimize:

; 244  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 60					; 0000003cH
	ret	0
?Optimize@CEnvelope@@QAEXXZ ENDP			; CEnvelope::Optimize
_TEXT	ENDS
PUBLIC	??0CEnvelope@@QAE@PAV0@@Z			; CEnvelope::CEnvelope
; Function compile flags: /Ogtpy
;	COMDAT ??0CEnvelope@@QAE@PAV0@@Z
_TEXT	SEGMENT
_i$115351 = -12						; size = 4
_this$ = -8						; size = 4
tv193 = -4						; size = 4
tv152 = 8						; size = 4
$T447125 = 8						; size = 4
_source$ = 8						; size = 4
??0CEnvelope@@QAE@PAV0@@Z PROC				; CEnvelope::CEnvelope, COMDAT
; _this$ = ecx

; 12   : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp

; 13   : 	*this 		= *source;

	mov	ebp, DWORD PTR _source$[esp+16]
	push	esi
	push	edi
	mov	edi, ecx
	lea	esi, DWORD PTR [edi+4]
	xor	eax, eax
	mov	DWORD PTR [edi], OFFSET ??_7CEnvelope@@6B@
	add	ebp, 4
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	push	ebp
	mov	ebx, esi
	mov	DWORD PTR _this$[esp+32], edi
	mov	DWORD PTR tv193[esp+32], esi
	mov	DWORD PTR [esi+8], eax
	call	??4?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::operator=
	mov	eax, DWORD PTR _source$[esp+24]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edi+16], ecx
	mov	edx, DWORD PTR [eax+20]
	mov	DWORD PTR [edi+20], edx

; 14   : 	for (u32 i=0; i<source->keys.size(); i++)

	mov	eax, DWORD PTR [ebp+4]
	sub	eax, DWORD PTR [ebp]
	xor	edi, edi
	sar	eax, 2
	mov	DWORD PTR _i$115351[esp+28], edi
	je	SHORT $LN75@CEnvelope@2
$LL3@CEnvelope@2:

; 15   :     	keys[i]	= xr_new<st_Key> (*source->keys[i]);

	mov	eax, DWORD PTR [ebp]
	push	eax
	lea	ebx, DWORD PTR [edi*4]
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	mov	ecx, DWORD PTR [eax+ebx]
	add	eax, ebx
	add	esp, 4
	mov	DWORD PTR $T447125[esp+24], ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	37					; 00000025H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	test	eax, eax
	je	SHORT $LN52@CEnvelope@2
	mov	esi, DWORD PTR $T447125[esp+24]
	mov	ecx, 9
	mov	edi, eax
	rep movsd
	movsb
	mov	esi, DWORD PTR tv193[esp+28]
	mov	edi, DWORD PTR _i$115351[esp+28]
	mov	DWORD PTR tv152[esp+24], eax
	jmp	SHORT $LN58@CEnvelope@2
$LN52@CEnvelope@2:
	mov	DWORD PTR tv152[esp+24], 0
$LN58@CEnvelope@2:
	mov	eax, DWORD PTR [esi]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	mov	edx, DWORD PTR tv152[esp+28]
	mov	DWORD PTR [eax+ebx], edx
	mov	eax, DWORD PTR [ebp+4]
	sub	eax, DWORD PTR [ebp]
	add	edi, 1
	sar	eax, 2
	add	esp, 4
	cmp	edi, eax
	mov	DWORD PTR _i$115351[esp+28], edi
	jb	SHORT $LL3@CEnvelope@2
$LN75@CEnvelope@2:

; 16   : }

	mov	eax, DWORD PTR _this$[esp+28]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	4
??0CEnvelope@@QAE@PAV0@@Z ENDP				; CEnvelope::CEnvelope
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.c
;	COMDAT ?insert@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEPAPAXPAPAXABQAX@Z
_TEXT	SEGMENT
$T492668 = -1						; size = 1
?insert@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEPAPAXPAPAXABQAX@Z PROC ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::insert, COMDAT
; _this$ = edx
; ___pos$ = ecx
; ___x$ = eax

; 216  : vector<_Tp, _Alloc>::insert(iterator __pos, const _Tp& __x) {

	push	ecx
	push	esi
	push	edi
	mov	edi, edx

; 217  :   size_type __n = __pos - begin();
; 218  :   _M_fill_insert(__pos, 1, __x);

	mov	edx, DWORD PTR [edi+8]
	sub	edx, DWORD PTR [edi+4]
	mov	esi, ecx
	sub	esi, DWORD PTR [edi]
	sar	edx, 2
	sar	esi, 2
	cmp	edx, 1
	jb	SHORT $LN6@insert@14
	lea	edx, DWORD PTR $T492668[esp+12]
	push	edx
	push	eax
	push	1
	push	ecx
	mov	ecx, edi
	call	?_M_fill_insert_aux@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@AAEXPAPAXIABQAXABU__false_type@3@@Z ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::_M_fill_insert_aux

; 219  :   return begin() + __n;

	mov	eax, DWORD PTR [edi]
	pop	edi
	lea	eax, DWORD PTR [eax+esi*4]
	pop	esi

; 220  : }

	pop	ecx
	ret	0

; 217  :   size_type __n = __pos - begin();
; 218  :   _M_fill_insert(__pos, 1, __x);

$LN6@insert@14:
	push	0
	push	1
	push	ecx
	call	?_M_insert_overflow@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@AAEXPAPAXABQAXABU__true_type@3@I_N@Z ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::_M_insert_overflow

; 219  :   return begin() + __n;

	mov	eax, DWORD PTR [edi]
	pop	edi
	lea	eax, DWORD PTR [eax+esi*4]
	pop	esi

; 220  : }

	pop	ecx
	ret	0
?insert@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEPAPAXPAPAXABQAX@Z ENDP ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::insert
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ?resize@?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAEXIABQAUst_Key@@@Z
_TEXT	SEGMENT
?resize@?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAEXIABQAUst_Key@@@Z PROC ; stlp_std::vector<st_Key *,xalloc<st_Key *> >::resize, COMDAT
; _this$ = edx
; ___new_size$ = ecx
; ___x$ = eax

; 217  :   { _M_impl.resize(__new_size, cast_traits::to_storage_type_cref(__x)); }

	jmp	?resize@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEXIABQAX@Z ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::resize
?resize@?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAEXIABQAUst_Key@@@Z ENDP ; stlp_std::vector<st_Key *,xalloc<st_Key *> >::resize
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?insert@?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAEPAPAUst_Key@@PAPAU3@ABQAU3@@Z
_TEXT	SEGMENT
$T492732 = -1						; size = 1
?insert@?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAEPAPAUst_Key@@PAPAU3@ABQAU3@@Z PROC ; stlp_std::vector<st_Key *,xalloc<st_Key *> >::insert, COMDAT
; _this$ = edx
; ___pos$ = ecx
; ___x$ = eax

; 178  :   { return cast_traits::to_value_type_ptr(_M_impl.insert(cast_traits::to_storage_type_ptr(__pos),

	push	ecx
	push	esi
	push	edi
	mov	edi, edx

; 179  :                                                          cast_traits::to_storage_type_cref(__x))); }

	mov	edx, DWORD PTR [edi+8]
	sub	edx, DWORD PTR [edi+4]
	mov	esi, ecx
	sub	esi, DWORD PTR [edi]
	sar	edx, 2
	sar	esi, 2
	cmp	edx, 1
	jb	SHORT $LN16@insert@15
	lea	edx, DWORD PTR $T492732[esp+12]
	push	edx
	push	eax
	push	1
	push	ecx
	mov	ecx, edi
	call	?_M_fill_insert_aux@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@AAEXPAPAXIABQAXABU__false_type@3@@Z ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::_M_fill_insert_aux
	mov	edi, DWORD PTR [edi]
	lea	eax, DWORD PTR [edi+esi*4]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 4
	pop	edi
	pop	esi
	pop	ecx
	ret	0
$LN16@insert@15:
	push	0
	push	1
	push	ecx
	call	?_M_insert_overflow@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@AAEXPAPAXABQAXABU__true_type@3@I_N@Z ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::_M_insert_overflow
	mov	edi, DWORD PTR [edi]
	lea	eax, DWORD PTR [edi+esi*4]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 4
	pop	edi
	pop	esi
	pop	ecx
	ret	0
?insert@?$vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@stlp_std@@QAEPAPAUst_Key@@PAPAU3@ABQAU3@@Z ENDP ; stlp_std::vector<st_Key *,xalloc<st_Key *> >::insert
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ?clear@?$xr_vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$xr_vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@@QAEXXZ PROC ; xr_vector<st_Key *,xalloc<st_Key *> >::clear, COMDAT
; _this$ = edi

; 133  : 	void	clear				()									{ clear_and_free	();			}

	mov	ecx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edi]
	cmp	eax, ecx
	je	SHORT $LN16@clear@69
	push	esi
	mov	esi, ecx
	sub	esi, ecx
	je	SHORT $LN22@clear@69
	push	esi
	push	ecx
	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	add	eax, esi
$LN22@clear@69:
	mov	DWORD PTR [edi+4], eax
	pop	esi
$LN16@clear@69:
	ret	0
?clear@?$xr_vector@PAUst_Key@@V?$xalloc@PAUst_Key@@@@@@QAEXXZ ENDP ; xr_vector<st_Key *,xalloc<st_Key *> >::clear
_TEXT	ENDS
PUBLIC	?LoadA@CEnvelope@@QAEXAAVIReader@@@Z		; CEnvelope::LoadA
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\envelope.cpp
;	COMDAT ?LoadA@CEnvelope@@QAEXAAVIReader@@@Z
_TEXT	SEGMENT
_f$ = -556						; size = 36
_this$ = -520						; size = 4
$T492875 = -516						; size = 4
_buf$ = -512						; size = 512
_F$ = 8							; size = 4
?LoadA@CEnvelope@@QAEXAAVIReader@@@Z PROC		; CEnvelope::LoadA, COMDAT
; _this$ = ecx

; 181  : {

	sub	esp, 556				; 0000022cH
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _this$[esp+568], edi

; 182  : 	Clear		();

	call	?Clear@CEnvelope@@QAEXXZ		; CEnvelope::Clear

; 183  : 	string512 	buf;
; 184  :     float		f[9];
; 185  : 	F.r_string(buf,sizeof(buf));

	mov	ebx, DWORD PTR _F$[esp+564]
	mov	esi, DWORD PTR __imp_?r_string@IReader@@QAEXPADI@Z
	push	512					; 00000200H
	lea	eax, DWORD PTR _buf$[esp+572]
	push	eax
	mov	ecx, ebx
	call	esi

; 186  : 	if (strstr(buf,"{ Envelope")){

	lea	ecx, DWORD PTR _buf$[esp+568]
	push	OFFSET ??_C@_0L@PDDPJNOG@?$HL?5Envelope?$AA@
	push	ecx
	call	DWORD PTR __imp__strstr
	add	esp, 8
	test	eax, eax
	je	$LN2@LoadA
	push	ebp

; 187  : 		F.r_string(buf,sizeof(buf));

	push	512					; 00000200H
	lea	edx, DWORD PTR _buf$[esp+576]
	push	edx
	mov	ecx, ebx
	call	esi

; 188  :         int nkeys=atoi(buf);

	lea	eax, DWORD PTR _buf$[esp+572]
	push	eax
	call	DWORD PTR __imp__atoi
	mov	ecx, eax

; 189  : 		keys.resize(nkeys);

	lea	esi, DWORD PTR [edi+4]
	xor	ebp, ebp
	add	esp, 4
	lea	eax, DWORD PTR $T492875[esp+572]
	mov	edx, esi
	mov	DWORD PTR $T492875[esp+572], ebp
	call	?resize@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEXIABQAX@Z ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::resize

; 190  : 		for (u32 i=0; i<keys.size(); i++){

	mov	ecx, DWORD PTR [esi+4]
	sub	ecx, DWORD PTR [esi]
	sar	ecx, 2
	je	$LN12@LoadA
	npad	5
$LL14@LoadA:

; 191  :     		keys[i]	= xr_new<st_Key> ();

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	37					; 00000025H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	mov	edi, eax
	test	edi, edi
	je	SHORT $LN34@LoadA
	mov	edx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	eax, DWORD PTR [edx+12]
	push	37					; 00000025H
	push	0
	push	edi
	call	eax
	jmp	SHORT $LN42@LoadA
$LN34@LoadA:
	xor	edi, edi
$LN42@LoadA:
	mov	eax, DWORD PTR [esi]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	mov	DWORD PTR [eax+ebp*4], edi

; 192  :             st_Key& K=*keys[i];

	mov	eax, DWORD PTR [esi]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	mov	edi, DWORD PTR [eax+ebp*4]
	add	esp, 8

; 193  : 			F.r_string(buf,sizeof(buf));

	push	512					; 00000200H
	lea	ecx, DWORD PTR _buf$[esp+576]
	push	ecx
	mov	ecx, ebx
	call	DWORD PTR __imp_?r_string@IReader@@QAEXPADI@Z

; 194  :             int cnt = sscanf	(buf,"Key %f %f %f %f %f %f %f %f %f", f+0, f+1, f+2, f+3, f+4, f+5, f+6, f+7, f+8);

	lea	edx, DWORD PTR _f$[esp+604]
	push	edx
	lea	eax, DWORD PTR _f$[esp+604]
	push	eax
	lea	ecx, DWORD PTR _f$[esp+604]
	push	ecx
	lea	edx, DWORD PTR _f$[esp+604]
	push	edx
	lea	eax, DWORD PTR _f$[esp+604]
	push	eax
	lea	ecx, DWORD PTR _f$[esp+604]
	push	ecx
	lea	edx, DWORD PTR _f$[esp+604]
	push	edx
	lea	eax, DWORD PTR _f$[esp+604]
	push	eax
	lea	ecx, DWORD PTR _f$[esp+604]
	push	ecx
	lea	edx, DWORD PTR _buf$[esp+608]
	push	OFFSET ??_C@_0BP@MGCNGGP@Key?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?$AA@
	push	edx
	call	DWORD PTR __imp__sscanf
	add	esp, 44					; 0000002cH

; 195  :             R_ASSERT(cnt==9);

	cmp	BYTE PTR ?ignore_always@?8??LoadA@CEnvelope@@QAEXAAVIReader@@@Z@4_NA, 0
	jne	SHORT $LN10@LoadA
	cmp	eax, 9
	je	SHORT $LN10@LoadA
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?8??LoadA@CEnvelope@@QAEXAAVIReader@@@Z@4_NA
	push	OFFSET ??_C@_0BB@JCNOMHAO@CEnvelope?3?3LoadA?$AA@
	push	195					; 000000c3H
	push	OFFSET ??_C@_0DB@FKACCOIF@D?3?2CLEARSKY?2sources?2engine?2xrEng@
	push	OFFSET ??_C@_06MGBHIFNJ@cnt?$DN?$DN9?$AA@
	call	DWORD PTR __imp_?fail@xrDebug@@QAEXPBD0H0AA_N@Z
$LN10@LoadA:

; 196  : 			K.value = f[ 0 ];

	movss	xmm0, DWORD PTR _f$[esp+572]
	movss	DWORD PTR [edi], xmm0

; 197  :       		K.time  = f[ 1 ];

	movss	xmm0, DWORD PTR _f$[esp+576]
	movss	DWORD PTR [edi+4], xmm0

; 198  :       		K.shape = ( u8 ) f[ 2 ];

	cvttss2si eax, DWORD PTR _f$[esp+580]

; 199  : 			if ( K.shape == SHAPE_TCB ) {

	test	al, al
	mov	BYTE PTR [edi+8], al
	jne	SHORT $LN7@LoadA

; 200  :          		K.tension    = f[ 3 ];

	movss	xmm0, DWORD PTR _f$[esp+584]
	movss	DWORD PTR [edi+9], xmm0

; 201  :          		K.continuity = f[ 4 ];

	movss	xmm0, DWORD PTR _f$[esp+588]
	movss	DWORD PTR [edi+13], xmm0

; 202  :          		K.bias       = f[ 5 ];

	movss	xmm0, DWORD PTR _f$[esp+592]
	movss	DWORD PTR [edi+17], xmm0
$LN7@LoadA:

; 203  :       		}
; 204  :             if ( K.shape == SHAPE_BEZ2 ) {

	cmp	al, 5
	jne	SHORT $LN6@LoadA

; 205  :          		K.param[ 0 ] = f[ 3 ];

	movss	xmm0, DWORD PTR _f$[esp+584]
	movss	DWORD PTR [edi+21], xmm0

; 206  :          		K.param[ 1 ] = f[ 4 ];

	movss	xmm0, DWORD PTR _f$[esp+588]
	movss	DWORD PTR [edi+25], xmm0

; 207  :          		K.param[ 2 ] = f[ 5 ];

	movss	xmm0, DWORD PTR _f$[esp+592]
	movss	DWORD PTR [edi+29], xmm0

; 208  :          		K.param[ 3 ] = f[ 6 ];

	movss	xmm0, DWORD PTR _f$[esp+596]
	movss	DWORD PTR [edi+33], xmm0

; 209  :       		}else{

	jmp	SHORT $LN13@LoadA
$LN6@LoadA:

; 210  :          		K.param[ 0 ] = f[ 6 ];

	movss	xmm0, DWORD PTR _f$[esp+596]
	movss	DWORD PTR [edi+21], xmm0

; 211  :                 K.param[ 1 ] = f[ 7 ];

	movss	xmm0, DWORD PTR _f$[esp+600]
	movss	DWORD PTR [edi+25], xmm0
$LN13@LoadA:
	mov	eax, DWORD PTR [esi+4]
	sub	eax, DWORD PTR [esi]
	add	ebp, 1
	sar	eax, 2
	cmp	ebp, eax
	jb	$LL14@LoadA

; 190  : 		for (u32 i=0; i<keys.size(); i++){

	mov	edi, DWORD PTR _this$[esp+572]
$LN12@LoadA:

; 212  :       		}
; 213  : 	    }
; 214  :         // behavior <pre> <post>
; 215  : 		F.r_string(buf,sizeof(buf));

	push	512					; 00000200H
	lea	ecx, DWORD PTR _buf$[esp+576]
	push	ecx
	mov	ecx, ebx
	call	DWORD PTR __imp_?r_string@IReader@@QAEXPADI@Z

; 216  : 		int cnt = sscanf(buf,"Behaviors %d %d", behavior[0], behavior[1] );

	mov	edx, DWORD PTR [edi+20]
	mov	eax, DWORD PTR [edi+16]
	push	edx
	push	eax
	lea	ecx, DWORD PTR _buf$[esp+580]
	push	OFFSET ??_C@_0BA@PAABFJOJ@Behaviors?5?$CFd?5?$CFd?$AA@
	push	ecx
	call	DWORD PTR __imp__sscanf
	add	esp, 16					; 00000010H

; 217  :         R_ASSERT(cnt==2);

	cmp	BYTE PTR ?ignore_always@?BF@??LoadA@CEnvelope@@QAEXAAVIReader@@@Z@4_NA, 0
	pop	ebp
	jne	SHORT $LN2@LoadA
	cmp	eax, 2
	je	SHORT $LN2@LoadA
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?BF@??LoadA@CEnvelope@@QAEXAAVIReader@@@Z@4_NA
	push	OFFSET ??_C@_0BB@JCNOMHAO@CEnvelope?3?3LoadA?$AA@
	push	217					; 000000d9H
	push	OFFSET ??_C@_0DB@FKACCOIF@D?3?2CLEARSKY?2sources?2engine?2xrEng@
	push	OFFSET ??_C@_06CFODFMBC@cnt?$DN?$DN2?$AA@
	call	DWORD PTR __imp_?fail@xrDebug@@QAEXPBD0H0AA_N@Z
$LN2@LoadA:
	pop	edi
	pop	esi
	pop	ebx

; 218  :     }
; 219  : }

	add	esp, 556				; 0000022cH
	ret	4
?LoadA@CEnvelope@@QAEXAAVIReader@@@Z ENDP		; CEnvelope::LoadA
_TEXT	ENDS
PUBLIC	?Load_2@CEnvelope@@QAEXAAVIReader@@@Z		; CEnvelope::Load_2
; Function compile flags: /Ogtpy
;	COMDAT ?Load_2@CEnvelope@@QAEXAAVIReader@@@Z
_TEXT	SEGMENT
$T492989 = -4						; size = 4
_F$ = 8							; size = 4
?Load_2@CEnvelope@@QAEXAAVIReader@@@Z PROC		; CEnvelope::Load_2, COMDAT
; _this$ = ecx

; 166  : {

	push	ecx
	push	ebx
	push	ebp
	push	esi
	mov	ebx, ecx

; 167  : 	Clear		();

	call	?Clear@CEnvelope@@QAEXXZ		; CEnvelope::Clear

; 168  : 	behavior[0]	= F.r_u8();

	mov	esi, DWORD PTR _F$[esp+12]
	mov	ecx, esi
	call	DWORD PTR __imp_?r_u8@?$IReaderBase@VIReader@@@@QAEEXZ
	movzx	eax, al

; 169  : 	behavior[1]	= F.r_u8();

	mov	ecx, esi
	mov	DWORD PTR [ebx+16], eax
	call	DWORD PTR __imp_?r_u8@?$IReaderBase@VIReader@@@@QAEEXZ
	movzx	ecx, al
	mov	DWORD PTR [ebx+20], ecx

; 170  : 	keys.resize	(F.r_u16());

	xor	ebp, ebp
	mov	ecx, esi
	mov	DWORD PTR $T492989[esp+16], ebp
	call	DWORD PTR __imp_?r_u16@?$IReaderBase@VIReader@@@@QAEGXZ
	movzx	ecx, ax
	add	ebx, 4
	lea	eax, DWORD PTR $T492989[esp+16]
	mov	edx, ebx
	call	?resize@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEXIABQAX@Z ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::resize

; 171  : 	for (u32 i=0; i<keys.size(); i++){

	mov	edx, DWORD PTR [ebx+4]
	sub	edx, DWORD PTR [ebx]
	sar	edx, 2
	je	SHORT $LN1@Load_2@2
	push	edi
	npad	11
$LL54@Load_2@2:

; 172  :     	keys[i]	= xr_new<st_Key> ();

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	37					; 00000025H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	mov	edi, eax
	test	edi, edi
	je	SHORT $LN20@Load_2@2
	mov	eax, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ecx, DWORD PTR [eax+12]
	push	37					; 00000025H
	push	0
	push	edi
	call	ecx
	mov	esi, edi
	jmp	SHORT $LN28@Load_2@2
$LN20@Load_2@2:
	xor	esi, esi
$LN28@Load_2@2:
	mov	eax, DWORD PTR [ebx]
	push	eax
	lea	edi, DWORD PTR [ebp*4]
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	mov	DWORD PTR [eax+edi], esi

; 173  :         keys[i]->Load_2(F);

	mov	eax, DWORD PTR [ebx]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	mov	esi, DWORD PTR _F$[esp+24]
	add	eax, edi
	mov	edi, DWORD PTR [eax]
	add	esp, 8
	call	?Load_2@st_Key@@QAEXAAVIReader@@@Z	; st_Key::Load_2
	mov	edx, DWORD PTR [ebx+4]
	sub	edx, DWORD PTR [ebx]
	add	ebp, 1
	sar	edx, 2
	cmp	ebp, edx
	jb	SHORT $LL54@Load_2@2
	pop	edi
$LN1@Load_2@2:
	pop	esi
	pop	ebp
	pop	ebx

; 174  :     }
; 175  : }

	pop	ecx
	ret	4
?Load_2@CEnvelope@@QAEXAAVIReader@@@Z ENDP		; CEnvelope::Load_2
_TEXT	ENDS
PUBLIC	?Load_1@CEnvelope@@QAEXAAVIReader@@@Z		; CEnvelope::Load_1
; Function compile flags: /Ogtpy
;	COMDAT ?Load_1@CEnvelope@@QAEXAAVIReader@@@Z
_TEXT	SEGMENT
tv139 = 8						; size = 4
$T493103 = 8						; size = 4
_F$ = 8							; size = 4
?Load_1@CEnvelope@@QAEXAAVIReader@@@Z PROC		; CEnvelope::Load_1, COMDAT
; _this$ = ecx

; 154  : {

	push	ebx
	push	ebp
	push	edi
	mov	ebx, ecx

; 155  : 	Clear		();

	call	?Clear@CEnvelope@@QAEXXZ		; CEnvelope::Clear

; 156  : 	F.r			(behavior,sizeof(int)*2);

	mov	edi, DWORD PTR _F$[esp+8]
	push	8
	lea	eax, DWORD PTR [ebx+16]
	push	eax
	mov	ecx, edi
	call	DWORD PTR __imp_?r@IReader@@QAEXPAXH@Z

; 157  :     int y		= F.r_u32();

	mov	ecx, edi
	call	DWORD PTR __imp_?r_u32@?$IReaderBase@VIReader@@@@QAEIXZ
	mov	ecx, eax

; 158  : 	keys.resize	(y);

	add	ebx, 4
	xor	ebp, ebp
	lea	eax, DWORD PTR $T493103[esp+8]
	mov	edx, ebx
	mov	DWORD PTR $T493103[esp+8], ebp
	call	?resize@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEXIABQAX@Z ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::resize

; 159  : 	for (u32 i=0; i<keys.size(); i++){

	mov	ecx, DWORD PTR [ebx+4]
	sub	ecx, DWORD PTR [ebx]
	sar	ecx, 2
	je	$LN1@Load_1
	push	esi
	npad	7
$LL56@Load_1:

; 160  :     	keys[i]	= xr_new<st_Key> ();

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	37					; 00000025H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN20@Load_1
	mov	edx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	eax, DWORD PTR [edx+12]
	push	37					; 00000025H
	push	0
	push	esi
	call	eax
	mov	DWORD PTR tv139[esp+12], esi
	jmp	SHORT $LN28@Load_1
$LN20@Load_1:
	mov	DWORD PTR tv139[esp+12], 0
$LN28@Load_1:
	mov	eax, DWORD PTR [ebx]
	push	eax
	lea	esi, DWORD PTR [ebp*4]
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	mov	ecx, DWORD PTR tv139[esp+16]
	mov	DWORD PTR [eax+esi], ecx

; 161  :         keys[i]->Load_1(F);

	mov	eax, DWORD PTR [ebx]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	eax, esi
	mov	esi, DWORD PTR [eax]
	add	esp, 8
	mov	ecx, edi
	call	DWORD PTR __imp_?r_float@?$IReaderBase@VIReader@@@@QAEMXZ
	fstp	DWORD PTR [esi]
	mov	ecx, edi
	call	DWORD PTR __imp_?r_float@?$IReaderBase@VIReader@@@@QAEMXZ
	fstp	DWORD PTR [esi+4]
	mov	ecx, edi
	call	DWORD PTR __imp_?r_u32@?$IReaderBase@VIReader@@@@QAEIXZ
	mov	ecx, edi
	mov	BYTE PTR [esi+8], al
	call	DWORD PTR __imp_?r_float@?$IReaderBase@VIReader@@@@QAEMXZ
	fstp	DWORD PTR [esi+9]
	mov	ecx, edi
	call	DWORD PTR __imp_?r_float@?$IReaderBase@VIReader@@@@QAEMXZ
	fstp	DWORD PTR [esi+13]
	mov	ecx, edi
	call	DWORD PTR __imp_?r_float@?$IReaderBase@VIReader@@@@QAEMXZ
	fstp	DWORD PTR [esi+17]
	push	16					; 00000010H
	add	esi, 21					; 00000015H
	push	esi
	mov	ecx, edi
	call	DWORD PTR __imp_?r@IReader@@QAEXPAXH@Z
	mov	edx, DWORD PTR [ebx+4]
	sub	edx, DWORD PTR [ebx]
	add	ebp, 1
	sar	edx, 2
	cmp	ebp, edx
	jb	$LL56@Load_1
	pop	esi
$LN1@Load_1:
	pop	edi
	pop	ebp
	pop	ebx

; 162  :     }
; 163  : }

	ret	4
?Load_1@CEnvelope@@QAEXAAVIReader@@@Z ENDP		; CEnvelope::Load_1
_TEXT	ENDS
PUBLIC	?InsertKey@CEnvelope@@QAEXMM@Z			; CEnvelope::InsertKey
; Function compile flags: /Ogtpy
;	COMDAT ?InsertKey@CEnvelope@@QAEXMM@Z
_TEXT	SEGMENT
tv235 = -4						; size = 4
_K$ = -4						; size = 4
$T493357 = 8						; size = 1
_t$ = 8							; size = 4
_val$ = 12						; size = 4
?InsertKey@CEnvelope@@QAEXMM@Z PROC			; CEnvelope::InsertKey, COMDAT
; _this$ = ecx

; 58   : {	

	push	ecx
	push	ebx
	push	esi
	mov	ebx, ecx

; 59   : 	for (KeyIt k_it=keys.begin(); k_it!=keys.end(); k_it++){

	mov	eax, DWORD PTR [ebx+4]
	push	edi
	lea	edi, DWORD PTR [ebx+4]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	mov	esi, eax
	mov	eax, DWORD PTR [ebx+8]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 8
	cmp	esi, eax
	je	SHORT $LN67@InsertKey@2
	npad	12
$LL5@InsertKey@2:

; 60   :     	if (fsimilar((*k_it)->time,t,EPS_L)){ 

	mov	eax, DWORD PTR [esi]
	movss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR tv235[esp+16], xmm0
	subss	xmm0, DWORD PTR _t$[esp+12]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_fabsf
	fld	DWORD PTR _EPS_L
	add	esp, 4
	fcomip	ST(1)
	fstp	ST(0)
	ja	SHORT $LN66@InsertKey@2

; 62   :             return;
; 63   :         }
; 64   :         // insert before
; 65   :     	if ((*k_it)->time>t) break;

	movss	xmm0, DWORD PTR tv235[esp+16]
	comiss	xmm0, DWORD PTR _t$[esp+12]
	ja	SHORT $LN67@InsertKey@2
	mov	eax, DWORD PTR [ebx+8]
	push	eax
	add	esi, 4
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 4
	cmp	esi, eax
	jne	SHORT $LL5@InsertKey@2
$LN67@InsertKey@2:

; 66   :     }
; 67   :     // create _new key
; 68   :     st_Key* K 	= xr_new<st_Key>();

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	ebp
	push	37					; 00000025H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	mov	ebp, eax
	test	ebp, ebp
	je	SHORT $LN34@InsertKey@2
	mov	edx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	eax, DWORD PTR [edx+12]
	push	37					; 00000025H
	push	0
	push	ebp
	call	eax
	mov	eax, ebp
	jmp	SHORT $LN72@InsertKey@2
$LN66@InsertKey@2:

; 61   :         	(*k_it)->value= val;

	mov	ecx, DWORD PTR [esi]
	movss	xmm0, DWORD PTR _val$[esp+12]
	pop	edi
	pop	esi
	movss	DWORD PTR [ecx], xmm0
	pop	ebx

; 75   : }

	pop	ecx
	ret	8

; 66   :     }
; 67   :     // create _new key
; 68   :     st_Key* K 	= xr_new<st_Key>();

$LN34@InsertKey@2:
	xor	eax, eax
$LN72@InsertKey@2:

; 69   :     K->time 	= t;

	movss	xmm0, DWORD PTR _t$[esp+16]
	movss	DWORD PTR [eax+4], xmm0

; 70   :     K->value 	= val;

	movss	xmm0, DWORD PTR _val$[esp+16]
	movss	DWORD PTR [eax], xmm0

; 71   :     K->shape	= SHAPE_TCB; 

	mov	BYTE PTR [eax+8], 0
	mov	DWORD PTR _K$[esp+20], eax

; 72   :     behavior[0]	= BEH_CONSTANT;

	mov	eax, 1
	mov	DWORD PTR [ebx+16], eax

; 73   :     behavior[1]	= BEH_CONSTANT;

	mov	DWORD PTR [ebx+20], eax

; 74   :     keys.insert	(k_it,K);

	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, DWORD PTR [edi+4]
	mov	ebx, esi
	sub	ebx, DWORD PTR [edi]
	sar	ecx, 2
	sar	ebx, 2
	cmp	ecx, eax
	pop	ebp
	jb	SHORT $LN55@InsertKey@2
	lea	edx, DWORD PTR $T493357[esp+12]
	push	edx
	lea	ecx, DWORD PTR _K$[esp+20]
	push	ecx
	push	eax
	push	esi
	mov	ecx, edi
	call	?_M_fill_insert_aux@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@AAEXPAPAXIABQAXABU__false_type@3@@Z ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::_M_fill_insert_aux
	jmp	SHORT $LN54@InsertKey@2
$LN55@InsertKey@2:
	push	0
	push	eax
	push	esi
	lea	eax, DWORD PTR _K$[esp+28]
	call	?_M_insert_overflow@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@AAEXPAPAXABQAXABU__true_type@3@I_N@Z ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::_M_insert_overflow
$LN54@InsertKey@2:
	mov	edx, DWORD PTR [edi]
	lea	eax, DWORD PTR [edx+ebx*4]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 75   : }

	pop	ecx
	ret	8
?InsertKey@CEnvelope@@QAEXMM@Z ENDP			; CEnvelope::InsertKey
_TEXT	ENDS
PUBLIC	?ClearAndFree@CEnvelope@@QAEXXZ			; CEnvelope::ClearAndFree
; Function compile flags: /Ogtpy
;	COMDAT ?ClearAndFree@CEnvelope@@QAEXXZ
_TEXT	SEGMENT
?ClearAndFree@CEnvelope@@QAEXXZ PROC			; CEnvelope::ClearAndFree, COMDAT
; _this$ = ecx

; 19   : {

	push	edi
	mov	edi, ecx

; 20   : 	Clear();

	call	?Clear@CEnvelope@@QAEXXZ		; CEnvelope::Clear

; 21   :     keys.clear();

	mov	ecx, DWORD PTR [edi+8]
	mov	eax, DWORD PTR [edi+4]
	cmp	eax, ecx
	je	SHORT $LN18@ClearAndFr
	push	esi
	mov	esi, ecx
	sub	esi, ecx
	je	SHORT $LN24@ClearAndFr
	push	esi
	push	ecx
	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	add	eax, esi
$LN24@ClearAndFr:
	mov	DWORD PTR [edi+8], eax
	pop	esi
$LN18@ClearAndFr:
	pop	edi

; 22   : }

	ret	0
?ClearAndFree@CEnvelope@@QAEXXZ ENDP			; CEnvelope::ClearAndFree
END

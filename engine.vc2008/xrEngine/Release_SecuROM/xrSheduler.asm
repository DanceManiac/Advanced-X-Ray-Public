; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	D:\CLEARSKY\sources\engine\xrEngine\xrSheduler.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	?empty@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QBE_NXZ ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::empty
PUBLIC	?empty@?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QBE_NXZ ; stlp_std::vector<CSheduler::Item,xalloc<CSheduler::Item> >::empty
PUBLIC	?back@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEAAUItem@CSheduler@@XZ ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::back
PUBLIC	?back@?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAEAAUItem@CSheduler@@XZ ; stlp_std::vector<CSheduler::Item,xalloc<CSheduler::Item> >::back
PUBLIC	??$_max@I@@YAIII@Z				; _max<unsigned int>
PUBLIC	??$clamp@I@@YAXAAIABI1@Z			; clamp<unsigned int>
PUBLIC	??$clampr@I@@YAIABI00@Z				; clampr<unsigned int>
PUBLIC	?iCeil@@YAHM@Z					; iCeil
PUBLIC	??$clamp@M@@YAXAAMABM1@Z			; clamp<float>
PUBLIC	?_M_set@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@AAEXPAUItemReg@CSheduler@@00@Z ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::_M_set
PUBLIC	??$__fill_n@PAUItemReg@CSheduler@@IU12@@priv@stlp_std@@YAPAUItemReg@CSheduler@@PAU23@IABU23@@Z ; stlp_std::priv::__fill_n<CSheduler::ItemReg *,unsigned int,CSheduler::ItemReg>
PUBLIC	?_M_insert_overflow@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@AAEXPAUItemReg@CSheduler@@ABU45@ABU__true_type@3@I_N@Z ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::_M_insert_overflow
PUBLIC	??$_Copy_Construct@UItemReg@CSheduler@@@stlp_std@@YAXPAUItemReg@CSheduler@@ABU12@@Z ; stlp_std::_Copy_Construct<CSheduler::ItemReg>
PUBLIC	?push_back@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAEXABUItemReg@CSheduler@@@Z ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::push_back
PUBLIC	?to_storage_type_cref@?$_CastTraits@UItemReg@CSheduler@@U12@@priv@stlp_std@@SAABUItemReg@CSheduler@@ABU45@@Z ; stlp_std::priv::_CastTraits<CSheduler::ItemReg,CSheduler::ItemReg>::to_storage_type_cref
PUBLIC	?push_back@?$vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@stlp_std@@QAEXABUItemReg@CSheduler@@@Z ; stlp_std::vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::push_back
PUBLIC	?_M_erase@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@AAEPAUItem@CSheduler@@PAU45@0ABU__false_type@3@@Z ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::_M_erase
PUBLIC	?erase@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEPAUItem@CSheduler@@PAU45@0@Z ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::erase
PUBLIC	?clear@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEXXZ ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::clear
PUBLIC	?clear@?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAEXXZ ; stlp_std::vector<CSheduler::Item,xalloc<CSheduler::Item> >::clear
PUBLIC	?clear_and_free@?$xr_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@@QAEXXZ ; xr_vector<CSheduler::Item,xalloc<CSheduler::Item> >::clear_and_free
PUBLIC	?clear@?$xr_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@@QAEXXZ ; xr_vector<CSheduler::Item,xalloc<CSheduler::Item> >::clear
PUBLIC	??$__destroy_aux@UItemReg@CSheduler@@@stlp_std@@YAXPAUItemReg@CSheduler@@ABU__true_type@0@@Z ; stlp_std::__destroy_aux<CSheduler::ItemReg>
PUBLIC	??$_Destroy@UItemReg@CSheduler@@@stlp_std@@YAXPAUItemReg@CSheduler@@@Z ; stlp_std::_Destroy<CSheduler::ItemReg>
PUBLIC	?_M_erase@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@AAEPAUItemReg@CSheduler@@PAU45@ABU__false_type@3@@Z ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::_M_erase
PUBLIC	?erase@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAEPAUItemReg@CSheduler@@PAU45@@Z ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::erase
PUBLIC	?to_storage_type_ptr@?$_CastTraits@UItemReg@CSheduler@@U12@@priv@stlp_std@@SAPAUItemReg@CSheduler@@PAU45@@Z ; stlp_std::priv::_CastTraits<CSheduler::ItemReg,CSheduler::ItemReg>::to_storage_type_ptr
PUBLIC	?erase@?$vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@stlp_std@@QAEPAUItemReg@CSheduler@@PAU34@@Z ; stlp_std::vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::erase
PUBLIC	?size@?$vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@stlp_std@@QBEIXZ ; stlp_std::vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::size
PUBLIC	?size@?$xr_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@@QBEIXZ ; xr_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::size
PUBLIC	??$__copy_ptrs@PAUItemReg@CSheduler@@PAU12@@priv@stlp_std@@YAPAUItemReg@CSheduler@@PAU23@00ABU__true_type@1@@Z ; stlp_std::priv::__copy_ptrs<CSheduler::ItemReg *,CSheduler::ItemReg *>
PUBLIC	?_M_erase@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@AAEPAUItemReg@CSheduler@@PAU45@0ABU__false_type@3@@Z ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::_M_erase
PUBLIC	?erase@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAEPAUItemReg@CSheduler@@PAU45@0@Z ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::erase
PUBLIC	?clear@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAEXXZ ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::clear
PUBLIC	?clear@?$vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@stlp_std@@QAEXXZ ; stlp_std::vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::clear
PUBLIC	?clear_and_free@?$xr_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@@QAEXXZ ; xr_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::clear_and_free
PUBLIC	?clear@?$xr_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@@QAEXXZ ; xr_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::clear
PUBLIC	?to_value_type_ptr@?$_CastTraits@UItemReg@CSheduler@@U12@@priv@stlp_std@@SAPAUItemReg@CSheduler@@PAU45@@Z ; stlp_std::priv::_CastTraits<CSheduler::ItemReg,CSheduler::ItemReg>::to_value_type_ptr
PUBLIC	?begin@?$vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@stlp_std@@QAEPAUItemReg@CSheduler@@XZ ; stlp_std::vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::begin
PUBLIC	??A?$xr_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@@QAEAAUItemReg@CSheduler@@I@Z ; xr_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::operator[]
PUBLIC	??0Item@CSheduler@@QAE@XZ			; CSheduler::Item::Item
PUBLIC	??$__copy@PAUItem@CSheduler@@PAU12@H@priv@stlp_std@@YAPAUItem@CSheduler@@PAU23@00ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__copy<CSheduler::Item *,CSheduler::Item *,int>
PUBLIC	??$__copy_ptrs@PAUItem@CSheduler@@PAU12@@priv@stlp_std@@YAPAUItem@CSheduler@@PAU23@00ABU__false_type@1@@Z ; stlp_std::priv::__copy_ptrs<CSheduler::Item *,CSheduler::Item *>
PUBLIC	?_M_erase@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@AAEPAUItem@CSheduler@@PAU45@ABU__false_type@3@@Z ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::_M_erase
PUBLIC	?erase@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEPAUItem@CSheduler@@PAU45@@Z ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::erase
PUBLIC	?to_storage_type_ptr@?$_CastTraits@UItem@CSheduler@@U12@@priv@stlp_std@@SAPAUItem@CSheduler@@PAU45@@Z ; stlp_std::priv::_CastTraits<CSheduler::Item,CSheduler::Item>::to_storage_type_ptr
PUBLIC	?erase@?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAEPAUItem@CSheduler@@PAU34@@Z ; stlp_std::vector<CSheduler::Item,xalloc<CSheduler::Item> >::erase
PUBLIC	?size@?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QBEIXZ ; stlp_std::vector<CSheduler::Item,xalloc<CSheduler::Item> >::size
PUBLIC	?size@?$xr_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@@QBEIXZ ; xr_vector<CSheduler::Item,xalloc<CSheduler::Item> >::size
PUBLIC	??A?$xr_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@@QAEAAUItem@CSheduler@@I@Z ; xr_vector<CSheduler::Item,xalloc<CSheduler::Item> >::operator[]
PUBLIC	??$__destroy_mv_srcs@V?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@UItem@CSheduler@@@stlp_std@@YAXV?$reverse_iterator@PAUItem@CSheduler@@@0@0PAUItem@CSheduler@@@Z ; stlp_std::__destroy_mv_srcs<stlp_std::reverse_iterator<CSheduler::Item *>,CSheduler::Item>
PUBLIC	??$_Destroy_Moved_Range@V?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@@stlp_std@@YAXV?$reverse_iterator@PAUItem@CSheduler@@@0@0@Z ; stlp_std::_Destroy_Moved_Range<stlp_std::reverse_iterator<CSheduler::Item *> >
PUBLIC	?_M_clear_after_move@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@AAEXXZ ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::_M_clear_after_move
PUBLIC	?_M_set@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@AAEXPAUItem@CSheduler@@00@Z ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::_M_set
PUBLIC	??$__ucopy@PAUItem@CSheduler@@PAU12@H@priv@stlp_std@@YAPAUItem@CSheduler@@PAU23@00ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<CSheduler::Item *,CSheduler::Item *,int>
PUBLIC	??$__ucopy_ptrs@PAUItem@CSheduler@@PAU12@@priv@stlp_std@@YAPAUItem@CSheduler@@PAU23@00ABU__false_type@1@@Z ; stlp_std::priv::__ucopy_ptrs<CSheduler::Item *,CSheduler::Item *>
PUBLIC	??$__uninitialized_move@PAUItem@CSheduler@@PAU12@U__false_type@stlp_std@@@priv@stlp_std@@YAPAUItem@CSheduler@@PAU23@00U__false_type@1@ABU41@@Z ; stlp_std::priv::__uninitialized_move<CSheduler::Item *,CSheduler::Item *,stlp_std::__false_type>
PUBLIC	??$__ufill@PAUItem@CSheduler@@U12@H@priv@stlp_std@@YAXPAUItem@CSheduler@@0ABU23@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ufill<CSheduler::Item *,CSheduler::Item,int>
PUBLIC	??$__uninitialized_fill_n@PAUItem@CSheduler@@IU12@@priv@stlp_std@@YAPAUItem@CSheduler@@PAU23@IABU23@@Z ; stlp_std::priv::__uninitialized_fill_n<CSheduler::Item *,unsigned int,CSheduler::Item>
PUBLIC	?_M_insert_overflow_aux@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@AAEXPAUItem@CSheduler@@ABU45@ABU__false_type@3@I_N@Z ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::_M_insert_overflow_aux
PUBLIC	?_M_insert_overflow@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@AAEXPAUItem@CSheduler@@ABU45@ABU__false_type@3@I_N@Z ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::_M_insert_overflow
PUBLIC	??$_Copy_Construct@UItem@CSheduler@@@stlp_std@@YAXPAUItem@CSheduler@@ABU12@@Z ; stlp_std::_Copy_Construct<CSheduler::Item>
PUBLIC	?push_back@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEXABUItem@CSheduler@@@Z ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::push_back
PUBLIC	?to_storage_type_cref@?$_CastTraits@UItem@CSheduler@@U12@@priv@stlp_std@@SAABUItem@CSheduler@@ABU45@@Z ; stlp_std::priv::_CastTraits<CSheduler::Item,CSheduler::Item>::to_storage_type_cref
PUBLIC	?push_back@?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAEXABUItem@CSheduler@@@Z ; stlp_std::vector<CSheduler::Item,xalloc<CSheduler::Item> >::push_back
PUBLIC	??$__push_heap_aux@PAUItem@CSheduler@@HU12@@stlp_std@@YAXPAUItem@CSheduler@@0PAH0@Z ; stlp_std::__push_heap_aux<CSheduler::Item *,int,CSheduler::Item>
PUBLIC	??$push_heap@PAUItem@CSheduler@@@stlp_std@@YAXPAUItem@CSheduler@@0@Z ; stlp_std::push_heap<CSheduler::Item *>
PUBLIC	?begin@?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAEPAUItem@CSheduler@@XZ ; stlp_std::vector<CSheduler::Item,xalloc<CSheduler::Item> >::begin
PUBLIC	?to_value_type_ptr@?$_CastTraits@UItem@CSheduler@@U12@@priv@stlp_std@@SAPAUItem@CSheduler@@PAU45@@Z ; stlp_std::priv::_CastTraits<CSheduler::Item,CSheduler::Item>::to_value_type_ptr
PUBLIC	?end@?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAEPAUItem@CSheduler@@XZ ; stlp_std::vector<CSheduler::Item,xalloc<CSheduler::Item> >::end
PUBLIC	??$_Destroy@UItem@CSheduler@@@stlp_std@@YAXPAUItem@CSheduler@@@Z ; stlp_std::_Destroy<CSheduler::Item>
PUBLIC	?pop_back@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEXXZ ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::pop_back
PUBLIC	?pop_back@?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAEXXZ ; stlp_std::vector<CSheduler::Item,xalloc<CSheduler::Item> >::pop_back
PUBLIC	??MItem@CSheduler@@QAE_NAAU01@@Z		; CSheduler::Item::operator<
PUBLIC	??$__push_heap@PAUItem@CSheduler@@HU12@@stlp_std@@YAXPAUItem@CSheduler@@HHU12@@Z ; stlp_std::__push_heap<CSheduler::Item *,int,CSheduler::Item>
PUBLIC	??$__adjust_heap@PAUItem@CSheduler@@HU12@@stlp_std@@YAXPAUItem@CSheduler@@HHU12@@Z ; stlp_std::__adjust_heap<CSheduler::Item *,int,CSheduler::Item>
PUBLIC	??$__pop_heap@PAUItem@CSheduler@@U12@H@stlp_std@@YAXPAUItem@CSheduler@@00U12@PAH@Z ; stlp_std::__pop_heap<CSheduler::Item *,CSheduler::Item,int>
PUBLIC	??$__pop_heap_aux@PAUItem@CSheduler@@U12@@stlp_std@@YAXPAUItem@CSheduler@@00@Z ; stlp_std::__pop_heap_aux<CSheduler::Item *,CSheduler::Item>
PUBLIC	??$pop_heap@PAUItem@CSheduler@@@stlp_std@@YAXPAUItem@CSheduler@@0@Z ; stlp_std::pop_heap<CSheduler::Item *>
PUBLIC	?psShedulerCurrent@@3MA				; psShedulerCurrent
PUBLIC	?psShedulerTarget@@3MA				; psShedulerTarget
PUBLIC	?g_bSheduleInProgress@@3HA			; g_bSheduleInProgress
PUBLIC	??_C@_0BC@FHMDICED@CSheduler?3?3Update?$AA@	; `string'
PUBLIC	??_C@_0DD@DAIAEPIB@D?3?2CLEARSKY?2sources?2engine?2xrEng@ ; `string'
PUBLIC	??_C@_0BB@NEBKLIE@Device?4Statistic?$AA@	; `string'
PUBLIC	??_C@_08PDHDIBNI@T?4Object?$AA@			; `string'
EXTRN	__imp_?qpc_freq@CPU@@3_KA:QWORD
?g_bSheduleInProgress@@3HA DD 01H DUP (?)		; g_bSheduleInProgress
;	COMDAT ?ignore_always@?3??Update@CSheduler@@QAEXXZ@4_NA
_BSS	SEGMENT
?ignore_always@?3??Update@CSheduler@@QAEXXZ@4_NA DB 01H DUP (?) ; `CSheduler::Update'::`4'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?9??Update@CSheduler@@QAEXXZ@4_NA
_BSS	SEGMENT
?ignore_always@?9??Update@CSheduler@@QAEXXZ@4_NA DB 01H DUP (?) ; `CSheduler::Update'::`10'::ignore_always
;	COMDAT ??_C@_08PDHDIBNI@T?4Object?$AA@
CONST	SEGMENT
??_C@_08PDHDIBNI@T?4Object?$AA@ DB 'T.Object', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NEBKLIE@Device?4Statistic?$AA@
CONST	SEGMENT
??_C@_0BB@NEBKLIE@Device?4Statistic?$AA@ DB 'Device.Statistic', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@DAIAEPIB@D?3?2CLEARSKY?2sources?2engine?2xrEng@
CONST	SEGMENT
??_C@_0DD@DAIAEPIB@D?3?2CLEARSKY?2sources?2engine?2xrEng@ DB 'D:\CLEARSKY'
	DB	'\sources\engine\xrEngine\xrSheduler.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FHMDICED@CSheduler?3?3Update?$AA@
CONST	SEGMENT
??_C@_0BC@FHMDICED@CSheduler?3?3Update?$AA@ DB 'CSheduler::Update', 00H ; `string'
?psShedulerCurrent@@3MA DD 041200000r		; 10	; psShedulerCurrent
?psShedulerTarget@@3MA DD 041200000r		; 10	; psShedulerTarget
_psShedulerReaction DD 03dcccccdr		; 0.1
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_bitwise.h
;	COMDAT ?iCeil@@YAHM@Z
_TEXT	SEGMENT
_a$ = -4						; size = 4
?iCeil@@YAHM@Z PROC					; iCeil, COMDAT

; 103  : {

	push	ecx

; 104  :     int a			= (*(const int*)(&x));

	fld	DWORD PTR ?psShedulerCurrent@@3MA	; psShedulerCurrent
	push	esi
	fstp	DWORD PTR _a$[esp+8]

; 105  :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, 158				; 0000009eH
	mov	esi, DWORD PTR _a$[esp+8]
	mov	eax, esi
	sar	eax, 23					; 00000017H
	and	eax, 255				; 000000ffH
	sub	ecx, eax

; 106  :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	eax, esi
	or	eax, -8388608				; ff800000H
	shl	eax, 8
	shr	eax, cl

; 107  :     exponent		+= 31-127;

	sub	ecx, 96					; 00000060H

; 108  :     {
; 109  :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	edx, 1
	shl	edx, cl
	sub	edx, 1
	sar	edx, 8
	and	edx, esi
	neg	edx
	sbb	edx, edx

; 110  :         exponent	-=	(31-127)+32;
; 111  :         exponent	>>=	31;
; 112  :         a			=	~((a-1)>>31);		/* change sign */

	add	esi, -1
	sar	esi, 31					; 0000001fH
	not	esi
	add	edx, 1

; 113  :         r			-=	(imask&a);

	and	edx, esi
	add	ecx, 64					; 00000040H
	sub	eax, edx
	sar	ecx, 31					; 0000001fH

; 114  :         r			&=	exponent;

	and	eax, ecx

; 115  :         r			^=	a;

	xor	eax, esi

; 116  :         r			=	-r;                 /* change sign */

	neg	eax
	pop	esi

; 117  :     }
; 118  :     return r;								/* r = (int)(ceil(f)) */
; 119  : }

	pop	ecx
	ret	0
?iCeil@@YAHM@Z ENDP					; iCeil
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\xrsheduler.h
_TEXT	ENDS
;	COMDAT ??MItem@CSheduler@@QAE_NAAU01@@Z
_TEXT	SEGMENT
??MItem@CSheduler@@QAE_NAAU01@@Z PROC			; CSheduler::Item::operator<, COMDAT
; _this$ = eax
; _I$ = edx

; 18   : 		{	return dwTimeForExecute > I.dwTimeForExecute; }

	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [edx], ecx
	sbb	eax, eax
	neg	eax
	ret	0
??MItem@CSheduler@@QAE_NAAU01@@Z ENDP			; CSheduler::Item::operator<
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_construct.h
_TEXT	ENDS
;	COMDAT ??$__destroy_aux@UItemReg@CSheduler@@@stlp_std@@YAXPAUItemReg@CSheduler@@ABU__true_type@0@@Z
_TEXT	SEGMENT
??$__destroy_aux@UItemReg@CSheduler@@@stlp_std@@YAXPAUItemReg@CSheduler@@ABU__true_type@0@@Z PROC ; stlp_std::__destroy_aux<CSheduler::ItemReg>, COMDAT

; 56   : inline void __destroy_aux(_Tp*, const __true_type& /*_Trivial_destructor*/) {}

	ret	0
??$__destroy_aux@UItemReg@CSheduler@@@stlp_std@@YAXPAUItemReg@CSheduler@@ABU__true_type@0@@Z ENDP ; stlp_std::__destroy_aux<CSheduler::ItemReg>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_algobase.h
_TEXT	ENDS
;	COMDAT ??$__fill_n@PAUItemReg@CSheduler@@IU12@@priv@stlp_std@@YAPAUItemReg@CSheduler@@PAU23@IABU23@@Z
_TEXT	SEGMENT
??$__fill_n@PAUItemReg@CSheduler@@IU12@@priv@stlp_std@@YAPAUItemReg@CSheduler@@PAU23@IABU23@@Z PROC ; stlp_std::priv::__fill_n<CSheduler::ItemReg *,unsigned int,CSheduler::ItemReg>, COMDAT
; ___first$ = eax
; ___n$ = edx
; ___val$ = ecx

; 403  :   _STLP_FIX_LITERAL_BUG(__first)
; 404  :   for ( ; __n > 0; --__n, ++__first)

	test	edx, edx
	jbe	SHORT $LN1@fill_n@17
	push	esi
$LL3@fill_n@17:

; 405  :     *__first = __val;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	sub	edx, 1
	add	eax, 12					; 0000000cH
	test	edx, edx
	ja	SHORT $LL3@fill_n@17
	pop	esi
$LN1@fill_n@17:

; 406  :   return __first;
; 407  : }

	ret	0
??$__fill_n@PAUItemReg@CSheduler@@IU12@@priv@stlp_std@@YAPAUItemReg@CSheduler@@PAU23@IABU23@@Z ENDP ; stlp_std::priv::__fill_n<CSheduler::ItemReg *,unsigned int,CSheduler::ItemReg>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ?_M_set@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@AAEXPAUItemReg@CSheduler@@00@Z
_TEXT	SEGMENT
___e$ = 8						; size = 4
?_M_set@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@AAEXPAUItemReg@CSheduler@@00@Z PROC ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::_M_set, COMDAT
; _this$ = eax
; ___s$ = ecx
; ___f$ = edx

; 626  :     this->_M_start = __s;

	mov	DWORD PTR [eax], ecx

; 627  :     this->_M_finish = __f;
; 628  :     this->_M_end_of_storage._M_data = __e;

	mov	ecx, DWORD PTR ___e$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], ecx

; 629  :   }

	ret	4
?_M_set@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@AAEXPAUItemReg@CSheduler@@00@Z ENDP ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::_M_set
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_M_set@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@AAEXPAUItem@CSheduler@@00@Z
_TEXT	SEGMENT
___e$ = 8						; size = 4
?_M_set@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@AAEXPAUItem@CSheduler@@00@Z PROC ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::_M_set, COMDAT
; _this$ = eax
; ___s$ = ecx
; ___f$ = edx

; 626  :     this->_M_start = __s;

	mov	DWORD PTR [eax], ecx

; 627  :     this->_M_finish = __f;
; 628  :     this->_M_end_of_storage._M_data = __e;

	mov	ecx, DWORD PTR ___e$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], ecx

; 629  :   }

	ret	4
?_M_set@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@AAEXPAUItem@CSheduler@@00@Z ENDP ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::_M_set
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_construct.h
_TEXT	ENDS
;	COMDAT ??$_Destroy@UItemReg@CSheduler@@@stlp_std@@YAXPAUItemReg@CSheduler@@@Z
_TEXT	SEGMENT
??$_Destroy@UItemReg@CSheduler@@@stlp_std@@YAXPAUItemReg@CSheduler@@@Z PROC ; stlp_std::_Destroy<CSheduler::ItemReg>, COMDAT

; 60   : #if defined (_STLP_MSVC) && (_STLP_MSVC <= 1010)
; 61   :   __pointer;
; 62   : #endif
; 63   :   typedef typename __type_traits<_Tp>::has_trivial_destructor _Trivial_destructor;
; 64   :   __destroy_aux(__pointer, _Trivial_destructor());
; 65   : #if defined (_STLP_DEBUG_UNINITIALIZED)
; 66   :   memset(__REINTERPRET_CAST(char*, __pointer), _STLP_SHRED_BYTE, sizeof(_Tp));
; 67   : #endif
; 68   : }

	ret	0
??$_Destroy@UItemReg@CSheduler@@@stlp_std@@YAXPAUItemReg@CSheduler@@@Z ENDP ; stlp_std::_Destroy<CSheduler::ItemReg>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\vector.h
_TEXT	ENDS
;	COMDAT ??$clamp@M@@YAXAAMABM1@Z
_TEXT	SEGMENT
??$clamp@M@@YAXAAMABM1@Z PROC				; clamp<float>, COMDAT
; _val$ = eax
; __high$ = ecx

; 98   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	movss	xmm0, DWORD PTR [ecx]
	movss	xmm1, DWORD PTR [eax]
	comiss	xmm1, xmm0
	jbe	SHORT $LN1@clamp@2
	movss	DWORD PTR [eax], xmm0
$LN1@clamp@2:

; 99   : };

	ret	0
??$clamp@M@@YAXAAMABM1@Z ENDP				; clamp<float>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$clampr@I@@YAIABI00@Z
_TEXT	SEGMENT
??$clampr@I@@YAIABI00@Z PROC				; clampr<unsigned int>, COMDAT
; _val$ = eax
; __high$ = ecx

; 102  : 	if		( val<_low	)	return _low; 
; 103  : 	else if	( val>_high )	return _high;

	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	cmp	eax, ecx
	jbe	SHORT $LN8@clampr@3
	mov	eax, ecx
$LN8@clampr@3:

; 104  : 	else					return val;
; 105  : };

	ret	0
??$clampr@I@@YAIABI00@Z ENDP				; clampr<unsigned int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$clamp@I@@YAXAAIABI1@Z
_TEXT	SEGMENT
??$clamp@I@@YAXAAIABI1@Z PROC				; clamp<unsigned int>, COMDAT
; _val$ = ecx
; __high$ = eax

; 98   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	mov	eax, DWORD PTR [eax]
	cmp	DWORD PTR [ecx], eax
	jbe	SHORT $LN1@clamp@3
	mov	DWORD PTR [ecx], eax
$LN1@clamp@3:

; 99   : };

	ret	0
??$clamp@I@@YAXAAIABI1@Z ENDP				; clamp<unsigned int>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_std_extensions.h
_TEXT	ENDS
;	COMDAT ??$_max@I@@YAIII@Z
_TEXT	SEGMENT
??$_max@I@@YAIII@Z PROC					; _max<unsigned int>, COMDAT
; _a$ = ecx
; _b$ = eax

; 95   : template <class T>	IC T		_max	(T a, T b)	{ return a>b?a:b;	}

	cmp	ecx, eax
	jbe	SHORT $LN4@max@2
	mov	eax, ecx
$LN4@max@2:
	ret	0
??$_max@I@@YAIII@Z ENDP					; _max<unsigned int>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_tools.h
_TEXT	ENDS
;	COMDAT ?to_storage_type_cref@?$_CastTraits@UItemReg@CSheduler@@U12@@priv@stlp_std@@SAABUItemReg@CSheduler@@ABU45@@Z
_TEXT	SEGMENT
?to_storage_type_cref@?$_CastTraits@UItemReg@CSheduler@@U12@@priv@stlp_std@@SAABUItemReg@CSheduler@@ABU45@@Z PROC ; stlp_std::priv::_CastTraits<CSheduler::ItemReg,CSheduler::ItemReg>::to_storage_type_cref, COMDAT
; ___ref$ = eax

; 254  :   { return __ref; }

	ret	0
?to_storage_type_cref@?$_CastTraits@UItemReg@CSheduler@@U12@@priv@stlp_std@@SAABUItemReg@CSheduler@@ABU45@@Z ENDP ; stlp_std::priv::_CastTraits<CSheduler::ItemReg,CSheduler::ItemReg>::to_storage_type_cref
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?to_storage_type_ptr@?$_CastTraits@UItemReg@CSheduler@@U12@@priv@stlp_std@@SAPAUItemReg@CSheduler@@PAU45@@Z
_TEXT	SEGMENT
?to_storage_type_ptr@?$_CastTraits@UItemReg@CSheduler@@U12@@priv@stlp_std@@SAPAUItemReg@CSheduler@@PAU45@@Z PROC ; stlp_std::priv::_CastTraits<CSheduler::ItemReg,CSheduler::ItemReg>::to_storage_type_ptr, COMDAT
; ___ptr$ = eax

; 248  :   { return __ptr; }

	ret	0
?to_storage_type_ptr@?$_CastTraits@UItemReg@CSheduler@@U12@@priv@stlp_std@@SAPAUItemReg@CSheduler@@PAU45@@Z ENDP ; stlp_std::priv::_CastTraits<CSheduler::ItemReg,CSheduler::ItemReg>::to_storage_type_ptr
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?to_value_type_ptr@?$_CastTraits@UItemReg@CSheduler@@U12@@priv@stlp_std@@SAPAUItemReg@CSheduler@@PAU45@@Z
_TEXT	SEGMENT
?to_value_type_ptr@?$_CastTraits@UItemReg@CSheduler@@U12@@priv@stlp_std@@SAPAUItemReg@CSheduler@@PAU45@@Z PROC ; stlp_std::priv::_CastTraits<CSheduler::ItemReg,CSheduler::ItemReg>::to_value_type_ptr, COMDAT
; ___ptr$ = eax

; 237  :   { return __ptr; }

	ret	0
?to_value_type_ptr@?$_CastTraits@UItemReg@CSheduler@@U12@@priv@stlp_std@@SAPAUItemReg@CSheduler@@PAU45@@Z ENDP ; stlp_std::priv::_CastTraits<CSheduler::ItemReg,CSheduler::ItemReg>::to_value_type_ptr
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?to_storage_type_cref@?$_CastTraits@UItem@CSheduler@@U12@@priv@stlp_std@@SAABUItem@CSheduler@@ABU45@@Z
_TEXT	SEGMENT
?to_storage_type_cref@?$_CastTraits@UItem@CSheduler@@U12@@priv@stlp_std@@SAABUItem@CSheduler@@ABU45@@Z PROC ; stlp_std::priv::_CastTraits<CSheduler::Item,CSheduler::Item>::to_storage_type_cref, COMDAT
; ___ref$ = eax

; 254  :   { return __ref; }

	ret	0
?to_storage_type_cref@?$_CastTraits@UItem@CSheduler@@U12@@priv@stlp_std@@SAABUItem@CSheduler@@ABU45@@Z ENDP ; stlp_std::priv::_CastTraits<CSheduler::Item,CSheduler::Item>::to_storage_type_cref
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?to_storage_type_ptr@?$_CastTraits@UItem@CSheduler@@U12@@priv@stlp_std@@SAPAUItem@CSheduler@@PAU45@@Z
_TEXT	SEGMENT
?to_storage_type_ptr@?$_CastTraits@UItem@CSheduler@@U12@@priv@stlp_std@@SAPAUItem@CSheduler@@PAU45@@Z PROC ; stlp_std::priv::_CastTraits<CSheduler::Item,CSheduler::Item>::to_storage_type_ptr, COMDAT
; ___ptr$ = eax

; 248  :   { return __ptr; }

	ret	0
?to_storage_type_ptr@?$_CastTraits@UItem@CSheduler@@U12@@priv@stlp_std@@SAPAUItem@CSheduler@@PAU45@@Z ENDP ; stlp_std::priv::_CastTraits<CSheduler::Item,CSheduler::Item>::to_storage_type_ptr
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?to_value_type_ptr@?$_CastTraits@UItem@CSheduler@@U12@@priv@stlp_std@@SAPAUItem@CSheduler@@PAU45@@Z
_TEXT	SEGMENT
?to_value_type_ptr@?$_CastTraits@UItem@CSheduler@@U12@@priv@stlp_std@@SAPAUItem@CSheduler@@PAU45@@Z PROC ; stlp_std::priv::_CastTraits<CSheduler::Item,CSheduler::Item>::to_value_type_ptr, COMDAT
; ___ptr$ = eax

; 237  :   { return __ptr; }

	ret	0
?to_value_type_ptr@?$_CastTraits@UItem@CSheduler@@U12@@priv@stlp_std@@SAPAUItem@CSheduler@@PAU45@@Z ENDP ; stlp_std::priv::_CastTraits<CSheduler::Item,CSheduler::Item>::to_value_type_ptr
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ?empty@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QBE_NXZ PROC ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::empty, COMDAT
; _this$ = eax

; 188  :   bool empty() const            { return this->_M_start == this->_M_finish; }

	mov	ecx, DWORD PTR [eax]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	sete	dl
	mov	al, dl
	ret	0
?empty@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QBE_NXZ ENDP ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::empty
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ?empty@?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QBE_NXZ PROC ; stlp_std::vector<CSheduler::Item,xalloc<CSheduler::Item> >::empty, COMDAT
; _this$ = eax

; 93   :   bool empty() const            { return _M_impl.empty(); }

	mov	ecx, DWORD PTR [eax]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	sete	dl
	mov	al, dl
	ret	0
?empty@?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QBE_NXZ ENDP ; stlp_std::vector<CSheduler::Item,xalloc<CSheduler::Item> >::empty
_TEXT	ENDS
PUBLIC	?Initialize@CSheduler@@QAEXXZ			; CSheduler::Initialize
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\xrsheduler.cpp
;	COMDAT ?Initialize@CSheduler@@QAEXXZ
_TEXT	SEGMENT
?Initialize@CSheduler@@QAEXXZ PROC			; CSheduler::Initialize, COMDAT
; _this$ = ecx

; 15   : 	m_current_step_obj	= NULL;

	xor	eax, eax
	mov	DWORD PTR [ecx+48], eax

; 16   : 	m_processing_now	= false;

	mov	BYTE PTR [ecx+52], al

; 17   : }

	ret	0
?Initialize@CSheduler@@QAEXXZ ENDP			; CSheduler::Initialize
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_algobase.h
;	COMDAT ??$__copy_ptrs@PAUItemReg@CSheduler@@PAU12@@priv@stlp_std@@YAPAUItemReg@CSheduler@@PAU23@00ABU__true_type@1@@Z
_TEXT	SEGMENT
??$__copy_ptrs@PAUItemReg@CSheduler@@PAU12@@priv@stlp_std@@YAPAUItemReg@CSheduler@@PAU23@00ABU__true_type@1@@Z PROC ; stlp_std::priv::__copy_ptrs<CSheduler::ItemReg *,CSheduler::ItemReg *>, COMDAT
; ___first$ = edx
; ___last$ = ecx
; ___result$ = eax

; 255  :   // we know they all pointers, so this cast is OK
; 256  :   //  return (_OutputIter)__copy_trivial(&(*__first), &(*__last), &(*__result));
; 257  :   return (_OutputIter)__copy_trivial(__first, __last, __result);

	sub	ecx, edx
	push	esi
	mov	esi, ecx
	je	SHORT $LN6@copy_ptrs@29
	push	esi
	push	edx
	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	add	eax, esi
$LN6@copy_ptrs@29:
	pop	esi

; 258  : }

	ret	0
??$__copy_ptrs@PAUItemReg@CSheduler@@PAU12@@priv@stlp_std@@YAPAUItemReg@CSheduler@@PAU23@00ABU__true_type@1@@Z ENDP ; stlp_std::priv::__copy_ptrs<CSheduler::ItemReg *,CSheduler::ItemReg *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_construct.h
_TEXT	ENDS
;	COMDAT ??$_Copy_Construct@UItemReg@CSheduler@@@stlp_std@@YAXPAUItemReg@CSheduler@@ABU12@@Z
_TEXT	SEGMENT
??$_Copy_Construct@UItemReg@CSheduler@@@stlp_std@@YAXPAUItemReg@CSheduler@@ABU12@@Z PROC ; stlp_std::_Copy_Construct<CSheduler::ItemReg>, COMDAT
; ___p$ = eax
; ___val$ = ecx

; 110  : #if defined (_STLP_DEBUG_UNINITIALIZED)
; 111  :   memset((char*)__p, _STLP_SHRED_BYTE, sizeof(_Tp));
; 112  : #endif
; 113  :   _STLP_PLACEMENT_NEW (__p) _Tp(__val);

	test	eax, eax
	je	SHORT $LN3@Copy_Const@15
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx
$LN3@Copy_Const@15:

; 114  : }

	ret	0
??$_Copy_Construct@UItemReg@CSheduler@@@stlp_std@@YAXPAUItemReg@CSheduler@@ABU12@@Z ENDP ; stlp_std::_Copy_Construct<CSheduler::ItemReg>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ?_M_erase@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@AAEPAUItemReg@CSheduler@@PAU45@0ABU__false_type@3@@Z
_TEXT	SEGMENT
?_M_erase@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@AAEPAUItemReg@CSheduler@@PAU45@0ABU__false_type@3@@Z PROC ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::_M_erase, COMDAT
; _this$ = ebx
; ___first$ = edi
; ___last$ = eax

; 578  :   iterator _M_erase(iterator __first, iterator __last, const __false_type& /*_Movable*/) {

	push	esi

; 579  :     pointer __i = _STLP_PRIV __copy_ptrs(__last, this->_M_finish, __first, _TrivialCopy());

	mov	esi, DWORD PTR [ebx+4]
	sub	esi, eax
	je	SHORT $LN7@M_erase@18
	push	esi
	push	eax
	push	edi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	add	eax, esi

; 580  :     _STLP_STD::_Destroy_Range(__i, this->_M_finish);
; 581  :     this->_M_finish = __i;

	mov	DWORD PTR [ebx+4], eax

; 582  :     return __first;

	mov	eax, edi
	pop	esi

; 583  :   }

	ret	0

; 579  :     pointer __i = _STLP_PRIV __copy_ptrs(__last, this->_M_finish, __first, _TrivialCopy());

$LN7@M_erase@18:

; 580  :     _STLP_STD::_Destroy_Range(__i, this->_M_finish);
; 581  :     this->_M_finish = __i;

	mov	DWORD PTR [ebx+4], edi

; 582  :     return __first;

	mov	eax, edi
	pop	esi

; 583  :   }

	ret	0
?_M_erase@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@AAEPAUItemReg@CSheduler@@PAU45@0ABU__false_type@3@@Z ENDP ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::_M_erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?erase@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAEPAUItemReg@CSheduler@@PAU45@0@Z
_TEXT	SEGMENT
?erase@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAEPAUItemReg@CSheduler@@PAU45@0@Z PROC ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::erase, COMDAT
; _this$ = ebx
; ___first$ = edi
; ___last$ = eax

; 590  :     if (__first == __last)

	cmp	edi, eax

; 591  :       return __first;

	je	SHORT $LN12@erase@22
	push	esi

; 592  :     return _M_erase(__first, __last, _Movable());

	mov	esi, DWORD PTR [ebx+4]
	sub	esi, eax
	je	SHORT $LN10@erase@22
	push	esi
	push	eax
	push	edi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	add	eax, esi
	mov	DWORD PTR [ebx+4], eax
	pop	esi
	mov	eax, edi

; 593  :   }

	ret	0

; 592  :     return _M_erase(__first, __last, _Movable());

$LN10@erase@22:
	mov	eax, edi
	mov	DWORD PTR [ebx+4], eax
	pop	esi
$LN12@erase@22:
	mov	eax, edi

; 593  :   }

	ret	0
?erase@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAEPAUItemReg@CSheduler@@PAU45@0@Z ENDP ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?clear@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAEXXZ PROC ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::clear, COMDAT
; _this$ = edi

; 611  :     erase(begin(), end());

	mov	ecx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edi]
	cmp	eax, ecx
	je	SHORT $LN10@clear@18
	push	esi
	mov	esi, ecx
	sub	esi, ecx
	je	SHORT $LN16@clear@18
	push	esi
	push	ecx
	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	add	eax, esi
$LN16@clear@18:
	mov	DWORD PTR [edi+4], eax
	pop	esi
$LN10@clear@18:

; 612  :   }

	ret	0
?clear@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAEXXZ ENDP ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::clear
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_M_erase@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@AAEPAUItemReg@CSheduler@@PAU45@ABU__false_type@3@@Z
_TEXT	SEGMENT
?_M_erase@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@AAEPAUItemReg@CSheduler@@PAU45@ABU__false_type@3@@Z PROC ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::_M_erase, COMDAT
; _this$ = esi
; ___pos$ = edi

; 549  :     if (__pos + 1 != end())

	mov	eax, DWORD PTR [esi+4]
	lea	ecx, DWORD PTR [edi+12]
	cmp	ecx, eax
	je	SHORT $LN13@M_erase@19

; 550  :       _STLP_PRIV __copy_ptrs(__pos + 1, this->_M_finish, __pos, _TrivialCopy());

	sub	eax, ecx
	je	SHORT $LN13@M_erase@19
	push	eax
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
$LN13@M_erase@19:

; 551  :     --this->_M_finish;

	add	DWORD PTR [esi+4], -12			; fffffff4H

; 552  :     _STLP_STD::_Destroy(this->_M_finish);
; 553  :     return __pos;

	mov	eax, edi

; 554  :   }

	ret	0
?_M_erase@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@AAEPAUItemReg@CSheduler@@PAU45@ABU__false_type@3@@Z ENDP ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::_M_erase
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ?clear@?$vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@stlp_std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@stlp_std@@QAEXXZ PROC ; stlp_std::vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::clear, COMDAT
; _this$ = edi

; 223  :   void clear() { _M_impl.clear(); }

	mov	ecx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edi]
	cmp	eax, ecx
	je	SHORT $LN12@clear@19
	push	esi
	mov	esi, ecx
	sub	esi, ecx
	je	SHORT $LN18@clear@19
	push	esi
	push	ecx
	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	add	eax, esi
$LN18@clear@19:
	mov	DWORD PTR [edi+4], eax
	pop	esi
$LN12@clear@19:
	ret	0
?clear@?$vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@stlp_std@@QAEXXZ ENDP ; stlp_std::vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::clear
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ?erase@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAEPAUItemReg@CSheduler@@PAU45@@Z
_TEXT	SEGMENT
?erase@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAEPAUItemReg@CSheduler@@PAU45@@Z PROC ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::erase, COMDAT
; _this$ = esi
; ___pos$ = edi

; 587  :     return _M_erase(__pos, _Movable());

	mov	eax, DWORD PTR [esi+4]
	lea	ecx, DWORD PTR [edi+12]
	cmp	ecx, eax
	je	SHORT $LN15@erase@23
	sub	eax, ecx
	je	SHORT $LN15@erase@23
	push	eax
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
$LN15@erase@23:
	add	DWORD PTR [esi+4], -12			; fffffff4H
	mov	eax, edi

; 588  :   }

	ret	0
?erase@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAEPAUItemReg@CSheduler@@PAU45@@Z ENDP ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::erase
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ?size@?$vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@stlp_std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@stlp_std@@QBEIXZ PROC ; stlp_std::vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::size, COMDAT
; _this$ = eax

; 89   :   size_type size() const        { return _M_impl.size(); }

	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR [eax]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	ret	0
?size@?$vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@stlp_std@@QBEIXZ ENDP ; stlp_std::vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::size
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ?clear_and_free@?$xr_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear_and_free@?$xr_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@@QAEXXZ PROC ; xr_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::clear_and_free, COMDAT
; _this$ = edi

; 128  : 	void	clear_and_free		()									{ inherited::clear();			}

	mov	ecx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edi]
	cmp	eax, ecx
	je	SHORT $LN14@clear_and_@6
	push	esi
	mov	esi, ecx
	sub	esi, ecx
	je	SHORT $LN20@clear_and_@6
	push	esi
	push	ecx
	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	add	eax, esi
$LN20@clear_and_@6:
	mov	DWORD PTR [edi+4], eax
	pop	esi
$LN14@clear_and_@6:
	ret	0
?clear_and_free@?$xr_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@@QAEXXZ ENDP ; xr_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::clear_and_free
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ?back@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEAAUItem@CSheduler@@XZ
_TEXT	SEGMENT
?back@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEAAUItem@CSheduler@@XZ PROC ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::back, COMDAT
; _this$ = eax

; 195  :   reference back()              { return *(end() - 1); }

	mov	eax, DWORD PTR [eax+4]
	sub	eax, 20					; 00000014H
	ret	0
?back@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEAAUItem@CSheduler@@XZ ENDP ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::back
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ?size@?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QBEIXZ PROC ; stlp_std::vector<CSheduler::Item,xalloc<CSheduler::Item> >::size, COMDAT
; _this$ = eax

; 89   :   size_type size() const        { return _M_impl.size(); }

	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR [eax]
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	ret	0
?size@?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QBEIXZ ENDP ; stlp_std::vector<CSheduler::Item,xalloc<CSheduler::Item> >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?erase@?$vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@stlp_std@@QAEPAUItemReg@CSheduler@@PAU34@@Z
_TEXT	SEGMENT
?erase@?$vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@stlp_std@@QAEPAUItemReg@CSheduler@@PAU34@@Z PROC ; stlp_std::vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::erase, COMDAT
; _this$ = esi
; ___pos$ = edi

; 206  :   {return cast_traits::to_value_type_ptr(_M_impl.erase(cast_traits::to_storage_type_ptr(__pos)));}

	mov	eax, DWORD PTR [esi+4]
	lea	ecx, DWORD PTR [edi+12]
	cmp	ecx, eax
	je	SHORT $LN21@erase@24
	sub	eax, ecx
	je	SHORT $LN21@erase@24
	push	eax
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
$LN21@erase@24:
	add	DWORD PTR [esi+4], -12			; fffffff4H
	mov	eax, edi
	ret	0
?erase@?$vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@stlp_std@@QAEPAUItemReg@CSheduler@@PAU34@@Z ENDP ; stlp_std::vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@stlp_std@@QAEPAUItemReg@CSheduler@@XZ
_TEXT	SEGMENT
?begin@?$vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@stlp_std@@QAEPAUItemReg@CSheduler@@XZ PROC ; stlp_std::vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::begin, COMDAT
; _this$ = eax

; 79   :   iterator begin()             { return cast_traits::to_value_type_ptr(_M_impl.begin()); }

	mov	eax, DWORD PTR [eax]
	ret	0
?begin@?$vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@stlp_std@@QAEPAUItemReg@CSheduler@@XZ ENDP ; stlp_std::vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::begin
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ??A?$xr_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@@QAEAAUItemReg@CSheduler@@I@Z
_TEXT	SEGMENT
??A?$xr_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@@QAEAAUItemReg@CSheduler@@I@Z PROC ; xr_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::operator[], COMDAT
; _this$ = ecx
; __Pos$ = eax

; 139  : 	reference operator[]		(size_type _Pos)					{ {VERIFY2(_Pos<size(),make_string("index is out of range: index requested[%d], size of container[%d]", _Pos, size()).c_str());} return (*(begin() + _Pos)); }

	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [edx+eax*4]
	ret	0
??A?$xr_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@@QAEAAUItemReg@CSheduler@@I@Z ENDP ; xr_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?clear@?$xr_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$xr_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@@QAEXXZ PROC ; xr_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::clear, COMDAT
; _this$ = edi

; 133  : 	void	clear				()									{ clear_and_free	();			}

	mov	ecx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edi]
	cmp	eax, ecx
	je	SHORT $LN16@clear@20
	push	esi
	mov	esi, ecx
	sub	esi, ecx
	je	SHORT $LN22@clear@20
	push	esi
	push	ecx
	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	add	eax, esi
$LN22@clear@20:
	mov	DWORD PTR [edi+4], eax
	pop	esi
$LN16@clear@20:
	ret	0
?clear@?$xr_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@@QAEXXZ ENDP ; xr_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::clear
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$xr_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@@QBEIXZ
_TEXT	SEGMENT
?size@?$xr_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@@QBEIXZ PROC ; xr_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::size, COMDAT
; _this$ = eax

; 126  : 	u32		size				() const							{ return (u32)inherited::size();} 

	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR [eax]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	ret	0
?size@?$xr_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@@QBEIXZ ENDP ; xr_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::size
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ?back@?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAEAAUItem@CSheduler@@XZ
_TEXT	SEGMENT
?back@?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAEAAUItem@CSheduler@@XZ PROC ; stlp_std::vector<CSheduler::Item,xalloc<CSheduler::Item> >::back, COMDAT
; _this$ = eax

; 100  :   reference back()              { return cast_traits::to_value_type_ref(_M_impl.back()); }

	mov	eax, DWORD PTR [eax+4]
	sub	eax, 20					; 00000014H
	ret	0
?back@?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAEAAUItem@CSheduler@@XZ ENDP ; stlp_std::vector<CSheduler::Item,xalloc<CSheduler::Item> >::back
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAEPAUItem@CSheduler@@XZ
_TEXT	SEGMENT
?end@?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAEPAUItem@CSheduler@@XZ PROC ; stlp_std::vector<CSheduler::Item,xalloc<CSheduler::Item> >::end, COMDAT
; _this$ = eax

; 81   :   iterator end()               { return cast_traits::to_value_type_ptr(_M_impl.end()); }

	mov	eax, DWORD PTR [eax+4]
	ret	0
?end@?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAEPAUItem@CSheduler@@XZ ENDP ; stlp_std::vector<CSheduler::Item,xalloc<CSheduler::Item> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAEPAUItem@CSheduler@@XZ
_TEXT	SEGMENT
?begin@?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAEPAUItem@CSheduler@@XZ PROC ; stlp_std::vector<CSheduler::Item,xalloc<CSheduler::Item> >::begin, COMDAT
; _this$ = eax

; 79   :   iterator begin()             { return cast_traits::to_value_type_ptr(_M_impl.begin()); }

	mov	eax, DWORD PTR [eax]
	ret	0
?begin@?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAEPAUItem@CSheduler@@XZ ENDP ; stlp_std::vector<CSheduler::Item,xalloc<CSheduler::Item> >::begin
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ??A?$xr_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@@QAEAAUItem@CSheduler@@I@Z
_TEXT	SEGMENT
??A?$xr_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@@QAEAAUItem@CSheduler@@I@Z PROC ; xr_vector<CSheduler::Item,xalloc<CSheduler::Item> >::operator[], COMDAT
; _this$ = ecx
; __Pos$ = eax

; 139  : 	reference operator[]		(size_type _Pos)					{ {VERIFY2(_Pos<size(),make_string("index is out of range: index requested[%d], size of container[%d]", _Pos, size()).c_str());} return (*(begin() + _Pos)); }

	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [edx+eax*4]
	ret	0
??A?$xr_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@@QAEAAUItem@CSheduler@@I@Z ENDP ; xr_vector<CSheduler::Item,xalloc<CSheduler::Item> >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$xr_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@@QBEIXZ
_TEXT	SEGMENT
?size@?$xr_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@@QBEIXZ PROC ; xr_vector<CSheduler::Item,xalloc<CSheduler::Item> >::size, COMDAT
; _this$ = eax

; 126  : 	u32		size				() const							{ return (u32)inherited::size();} 

	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR [eax]
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	ret	0
?size@?$xr_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@@QBEIXZ ENDP ; xr_vector<CSheduler::Item,xalloc<CSheduler::Item> >::size
; Function compile flags: /Ogtpy
;	COMDAT ??0Item@CSheduler@@QAE@XZ
_TEXT	SEGMENT
??0Item@CSheduler@@QAE@XZ PROC				; CSheduler::Item::Item, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax+8], 0
	ret	0
??0Item@CSheduler@@QAE@XZ ENDP				; CSheduler::Item::Item
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_construct.h
;	COMDAT ??$__destroy_mv_srcs@V?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@UItem@CSheduler@@@stlp_std@@YAXV?$reverse_iterator@PAUItem@CSheduler@@@0@0PAUItem@CSheduler@@@Z
_TEXT	SEGMENT
___first$ = 8						; size = 4
___last$ = 12						; size = 4
??$__destroy_mv_srcs@V?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@UItem@CSheduler@@@stlp_std@@YAXV?$reverse_iterator@PAUItem@CSheduler@@@0@0PAUItem@CSheduler@@@Z PROC ; stlp_std::__destroy_mv_srcs<stlp_std::reverse_iterator<CSheduler::Item *>,CSheduler::Item>, COMDAT

; 193  :   typedef typename __move_traits<_Tp>::complete _CompleteMove;
; 194  :   __destroy_range_aux(__first, __last, __ptr, _CompleteMove());

	mov	eax, DWORD PTR ___first$[esp-4]
	mov	edx, DWORD PTR ___last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN7@destroy_mv
	add	eax, -12				; fffffff4H
	npad	1
$LL12@destroy_mv:
	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN33@destroy_mv
	add	DWORD PTR [ecx], -1
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN33@destroy_mv
	mov	DWORD PTR [eax], 0
$LN33@destroy_mv:
	sub	eax, 20					; 00000014H
	lea	ecx, DWORD PTR [eax+12]
	cmp	ecx, edx
	jne	SHORT $LL12@destroy_mv
$LN7@destroy_mv:

; 195  : }

	ret	0
??$__destroy_mv_srcs@V?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@UItem@CSheduler@@@stlp_std@@YAXV?$reverse_iterator@PAUItem@CSheduler@@@0@0PAUItem@CSheduler@@@Z ENDP ; stlp_std::__destroy_mv_srcs<stlp_std::reverse_iterator<CSheduler::Item *>,CSheduler::Item>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_Moved_Range@V?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@@stlp_std@@YAXV?$reverse_iterator@PAUItem@CSheduler@@@0@0@Z
_TEXT	SEGMENT
___first$ = 8						; size = 4
___last$ = 12						; size = 4
??$_Destroy_Moved_Range@V?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@@stlp_std@@YAXV?$reverse_iterator@PAUItem@CSheduler@@@0@0@Z PROC ; stlp_std::_Destroy_Moved_Range<stlp_std::reverse_iterator<CSheduler::Item *> >, COMDAT

; 199  :   __destroy_mv_srcs(__first, __last, _STLP_VALUE_TYPE(__first, _ForwardIterator));

	mov	edx, DWORD PTR ___first$[esp-4]
	push	ecx
	mov	ecx, DWORD PTR ___last$[esp]
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	push	ecx
	mov	eax, esp
	mov	DWORD PTR [eax], edx
	call	??$__destroy_mv_srcs@V?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@UItem@CSheduler@@@stlp_std@@YAXV?$reverse_iterator@PAUItem@CSheduler@@@0@0PAUItem@CSheduler@@@Z ; stlp_std::__destroy_mv_srcs<stlp_std::reverse_iterator<CSheduler::Item *>,CSheduler::Item>
	add	esp, 8

; 200  : }

	ret	0
??$_Destroy_Moved_Range@V?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@@stlp_std@@YAXV?$reverse_iterator@PAUItem@CSheduler@@@0@0@Z ENDP ; stlp_std::_Destroy_Moved_Range<stlp_std::reverse_iterator<CSheduler::Item *> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ?_M_clear_after_move@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@AAEXXZ
_TEXT	SEGMENT
?_M_clear_after_move@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@AAEXXZ PROC ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::_M_clear_after_move, COMDAT
; _this$ = eax

; 620  :   void _M_clear_after_move() {

	push	esi
	mov	esi, eax

; 621  :     _STLP_STD::_Destroy_Moved_Range(rbegin(), rend());

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi]
	push	ecx
	mov	edx, esp
	mov	DWORD PTR [edx], eax
	push	ecx
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	call	??$__destroy_mv_srcs@V?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@UItem@CSheduler@@@stlp_std@@YAXV?$reverse_iterator@PAUItem@CSheduler@@@0@0PAUItem@CSheduler@@@Z ; stlp_std::__destroy_mv_srcs<stlp_std::reverse_iterator<CSheduler::Item *>,CSheduler::Item>

; 622  :     this->_M_end_of_storage.deallocate(this->_M_start, this->_M_end_of_storage._M_data - this->_M_start);

	mov	esi, DWORD PTR [esi]
	add	esp, 8
	test	esi, esi
	je	SHORT $LN23@M_clear_af@3
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN23@M_clear_af@3:

; 623  :   }

	pop	esi
	ret	0
?_M_clear_after_move@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@AAEXXZ ENDP ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::_M_clear_after_move
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_construct.h
_TEXT	ENDS
;	COMDAT ??$_Destroy@UItem@CSheduler@@@stlp_std@@YAXPAUItem@CSheduler@@@Z
_TEXT	SEGMENT
??$_Destroy@UItem@CSheduler@@@stlp_std@@YAXPAUItem@CSheduler@@@Z PROC ; stlp_std::_Destroy<CSheduler::Item>, COMDAT
; ___pointer$ = ecx

; 60   : #if defined (_STLP_MSVC) && (_STLP_MSVC <= 1010)
; 61   :   __pointer;
; 62   : #endif
; 63   :   typedef typename __type_traits<_Tp>::has_trivial_destructor _Trivial_destructor;
; 64   :   __destroy_aux(__pointer, _Trivial_destructor());

	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN12@Destroy@5
	add	DWORD PTR [eax], -1
	mov	eax, DWORD PTR [ecx+8]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN12@Destroy@5
	mov	DWORD PTR [ecx+8], 0
$LN12@Destroy@5:

; 65   : #if defined (_STLP_DEBUG_UNINITIALIZED)
; 66   :   memset(__REINTERPRET_CAST(char*, __pointer), _STLP_SHRED_BYTE, sizeof(_Tp));
; 67   : #endif
; 68   : }

	ret	0
??$_Destroy@UItem@CSheduler@@@stlp_std@@YAXPAUItem@CSheduler@@@Z ENDP ; stlp_std::_Destroy<CSheduler::Item>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.c
_TEXT	ENDS
;	COMDAT ?_M_insert_overflow@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@AAEXPAUItemReg@CSheduler@@ABU45@ABU__true_type@3@I_N@Z
_TEXT	SEGMENT
___fill_len$ = -8					; size = 4
___new_start$ = -4					; size = 4
___old_size$ = 8					; size = 4
___x$ = 8						; size = 4
?_M_insert_overflow@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@AAEXPAUItemReg@CSheduler@@ABU45@ABU__true_type@3@I_N@Z PROC ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::_M_insert_overflow, COMDAT
; _this$ = edi
; ___pos$ = eax

; 109  :                                              size_type __fill_len, bool __atend ) {

	sub	esp, 8

; 110  :   const size_type __old_size = size();

	mov	ecx, DWORD PTR [edi+4]
	sub	ecx, DWORD PTR [edi]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR ___x$[esp+12]
	push	esi
	mov	esi, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 111  :   size_type __len = __old_size + (max)(__old_size, __fill_len);

	lea	ecx, DWORD PTR ___fill_len$[esp+20]
	push	ecx
	lea	edx, DWORD PTR ___old_size$[esp+20]
	push	edx
	mov	DWORD PTR ___fill_len$[esp+28], 1
	mov	DWORD PTR ___old_size$[esp+24], eax
	call	??$max@I@stlp_std@@YAABIABI0@Z		; stlp_std::max<unsigned int>
	mov	eax, DWORD PTR [eax]
	add	eax, DWORD PTR ___old_size$[esp+24]

; 112  : 
; 113  :   pointer __new_start = this->_M_end_of_storage.allocate(__len, __len);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	ebx, DWORD PTR [eax+eax*2]
	add	ebx, ebx
	add	esp, 8
	add	ebx, ebx
	push	ebx
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 114  :   pointer __new_finish = __STATIC_CAST(pointer, _STLP_PRIV __copy_trivial(this->_M_start, __pos, __new_start));

	mov	ecx, DWORD PTR [edi]
	sub	esi, ecx
	mov	edx, eax
	mov	DWORD PTR ___new_start$[esp+20], edx
	je	SHORT $LN23@M_insert_o@22
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove
	mov	edx, DWORD PTR ___new_start$[esp+32]
	add	esp, 12					; 0000000cH
	add	eax, esi
$LN23@M_insert_o@22:

; 115  :   // handle insertion
; 116  :   __new_finish = _STLP_PRIV __fill_n(__new_finish, __fill_len, __x);

	mov	ecx, DWORD PTR ___fill_len$[esp+20]
	test	ecx, ecx
	mov	esi, eax
	jbe	SHORT $LN24@M_insert_o@22
$LL26@M_insert_o@22:
	mov	eax, DWORD PTR [ebp]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [ebp+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [ebp+8]
	mov	DWORD PTR [esi+8], eax
	sub	ecx, 1
	add	esi, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LL26@M_insert_o@22
$LN24@M_insert_o@22:

; 117  :   if (!__atend)
; 118  :     __new_finish = __STATIC_CAST(pointer, _STLP_PRIV __copy_trivial(__pos, this->_M_finish, __new_finish)); // copy remainder
; 119  :   _M_clear();

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN63@M_insert_o@22
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	edx, DWORD PTR ___new_start$[esp+20]
$LN63@M_insert_o@22:

; 120  :   _M_set(__new_start, __new_finish, __new_start + __len);

	mov	DWORD PTR [edi+4], esi

; 121  : }

	pop	esi
	add	ebx, edx
	pop	ebp
	mov	DWORD PTR [edi+8], ebx
	mov	DWORD PTR [edi], edx
	pop	ebx
	add	esp, 8
	ret	4
?_M_insert_overflow@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@AAEXPAUItemReg@CSheduler@@ABU45@ABU__true_type@3@I_N@Z ENDP ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::_M_insert_overflow
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ?push_back@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAEXABUItemReg@CSheduler@@@Z
_TEXT	SEGMENT
?push_back@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAEXABUItemReg@CSheduler@@@Z PROC ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::push_back, COMDAT
; _this$ = eax
; ___x$ = ecx

; 360  :   void push_back(const _Tp& __x) {

	push	edi
	mov	edi, eax

; 361  : #endif /*!_STLP_DONT_SUP_DFLT_PARAM && !_STLP_NO_ANACHRONISMS*/
; 362  :     if (this->_M_finish != this->_M_end_of_storage._M_data) {

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, DWORD PTR [edi+8]
	je	SHORT $LN2@push_back@30

; 363  :       _Copy_Construct(this->_M_finish, __x);

	test	eax, eax
	je	SHORT $LN7@push_back@30
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx
$LN7@push_back@30:

; 364  :       ++this->_M_finish;

	add	DWORD PTR [edi+4], 12			; 0000000cH
	pop	edi

; 368  :   }

	ret	0
$LN2@push_back@30:

; 365  :     }
; 366  :     else
; 367  :       _M_insert_overflow(this->_M_finish, __x, _TrivialCopy(), 1UL, true);

	push	ecx
	call	?_M_insert_overflow@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@AAEXPAUItemReg@CSheduler@@ABU45@ABU__true_type@3@I_N@Z ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::_M_insert_overflow
	pop	edi

; 368  :   }

	ret	0
?push_back@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAEXABUItemReg@CSheduler@@@Z ENDP ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::push_back
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?pop_back@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEXXZ PROC ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::pop_back, COMDAT
; _this$ = eax

; 532  :     --this->_M_finish;

	add	DWORD PTR [eax+4], -20			; ffffffecH
	mov	ecx, DWORD PTR [eax+4]

; 533  :     _STLP_STD::_Destroy(this->_M_finish);

	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN14@pop_back@2
	add	DWORD PTR [eax], -1
	mov	eax, DWORD PTR [ecx+8]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN14@pop_back@2
	mov	DWORD PTR [ecx+8], 0
$LN14@pop_back@2:

; 534  :   }

	ret	0
?pop_back@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEXXZ ENDP ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::pop_back
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@stlp_std@@QAEXABUItemReg@CSheduler@@@Z
_TEXT	SEGMENT
?push_back@?$vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@stlp_std@@QAEXABUItemReg@CSheduler@@@Z PROC ; stlp_std::vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::push_back, COMDAT
; _this$ = eax
; ___x$ = ecx

; 171  :   { _M_impl.push_back(cast_traits::to_storage_type_cref(__x)); }

	push	edi
	mov	edi, eax
	mov	eax, DWORD PTR [edi+4]
	cmp	eax, DWORD PTR [edi+8]
	je	SHORT $LN6@push_back@31
	test	eax, eax
	je	SHORT $LN11@push_back@31
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx
$LN11@push_back@31:
	add	DWORD PTR [edi+4], 12			; 0000000cH
	pop	edi
	ret	0
$LN6@push_back@31:
	push	ecx
	call	?_M_insert_overflow@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@AAEXPAUItemReg@CSheduler@@ABU45@ABU__true_type@3@I_N@Z ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::_M_insert_overflow
	pop	edi
	ret	0
?push_back@?$vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@stlp_std@@QAEXABUItemReg@CSheduler@@@Z ENDP ; stlp_std::vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::push_back
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?pop_back@?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAEXXZ PROC ; stlp_std::vector<CSheduler::Item,xalloc<CSheduler::Item> >::pop_back, COMDAT
; _this$ = eax

; 204  :   void pop_back() {_M_impl.pop_back();}

	add	DWORD PTR [eax+4], -20			; ffffffecH
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN16@pop_back@3
	add	DWORD PTR [eax], -1
	mov	eax, DWORD PTR [ecx+8]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN16@pop_back@3
	mov	DWORD PTR [ecx+8], 0
$LN16@pop_back@3:
	ret	0
?pop_back@?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAEXXZ ENDP ; stlp_std::vector<CSheduler::Item,xalloc<CSheduler::Item> >::pop_back
_TEXT	ENDS
PUBLIC	?Register@CSheduler@@QAEXPAVISheduled@@H@Z	; CSheduler::Register
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\xrsheduler.cpp
;	COMDAT ?Register@CSheduler@@QAEXPAVISheduled@@H@Z
_TEXT	SEGMENT
_R$ = -12						; size = 12
_A$ = 8							; size = 4
_RT$ = 12						; size = 4
?Register@CSheduler@@QAEXPAVISheduled@@H@Z PROC		; CSheduler::Register, COMDAT
; _this$ = ecx

; 229  : {

	sub	esp, 12					; 0000000cH

; 230  : 	VERIFY		(!Registered(A));
; 231  : 
; 232  : 	ItemReg		R;
; 233  : 	R.OP		= TRUE				;
; 234  : 	R.RT		= RT				;

	mov	eax, DWORD PTR _RT$[esp+8]

; 235  : 	R.Object	= A					;

	mov	edx, DWORD PTR _A$[esp+8]
	push	ebx
	mov	ebx, eax

; 236  : 	R.Object->shedule.b_RT	= RT	;

	shl	eax, 28					; 0000001cH
	xor	eax, DWORD PTR [edx+4]
	push	esi
	and	eax, 268435456				; 10000000H
	xor	DWORD PTR [edx+4], eax

; 237  : 
; 238  : #ifdef DEBUG_SCHEDULER
; 239  : 	Msg			("SCHEDULER: register [%s][%x]",*A->shedule_Name(),A);
; 240  : #endif // DEBUG_SCHEDULER
; 241  : 
; 242  : 	Registration.push_back	(R);

	mov	eax, DWORD PTR [ecx+40]
	cmp	eax, DWORD PTR [ecx+44]
	push	edi
	lea	edi, DWORD PTR [ecx+36]
	mov	esi, 1
	mov	DWORD PTR _R$[esp+24], esi
	mov	DWORD PTR _R$[esp+28], ebx
	mov	DWORD PTR _R$[esp+32], edx
	je	SHORT $LN11@Register
	test	eax, eax
	je	SHORT $LN16@Register
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], edx
$LN16@Register:
	add	DWORD PTR [edi+4], 12			; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 243  : }

	add	esp, 12					; 0000000cH
	ret	8

; 237  : 
; 238  : #ifdef DEBUG_SCHEDULER
; 239  : 	Msg			("SCHEDULER: register [%s][%x]",*A->shedule_Name(),A);
; 240  : #endif // DEBUG_SCHEDULER
; 241  : 
; 242  : 	Registration.push_back	(R);

$LN11@Register:
	lea	ecx, DWORD PTR _R$[esp+24]
	push	ecx
	call	?_M_insert_overflow@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@AAEXPAUItemReg@CSheduler@@ABU45@ABU__true_type@3@I_N@Z ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::_M_insert_overflow
	pop	edi
	pop	esi
	pop	ebx

; 243  : }

	add	esp, 12					; 0000000cH
	ret	8
?Register@CSheduler@@QAEXPAVISheduled@@H@Z ENDP		; CSheduler::Register
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_uninitialized.h
;	COMDAT ??$__ucopy@PAUItem@CSheduler@@PAU12@H@priv@stlp_std@@YAPAUItem@CSheduler@@PAU23@00ABUrandom_access_iterator_tag@1@PAH@Z
_TEXT	SEGMENT
??$__ucopy@PAUItem@CSheduler@@PAU12@H@priv@stlp_std@@YAPAUItem@CSheduler@@PAU23@00ABUrandom_access_iterator_tag@1@PAH@Z PROC ; stlp_std::priv::__ucopy<CSheduler::Item *,CSheduler::Item *,int>, COMDAT
; ___first$ = edx
; ___last$ = eax
; ___result$ = ecx

; 83   :                            _OutputIter __result, const random_access_iterator_tag &, _Distance*) {

	push	ebx
	push	esi
	mov	esi, edx

; 84   :   _OutputIter __cur = __result;
; 85   :   _STLP_TRY {
; 86   :     for (_Distance __n = __last - __first; __n > 0; --__n) {

	sub	eax, esi
	mov	edx, eax
	mov	eax, 1717986919				; 66666667H
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	xor	ebx, ebx
	cmp	eax, ebx
	jle	SHORT $LN25@ucopy@23
	push	edi
$LL3@ucopy@23:

; 87   :       _Param_Construct(&*__cur, *__first);

	cmp	ecx, ebx
	je	SHORT $LN8@ucopy@23
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], edx
	mov	DWORD PTR [ecx+8], ebx
	mov	edi, DWORD PTR [esi+8]
	cmp	edi, ebx
	je	SHORT $LN16@ucopy@23
	add	DWORD PTR [edi], 1
$LN16@ucopy@23:
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, ebx
	je	SHORT $LN19@ucopy@23
	add	DWORD PTR [edx], -1
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx], ebx
	jne	SHORT $LN19@ucopy@23
	mov	DWORD PTR [ecx+8], ebx
$LN19@ucopy@23:
	mov	DWORD PTR [ecx+8], edi
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [ecx+16], edx
$LN8@ucopy@23:
	sub	eax, 1

; 88   :       ++__first;

	add	esi, 20					; 00000014H

; 89   :       ++__cur;

	add	ecx, 20					; 00000014H
	cmp	eax, ebx
	jg	SHORT $LL3@ucopy@23
	pop	edi
$LN25@ucopy@23:
	pop	esi

; 90   :     }
; 91   :     return __cur;

	mov	eax, ecx
	pop	ebx

; 92   :   }
; 93   :   _STLP_UNWIND(_STLP_STD::_Destroy_Range(__result, __cur))
; 94   :   _STLP_RET_AFTER_THROW(__cur)
; 95   : }

	ret	0
??$__ucopy@PAUItem@CSheduler@@PAU12@H@priv@stlp_std@@YAPAUItem@CSheduler@@PAU23@00ABUrandom_access_iterator_tag@1@PAH@Z ENDP ; stlp_std::priv::__ucopy<CSheduler::Item *,CSheduler::Item *,int>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_heap.c
_TEXT	ENDS
;	COMDAT ??$__push_heap@PAUItem@CSheduler@@HU12@@stlp_std@@YAXPAUItem@CSheduler@@HHU12@@Z
_TEXT	SEGMENT
___val$ = 8						; size = 20
??$__push_heap@PAUItem@CSheduler@@HU12@@stlp_std@@YAXPAUItem@CSheduler@@HHU12@@Z PROC ; stlp_std::__push_heap<CSheduler::Item *,int,CSheduler::Item>, COMDAT
; ___first$ = ebx
; ___holeIndex$ = ecx

; 45   :   _Distance __parent = (__holeIndex - 1) / 2;

	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
	sar	eax, 1

; 46   :   while (__holeIndex > __topIndex && *(__first + __parent) < __val) {

	test	ecx, ecx
	jle	SHORT $LN39@push_heap@6
	push	esi
	push	edi
	npad	2
$LL2@push_heap@6:
	lea	edx, DWORD PTR [eax+eax*4]
	mov	esi, DWORD PTR [ebx+edx*4]
	cmp	esi, DWORD PTR ___val$[esp+4]
	lea	edx, DWORD PTR [ebx+edx*4]
	jbe	SHORT $LN41@push_heap@6

; 47   :     *(__first + __holeIndex) = *(__first + __parent);

	lea	ecx, DWORD PTR [ecx+ecx*4]
	lea	ecx, DWORD PTR [ebx+ecx*4]
	mov	DWORD PTR [ecx], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], esi
	mov	esi, DWORD PTR [edx+8]
	test	esi, esi
	je	SHORT $LN11@push_heap@6
	add	DWORD PTR [esi], 1
$LN11@push_heap@6:
	mov	edi, DWORD PTR [ecx+8]
	test	edi, edi
	je	SHORT $LN14@push_heap@6
	add	DWORD PTR [edi], -1
	mov	edi, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edi], 0
	jne	SHORT $LN14@push_heap@6
	mov	DWORD PTR [ecx+8], 0
$LN14@push_heap@6:
	mov	DWORD PTR [ecx+8], esi
	mov	esi, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], esi
	mov	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], edx

; 48   :     __holeIndex = __parent;

	mov	ecx, eax

; 49   :     __parent = (__holeIndex - 1) / 2;

	add	eax, -1
	cdq
	sub	eax, edx
	sar	eax, 1
	test	ecx, ecx
	jg	SHORT $LL2@push_heap@6
$LN41@push_heap@6:
	pop	edi
	pop	esi
$LN39@push_heap@6:

; 50   :   }
; 51   :   *(__first + __holeIndex) = __val;

	mov	edx, DWORD PTR ___val$[esp]
	lea	eax, DWORD PTR [ecx+ecx*4]
	mov	ecx, DWORD PTR ___val$[esp-4]
	lea	eax, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR ___val$[esp+4]
	test	ecx, ecx
	mov	DWORD PTR [eax+4], edx
	je	SHORT $LN22@push_heap@6
	add	DWORD PTR [ecx], 1
$LN22@push_heap@6:
	mov	edx, DWORD PTR [eax+8]
	test	edx, edx
	je	SHORT $LN40@push_heap@6
	add	DWORD PTR [edx], -1
	mov	edx, DWORD PTR [eax+8]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN40@push_heap@6
	mov	DWORD PTR [eax+8], 0
$LN40@push_heap@6:

; 52   : }

	test	ecx, ecx
	mov	edx, DWORD PTR ___val$[esp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR ___val$[esp+12]
	mov	DWORD PTR [eax+16], edx
	je	SHORT $LN33@push_heap@6
	add	DWORD PTR [ecx], -1
$LN33@push_heap@6:
	ret	0
??$__push_heap@PAUItem@CSheduler@@HU12@@stlp_std@@YAXPAUItem@CSheduler@@HHU12@@Z ENDP ; stlp_std::__push_heap<CSheduler::Item *,int,CSheduler::Item>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_uninitialized.h
_TEXT	ENDS
;	COMDAT ??$__ufill@PAUItem@CSheduler@@U12@H@priv@stlp_std@@YAXPAUItem@CSheduler@@0ABU23@ABUrandom_access_iterator_tag@1@PAH@Z
_TEXT	SEGMENT
??$__ufill@PAUItem@CSheduler@@U12@H@priv@stlp_std@@YAXPAUItem@CSheduler@@0ABU23@ABUrandom_access_iterator_tag@1@PAH@Z PROC ; stlp_std::priv::__ufill<CSheduler::Item *,CSheduler::Item,int>, COMDAT
; ___first$ = ecx
; ___last$ = eax
; ___x$ = edi

; 246  :                     const _Tp& __x, const random_access_iterator_tag &, _Distance*) {

	push	esi
	mov	esi, ecx

; 248  :   _STLP_TRY {
; 249  :     for (_Distance __n = __last - __first; __n > 0; --__n, ++__cur)

	sub	eax, esi
	mov	ecx, eax
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	test	ecx, ecx
	jle	SHORT $LN1@ufill@15

; 247  :   _ForwardIter __cur = __first;

	lea	eax, DWORD PTR [esi+8]
	npad	1
$LL3@ufill@15:

; 250  :       _Param_Construct(&*__cur, __x);

	lea	edx, DWORD PTR [eax-8]
	test	edx, edx
	je	SHORT $LN2@ufill@15
	mov	edx, DWORD PTR [edi]
	mov	DWORD PTR [eax-8], edx
	mov	edx, DWORD PTR [edi+4]
	mov	DWORD PTR [eax-4], edx
	mov	DWORD PTR [eax], 0
	mov	esi, DWORD PTR [edi+8]
	test	esi, esi
	je	SHORT $LN16@ufill@15
	add	DWORD PTR [esi], 1
$LN16@ufill@15:
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN19@ufill@15
	add	DWORD PTR [edx], -1
	mov	edx, DWORD PTR [eax]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN19@ufill@15
	mov	DWORD PTR [eax], 0
$LN19@ufill@15:
	mov	DWORD PTR [eax], esi
	mov	edx, DWORD PTR [edi+12]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [edi+16]
	mov	DWORD PTR [eax+8], edx
$LN2@ufill@15:
	sub	ecx, 1
	add	eax, 20					; 00000014H
	test	ecx, ecx
	jg	SHORT $LL3@ufill@15
$LN1@ufill@15:
	pop	esi

; 251  :   }
; 252  :   _STLP_UNWIND(_STLP_STD::_Destroy_Range(__first, __cur))
; 253  : }

	ret	0
??$__ufill@PAUItem@CSheduler@@U12@H@priv@stlp_std@@YAXPAUItem@CSheduler@@0ABU23@ABUrandom_access_iterator_tag@1@PAH@Z ENDP ; stlp_std::priv::__ufill<CSheduler::Item *,CSheduler::Item,int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$__ucopy_ptrs@PAUItem@CSheduler@@PAU12@@priv@stlp_std@@YAPAUItem@CSheduler@@PAU23@00ABU__false_type@1@@Z
_TEXT	SEGMENT
??$__ucopy_ptrs@PAUItem@CSheduler@@PAU12@@priv@stlp_std@@YAPAUItem@CSheduler@@PAU23@00ABU__false_type@1@@Z PROC ; stlp_std::priv::__ucopy_ptrs<CSheduler::Item *,CSheduler::Item *>, COMDAT
; ___first$ = edx
; ___last$ = eax
; ___result$ = ecx

; 113  : { return __ucopy(__first, __last, __result, random_access_iterator_tag(), (ptrdiff_t*)0); }

	jmp	??$__ucopy@PAUItem@CSheduler@@PAU12@H@priv@stlp_std@@YAPAUItem@CSheduler@@PAU23@00ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<CSheduler::Item *,CSheduler::Item *,int>
??$__ucopy_ptrs@PAUItem@CSheduler@@PAU12@@priv@stlp_std@@YAPAUItem@CSheduler@@PAU23@00ABU__false_type@1@@Z ENDP ; stlp_std::priv::__ucopy_ptrs<CSheduler::Item *,CSheduler::Item *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_algobase.h
_TEXT	ENDS
;	COMDAT ??$__copy@PAUItem@CSheduler@@PAU12@H@priv@stlp_std@@YAPAUItem@CSheduler@@PAU23@00ABUrandom_access_iterator_tag@1@PAH@Z
_TEXT	SEGMENT
??$__copy@PAUItem@CSheduler@@PAU12@H@priv@stlp_std@@YAPAUItem@CSheduler@@PAU23@00ABUrandom_access_iterator_tag@1@PAH@Z PROC ; stlp_std::priv::__copy<CSheduler::Item *,CSheduler::Item *,int>, COMDAT
; ___first$ = edx
; ___last$ = eax
; ___result$ = ecx

; 200  :        _OutputIter __result, const random_access_iterator_tag &, _Distance*) {

	push	esi
	mov	esi, edx

; 201  :   for (_Distance __n = __last - __first; __n > 0; --__n) {

	sub	eax, esi
	mov	edx, eax
	mov	eax, 1717986919				; 66666667H
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	test	eax, eax
	jle	SHORT $LN19@copy@28
	push	edi
	npad	3
$LL3@copy@28:

; 202  :     *__result = *__first;

	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [esi+8]
	test	edx, edx
	je	SHORT $LN10@copy@28
	add	DWORD PTR [edx], 1
$LN10@copy@28:
	mov	edi, DWORD PTR [ecx+8]
	test	edi, edi
	je	SHORT $LN13@copy@28
	add	DWORD PTR [edi], -1
	mov	edi, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edi], 0
	jne	SHORT $LN13@copy@28
	mov	DWORD PTR [ecx+8], 0
$LN13@copy@28:
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [ecx+16], edx
	sub	eax, 1

; 203  :     ++__first;

	add	esi, 20					; 00000014H

; 204  :     ++__result;

	add	ecx, 20					; 00000014H
	test	eax, eax
	jg	SHORT $LL3@copy@28
	pop	edi
$LN19@copy@28:

; 205  :   }
; 206  :   return __result;

	mov	eax, ecx
	pop	esi

; 207  : }

	ret	0
??$__copy@PAUItem@CSheduler@@PAU12@H@priv@stlp_std@@YAPAUItem@CSheduler@@PAU23@00ABUrandom_access_iterator_tag@1@PAH@Z ENDP ; stlp_std::priv::__copy<CSheduler::Item *,CSheduler::Item *,int>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_heap.c
_TEXT	ENDS
;	COMDAT ??$__push_heap_aux@PAUItem@CSheduler@@HU12@@stlp_std@@YAXPAUItem@CSheduler@@0PAH0@Z
_TEXT	SEGMENT
??$__push_heap_aux@PAUItem@CSheduler@@HU12@@stlp_std@@YAXPAUItem@CSheduler@@0PAH0@Z PROC ; stlp_std::__push_heap_aux<CSheduler::Item *,int,CSheduler::Item>, COMDAT
; ___first$ = eax
; ___last$ = ecx

; 59   :   __push_heap(__first, _Distance((__last - __first) - 1), _Distance(0),
; 60   :               _Tp(*(__last - 1)));

	mov	edx, DWORD PTR [ecx-20]
	push	ebx
	push	esi
	sub	esp, 20					; 00000014H
	mov	ebx, eax
	mov	eax, esp
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx-16]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], 0
	mov	edx, DWORD PTR [ecx-12]
	test	edx, edx
	je	SHORT $LN7@push_heap_
	add	DWORD PTR [edx], 1
$LN7@push_heap_:
	mov	esi, DWORD PTR [eax+8]
	test	esi, esi
	je	SHORT $LN10@push_heap_
	add	DWORD PTR [esi], -1
	mov	esi, DWORD PTR [eax+8]
	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN10@push_heap_
	mov	DWORD PTR [eax+8], 0
$LN10@push_heap_:
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx-8]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx-4]
	mov	DWORD PTR [eax+16], edx
	sub	ecx, ebx
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	lea	ecx, DWORD PTR [edx+eax-1]
	call	??$__push_heap@PAUItem@CSheduler@@HU12@@stlp_std@@YAXPAUItem@CSheduler@@HHU12@@Z ; stlp_std::__push_heap<CSheduler::Item *,int,CSheduler::Item>
	add	esp, 20					; 00000014H

; 61   : }

	pop	esi
	pop	ebx
	ret	0
??$__push_heap_aux@PAUItem@CSheduler@@HU12@@stlp_std@@YAXPAUItem@CSheduler@@0PAH0@Z ENDP ; stlp_std::__push_heap_aux<CSheduler::Item *,int,CSheduler::Item>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_uninitialized.h
_TEXT	ENDS
;	COMDAT ??$__uninitialized_fill_n@PAUItem@CSheduler@@IU12@@priv@stlp_std@@YAPAUItem@CSheduler@@PAU23@IABU23@@Z
_TEXT	SEGMENT
??$__uninitialized_fill_n@PAUItem@CSheduler@@IU12@@priv@stlp_std@@YAPAUItem@CSheduler@@PAU23@IABU23@@Z PROC ; stlp_std::priv::__uninitialized_fill_n<CSheduler::Item *,unsigned int,CSheduler::Item>, COMDAT
; ___first$ = ecx
; ___n$ = eax
; ___x$ = edi

; 314  :   _ForwardIter __last = __first + __n;

	lea	eax, DWORD PTR [eax+eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+eax*4]

; 315  :   __ufill(__first, __last, __x, random_access_iterator_tag(), (ptrdiff_t*)0);

	mov	eax, esi
	call	??$__ufill@PAUItem@CSheduler@@U12@H@priv@stlp_std@@YAXPAUItem@CSheduler@@0ABU23@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ufill<CSheduler::Item *,CSheduler::Item,int>

; 316  :   return __last;

	mov	eax, esi
	pop	esi

; 317  : }

	ret	0
??$__uninitialized_fill_n@PAUItem@CSheduler@@IU12@@priv@stlp_std@@YAPAUItem@CSheduler@@PAU23@IABU23@@Z ENDP ; stlp_std::priv::__uninitialized_fill_n<CSheduler::Item *,unsigned int,CSheduler::Item>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$__uninitialized_move@PAUItem@CSheduler@@PAU12@U__false_type@stlp_std@@@priv@stlp_std@@YAPAUItem@CSheduler@@PAU23@00U__false_type@1@ABU41@@Z
_TEXT	SEGMENT
___trivial_ucpy$ = 8					; size = 1
??$__uninitialized_move@PAUItem@CSheduler@@PAU12@U__false_type@stlp_std@@@priv@stlp_std@@YAPAUItem@CSheduler@@PAU23@00U__false_type@1@ABU41@@Z PROC ; stlp_std::priv::__uninitialized_move<CSheduler::Item *,CSheduler::Item *,stlp_std::__false_type>, COMDAT
; ___first$ = edx
; ___last$ = eax
; ___result$ = ecx

; 414  : { return __ucopy_ptrs(__first, __last, __result, __trivial_ucpy); }

	jmp	??$__ucopy@PAUItem@CSheduler@@PAU12@H@priv@stlp_std@@YAPAUItem@CSheduler@@PAU23@00ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<CSheduler::Item *,CSheduler::Item *,int>
??$__uninitialized_move@PAUItem@CSheduler@@PAU12@U__false_type@stlp_std@@@priv@stlp_std@@YAPAUItem@CSheduler@@PAU23@00U__false_type@1@ABU41@@Z ENDP ; stlp_std::priv::__uninitialized_move<CSheduler::Item *,CSheduler::Item *,stlp_std::__false_type>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_algobase.h
_TEXT	ENDS
;	COMDAT ??$__copy_ptrs@PAUItem@CSheduler@@PAU12@@priv@stlp_std@@YAPAUItem@CSheduler@@PAU23@00ABU__false_type@1@@Z
_TEXT	SEGMENT
??$__copy_ptrs@PAUItem@CSheduler@@PAU12@@priv@stlp_std@@YAPAUItem@CSheduler@@PAU23@00ABU__false_type@1@@Z PROC ; stlp_std::priv::__copy_ptrs<CSheduler::Item *,CSheduler::Item *>, COMDAT
; ___first$ = edx
; ___last$ = eax
; ___result$ = ecx

; 250  :   return __copy(__first, __last, __result, random_access_iterator_tag(), (ptrdiff_t*)0);

	jmp	??$__copy@PAUItem@CSheduler@@PAU12@H@priv@stlp_std@@YAPAUItem@CSheduler@@PAU23@00ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__copy<CSheduler::Item *,CSheduler::Item *,int>
??$__copy_ptrs@PAUItem@CSheduler@@PAU12@@priv@stlp_std@@YAPAUItem@CSheduler@@PAU23@00ABU__false_type@1@@Z ENDP ; stlp_std::priv::__copy_ptrs<CSheduler::Item *,CSheduler::Item *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_construct.h
_TEXT	ENDS
;	COMDAT ??$_Copy_Construct@UItem@CSheduler@@@stlp_std@@YAXPAUItem@CSheduler@@ABU12@@Z
_TEXT	SEGMENT
??$_Copy_Construct@UItem@CSheduler@@@stlp_std@@YAXPAUItem@CSheduler@@ABU12@@Z PROC ; stlp_std::_Copy_Construct<CSheduler::Item>, COMDAT
; ___p$ = eax
; ___val$ = ecx

; 110  : #if defined (_STLP_DEBUG_UNINITIALIZED)
; 111  :   memset((char*)__p, _STLP_SHRED_BYTE, sizeof(_Tp));
; 112  : #endif
; 113  :   _STLP_PLACEMENT_NEW (__p) _Tp(__val);

	test	eax, eax
	je	SHORT $LN3@Copy_Const@34
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	push	esi
	mov	DWORD PTR [eax+8], 0
	mov	esi, DWORD PTR [ecx+8]
	test	esi, esi
	je	SHORT $LN11@Copy_Const@34
	add	DWORD PTR [esi], 1
$LN11@Copy_Const@34:
	mov	edx, DWORD PTR [eax+8]
	test	edx, edx
	je	SHORT $LN14@Copy_Const@34
	add	DWORD PTR [edx], -1
	mov	edx, DWORD PTR [eax+8]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN14@Copy_Const@34
	mov	DWORD PTR [eax+8], 0
$LN14@Copy_Const@34:
	mov	DWORD PTR [eax+8], esi
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], ecx
	pop	esi
$LN3@Copy_Const@34:

; 114  : }

	ret	0
??$_Copy_Construct@UItem@CSheduler@@@stlp_std@@YAXPAUItem@CSheduler@@ABU12@@Z ENDP ; stlp_std::_Copy_Construct<CSheduler::Item>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_heap.c
_TEXT	ENDS
;	COMDAT ??$push_heap@PAUItem@CSheduler@@@stlp_std@@YAXPAUItem@CSheduler@@0@Z
_TEXT	SEGMENT
??$push_heap@PAUItem@CSheduler@@@stlp_std@@YAXPAUItem@CSheduler@@0@Z PROC ; stlp_std::push_heap<CSheduler::Item *>, COMDAT
; ___first$ = eax
; ___last$ = ecx

; 67   :   __push_heap_aux(__first, __last,
; 68   :                   _STLP_DISTANCE_TYPE(__first, _RandomAccessIterator), _STLP_VALUE_TYPE(__first, _RandomAccessIterator));

	jmp	??$__push_heap_aux@PAUItem@CSheduler@@HU12@@stlp_std@@YAXPAUItem@CSheduler@@0PAH0@Z ; stlp_std::__push_heap_aux<CSheduler::Item *,int,CSheduler::Item>
??$push_heap@PAUItem@CSheduler@@@stlp_std@@YAXPAUItem@CSheduler@@0@Z ENDP ; stlp_std::push_heap<CSheduler::Item *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.c
_TEXT	ENDS
;	COMDAT ?_M_insert_overflow_aux@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@AAEXPAUItem@CSheduler@@ABU45@ABU__false_type@3@I_N@Z
_TEXT	SEGMENT
___old_size$ = -12					; size = 4
___fill_len$ = -8					; size = 4
___new_start$ = -4					; size = 4
___last$465623 = 8					; size = 4
___pos$ = 8						; size = 4
___x$ = 12						; size = 4
?_M_insert_overflow_aux@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@AAEXPAUItem@CSheduler@@ABU45@ABU__false_type@3@I_N@Z PROC ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::_M_insert_overflow_aux, COMDAT
; _this$ = esi

; 84   :                                                  size_type __fill_len, bool __atend ) {

	sub	esp, 12					; 0000000cH

; 85   :   const size_type __old_size = size();

	mov	ecx, DWORD PTR [esi+4]
	sub	ecx, DWORD PTR [esi]
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	push	ebx
	mov	eax, edx
	push	ebp
	shr	eax, 31					; 0000001fH
	push	edi
	add	eax, edx

; 86   :   size_type __len = __old_size + (max)(__old_size, __fill_len);

	lea	ecx, DWORD PTR ___fill_len$[esp+24]
	push	ecx
	lea	edx, DWORD PTR ___old_size$[esp+28]
	push	edx
	mov	DWORD PTR ___fill_len$[esp+32], 1
	mov	DWORD PTR ___old_size$[esp+32], eax
	call	??$max@I@stlp_std@@YAABIABI0@Z		; stlp_std::max<unsigned int>
	mov	eax, DWORD PTR [eax]
	add	eax, DWORD PTR ___old_size$[esp+32]

; 87   : 
; 88   :   pointer __new_start = this->_M_end_of_storage.allocate(__len, __len);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	ebp, DWORD PTR [eax+eax*4]
	add	ebp, ebp
	add	esp, 8
	add	ebp, ebp
	push	ebp
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 89   :   pointer __new_finish = __new_start;
; 90   :   _STLP_TRY {
; 91   :     __new_finish = _STLP_PRIV __uninitialized_move(this->_M_start, __pos, __new_start, _TrivialUCopy(), _Movable());

	mov	edx, DWORD PTR [esi]
	mov	edi, eax
	mov	eax, DWORD PTR ___pos$[esp+20]
	mov	ecx, edi
	mov	DWORD PTR ___new_start$[esp+24], edi
	call	??$__ucopy@PAUItem@CSheduler@@PAU12@H@priv@stlp_std@@YAPAUItem@CSheduler@@PAU23@00ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<CSheduler::Item *,CSheduler::Item *,int>
	mov	ebx, eax

; 92   :     // handle insertion
; 93   :     if (__fill_len == 1) {

	mov	eax, DWORD PTR ___fill_len$[esp+24]
	cmp	eax, 1
	jne	SHORT $LN3@M_insert_o@27

; 94   :       _Copy_Construct(__new_finish, __x);

	test	ebx, ebx
	je	SHORT $LN28@M_insert_o@27
	mov	eax, DWORD PTR ___x$[esp+20]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ebx], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ebx+4], edx
	mov	DWORD PTR [ebx+8], 0
	mov	edx, DWORD PTR [eax+8]
	test	edx, edx
	je	SHORT $LN36@M_insert_o@27
	add	DWORD PTR [edx], 1
$LN36@M_insert_o@27:
	mov	ecx, DWORD PTR [ebx+8]
	test	ecx, ecx
	je	SHORT $LN39@M_insert_o@27
	add	DWORD PTR [ecx], -1
	mov	ecx, DWORD PTR [ebx+8]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN39@M_insert_o@27
	mov	DWORD PTR [ebx+8], 0
$LN39@M_insert_o@27:
	mov	DWORD PTR [ebx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ebx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ebx+16], eax
$LN28@M_insert_o@27:

; 95   :       ++__new_finish;

	add	ebx, 20					; 00000014H

; 96   :     } else

	jmp	SHORT $LN1@M_insert_o@27
$LN3@M_insert_o@27:

; 97   :       __new_finish = _STLP_PRIV __uninitialized_fill_n(__new_finish, __fill_len, __x);

	mov	edi, DWORD PTR ___x$[esp+20]
	lea	ecx, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [ebx+ecx*4]
	mov	ecx, ebx
	mov	DWORD PTR ___last$465623[esp+20], eax
	call	??$__ufill@PAUItem@CSheduler@@U12@H@priv@stlp_std@@YAXPAUItem@CSheduler@@0ABU23@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ufill<CSheduler::Item *,CSheduler::Item,int>
	mov	ebx, DWORD PTR ___last$465623[esp+20]
	mov	edi, DWORD PTR ___new_start$[esp+24]
$LN1@M_insert_o@27:

; 98   :     if (!__atend)
; 99   :       __new_finish = _STLP_PRIV __uninitialized_move(__pos, this->_M_finish, __new_finish, _TrivialUCopy(), _Movable()); // copy remainder
; 100  :   }
; 101  :   _STLP_UNWIND((_STLP_STD::_Destroy_Range(__new_start,__new_finish),
; 102  :                this->_M_end_of_storage.deallocate(__new_start,__len)))
; 103  :   _M_clear_after_move();

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi]
	push	ecx
	mov	edx, esp
	mov	DWORD PTR [edx], eax
	push	ecx
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	call	??$__destroy_mv_srcs@V?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@UItem@CSheduler@@@stlp_std@@YAXV?$reverse_iterator@PAUItem@CSheduler@@@0@0PAUItem@CSheduler@@@Z ; stlp_std::__destroy_mv_srcs<stlp_std::reverse_iterator<CSheduler::Item *>,CSheduler::Item>
	mov	eax, DWORD PTR [esi]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN71@M_insert_o@27
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN71@M_insert_o@27:

; 104  :   _M_set(__new_start, __new_finish, __new_start + __len);

	add	ebp, edi
	mov	DWORD PTR [esi], edi

; 105  : }

	pop	edi
	mov	DWORD PTR [esi+8], ebp
	pop	ebp
	mov	DWORD PTR [esi+4], ebx
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	8
?_M_insert_overflow_aux@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@AAEXPAUItem@CSheduler@@ABU45@ABU__false_type@3@I_N@Z ENDP ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::_M_insert_overflow_aux
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ?_M_erase@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@AAEPAUItem@CSheduler@@PAU45@0ABU__false_type@3@@Z
_TEXT	SEGMENT
?_M_erase@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@AAEPAUItem@CSheduler@@PAU45@0ABU__false_type@3@@Z PROC ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::_M_erase, COMDAT
; _this$ = edi
; ___first$ = ebx
; ___last$ = edx

; 579  :     pointer __i = _STLP_PRIV __copy_ptrs(__last, this->_M_finish, __first, _TrivialCopy());

	mov	eax, DWORD PTR [edi+4]
	push	esi
	mov	ecx, ebx
	call	??$__copy@PAUItem@CSheduler@@PAU12@H@priv@stlp_std@@YAPAUItem@CSheduler@@PAU23@00ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__copy<CSheduler::Item *,CSheduler::Item *,int>

; 580  :     _STLP_STD::_Destroy_Range(__i, this->_M_finish);

	mov	esi, DWORD PTR [edi+4]
	cmp	eax, esi
	je	SHORT $LN34@M_erase@38

; 579  :     pointer __i = _STLP_PRIV __copy_ptrs(__last, this->_M_finish, __first, _TrivialCopy());

	lea	ecx, DWORD PTR [eax+8]

; 580  :     _STLP_STD::_Destroy_Range(__i, this->_M_finish);

$LL11@M_erase@38:
	mov	edx, DWORD PTR [ecx]
	test	edx, edx
	je	SHORT $LN23@M_erase@38
	add	DWORD PTR [edx], -1
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN23@M_erase@38
	mov	DWORD PTR [ecx], 0
$LN23@M_erase@38:
	add	ecx, 20					; 00000014H
	lea	edx, DWORD PTR [ecx-8]
	cmp	edx, esi
	jne	SHORT $LL11@M_erase@38
$LN34@M_erase@38:

; 581  :     this->_M_finish = __i;

	mov	DWORD PTR [edi+4], eax

; 582  :     return __first;

	mov	eax, ebx
	pop	esi

; 583  :   }

	ret	0
?_M_erase@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@AAEPAUItem@CSheduler@@PAU45@0ABU__false_type@3@@Z ENDP ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::_M_erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?erase@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEPAUItem@CSheduler@@PAU45@0@Z
_TEXT	SEGMENT
?erase@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEPAUItem@CSheduler@@PAU45@0@Z PROC ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::erase, COMDAT
; _this$ = edi
; ___first$ = eax
; ___last$ = edx

; 590  :     if (__first == __last)

	cmp	eax, edx

; 591  :       return __first;

	je	SHORT $LN2@erase@59
	push	ebx

; 592  :     return _M_erase(__first, __last, _Movable());

	mov	ebx, eax
	call	?_M_erase@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@AAEPAUItem@CSheduler@@PAU45@0ABU__false_type@3@@Z ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::_M_erase
	pop	ebx
$LN2@erase@59:

; 593  :   }

	ret	0
?erase@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEPAUItem@CSheduler@@PAU45@0@Z ENDP ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?clear@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEXXZ PROC ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::clear, COMDAT
; _this$ = eax

; 610  :   void clear() {

	push	ebx
	push	edi
	mov	edi, eax

; 611  :     erase(begin(), end());

	mov	edx, DWORD PTR [edi+4]
	mov	ebx, DWORD PTR [edi]
	cmp	ebx, edx
	je	SHORT $LN8@clear@66
	call	?_M_erase@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@AAEPAUItem@CSheduler@@PAU45@0ABU__false_type@3@@Z ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::_M_erase
$LN8@clear@66:
	pop	edi
	pop	ebx

; 612  :   }

	ret	0
?clear@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEXXZ ENDP ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::clear
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_M_erase@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@AAEPAUItem@CSheduler@@PAU45@ABU__false_type@3@@Z
_TEXT	SEGMENT
?_M_erase@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@AAEPAUItem@CSheduler@@PAU45@ABU__false_type@3@@Z PROC ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::_M_erase, COMDAT
; _this$ = eax
; ___pos$ = edi

; 548  :   iterator _M_erase(iterator __pos, const __false_type& /*_Movable*/) {

	push	esi
	mov	esi, eax

; 549  :     if (__pos + 1 != end())

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [edi+20]
	cmp	edx, eax
	je	SHORT $LN6@M_erase@39

; 550  :       _STLP_PRIV __copy_ptrs(__pos + 1, this->_M_finish, __pos, _TrivialCopy());

	mov	ecx, edi
	call	??$__copy@PAUItem@CSheduler@@PAU12@H@priv@stlp_std@@YAPAUItem@CSheduler@@PAU23@00ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__copy<CSheduler::Item *,CSheduler::Item *,int>
$LN6@M_erase@39:

; 551  :     --this->_M_finish;

	add	DWORD PTR [esi+4], -20			; ffffffecH
	mov	esi, DWORD PTR [esi+4]

; 552  :     _STLP_STD::_Destroy(this->_M_finish);

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN29@M_erase@39
	add	DWORD PTR [eax], -1
	mov	eax, DWORD PTR [esi+8]
	cmp	DWORD PTR [eax], 0

; 553  :     return __pos;

	mov	eax, edi
	jne	SHORT $LN19@M_erase@39

; 552  :     _STLP_STD::_Destroy(this->_M_finish);

	mov	DWORD PTR [esi+8], 0
	pop	esi

; 554  :   }

	ret	0
$LN29@M_erase@39:

; 553  :     return __pos;

	mov	eax, edi

; 552  :     _STLP_STD::_Destroy(this->_M_finish);

$LN19@M_erase@39:
	pop	esi

; 554  :   }

	ret	0
?_M_erase@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@AAEPAUItem@CSheduler@@PAU45@ABU__false_type@3@@Z ENDP ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::_M_erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_M_insert_overflow@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@AAEXPAUItem@CSheduler@@ABU45@ABU__false_type@3@I_N@Z
_TEXT	SEGMENT
?_M_insert_overflow@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@AAEXPAUItem@CSheduler@@ABU45@ABU__false_type@3@I_N@Z PROC ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::_M_insert_overflow, COMDAT
; _this$ = esi
; ___pos$ = ecx
; ___x$ = eax

; 161  :   { _M_insert_overflow_aux(__pos, __x, _Movable(), __fill_len, __atend); }

	push	eax
	push	ecx
	call	?_M_insert_overflow_aux@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@AAEXPAUItem@CSheduler@@ABU45@ABU__false_type@3@I_N@Z ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::_M_insert_overflow_aux
	ret	0
?_M_insert_overflow@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@AAEXPAUItem@CSheduler@@ABU45@ABU__false_type@3@I_N@Z ENDP ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::_M_insert_overflow
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ?clear@?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAEXXZ PROC ; stlp_std::vector<CSheduler::Item,xalloc<CSheduler::Item> >::clear, COMDAT
; _this$ = eax

; 223  :   void clear() { _M_impl.clear(); }

	push	ebx
	push	edi
	mov	edi, eax
	mov	edx, DWORD PTR [edi+4]
	mov	ebx, DWORD PTR [edi]
	cmp	ebx, edx
	je	SHORT $LN10@clear@67
	call	?_M_erase@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@AAEPAUItem@CSheduler@@PAU45@0ABU__false_type@3@@Z ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::_M_erase
$LN10@clear@67:
	pop	edi
	pop	ebx
	ret	0
?clear@?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAEXXZ ENDP ; stlp_std::vector<CSheduler::Item,xalloc<CSheduler::Item> >::clear
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ?erase@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEPAUItem@CSheduler@@PAU45@@Z
_TEXT	SEGMENT
?erase@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEPAUItem@CSheduler@@PAU45@@Z PROC ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::erase, COMDAT
; _this$ = eax
; ___pos$ = edi

; 586  :   iterator erase(iterator __pos) {

	push	esi
	mov	esi, eax

; 587  :     return _M_erase(__pos, _Movable());

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [edi+20]
	cmp	edx, eax
	je	SHORT $LN8@erase@60
	mov	ecx, edi
	call	??$__copy@PAUItem@CSheduler@@PAU12@H@priv@stlp_std@@YAPAUItem@CSheduler@@PAU23@00ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__copy<CSheduler::Item *,CSheduler::Item *,int>
$LN8@erase@60:
	add	DWORD PTR [esi+4], -20			; ffffffecH
	mov	esi, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN31@erase@60
	add	DWORD PTR [eax], -1
	mov	eax, DWORD PTR [esi+8]
	cmp	DWORD PTR [eax], 0
	mov	eax, edi
	jne	SHORT $LN21@erase@60
	mov	DWORD PTR [esi+8], 0
	pop	esi

; 588  :   }

	ret	0
$LN31@erase@60:

; 587  :     return _M_erase(__pos, _Movable());

	mov	eax, edi
$LN21@erase@60:
	pop	esi

; 588  :   }

	ret	0
?erase@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEPAUItem@CSheduler@@PAU45@@Z ENDP ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?push_back@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEXABUItem@CSheduler@@@Z
_TEXT	SEGMENT
?push_back@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEXABUItem@CSheduler@@@Z PROC ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::push_back, COMDAT
; _this$ = eax
; ___x$ = ecx

; 360  :   void push_back(const _Tp& __x) {

	push	esi
	mov	esi, eax

; 361  : #endif /*!_STLP_DONT_SUP_DFLT_PARAM && !_STLP_NO_ANACHRONISMS*/
; 362  :     if (this->_M_finish != this->_M_end_of_storage._M_data) {

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, DWORD PTR [esi+8]
	je	SHORT $LN2@push_back@58

; 363  :       _Copy_Construct(this->_M_finish, __x);

	test	eax, eax
	je	SHORT $LN7@push_back@58
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	push	edi
	mov	DWORD PTR [eax+8], 0
	mov	edi, DWORD PTR [ecx+8]
	test	edi, edi
	je	SHORT $LN15@push_back@58
	add	DWORD PTR [edi], 1
$LN15@push_back@58:
	mov	edx, DWORD PTR [eax+8]
	test	edx, edx
	je	SHORT $LN18@push_back@58
	add	DWORD PTR [edx], -1
	mov	edx, DWORD PTR [eax+8]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN18@push_back@58
	mov	DWORD PTR [eax+8], 0
$LN18@push_back@58:
	mov	DWORD PTR [eax+8], edi
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], ecx
	pop	edi
$LN7@push_back@58:

; 364  :       ++this->_M_finish;

	add	DWORD PTR [esi+4], 20			; 00000014H
	pop	esi

; 368  :   }

	ret	0
$LN2@push_back@58:

; 365  :     }
; 366  :     else
; 367  :       _M_insert_overflow(this->_M_finish, __x, _TrivialCopy(), 1UL, true);

	push	ecx
	push	eax
	call	?_M_insert_overflow_aux@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@AAEXPAUItem@CSheduler@@ABU45@ABU__false_type@3@I_N@Z ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::_M_insert_overflow_aux
	pop	esi

; 368  :   }

	ret	0
?push_back@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEXABUItem@CSheduler@@@Z ENDP ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::push_back
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ?clear_and_free@?$xr_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear_and_free@?$xr_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@@QAEXXZ PROC ; xr_vector<CSheduler::Item,xalloc<CSheduler::Item> >::clear_and_free, COMDAT
; _this$ = eax

; 128  : 	void	clear_and_free		()									{ inherited::clear();			}

	push	ebx
	push	edi
	mov	edi, eax
	mov	edx, DWORD PTR [edi+4]
	mov	ebx, DWORD PTR [edi]
	cmp	ebx, edx
	je	SHORT $LN12@clear_and_@24
	call	?_M_erase@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@AAEPAUItem@CSheduler@@PAU45@0ABU__false_type@3@@Z ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::_M_erase
$LN12@clear_and_@24:
	pop	edi
	pop	ebx
	ret	0
?clear_and_free@?$xr_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@@QAEXXZ ENDP ; xr_vector<CSheduler::Item,xalloc<CSheduler::Item> >::clear_and_free
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ?erase@?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAEPAUItem@CSheduler@@PAU34@@Z
_TEXT	SEGMENT
?erase@?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAEPAUItem@CSheduler@@PAU34@@Z PROC ; stlp_std::vector<CSheduler::Item,xalloc<CSheduler::Item> >::erase, COMDAT
; _this$ = eax
; ___pos$ = edi

; 206  :   {return cast_traits::to_value_type_ptr(_M_impl.erase(cast_traits::to_storage_type_ptr(__pos)));}

	push	esi
	mov	esi, eax
	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [edi+20]
	cmp	edx, eax
	je	SHORT $LN12@erase@61
	mov	ecx, edi
	call	??$__copy@PAUItem@CSheduler@@PAU12@H@priv@stlp_std@@YAPAUItem@CSheduler@@PAU23@00ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__copy<CSheduler::Item *,CSheduler::Item *,int>
$LN12@erase@61:
	add	DWORD PTR [esi+4], -20			; ffffffecH
	mov	esi, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN37@erase@61
	add	DWORD PTR [eax], -1
	mov	eax, DWORD PTR [esi+8]
	cmp	DWORD PTR [eax], 0
	mov	eax, edi
	jne	SHORT $LN25@erase@61
	mov	DWORD PTR [esi+8], 0
	pop	esi
	ret	0
$LN37@erase@61:
	mov	eax, edi
$LN25@erase@61:
	pop	esi
	ret	0
?erase@?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAEPAUItem@CSheduler@@PAU34@@Z ENDP ; stlp_std::vector<CSheduler::Item,xalloc<CSheduler::Item> >::erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAEXABUItem@CSheduler@@@Z
_TEXT	SEGMENT
?push_back@?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAEXABUItem@CSheduler@@@Z PROC ; stlp_std::vector<CSheduler::Item,xalloc<CSheduler::Item> >::push_back, COMDAT
; _this$ = eax
; ___x$ = ecx

; 171  :   { _M_impl.push_back(cast_traits::to_storage_type_cref(__x)); }

	jmp	?push_back@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEXABUItem@CSheduler@@@Z ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::push_back
?push_back@?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAEXABUItem@CSheduler@@@Z ENDP ; stlp_std::vector<CSheduler::Item,xalloc<CSheduler::Item> >::push_back
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ?clear@?$xr_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$xr_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@@QAEXXZ PROC ; xr_vector<CSheduler::Item,xalloc<CSheduler::Item> >::clear, COMDAT
; _this$ = eax

; 133  : 	void	clear				()									{ clear_and_free	();			}

	push	ebx
	push	edi
	mov	edi, eax
	mov	edx, DWORD PTR [edi+4]
	mov	ebx, DWORD PTR [edi]
	cmp	ebx, edx
	je	SHORT $LN14@clear@68
	call	?_M_erase@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@AAEPAUItem@CSheduler@@PAU45@0ABU__false_type@3@@Z ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::_M_erase
$LN14@clear@68:
	pop	edi
	pop	ebx
	ret	0
?clear@?$xr_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@@QAEXXZ ENDP ; xr_vector<CSheduler::Item,xalloc<CSheduler::Item> >::clear
_TEXT	ENDS
PUBLIC	?Push@CSheduler@@AAEXAAUItem@1@@Z		; CSheduler::Push
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\xrsheduler.cpp
;	COMDAT ?Push@CSheduler@@AAEXAAUItem@1@@Z
_TEXT	SEGMENT
_I$ = 8							; size = 4
?Push@CSheduler@@AAEXAAUItem@1@@Z PROC			; CSheduler::Push, COMDAT
; _this$ = ecx

; 283  : {

	push	esi
	mov	esi, ecx

; 284  : 	Items.push_back	(I);

	mov	ecx, DWORD PTR _I$[esp]
	push	edi
	lea	edi, DWORD PTR [esi+12]
	mov	eax, edi
	call	?push_back@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEXABUItem@CSheduler@@@Z ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::push_back

; 285  : 	std::push_heap	(Items.begin(), Items.end());

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [edi]
	call	??$__push_heap_aux@PAUItem@CSheduler@@HU12@@stlp_std@@YAXPAUItem@CSheduler@@0PAH0@Z ; stlp_std::__push_heap_aux<CSheduler::Item *,int,CSheduler::Item>
	pop	edi
	pop	esi

; 286  : }

	ret	4
?Push@CSheduler@@AAEXAAUItem@1@@Z ENDP			; CSheduler::Push
_TEXT	ENDS
PUBLIC	?EnsureOrder@CSheduler@@QAEXPAVISheduled@@0@Z	; CSheduler::EnsureOrder
; Function compile flags: /Ogtpy
;	COMDAT ?EnsureOrder@CSheduler@@QAEXPAVISheduled@@0@Z
_TEXT	SEGMENT
_A$118248 = -20						; size = 20
_Before$ = 8						; size = 4
_After$ = 12						; size = 4
?EnsureOrder@CSheduler@@QAEXPAVISheduled@@0@Z PROC	; CSheduler::EnsureOrder, COMDAT
; _this$ = ecx

; 267  : {

	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	mov	esi, ecx

; 268  : 	VERIFY(Before->shedule.b_RT && After->shedule.b_RT);
; 269  : 
; 270  : 	for (u32 i=0; i<ItemsRT.size(); i++)

	mov	ebx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	sub	ecx, ebx
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	push	edi
	shr	eax, 31					; 0000001fH
	xor	edi, edi
	add	eax, edx
	je	$LN121@EnsureOrde
	push	ebp
	lea	ebp, DWORD PTR [ebx+12]
	npad	4
$LL4@EnsureOrde:

; 271  : 	{
; 272  : 		if (ItemsRT[i].Object==After) 

	mov	ecx, DWORD PTR _After$[esp+32]
	cmp	DWORD PTR [ebp], ecx
	je	SHORT $LN126@EnsureOrde
	mov	ecx, DWORD PTR [esi+4]
	sub	ecx, ebx
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	edi, 1
	add	eax, edx
	add	ebp, 20					; 00000014H
	cmp	edi, eax
	jb	SHORT $LL4@EnsureOrde
	pop	ebp
	pop	edi
	pop	esi
	pop	ebx

; 278  : 		}
; 279  : 	}
; 280  : }

	add	esp, 20					; 00000014H
	ret	8
$LN126@EnsureOrde:

; 273  : 		{
; 274  : 			Item	A			= ItemsRT[i];

	lea	eax, DWORD PTR [edi+edi*4]
	add	eax, eax
	add	eax, eax
	mov	edi, DWORD PTR [eax+ebx+8]
	test	edi, edi
	mov	ebp, DWORD PTR [eax+ebx]
	mov	ecx, DWORD PTR [eax+ebx+4]
	mov	DWORD PTR _A$118248[esp+36], ebp
	mov	DWORD PTR _A$118248[esp+40], ecx
	je	SHORT $LN128@EnsureOrde
	add	DWORD PTR [edi], 1
$LN128@EnsureOrde:
	mov	ecx, DWORD PTR [eax+ebx+16]
	mov	edx, DWORD PTR [eax+ebx+12]
	mov	DWORD PTR _A$118248[esp+52], ecx

; 275  : 			ItemsRT.erase		(ItemsRT.begin()+i);

	mov	ecx, DWORD PTR [esi]
	add	ecx, eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR _A$118248[esp+48], edx
	lea	edx, DWORD PTR [ecx+20]
	cmp	edx, eax
	mov	DWORD PTR _A$118248[esp+44], edi
	je	SHORT $LN66@EnsureOrde
	call	??$__copy@PAUItem@CSheduler@@PAU12@H@priv@stlp_std@@YAPAUItem@CSheduler@@PAU23@00ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__copy<CSheduler::Item *,CSheduler::Item *,int>
$LN66@EnsureOrde:
	add	DWORD PTR [esi+4], -20			; ffffffecH
	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [ecx+8]
	xor	ebx, ebx
	cmp	eax, ebx
	je	SHORT $LN129@EnsureOrde
	add	DWORD PTR [eax], -1
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx], ebx
	jne	SHORT $LN129@EnsureOrde
	mov	DWORD PTR [ecx+8], ebx
$LN129@EnsureOrde:

; 276  : 			ItemsRT.push_back	(A);

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, DWORD PTR [esi+8]
	je	SHORT $LN95@EnsureOrde
	cmp	eax, ebx
	je	SHORT $LN100@EnsureOrde
	cmp	edi, ebx
	mov	ecx, DWORD PTR _A$118248[esp+40]
	mov	DWORD PTR [eax], ebp
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ebx
	je	SHORT $LN108@EnsureOrde
	add	DWORD PTR [edi], 1
$LN108@EnsureOrde:
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, ebx
	je	SHORT $LN111@EnsureOrde
	add	DWORD PTR [ecx], -1
	mov	edx, DWORD PTR [eax+8]
	cmp	DWORD PTR [edx], ebx
	jne	SHORT $LN111@EnsureOrde
	mov	DWORD PTR [eax+8], ebx
$LN111@EnsureOrde:
	mov	ecx, DWORD PTR _A$118248[esp+48]
	mov	edx, DWORD PTR _A$118248[esp+52]
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], edx
$LN100@EnsureOrde:
	add	DWORD PTR [esi+4], 20			; 00000014H
	jmp	SHORT $LN115@EnsureOrde
$LN95@EnsureOrde:
	lea	ecx, DWORD PTR _A$118248[esp+36]
	push	ecx
	push	eax
	call	?_M_insert_overflow_aux@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@AAEXPAUItem@CSheduler@@ABU45@ABU__false_type@3@I_N@Z ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::_M_insert_overflow_aux
$LN115@EnsureOrde:

; 277  : 			return;

	cmp	edi, ebx
	je	SHORT $LN130@EnsureOrde
	add	DWORD PTR [edi], -1
$LN130@EnsureOrde:
	pop	ebp
$LN121@EnsureOrde:
	pop	edi
	pop	esi
	pop	ebx

; 278  : 		}
; 279  : 	}
; 280  : }

	add	esp, 20					; 00000014H
	ret	8
?EnsureOrder@CSheduler@@QAEXPAVISheduled@@0@Z ENDP	; CSheduler::EnsureOrder
_TEXT	ENDS
PUBLIC	?internal_Unregister@CSheduler@@AAE_NPAVISheduled@@H_N@Z ; CSheduler::internal_Unregister
; Function compile flags: /Ogtpy
;	COMDAT ?internal_Unregister@CSheduler@@AAE_NPAVISheduled@@H_N@Z
_TEXT	SEGMENT
_O$ = 8							; size = 4
_RT$ = 12						; size = 4
_warn_on_not_found$ = 16				; size = 1
?internal_Unregister@CSheduler@@AAE_NPAVISheduled@@H_N@Z PROC ; CSheduler::internal_Unregister, COMDAT
; _this$ = ecx

; 115  : {

	push	ebx
	push	ebp
	push	esi
	push	edi

; 116  : 	//the object may be already dead
; 117  : 	//VERIFY	(!O->shedule.b_locked)	;
; 118  : 	if (RT)
; 119  : 	{
; 120  : 		for (u32 i=0; i<ItemsRT.size(); i++)

	xor	edi, edi
	cmp	DWORD PTR _RT$[esp+12], edi
	mov	esi, ecx
	mov	eax, 1717986919				; 66666667H
	je	$LN11@internal_U@2
	mov	ebp, DWORD PTR [esi+4]
	mov	ebx, DWORD PTR [esi]
	mov	ecx, ebp
	sub	ecx, ebx
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	je	SHORT $LN106@internal_U@2
	add	ebx, 12					; 0000000cH
$LL10@internal_U@2:

; 121  : 		{
; 122  : 			if (ItemsRT[i].Object==O) {

	mov	ecx, DWORD PTR _O$[esp+12]
	cmp	DWORD PTR [ebx], ecx
	je	SHORT $LN102@internal_U@2
	mov	ecx, ebp
	sub	ecx, DWORD PTR [esi]
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	edi, 1
	add	eax, edx
	add	ebx, 20					; 00000014H
	cmp	edi, eax
	jb	SHORT $LL10@internal_U@2
$LN106@internal_U@2:

; 139  : 			}
; 140  : 		}
; 141  : 	}
; 142  : 	if (m_current_step_obj == O)

	mov	edx, DWORD PTR _O$[esp+12]
	cmp	DWORD PTR [esi+48], edx
	jne	$LN1@internal_U@2
	pop	edi

; 143  : 	{
; 144  : #ifdef DEBUG_SCHEDULER
; 145  : 		Msg					("SCHEDULER: internal unregister (self unregistering) [%x][%s]",O,"false");
; 146  : #endif // DEBUG_SCHEDULER
; 147  : 
; 148  : 		m_current_step_obj = NULL;

	mov	DWORD PTR [esi+48], 0
	pop	esi
	pop	ebp

; 149  : 		return true;

	mov	al, 1
	pop	ebx

; 158  : }

	ret	12					; 0000000cH
$LN102@internal_U@2:

; 123  : #ifdef DEBUG_SCHEDULER
; 124  : 				Msg					("SCHEDULER: internal unregister [%s][%x][%s]","unknown",O,"true");
; 125  : #endif // DEBUG_SCHEDULER
; 126  : 				ItemsRT.erase(ItemsRT.begin()+i);

	mov	ecx, DWORD PTR [esi]
	lea	edx, DWORD PTR [edi+edi*4]
	lea	ecx, DWORD PTR [ecx+edx*4]
	lea	edx, DWORD PTR [ecx+20]
	cmp	edx, ebp
	je	SHORT $LN48@internal_U@2
	mov	eax, ebp
	call	??$__copy@PAUItem@CSheduler@@PAU12@H@priv@stlp_std@@YAPAUItem@CSheduler@@PAU23@00ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__copy<CSheduler::Item *,CSheduler::Item *,int>
$LN48@internal_U@2:
	add	DWORD PTR [esi+4], -20			; ffffffecH
	mov	esi, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN61@internal_U@2
	add	DWORD PTR [eax], -1
	mov	eax, DWORD PTR [esi+8]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN61@internal_U@2
	mov	DWORD PTR [esi+8], 0
$LN61@internal_U@2:
	pop	edi
	pop	esi
	pop	ebp

; 127  : 				return				(true);

	mov	al, 1
	pop	ebx

; 158  : }

	ret	12					; 0000000cH
$LN11@internal_U@2:

; 128  : 			}
; 129  : 		}
; 130  : 	} else {
; 131  : 		for (u32 i=0; i<Items.size(); i++)

	mov	ecx, DWORD PTR [esi+16]
	sub	ecx, DWORD PTR [esi+12]
	imul	ecx
	sar	edx, 3
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	je	SHORT $LN106@internal_U@2
	mov	ebp, DWORD PTR [esi+12]
	lea	ebx, DWORD PTR [ebp+12]
	npad	2
$LL5@internal_U@2:

; 132  : 		{
; 133  : 			if (Items[i].Object==O) {

	mov	edx, DWORD PTR _O$[esp+12]
	cmp	DWORD PTR [ebx], edx
	je	SHORT $LN103@internal_U@2
	mov	ecx, DWORD PTR [esi+16]
	sub	ecx, ebp
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	edi, 1
	add	eax, edx
	add	ebx, 20					; 00000014H
	cmp	edi, eax
	jb	SHORT $LL5@internal_U@2
	jmp	$LN106@internal_U@2
$LN103@internal_U@2:

; 134  : #ifdef DEBUG_SCHEDULER
; 135  : 				Msg					("SCHEDULER: internal unregister [%s][%x][%s]",*Items[i].scheduled_name,O,"false");
; 136  : #endif // DEBUG_SCHEDULER
; 137  : 				Items[i].Object	= NULL;

	lea	ecx, DWORD PTR [edi+edi*4]
	pop	edi
	pop	esi
	mov	DWORD PTR [ebp+ecx*4+12], 0
	pop	ebp

; 138  : 				return				(true);

	mov	al, 1
	pop	ebx

; 158  : }

	ret	12					; 0000000cH
$LN1@internal_U@2:
	pop	edi
	pop	esi
	pop	ebp

; 150  : 	}
; 151  : 
; 152  : #ifdef DEBUG
; 153  : 	if (warn_on_not_found)
; 154  : 		Msg							("! scheduled object %s tries to unregister but is not registered",*O->shedule_Name());
; 155  : #endif // DEBUG
; 156  : 
; 157  : 	return							(false);

	xor	al, al
	pop	ebx

; 158  : }

	ret	12					; 0000000cH
?internal_Unregister@CSheduler@@AAE_NPAVISheduled@@H_N@Z ENDP ; CSheduler::internal_Unregister
_TEXT	ENDS
PUBLIC	?internal_Register@CSheduler@@AAEXPAVISheduled@@H@Z ; CSheduler::internal_Register
; Function compile flags: /Ogtpy
;	COMDAT ?internal_Register@CSheduler@@AAEXPAVISheduled@@H@Z
_TEXT	SEGMENT
_TNext$118191 = -20					; size = 20
_TNext$118188 = -20					; size = 20
$T467473 = 8						; size = 4
$T467472 = 8						; size = 4
_O$ = 8							; size = 4
_RT$ = 12						; size = 4
?internal_Register@CSheduler@@AAEXPAVISheduled@@H@Z PROC ; CSheduler::internal_Register, COMDAT
; _this$ = ecx

; 87   : {

	sub	esp, 20					; 00000014H

; 88   : 	VERIFY	(!O->shedule.b_locked)	;
; 89   : 	if (RT)
; 90   : 	{
; 91   : 		// Fill item structure
; 92   : 		Item						TNext;
; 93   : 		TNext.dwTimeForExecute		= Device.dwTimeGlobal;

	mov	eax, DWORD PTR ?Device@@3VCRenderDevice@@A+40
	push	ebx
	push	esi
	push	edi

; 94   : 		TNext.dwTimeOfLastExecute	= Device.dwTimeGlobal;
; 95   : 		TNext.Object				= O;

	mov	edi, DWORD PTR _O$[esp+28]
	mov	ebx, ecx

; 96   : 		TNext.scheduled_name		= O->shedule_Name();

	lea	ecx, DWORD PTR $T467472[esp+28]
	mov	DWORD PTR _TNext$118188[esp+32], eax
	mov	DWORD PTR _TNext$118188[esp+36], eax
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR _TNext$118188[esp+48], edi
	call	edx
	cmp	DWORD PTR _RT$[esp+28], 0
	mov	esi, DWORD PTR [eax]
	je	SHORT $LN2@internal_R
	test	esi, esi
	je	SHORT $LN17@internal_R
	add	DWORD PTR [esi], 1
$LN17@internal_R:
	mov	eax, DWORD PTR $T467472[esp+28]
	test	eax, eax
	mov	DWORD PTR _TNext$118188[esp+40], esi
	je	SHORT $LN23@internal_R
	add	DWORD PTR [eax], -1
$LN23@internal_R:

; 97   : 		O->shedule.b_RT				= TRUE;

	or	DWORD PTR [edi+4], 268435456		; 10000000H

; 98   : 
; 99   : 		ItemsRT.push_back			(TNext);

	lea	ecx, DWORD PTR _TNext$118188[esp+32]
	mov	eax, ebx
	call	?push_back@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEXABUItem@CSheduler@@@Z ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::push_back

; 100  : 	} else {

	jmp	SHORT $LN87@internal_R
$LN2@internal_R:

; 101  : 		// Fill item structure
; 102  : 		Item						TNext;
; 103  : 		TNext.dwTimeForExecute		= Device.dwTimeGlobal;
; 104  : 		TNext.dwTimeOfLastExecute	= Device.dwTimeGlobal;
; 105  : 		TNext.Object				= O;
; 106  : 		TNext.scheduled_name		= O->shedule_Name();

	test	esi, esi
	je	SHORT $LN48@internal_R
	add	DWORD PTR [esi], 1
$LN48@internal_R:
	mov	eax, DWORD PTR $T467473[esp+28]
	test	eax, eax
	mov	DWORD PTR _TNext$118191[esp+40], esi
	je	SHORT $LN54@internal_R
	add	DWORD PTR [eax], -1
$LN54@internal_R:

; 107  : 		O->shedule.b_RT				= FALSE;

	and	DWORD PTR [edi+4], -268435457		; efffffffH

; 108  : 
; 109  : 		// Insert into priority Queue
; 110  : 		Push						(TNext);

	lea	edi, DWORD PTR [ebx+12]
	lea	ecx, DWORD PTR _TNext$118191[esp+32]
	mov	eax, edi
	call	?push_back@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEXABUItem@CSheduler@@@Z ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::push_back
	mov	ecx, DWORD PTR [ebx+16]
	mov	eax, DWORD PTR [edi]
	call	??$__push_heap_aux@PAUItem@CSheduler@@HU12@@stlp_std@@YAXPAUItem@CSheduler@@0PAH0@Z ; stlp_std::__push_heap_aux<CSheduler::Item *,int,CSheduler::Item>
$LN87@internal_R:

; 111  : 	}

	test	esi, esi
	je	SHORT $LN82@internal_R
	add	DWORD PTR [esi], -1
$LN82@internal_R:
	pop	edi
	pop	esi
	pop	ebx

; 112  : }

	add	esp, 20					; 00000014H
	ret	8
?internal_Register@CSheduler@@AAEXPAVISheduled@@H@Z ENDP ; CSheduler::internal_Register
_TEXT	ENDS
PUBLIC	?internal_Registration@CSheduler@@AAEXXZ	; CSheduler::internal_Registration
; Function compile flags: /Ogtpy
;	COMDAT ?internal_Registration@CSheduler@@AAEXXZ
_TEXT	SEGMENT
tv459 = -8						; size = 4
tv457 = -4						; size = 4
?internal_Registration@CSheduler@@AAEXXZ PROC		; CSheduler::internal_Registration, COMDAT
; _this$ = ecx

; 48   : {

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 49   : 	for (u32 it=0; it<Registration.size(); it++)

	mov	ecx, DWORD PTR [esi+40]
	sub	ecx, DWORD PTR [esi+36]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	push	edi
	je	$LN8@internal_R@2
	push	ebx
	mov	edi, 1
	xor	ebx, ebx
	push	ebp
	mov	DWORD PTR tv457[esp+24], edi
	mov	DWORD PTR tv459[esp+24], ebx
	npad	12
$LL101@internal_R@2:

; 50   : 	{
; 51   : 		ItemReg&	R	= Registration	[it];

	mov	ebp, DWORD PTR [esi+36]

; 52   : 		if (R.OP)	{

	cmp	DWORD PTR [ebx+ebp], 0
	je	$LN7@internal_R@2

; 53   : 			// register
; 54   : 			// search for paired "unregister"
; 55   : 			BOOL	bFoundAndErased		= FALSE;
; 56   : 			for (u32 pair=it+1; pair<Registration.size(); pair++)

	mov	ecx, DWORD PTR [esi+40]
	sub	ecx, ebp
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	cmp	edi, ecx
	jae	SHORT $LN100@internal_R@2
	lea	ebx, DWORD PTR [ebx+ebp+12]
	npad	6
$LL6@internal_R@2:

; 57   : 			{
; 58   : 				ItemReg&	R_pair	= Registration	[pair];
; 59   : 				if	((!R_pair.OP)&&(R_pair.Object == R.Object))	{

	cmp	DWORD PTR [ebx], 0
	jne	SHORT $LN5@internal_R@2
	mov	edx, DWORD PTR [ebx+8]
	mov	eax, DWORD PTR tv459[esp+24]
	cmp	edx, DWORD PTR [eax+ebp+8]
	je	SHORT $LN97@internal_R@2
$LN5@internal_R@2:

; 53   : 			// register
; 54   : 			// search for paired "unregister"
; 55   : 			BOOL	bFoundAndErased		= FALSE;
; 56   : 			for (u32 pair=it+1; pair<Registration.size(); pair++)

	mov	ecx, DWORD PTR [esi+40]
	sub	ecx, ebp
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	edi, 1
	add	ecx, edx
	add	ebx, 12					; 0000000cH
	cmp	edi, ecx
	jb	SHORT $LL6@internal_R@2

; 57   : 			{
; 58   : 				ItemReg&	R_pair	= Registration	[pair];
; 59   : 				if	((!R_pair.OP)&&(R_pair.Object == R.Object))	{

	mov	edi, DWORD PTR tv457[esp+24]
	mov	ebx, DWORD PTR tv459[esp+24]
$LN100@internal_R@2:

; 68   : #ifdef DEBUG_SCHEDULER
; 69   : 				Msg						("SCHEDULER: internal register [%s][%x][%s]",*R.Object->shedule_Name(),R.Object,R.RT ? "true" : "false");
; 70   : #endif // DEBUG_SCHEDULER
; 71   : 				internal_Register		(R.Object,R.RT);

	mov	eax, DWORD PTR [ebx+ebp+4]
	mov	ecx, DWORD PTR [ebx+ebp+8]
	push	eax
	push	ecx
	mov	ecx, esi
	call	?internal_Register@CSheduler@@AAEXPAVISheduled@@H@Z ; CSheduler::internal_Register

; 72   : 			}
; 73   : #ifdef DEBUG_SCHEDULER
; 74   : 			else 
; 75   : 				Msg						("SCHEDULER: internal register skipped, because unregister found [%s][%x][%s]","unknown",R.Object,R.RT ? "true" : "false");
; 76   : #endif // DEBUG_SCHEDULER
; 77   : 		}
; 78   : 		else		{

	jmp	SHORT $LN9@internal_R@2
$LN97@internal_R@2:

; 60   : 					bFoundAndErased		= TRUE;
; 61   : 					Registration.erase	(Registration.begin()+pair	);

	mov	eax, DWORD PTR [esi+40]
	lea	edx, DWORD PTR [edi+edi*2]
	lea	edx, DWORD PTR [ebp+edx*4]
	lea	ecx, DWORD PTR [edx+12]
	cmp	ecx, eax
	je	SHORT $LN68@internal_R@2
	sub	eax, ecx
	je	SHORT $LN68@internal_R@2
	push	eax
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
$LN68@internal_R@2:
	add	DWORD PTR [esi+40], -12			; fffffff4H

; 62   : 					break				;
; 63   : 				}
; 64   : 			}
; 65   : 
; 66   : 			// register if non-paired
; 67   : 			if (!bFoundAndErased)		{

	mov	edi, DWORD PTR tv457[esp+24]
	mov	ebx, DWORD PTR tv459[esp+24]
	jmp	SHORT $LN9@internal_R@2
$LN7@internal_R@2:

; 79   : 			// unregister
; 80   : 			internal_Unregister			(R.Object,R.RT);

	mov	edx, DWORD PTR [ebx+ebp+4]
	mov	eax, DWORD PTR [ebx+ebp+8]
	push	1
	push	edx
	push	eax
	mov	ecx, esi
	call	?internal_Unregister@CSheduler@@AAE_NPAVISheduled@@H_N@Z ; CSheduler::internal_Unregister
$LN9@internal_R@2:
	mov	ecx, DWORD PTR [esi+40]
	sub	ecx, DWORD PTR [esi+36]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	ecx, edx
	add	edi, 1
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	ebx, 12					; 0000000cH
	lea	edx, DWORD PTR [edi-1]
	cmp	edx, ecx
	mov	DWORD PTR tv459[esp+24], ebx
	mov	DWORD PTR tv457[esp+24], edi
	jb	$LL101@internal_R@2
	pop	ebp
	pop	ebx
$LN8@internal_R@2:

; 81   : 		}
; 82   : 	}
; 83   : 	Registration.clear	();

	mov	ecx, DWORD PTR [esi+40]
	mov	eax, DWORD PTR [esi+36]
	cmp	eax, ecx
	je	SHORT $LN87@internal_R@2
	mov	edi, ecx
	sub	edi, ecx
	je	SHORT $LN93@internal_R@2
	push	edi
	push	ecx
	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	add	eax, edi
$LN93@internal_R@2:
	mov	DWORD PTR [esi+40], eax
$LN87@internal_R@2:
	pop	edi
	pop	esi

; 84   : }

	add	esp, 8
	ret	0
?internal_Registration@CSheduler@@AAEXXZ ENDP		; CSheduler::internal_Registration
_TEXT	ENDS
PUBLIC	?Destroy@CSheduler@@QAEXXZ			; CSheduler::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@CSheduler@@QAEXXZ
_TEXT	SEGMENT
?Destroy@CSheduler@@QAEXXZ PROC				; CSheduler::Destroy, COMDAT
; _this$ = ecx

; 20   : {

	push	esi
	push	edi
	mov	esi, ecx

; 21   : 	internal_Registration		();

	call	?internal_Registration@CSheduler@@AAEXXZ ; CSheduler::internal_Registration

; 22   : 
; 23   : 	for (u32 it=0; it<Items.size(); it++)

	mov	ecx, DWORD PTR [esi+16]
	sub	ecx, DWORD PTR [esi+12]
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	xor	edi, edi
	add	eax, edx
	je	SHORT $LN2@Destroy@12
	push	ebx
	xor	ebx, ebx
$LL4@Destroy@12:

; 24   : 	{
; 25   : 		if (0==Items[it].Object)	

	mov	ecx, DWORD PTR [esi+12]
	add	ecx, ebx
	cmp	DWORD PTR [ecx+12], 0
	jne	SHORT $LN3@Destroy@12

; 26   : 		{
; 27   : 			Items.erase(Items.begin()+it);

	mov	eax, DWORD PTR [esi+16]
	lea	edx, DWORD PTR [ecx+20]
	cmp	edx, eax
	je	SHORT $LN41@Destroy@12
	call	??$__copy@PAUItem@CSheduler@@PAU12@H@priv@stlp_std@@YAPAUItem@CSheduler@@PAU23@00ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__copy<CSheduler::Item *,CSheduler::Item *,int>
$LN41@Destroy@12:
	add	DWORD PTR [esi+16], -20			; ffffffecH
	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN54@Destroy@12
	add	DWORD PTR [eax], -1
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN54@Destroy@12
	mov	DWORD PTR [ecx+8], 0
$LN54@Destroy@12:

; 28   : 			it	--;

	sub	edi, 1
	sub	ebx, 20					; 00000014H
$LN3@Destroy@12:
	mov	ecx, DWORD PTR [esi+16]
	sub	ecx, DWORD PTR [esi+12]
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	edi, 1
	add	eax, edx
	add	ebx, 20					; 00000014H
	cmp	edi, eax
	jb	SHORT $LL4@Destroy@12
	pop	ebx
$LN2@Destroy@12:

; 29   : 		}
; 30   : 	}
; 31   : #ifdef DEBUG	
; 32   : 	if (!Items.empty())
; 33   : 	{
; 34   : 		string1024		_objects; _objects[0]=0;
; 35   : 
; 36   : 		Msg				("! Sheduler work-list is not empty");
; 37   : 		for (u32 it=0; it<Items.size(); it++)
; 38   : 			Msg("%s",*Items[it].Object->shedule_Name().c_str());
; 39   : 	}
; 40   : #endif // DEBUG
; 41   : 	ItemsRT.clear		();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	cmp	ecx, eax
	je	SHORT $LN236@Destroy@12
	mov	edx, eax
	call	??$__copy@PAUItem@CSheduler@@PAU12@H@priv@stlp_std@@YAPAUItem@CSheduler@@PAU23@00ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__copy<CSheduler::Item *,CSheduler::Item *,int>
	mov	edi, DWORD PTR [esi+4]
	cmp	eax, edi
	je	SHORT $LN235@Destroy@12
	lea	ecx, DWORD PTR [eax+8]
$LL90@Destroy@12:
	mov	edx, DWORD PTR [ecx]
	test	edx, edx
	je	SHORT $LN102@Destroy@12
	add	DWORD PTR [edx], -1
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN102@Destroy@12
	mov	DWORD PTR [ecx], 0
$LN102@Destroy@12:
	add	ecx, 20					; 00000014H
	lea	edx, DWORD PTR [ecx-8]
	cmp	edx, edi
	jne	SHORT $LL90@Destroy@12
$LN235@Destroy@12:
	mov	DWORD PTR [esi+4], eax
$LN236@Destroy@12:

; 42   : 	Items.clear			();

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [esi+12]
	cmp	ecx, eax
	je	SHORT $LN238@Destroy@12
	mov	edx, eax
	call	??$__copy@PAUItem@CSheduler@@PAU12@H@priv@stlp_std@@YAPAUItem@CSheduler@@PAU23@00ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__copy<CSheduler::Item *,CSheduler::Item *,int>
	mov	edi, DWORD PTR [esi+16]
	cmp	eax, edi
	je	SHORT $LN237@Destroy@12
	lea	ecx, DWORD PTR [eax+8]
$LL136@Destroy@12:
	mov	edx, DWORD PTR [ecx]
	test	edx, edx
	je	SHORT $LN148@Destroy@12
	add	DWORD PTR [edx], -1
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN148@Destroy@12
	mov	DWORD PTR [ecx], 0
$LN148@Destroy@12:
	add	ecx, 20					; 00000014H
	lea	edx, DWORD PTR [ecx-8]
	cmp	edx, edi
	jne	SHORT $LL136@Destroy@12
$LN237@Destroy@12:
	mov	DWORD PTR [esi+16], eax
$LN238@Destroy@12:

; 43   : 	ItemsProcessed.clear();

	mov	eax, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR [esi+24]
	cmp	ecx, eax
	je	SHORT $LN172@Destroy@12
	mov	edx, eax
	call	??$__copy@PAUItem@CSheduler@@PAU12@H@priv@stlp_std@@YAPAUItem@CSheduler@@PAU23@00ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__copy<CSheduler::Item *,CSheduler::Item *,int>
	mov	edi, DWORD PTR [esi+28]
	cmp	eax, edi
	je	SHORT $LN180@Destroy@12
	lea	ecx, DWORD PTR [eax+8]
	npad	1
$LL182@Destroy@12:
	mov	edx, DWORD PTR [ecx]
	test	edx, edx
	je	SHORT $LN194@Destroy@12
	add	DWORD PTR [edx], -1
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN194@Destroy@12
	mov	DWORD PTR [ecx], 0
$LN194@Destroy@12:
	add	ecx, 20					; 00000014H
	lea	edx, DWORD PTR [ecx-8]
	cmp	edx, edi
	jne	SHORT $LL182@Destroy@12
$LN180@Destroy@12:
	mov	DWORD PTR [esi+28], eax
$LN172@Destroy@12:

; 44   : 	Registration.clear	();

	mov	ecx, DWORD PTR [esi+40]
	mov	eax, DWORD PTR [esi+36]
	cmp	eax, ecx
	je	SHORT $LN218@Destroy@12
	mov	edi, ecx
	sub	edi, ecx
	je	SHORT $LN224@Destroy@12
	push	edi
	push	ecx
	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	add	eax, edi
$LN224@Destroy@12:
	mov	DWORD PTR [esi+40], eax
$LN218@Destroy@12:
	pop	edi
	pop	esi

; 45   : }

	ret	0
?Destroy@CSheduler@@QAEXXZ ENDP				; CSheduler::Destroy
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_heap.c
;	COMDAT ??$__adjust_heap@PAUItem@CSheduler@@HU12@@stlp_std@@YAXPAUItem@CSheduler@@HHU12@@Z
_TEXT	SEGMENT
___len$ = 8						; size = 4
___val$ = 12						; size = 20
??$__adjust_heap@PAUItem@CSheduler@@HU12@@stlp_std@@YAXPAUItem@CSheduler@@HHU12@@Z PROC ; stlp_std::__adjust_heap<CSheduler::Item *,int,CSheduler::Item>, COMDAT
; ___first$ = eax

; 112  :               _Distance __len, _Tp __val) {

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR ___len$[esp+4]
	mov	ebx, eax

; 113  :   _Distance __topIndex = __holeIndex;
; 114  :   _Distance __secondChild = 2 * __holeIndex + 2;

	mov	eax, 2
	push	esi
	xor	ecx, ecx

; 115  :   while (__secondChild < __len) {

	cmp	eax, ebp
	push	edi
	jge	SHORT $LN58@adjust_hea@6
$LL4@adjust_hea@6:

; 116  :     if (*(__first + __secondChild) < *(__first + (__secondChild - 1)))

	lea	edx, DWORD PTR [eax+eax*4]
	mov	esi, DWORD PTR [ebx+edx*4]
	cmp	esi, DWORD PTR [ebx+edx*4-20]
	lea	edx, DWORD PTR [ebx+edx*4]
	jbe	SHORT $LN53@adjust_hea@6

; 117  :       __secondChild--;

	sub	eax, 1
$LN53@adjust_hea@6:

; 118  :     *(__first + __holeIndex) = *(__first + __secondChild);

	lea	edx, DWORD PTR [eax+eax*4]
	mov	esi, DWORD PTR [ebx+edx*4]
	lea	edx, DWORD PTR [ebx+edx*4]
	lea	ecx, DWORD PTR [ecx+ecx*4]
	lea	ecx, DWORD PTR [ebx+ecx*4]
	mov	DWORD PTR [ecx], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], esi
	mov	esi, DWORD PTR [edx+8]
	test	esi, esi
	je	SHORT $LN13@adjust_hea@6
	add	DWORD PTR [esi], 1
$LN13@adjust_hea@6:
	mov	edi, DWORD PTR [ecx+8]
	test	edi, edi
	je	SHORT $LN16@adjust_hea@6
	add	DWORD PTR [edi], -1
	mov	edi, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edi], 0
	jne	SHORT $LN16@adjust_hea@6
	mov	DWORD PTR [ecx+8], 0
$LN16@adjust_hea@6:
	mov	DWORD PTR [ecx+8], esi
	mov	esi, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], esi
	mov	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], edx

; 119  :     __holeIndex = __secondChild;

	mov	ecx, eax

; 120  :     __secondChild = 2 * (__secondChild + 1);

	lea	eax, DWORD PTR [eax+eax+2]
	cmp	eax, ebp
	jl	SHORT $LL4@adjust_hea@6
$LN58@adjust_hea@6:

; 121  :   }
; 122  :   if (__secondChild == __len) {

	jne	SHORT $LN56@adjust_hea@6

; 123  :     *(__first + __holeIndex) = *(__first + (__secondChild - 1));

	lea	edx, DWORD PTR [eax+eax*4]
	mov	esi, DWORD PTR [ebx+edx*4-20]
	lea	edx, DWORD PTR [ebx+edx*4-20]
	lea	ecx, DWORD PTR [ecx+ecx*4]
	lea	ecx, DWORD PTR [ebx+ecx*4]
	mov	DWORD PTR [ecx], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], esi
	mov	esi, DWORD PTR [edx+8]
	test	esi, esi
	je	SHORT $LN54@adjust_hea@6
	add	DWORD PTR [esi], 1
$LN54@adjust_hea@6:
	mov	edi, DWORD PTR [ecx+8]
	test	edi, edi
	je	SHORT $LN55@adjust_hea@6
	add	DWORD PTR [edi], -1
	mov	edi, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edi], 0
	jne	SHORT $LN55@adjust_hea@6
	mov	DWORD PTR [ecx+8], 0
$LN55@adjust_hea@6:
	mov	DWORD PTR [ecx+8], esi
	mov	esi, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], esi
	mov	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], edx

; 124  :     __holeIndex = __secondChild - 1;

	lea	ecx, DWORD PTR [eax-1]
$LN56@adjust_hea@6:

; 125  :   }
; 126  :   __push_heap(__first, __holeIndex, __topIndex, __val);

	mov	edx, DWORD PTR ___val$[esp+12]
	mov	esi, DWORD PTR ___val$[esp+20]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR ___val$[esp+36]
	xor	edi, edi
	cmp	esi, edi
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], edi
	je	SHORT $LN35@adjust_hea@6
	add	DWORD PTR [esi], 1
$LN35@adjust_hea@6:
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, edi
	je	SHORT $LN57@adjust_hea@6
	add	DWORD PTR [edx], -1
	mov	edx, DWORD PTR [eax+8]
	cmp	DWORD PTR [edx], edi
	jne	SHORT $LN57@adjust_hea@6
	mov	DWORD PTR [eax+8], edi
$LN57@adjust_hea@6:
	mov	edx, DWORD PTR ___val$[esp+44]
	mov	DWORD PTR [eax+8], esi
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR ___val$[esp+48]
	mov	DWORD PTR [eax+16], edx
	call	??$__push_heap@PAUItem@CSheduler@@HU12@@stlp_std@@YAXPAUItem@CSheduler@@HHU12@@Z ; stlp_std::__push_heap<CSheduler::Item *,int,CSheduler::Item>
	add	esp, 20					; 00000014H

; 127  : }

	cmp	esi, edi
	je	SHORT $LN46@adjust_hea@6
	add	DWORD PTR [esi], -1
$LN46@adjust_hea@6:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
??$__adjust_heap@PAUItem@CSheduler@@HU12@@stlp_std@@YAXPAUItem@CSheduler@@HHU12@@Z ENDP ; stlp_std::__adjust_heap<CSheduler::Item *,int,CSheduler::Item>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_heap.h
_TEXT	ENDS
;	COMDAT ??$__pop_heap@PAUItem@CSheduler@@U12@H@stlp_std@@YAXPAUItem@CSheduler@@00U12@PAH@Z
_TEXT	SEGMENT
___val$ = 8						; size = 20
??$__pop_heap@PAUItem@CSheduler@@U12@H@stlp_std@@YAXPAUItem@CSheduler@@00U12@PAH@Z PROC ; stlp_std::__pop_heap<CSheduler::Item *,CSheduler::Item,int>, COMDAT
; ___first$ = ecx
; ___last$ = edx
; ___result$ = eax

; 56   : {

	push	esi
	push	edi
	mov	edi, edx

; 57   :   *__result = *__first;

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	test	edx, edx
	je	SHORT $LN7@pop_heap
	add	DWORD PTR [edx], 1
$LN7@pop_heap:
	mov	esi, DWORD PTR [eax+8]
	test	esi, esi
	je	SHORT $LN10@pop_heap
	add	DWORD PTR [esi], -1
	mov	esi, DWORD PTR [eax+8]
	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN10@pop_heap
	mov	DWORD PTR [eax+8], 0
$LN10@pop_heap:

; 58   :   __adjust_heap(__first, _Distance(0), _Distance(__last - __first), __val);

	mov	esi, DWORD PTR ___val$[esp+12]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	edx, DWORD PTR ___val$[esp+4]
	sub	esp, 20					; 00000014H
	test	esi, esi
	mov	eax, esp
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR ___val$[esp+28]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], 0
	je	SHORT $LN18@pop_heap
	add	DWORD PTR [esi], 1
$LN18@pop_heap:
	mov	edx, DWORD PTR [eax+8]
	test	edx, edx
	je	SHORT $LN21@pop_heap
	add	DWORD PTR [edx], -1
	mov	edx, DWORD PTR [eax+8]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN21@pop_heap
	mov	DWORD PTR [eax+8], 0
$LN21@pop_heap:
	mov	edx, DWORD PTR ___val$[esp+36]
	mov	DWORD PTR [eax+8], esi
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR ___val$[esp+40]
	mov	DWORD PTR [eax+16], edx
	sub	edi, ecx
	mov	edx, edi
	mov	eax, 1717986919				; 66666667H
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	push	eax
	mov	eax, ecx
	call	??$__adjust_heap@PAUItem@CSheduler@@HU12@@stlp_std@@YAXPAUItem@CSheduler@@HHU12@@Z ; stlp_std::__adjust_heap<CSheduler::Item *,int,CSheduler::Item>
	add	esp, 24					; 00000018H

; 59   : }

	test	esi, esi
	je	SHORT $LN29@pop_heap
	add	DWORD PTR [esi], -1
$LN29@pop_heap:
	pop	edi
	pop	esi
	ret	0
??$__pop_heap@PAUItem@CSheduler@@U12@H@stlp_std@@YAXPAUItem@CSheduler@@00U12@PAH@Z ENDP ; stlp_std::__pop_heap<CSheduler::Item *,CSheduler::Item,int>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_heap.c
_TEXT	ENDS
;	COMDAT ??$__pop_heap_aux@PAUItem@CSheduler@@U12@@stlp_std@@YAXPAUItem@CSheduler@@00@Z
_TEXT	SEGMENT
___first$ = 8						; size = 4
??$__pop_heap_aux@PAUItem@CSheduler@@U12@@stlp_std@@YAXPAUItem@CSheduler@@00@Z PROC ; stlp_std::__pop_heap_aux<CSheduler::Item *,CSheduler::Item>, COMDAT
; ___last$ = eax

; 133  :   __pop_heap(__first, __last - 1, __last - 1,
; 134  :              _Tp(*(__last - 1)), _STLP_DISTANCE_TYPE(__first, _RandomAccessIterator));

	mov	edx, DWORD PTR [eax-20]
	add	eax, -20				; ffffffecH
	push	esi
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR [eax+8]
	test	edx, edx
	je	SHORT $LN7@pop_heap_a
	add	DWORD PTR [edx], 1
$LN7@pop_heap_a:
	mov	esi, DWORD PTR [ecx+8]
	test	esi, esi
	je	SHORT $LN10@pop_heap_a
	add	DWORD PTR [esi], -1
	mov	esi, DWORD PTR [ecx+8]
	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN10@pop_heap_a
	mov	DWORD PTR [ecx+8], 0
$LN10@pop_heap_a:
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], edx
	mov	ecx, DWORD PTR ___first$[esp+20]
	mov	edx, eax
	call	??$__pop_heap@PAUItem@CSheduler@@U12@H@stlp_std@@YAXPAUItem@CSheduler@@00U12@PAH@Z ; stlp_std::__pop_heap<CSheduler::Item *,CSheduler::Item,int>
	add	esp, 20					; 00000014H

; 135  : }

	pop	esi
	ret	0
??$__pop_heap_aux@PAUItem@CSheduler@@U12@@stlp_std@@YAXPAUItem@CSheduler@@00@Z ENDP ; stlp_std::__pop_heap_aux<CSheduler::Item *,CSheduler::Item>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$pop_heap@PAUItem@CSheduler@@@stlp_std@@YAXPAUItem@CSheduler@@0@Z
_TEXT	SEGMENT
___last$ = 8						; size = 4
??$pop_heap@PAUItem@CSheduler@@@stlp_std@@YAXPAUItem@CSheduler@@0@Z PROC ; stlp_std::pop_heap<CSheduler::Item *>, COMDAT
; ___first$ = eax

; 140  :   __pop_heap_aux(__first, __last, _STLP_VALUE_TYPE(__first, _RandomAccessIterator));

	push	eax
	mov	eax, DWORD PTR ___last$[esp]
	call	??$__pop_heap_aux@PAUItem@CSheduler@@U12@@stlp_std@@YAXPAUItem@CSheduler@@00@Z ; stlp_std::__pop_heap_aux<CSheduler::Item *,CSheduler::Item>
	pop	ecx

; 141  : }

	ret	0
??$pop_heap@PAUItem@CSheduler@@@stlp_std@@YAXPAUItem@CSheduler@@0@Z ENDP ; stlp_std::pop_heap<CSheduler::Item *>
_TEXT	ENDS
PUBLIC	?Pop@CSheduler@@AAEXXZ				; CSheduler::Pop
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\xrsheduler.cpp
;	COMDAT ?Pop@CSheduler@@AAEXXZ
_TEXT	SEGMENT
?Pop@CSheduler@@AAEXXZ PROC				; CSheduler::Pop, COMDAT
; _this$ = ecx

; 289  : {

	push	esi
	mov	esi, ecx

; 290  : 	std::pop_heap	(Items.begin(), Items.end());

	mov	eax, DWORD PTR [esi+12]
	push	eax
	mov	eax, DWORD PTR [esi+16]
	call	??$__pop_heap_aux@PAUItem@CSheduler@@U12@@stlp_std@@YAXPAUItem@CSheduler@@00@Z ; stlp_std::__pop_heap_aux<CSheduler::Item *,CSheduler::Item>

; 291  : 	Items.pop_back	();

	add	DWORD PTR [esi+16], -20			; ffffffecH
	mov	esi, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [esi+8]
	add	esp, 4
	test	eax, eax
	je	SHORT $LN32@Pop
	add	DWORD PTR [eax], -1
	mov	ecx, DWORD PTR [esi+8]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN32@Pop
	mov	DWORD PTR [esi+8], 0
$LN32@Pop:
	pop	esi

; 292  : }

	ret	0
?Pop@CSheduler@@AAEXXZ ENDP				; CSheduler::Pop
_TEXT	ENDS
PUBLIC	?Unregister@CSheduler@@QAEXPAVISheduled@@@Z	; CSheduler::Unregister
; Function compile flags: /Ogtpy
;	COMDAT ?Unregister@CSheduler@@QAEXPAVISheduled@@@Z
_TEXT	SEGMENT
_R$ = -12						; size = 12
_A$ = 8							; size = 4
?Unregister@CSheduler@@QAEXPAVISheduled@@@Z PROC	; CSheduler::Unregister, COMDAT
; _this$ = ecx

; 246  : {

	sub	esp, 12					; 0000000cH
	push	esi

; 247  : 	VERIFY		(Registered(A));
; 248  : 
; 249  : #ifdef DEBUG_SCHEDULER
; 250  : 	Msg			("SCHEDULER: unregister [%s][%x]",*A->shedule_Name(),A);
; 251  : #endif // DEBUG_SCHEDULER
; 252  : 
; 253  : 	if (m_processing_now) {

	mov	esi, DWORD PTR _A$[esp+12]
	push	edi
	mov	edi, ecx
	cmp	BYTE PTR [edi+52], 0
	je	SHORT $LN1@Unregister

; 254  : 		if (internal_Unregister(A,A->shedule.b_RT,false))

	mov	eax, DWORD PTR [esi+4]
	shr	eax, 28					; 0000001cH
	push	0
	and	eax, 1
	push	eax
	push	esi
	call	?internal_Unregister@CSheduler@@AAE_NPAVISheduled@@H_N@Z ; CSheduler::internal_Unregister
	test	al, al
	jne	SHORT $LN12@Unregister
$LN1@Unregister:

; 255  : 			return;
; 256  : 	}
; 257  : 
; 258  : 	ItemReg		R;
; 259  : 	R.OP		= FALSE				;
; 260  : 	R.RT		= A->shedule.b_RT	;

	mov	ecx, DWORD PTR [esi+4]

; 261  : 	R.Object	= A					;
; 262  : 
; 263  : 	Registration.push_back			(R);

	mov	eax, DWORD PTR [edi+40]
	add	edi, 36					; 00000024H
	shr	ecx, 28					; 0000001cH
	xor	edx, edx
	and	ecx, 1
	cmp	eax, DWORD PTR [edi+8]
	mov	DWORD PTR _R$[esp+20], edx
	mov	DWORD PTR _R$[esp+24], ecx
	mov	DWORD PTR _R$[esp+28], esi
	je	SHORT $LN13@Unregister
	test	eax, eax
	je	SHORT $LN18@Unregister
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], esi
$LN18@Unregister:
	add	DWORD PTR [edi+4], 12			; 0000000cH
	pop	edi
	pop	esi

; 264  : }

	add	esp, 12					; 0000000cH
	ret	4

; 261  : 	R.Object	= A					;
; 262  : 
; 263  : 	Registration.push_back			(R);

$LN13@Unregister:
	lea	ecx, DWORD PTR _R$[esp+20]
	push	ecx
	call	?_M_insert_overflow@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@AAEXPAUItemReg@CSheduler@@ABU45@ABU__true_type@3@I_N@Z ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::_M_insert_overflow
$LN12@Unregister:
	pop	edi
	pop	esi

; 264  : }

	add	esp, 12					; 0000000cH
	ret	4
?Unregister@CSheduler@@QAEXPAVISheduled@@@Z ENDP	; CSheduler::Unregister
PUBLIC	?ProcessStep@CSheduler@@QAEXXZ			; CSheduler::ProcessStep
; Function compile flags: /Ogtpy
;	COMDAT ?ProcessStep@CSheduler@@QAEXXZ
_TEXT	SEGMENT
_this$ = -108						; size = 4
_v$536720 = -104					; size = 4
_dwTime$ = -100						; size = 4
$T536575 = -96						; size = 4
_i$118274 = -92						; size = 4
_a$537190 = -88						; size = 4
_Elapsed$118280 = -84					; size = 4
tv1332 = -80						; size = 4
_TNext$118308 = -76					; size = 20
_eTimer$ = -56						; size = 56
?ProcessStep@CSheduler@@QAEXXZ PROC			; CSheduler::ProcessStep, COMDAT
; _this$ = ecx

; 295  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 112				; 00000070H

; 296  : 	// Normal priority
; 297  : 	u32		dwTime					= Device.dwTimeGlobal;

	mov	eax, DWORD PTR ?Device@@3VCRenderDevice@@A+40
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 298  : 	CTimer							eTimer;

	lea	ecx, DWORD PTR _eTimer$[esp+128]
	mov	DWORD PTR _this$[esp+128], edi
	mov	DWORD PTR _dwTime$[esp+128], eax
	call	DWORD PTR __imp_??0CTimer@@QAE@XZ

; 299  : 	for (int i=0;!Items.empty() && Top().dwTimeForExecute < dwTime; ++i) {

	mov	ecx, DWORD PTR [edi+12]
	cmp	ecx, DWORD PTR [edi+16]
	lea	esi, DWORD PTR [edi+12]
	mov	DWORD PTR _i$118274[esp+128], 0
	je	$LN235@ProcessSte
$LN9@ProcessSte:
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR _dwTime$[esp+128]
	cmp	DWORD PTR [eax], edx
	jae	$LN235@ProcessSte

; 300  : 		u32		delta_ms			= dwTime - Top().dwTimeForExecute;
; 301  : 
; 302  : 		// Update
; 303  : 		Item	T					= Top	();

	mov	ebp, DWORD PTR [eax+8]
	test	ebp, ebp
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _v$536720[esp+128], ebp
	je	SHORT $LN56@ProcessSte
	add	DWORD PTR [ebp], 1
$LN56@ProcessSte:
	mov	ebx, DWORD PTR [eax+12]

; 304  : #ifdef DEBUG_SCHEDULER
; 305  : 		Msg		("SCHEDULER: process step [%s][%x][false]",*T.scheduled_name,T.Object);
; 306  : #endif // DEBUG_SCHEDULER
; 307  : 		u32		Elapsed				= dwTime-T.dwTimeOfLastExecute;

	mov	eax, edx
	sub	eax, ecx

; 308  : 		bool	condition;
; 309  : 		
; 310  : 		condition					= (NULL==T.Object || !T.Object->shedule_Needed());

	test	ebx, ebx
	mov	DWORD PTR _Elapsed$118280[esp+128], eax
	je	SHORT $LN12@ProcessSte
	mov	eax, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax+16]
	mov	ecx, ebx
	call	edx
	test	al, al
	jne	SHORT $LN6@ProcessSte
$LN12@ProcessSte:

; 311  : 		if (condition) {
; 312  : 			// Erase element
; 313  : #ifdef DEBUG_SCHEDULER
; 314  : 			Msg						("SCHEDULER: process unregister [%s][%x][%s]",*T.scheduled_name,T.Object,"false");
; 315  : #endif // DEBUG_SCHEDULER
; 316  : //			if (T.Object)
; 317  : //				Msg					("0x%08x UNREGISTERS because shedule_Needed() returned false",T.Object);
; 318  : //			else
; 319  : //				Msg					("UNREGISTERS unknown object");
; 320  : 			Pop						();

	mov	eax, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR [edi+16]
	call	??$__pop_heap_aux@PAUItem@CSheduler@@U12@@stlp_std@@YAXPAUItem@CSheduler@@00@Z ; stlp_std::__pop_heap_aux<CSheduler::Item *,CSheduler::Item>
	add	DWORD PTR [esi+4], -20			; ffffffecH
	mov	esi, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi+8]
	add	esp, 4
	test	eax, eax
	je	SHORT $LN94@ProcessSte
	add	DWORD PTR [eax], -1
	mov	ecx, DWORD PTR [esi+8]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN94@ProcessSte
	mov	DWORD PTR [esi+8], 0
$LN94@ProcessSte:

; 321  : 			continue;

	test	ebp, ebp
	je	$LN8@ProcessSte
	add	DWORD PTR [ebp], -1
	jmp	$LN8@ProcessSte
$LN6@ProcessSte:

; 322  : 		}
; 323  : 
; 324  : 		// Insert into priority Queue
; 325  : 		Pop							();

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edi+16]
	push	edx
	call	??$__pop_heap_aux@PAUItem@CSheduler@@U12@@stlp_std@@YAXPAUItem@CSheduler@@00@Z ; stlp_std::__pop_heap_aux<CSheduler::Item *,CSheduler::Item>
	add	DWORD PTR [esi+4], -20			; ffffffecH
	mov	esi, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi+8]
	add	esp, 4
	test	eax, eax
	je	SHORT $LN142@ProcessSte
	add	DWORD PTR [eax], -1
	mov	eax, DWORD PTR [esi+8]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN142@ProcessSte
	mov	DWORD PTR [esi+8], 0
$LN142@ProcessSte:

; 326  : 
; 327  : 		// Real update call
; 328  : 		// Msg						("------- %d:",Device.dwFrame);
; 329  : #ifdef DEBUG
; 330  : 		T.Object->dbg_startframe	= Device.dwFrame;
; 331  : 		eTimer.Start				();
; 332  : //		LPCSTR		_obj_name		= T.Object->shedule_Name().c_str();
; 333  : #endif // DEBUG
; 334  : 
; 335  : 		// Calc next update interval
; 336  : 		u32		dwMin				= _max(u32(30),T.Object->shedule.t_min);

	mov	eax, DWORD PTR [ebx+4]
	mov	esi, eax
	and	esi, 16383				; 00003fffH
	cmp	esi, 30					; 0000001eH
	jae	SHORT $LN153@ProcessSte
	mov	esi, 30					; 0000001eH
$LN153@ProcessSte:

; 337  : 		u32		dwMax				= (1000+T.Object->shedule.t_max)/2;
; 338  : 		float	scale				= T.Object->shedule_Scale	(); 

	mov	edx, DWORD PTR [ebx]
	shr	eax, 14					; 0000000eH
	and	eax, 16383				; 00003fffH
	add	eax, 1000				; 000003e8H
	shr	eax, 1
	mov	ebp, eax
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, ebx
	call	eax

; 339  : 		u32		dwUpdate			= dwMin+iFloor(float(dwMax-dwMin)*scale);

	mov	ecx, ebp
	sub	ecx, esi
	test	ecx, ecx
	mov	DWORD PTR tv1332[esp+128], ecx
	fild	DWORD PTR tv1332[esp+128]
	jge	SHORT $LN366@ProcessSte
	fadd	DWORD PTR __real@4f800000
$LN366@ProcessSte:
	fmulp	ST(1), ST(0)
	mov	ecx, 158				; 0000009eH
	mov	eax, 1
	fstp	DWORD PTR _a$537190[esp+128]
	mov	edi, DWORD PTR _a$537190[esp+128]
	mov	edx, edi
	sar	edx, 23					; 00000017H
	and	edx, 255				; 000000ffH
	sub	ecx, edx
	mov	edx, edi
	or	edx, -8388608				; ff800000H
	shl	edx, 8
	shr	edx, cl
	sub	ecx, 96					; 00000060H
	shl	eax, cl
	sub	eax, 1
	sar	eax, 8
	and	eax, edi
	neg	eax
	sbb	eax, eax
	sar	edi, 31					; 0000001fH
	add	eax, 1
	and	eax, edi
	sub	edx, eax
	add	ecx, 64					; 00000040H
	sar	ecx, 31					; 0000001fH
	and	edx, ecx
	xor	edx, edi
	add	edx, esi

; 340  : 		clamp	(dwUpdate,u32(_max(dwMin,u32(20))),dwMax);

	cmp	esi, 20					; 00000014H
	mov	edi, edx
	ja	SHORT $LN160@ProcessSte
	mov	esi, 20					; 00000014H
$LN160@ProcessSte:
	cmp	edi, esi
	jae	SHORT $LN163@ProcessSte
	mov	edi, esi
	jmp	SHORT $LN161@ProcessSte
$LN163@ProcessSte:
	cmp	edi, ebp
	jbe	SHORT $LN161@ProcessSte
	mov	edi, ebp
$LN161@ProcessSte:

; 341  : 
; 342  : 		
; 343  : 
; 344  : 		m_current_step_obj = T.Object;

	mov	ebp, DWORD PTR _this$[esp+128]
	mov	DWORD PTR [ebp+48], ebx

; 345  : //			try {
; 346  : 			T.Object->shedule_Update	(clampr(Elapsed,u32(1),u32(_max(u32(T.Object->shedule.t_max),u32(1000)))) );

	mov	eax, DWORD PTR [ebx+4]
	shr	eax, 14					; 0000000eH
	and	eax, 16383				; 00003fffH
	cmp	eax, 1000				; 000003e8H
	ja	SHORT $LN169@ProcessSte
	mov	eax, 1000				; 000003e8H
$LN169@ProcessSte:
	mov	ecx, DWORD PTR _Elapsed$118280[esp+128]
	cmp	ecx, 1
	jae	SHORT $LN173@ProcessSte
	mov	eax, 1
	jmp	SHORT $LN170@ProcessSte
$LN173@ProcessSte:
	cmp	ecx, eax
	ja	SHORT $LN170@ProcessSte
	mov	eax, ecx
$LN170@ProcessSte:
	mov	edx, DWORD PTR [ebx]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, ebx
	call	eax

; 347  : 			if (!m_current_step_obj)

	cmp	DWORD PTR [ebp+48], 0

; 348  : 			{
; 349  : #ifdef DEBUG_SCHEDULER
; 350  : 				Msg						("SCHEDULER: process unregister (self unregistering) [%s][%x][%s]",*T.scheduled_name,T.Object,"false");
; 351  : #endif // DEBUG_SCHEDULER
; 352  : 				continue;

	je	$LN243@ProcessSte

; 353  : 			}
; 354  : //			} catch (...) {
; 355  : #ifdef DEBUG
; 356  : //				Msg		("! xrSheduler: object '%s' raised an exception", _obj_name);
; 357  : //				throw	;
; 358  : #endif // DEBUG
; 359  : //			}
; 360  : 		m_current_step_obj = NULL;
; 361  : 
; 362  : #ifdef DEBUG
; 363  : //		u32	execTime				= eTimer.GetElapsed_ms		();
; 364  : #endif // DEBUG
; 365  : 
; 366  : 		// Fill item structure
; 367  : 		Item						TNext;
; 368  : 		TNext.dwTimeForExecute		= dwTime+dwUpdate;

	mov	eax, DWORD PTR _dwTime$[esp+128]
	add	edi, eax
	mov	DWORD PTR [ebp+48], 0

; 369  : 		TNext.dwTimeOfLastExecute	= dwTime;
; 370  : 		TNext.Object				= T.Object;
; 371  : 		TNext.scheduled_name		= T.Object->shedule_Name();

	mov	edx, DWORD PTR [ebx]
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR _TNext$118308[esp+132], eax
	lea	eax, DWORD PTR $T536575[esp+128]
	push	eax
	mov	ecx, ebx
	mov	DWORD PTR _TNext$118308[esp+132], edi
	mov	DWORD PTR _TNext$118308[esp+144], ebx
	call	edx
	mov	esi, DWORD PTR [eax]
	test	esi, esi
	je	SHORT $LN193@ProcessSte
	add	DWORD PTR [esi], 1
$LN193@ProcessSte:
	mov	eax, DWORD PTR $T536575[esp+128]
	test	eax, eax
	mov	DWORD PTR _TNext$118308[esp+136], esi
	je	SHORT $LN199@ProcessSte
	add	DWORD PTR [eax], -1
	mov	eax, DWORD PTR $T536575[esp+128]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN199@ProcessSte
	mov	DWORD PTR $T536575[esp+128], 0
$LN199@ProcessSte:

; 372  : 		ItemsProcessed.push_back	(TNext);

	lea	eax, DWORD PTR [ebp+24]
	lea	ecx, DWORD PTR _TNext$118308[esp+128]
	call	?push_back@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEXABUItem@CSheduler@@@Z ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::push_back

; 373  : 
; 374  : 
; 375  : #ifdef DEBUG
; 376  : //		u32	execTime				= eTimer.GetElapsed_ms		();
; 377  : 		// VERIFY3					(T.Object->dbg_update_shedule == T.Object->dbg_startframe, "Broken sequence of calls to 'shedule_Update'", _obj_name );
; 378  : 		if (delta_ms> 3*dwUpdate)	{
; 379  : 			//Msg	("! xrSheduler: failed to shedule object [%s] (%dms)",	_obj_name, delta_ms	);
; 380  : 		}
; 381  : //		if (execTime> 15)			{
; 382  : //			Msg	("* xrSheduler: too much time consumed by object [%s] (%dms)",	_obj_name, execTime	);
; 383  : //		}
; 384  : #endif // DEBUG
; 385  : 
; 386  : 		// 
; 387  : 		if ((i % 3) != (3 - 1))

	mov	ecx, DWORD PTR _i$118274[esp+128]
	mov	eax, 1431655766				; 55555556H
	imul	ecx
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	lea	edx, DWORD PTR [eax+eax*2]
	sub	ecx, edx
	cmp	ecx, 2

; 388  : 			continue;

	jne	SHORT $LN354@ProcessSte

; 389  : 
; 390  : 		if (Device.dwPrecacheFrame==0 && CPU::QPC() > cycles_limit)		

	cmp	DWORD PTR ?Device@@3VCRenderDevice@@A+12, 0
	jne	SHORT $LN354@ProcessSte
	call	DWORD PTR __imp_?QPC@CPU@@YA_KXZ
	cmp	edx, DWORD PTR [ebp+68]
	ja	SHORT $LN351@ProcessSte
	jb	SHORT $LN354@ProcessSte
	cmp	eax, DWORD PTR [ebp+64]
	ja	SHORT $LN351@ProcessSte
$LN354@ProcessSte:

; 395  : 		}
; 396  : 	}

	test	esi, esi
	je	SHORT $LN243@ProcessSte
	add	DWORD PTR [esi], -1
$LN243@ProcessSte:
	mov	eax, DWORD PTR _v$536720[esp+128]
	test	eax, eax
	je	SHORT $LN359@ProcessSte
	add	DWORD PTR [eax], -1
$LN359@ProcessSte:

; 388  : 			continue;

	mov	edi, ebp
$LN8@ProcessSte:

; 299  : 	for (int i=0;!Items.empty() && Top().dwTimeForExecute < dwTime; ++i) {

	mov	eax, DWORD PTR [edi+12]
	add	DWORD PTR _i$118274[esp+128], 1
	cmp	eax, DWORD PTR [edi+16]
	lea	esi, DWORD PTR [edi+12]
	jne	$LN9@ProcessSte

; 389  : 
; 390  : 		if (Device.dwPrecacheFrame==0 && CPU::QPC() > cycles_limit)		

	jmp	SHORT $LN235@ProcessSte
$LN351@ProcessSte:

; 391  : 		{
; 392  : 			// we have maxed out the load - increase heap
; 393  : 			psShedulerTarget		+= (psShedulerReaction * 3);
; 394  : 			break;

	test	esi, esi
	movss	xmm0, DWORD PTR ?psShedulerTarget@@3MA
	addss	xmm0, DWORD PTR _particles_time
	movss	DWORD PTR ?psShedulerTarget@@3MA, xmm0
	je	SHORT $LN227@ProcessSte
	add	DWORD PTR [esi], -1
$LN227@ProcessSte:
	mov	eax, DWORD PTR _v$536720[esp+128]
	test	eax, eax
	mov	edi, ebp
	je	SHORT $LN235@ProcessSte
	add	DWORD PTR [eax], -1
$LN235@ProcessSte:

; 397  : 
; 398  : 	// Push "processed" back
; 399  : 	while (ItemsProcessed.size())	{

	mov	ecx, DWORD PTR [edi+28]
	sub	ecx, DWORD PTR [edi+24]
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	je	$LN1@ProcessSte
$LN2@ProcessSte:

; 400  : 		Push	(ItemsProcessed.back())	;

	mov	ecx, DWORD PTR [edi+28]
	mov	eax, DWORD PTR [edi+16]
	lea	esi, DWORD PTR [edi+12]
	sub	ecx, 20					; 00000014H
	cmp	eax, DWORD PTR [esi+8]
	je	SHORT $LN276@ProcessSte
	test	eax, eax
	je	SHORT $LN281@ProcessSte
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], 0
	mov	ebx, DWORD PTR [ecx+8]
	test	ebx, ebx
	je	SHORT $LN289@ProcessSte
	add	DWORD PTR [ebx], 1
$LN289@ProcessSte:
	mov	edx, DWORD PTR [eax+8]
	test	edx, edx
	je	SHORT $LN292@ProcessSte
	add	DWORD PTR [edx], -1
	mov	edx, DWORD PTR [eax+8]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN292@ProcessSte
	mov	DWORD PTR [eax+8], 0
$LN292@ProcessSte:
	mov	DWORD PTR [eax+8], ebx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], ecx
$LN281@ProcessSte:
	add	DWORD PTR [esi+4], 20			; 00000014H
	jmp	SHORT $LN296@ProcessSte
$LN276@ProcessSte:
	push	ecx
	push	eax
	call	?_M_insert_overflow_aux@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@AAEXPAUItem@CSheduler@@ABU45@ABU__false_type@3@I_N@Z ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::_M_insert_overflow_aux
$LN296@ProcessSte:
	mov	eax, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [eax-20]
	mov	ebx, DWORD PTR [esi]
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax-16]
	xor	ebp, ebp
	mov	DWORD PTR [ecx+4], edx
	mov	DWORD PTR [ecx+8], ebp
	mov	edx, DWORD PTR [eax-12]
	cmp	edx, ebp
	je	SHORT $LN318@ProcessSte
	add	DWORD PTR [edx], 1
$LN318@ProcessSte:
	mov	esi, DWORD PTR [ecx+8]
	cmp	esi, ebp
	je	SHORT $LN321@ProcessSte
	add	DWORD PTR [esi], -1
	mov	esi, DWORD PTR [ecx+8]
	cmp	DWORD PTR [esi], ebp
	jne	SHORT $LN321@ProcessSte
	mov	DWORD PTR [ecx+8], ebp
$LN321@ProcessSte:
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax-8]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [eax-4]
	sub	eax, ebx
	mov	DWORD PTR [ecx+16], edx
	mov	ecx, eax
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	lea	ecx, DWORD PTR [edx+eax-1]
	call	??$__push_heap@PAUItem@CSheduler@@HU12@@stlp_std@@YAXPAUItem@CSheduler@@HHU12@@Z ; stlp_std::__push_heap<CSheduler::Item *,int,CSheduler::Item>

; 401  : 		ItemsProcessed.pop_back		()	;

	add	DWORD PTR [edi+28], -20			; ffffffecH
	mov	ecx, DWORD PTR [edi+28]
	mov	eax, DWORD PTR [ecx+8]
	add	esp, 20					; 00000014H
	cmp	eax, ebp
	je	SHORT $LN340@ProcessSte
	add	DWORD PTR [eax], -1
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx], ebp
	jne	SHORT $LN340@ProcessSte
	mov	DWORD PTR [ecx+8], ebp
$LN340@ProcessSte:
	mov	ecx, DWORD PTR [edi+28]
	sub	ecx, DWORD PTR [edi+24]
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	jne	$LN2@ProcessSte
$LN1@ProcessSte:

; 402  : 	}
; 403  : 
; 404  : 	// always try to decrease target
; 405  : 	psShedulerTarget	-= psShedulerReaction;

	movss	xmm0, DWORD PTR ?psShedulerTarget@@3MA
	subss	xmm0, DWORD PTR _psShedulerReaction

; 406  : }

	pop	edi
	movss	DWORD PTR ?psShedulerTarget@@3MA, xmm0
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ProcessStep@CSheduler@@QAEXXZ ENDP			; CSheduler::ProcessStep
PUBLIC	__real@42840000
PUBLIC	?Update@CSheduler@@QAEXXZ			; CSheduler::Update
EXTRN	__aulldiv:PROC
EXTRN	__allmul:PROC
;	COMDAT __real@42840000
; File d:\clearsky\sources\engine\xrcore\ftimer.h
CONST	SEGMENT
__real@42840000 DD 042840000r			; 66
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\xrsheduler.cpp
CONST	ENDS
;	COMDAT ?Update@CSheduler@@QAEXXZ
_TEXT	SEGMENT
_a$547614 = -4						; size = 4
_dwTime$ = -4						; size = 4
?Update@CSheduler@@QAEXXZ PROC				; CSheduler::Update, COMDAT
; _this$ = ecx

; 418  : {

	push	ecx
	push	ebx

; 419  : 	R_ASSERT						(Device.Statistic);

	xor	ebx, ebx
	cmp	BYTE PTR ?ignore_always@?3??Update@CSheduler@@QAEXXZ@4_NA, bl
	push	esi
	mov	esi, ecx
	jne	SHORT $LN11@Update@6
	cmp	DWORD PTR ?Device@@3VCRenderDevice@@A+920, ebx
	jne	SHORT $LN11@Update@6
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?3??Update@CSheduler@@QAEXXZ@4_NA
	push	OFFSET ??_C@_0BC@FHMDICED@CSheduler?3?3Update?$AA@
	push	419					; 000001a3H
	push	OFFSET ??_C@_0DD@DAIAEPIB@D?3?2CLEARSKY?2sources?2engine?2xrEng@
	push	OFFSET ??_C@_0BB@NEBKLIE@Device?4Statistic?$AA@
	call	DWORD PTR __imp_?fail@xrDebug@@QAEXPBD0H0AA_N@Z
$LN11@Update@6:

; 420  : 	// Initialize
; 421  : 	Device.Statistic->Sheduler.Begin();

	mov	eax, DWORD PTR __imp_?g_bEnableStatGather@@3HA
	push	ebp
	mov	ebp, DWORD PTR __imp_?QPC@CPU@@YA_KXZ
	push	edi
	mov	edi, DWORD PTR ?Device@@3VCRenderDevice@@A+920
	add	edi, 336				; 00000150H
	cmp	DWORD PTR [eax], ebx
	je	SHORT $LN54@Update@6
	add	DWORD PTR [edi+68], 1
	cmp	DWORD PTR [edi+24], ebx
	jne	SHORT $LN54@Update@6
	call	ebp
	sub	eax, DWORD PTR [edi+16]
	mov	DWORD PTR [edi+40], ebx
	sbb	edx, DWORD PTR [edi+20]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], edx
	mov	DWORD PTR [edi+44], ebx
	mov	DWORD PTR [edi+48], ebx
	mov	DWORD PTR [edi+52], ebx
$LN54@Update@6:

; 422  : 	cycles_start					= CPU::QPC			();

	call	ebp

; 423  : 	cycles_limit					= CPU::qpc_freq * u64 (iCeil(psShedulerCurrent)) / 1000i64 + cycles_start;

	movss	xmm0, DWORD PTR ?psShedulerCurrent@@3MA
	mov	DWORD PTR [esi+60], edx
	mov	DWORD PTR [esi+56], eax
	movss	DWORD PTR _a$547614[esp+20], xmm0
	mov	edi, DWORD PTR _a$547614[esp+20]
	mov	edx, edi
	sar	edx, 23					; 00000017H
	and	edx, 255				; 000000ffH
	mov	eax, edi
	or	eax, -8388608				; ff800000H
	shl	eax, 8
	mov	ecx, 158				; 0000009eH
	sub	ecx, edx
	shr	eax, cl
	sub	ecx, 96					; 00000060H
	mov	edx, 1
	shl	edx, cl
	sub	edx, 1
	sar	edx, 8
	and	edx, edi
	neg	edx
	sbb	edx, edx
	add	edi, -1
	sar	edi, 31					; 0000001fH
	add	edx, 1
	not	edi
	and	edx, edi
	add	ecx, 64					; 00000040H
	sub	eax, edx
	sar	ecx, 31					; 0000001fH
	and	eax, ecx
	mov	ecx, DWORD PTR __imp_?qpc_freq@CPU@@3_KA
	xor	eax, edi
	mov	edi, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	push	edi
	neg	eax
	cdq
	push	ecx
	push	edx
	push	eax
	call	__allmul
	push	ebx
	push	1000					; 000003e8H
	push	edx
	push	eax
	call	__aulldiv
	add	eax, DWORD PTR [esi+56]

; 424  : 	internal_Registration			();

	mov	ecx, esi
	adc	edx, DWORD PTR [esi+60]
	mov	DWORD PTR [esi+64], eax
	mov	DWORD PTR [esi+68], edx
	call	?internal_Registration@CSheduler@@AAEXXZ ; CSheduler::internal_Registration

; 425  : 	g_bSheduleInProgress			= TRUE;
; 426  : 
; 427  : #ifdef DEBUG_SCHEDULER
; 428  : 	Msg								("SCHEDULER: PROCESS STEP %d",Device.dwFrame);
; 429  : #endif // DEBUG_SCHEDULER
; 430  : 	// Realtime priority
; 431  : 	m_processing_now				= true;
; 432  : 	u32	dwTime						= Device.dwTimeGlobal;
; 433  : 	for (u32 it=0; it<ItemsRT.size(); it++)

	mov	ecx, DWORD PTR [esi+4]
	sub	ecx, DWORD PTR [esi]
	mov	BYTE PTR [esi+52], 1
	mov	edx, DWORD PTR ?Device@@3VCRenderDevice@@A+40
	mov	DWORD PTR _dwTime$[esp+20], edx
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	xor	ebp, ebp
	add	eax, edx
	mov	DWORD PTR ?g_bSheduleInProgress@@3HA, 1	; g_bSheduleInProgress
	je	$LN6@Update@6
	npad	1
$LL8@Update@6:

; 434  : 	{
; 435  : 		Item&	T					= ItemsRT[it];

	mov	edi, DWORD PTR [esi]
	add	edi, ebx

; 436  : 		R_ASSERT					(T.Object);

	cmp	BYTE PTR ?ignore_always@?9??Update@CSheduler@@QAEXXZ@4_NA, 0
	jne	SHORT $LN4@Update@6
	cmp	DWORD PTR [edi+12], 0
	jne	SHORT $LN4@Update@6
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?9??Update@CSheduler@@QAEXXZ@4_NA
	push	OFFSET ??_C@_0BC@FHMDICED@CSheduler?3?3Update?$AA@
	push	436					; 000001b4H
	push	OFFSET ??_C@_0DD@DAIAEPIB@D?3?2CLEARSKY?2sources?2engine?2xrEng@
	push	OFFSET ??_C@_08PDHDIBNI@T?4Object?$AA@
	call	DWORD PTR __imp_?fail@xrDebug@@QAEXPBD0H0AA_N@Z
$LN4@Update@6:

; 437  : #ifdef DEBUG_SCHEDULER
; 438  : 		Msg							("SCHEDULER: process step [%s][%x][true]",*T.Object->shedule_Name(),T.Object);
; 439  : #endif // DEBUG_SCHEDULER
; 440  : 		if(!T.Object->shedule_Needed()){

	mov	ecx, DWORD PTR [edi+12]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	call	eax
	test	al, al
	jne	SHORT $LN1@Update@6

; 441  : #ifdef DEBUG_SCHEDULER
; 442  : 			Msg						("SCHEDULER: process unregister [%s][%x][%s]",*T.Object->shedule_Name(),T.Object,"false");
; 443  : #endif // DEBUG_SCHEDULER
; 444  : 			T.dwTimeOfLastExecute	= dwTime;

	mov	ecx, DWORD PTR _dwTime$[esp+20]
	mov	DWORD PTR [edi+4], ecx

; 445  : 			continue;

	jmp	SHORT $LN7@Update@6
$LN1@Update@6:

; 446  : 		}
; 447  : 
; 448  : 		u32	Elapsed					= dwTime-T.dwTimeOfLastExecute;
; 449  : #ifdef DEBUG
; 450  : 		VERIFY						(T.Object->dbg_startframe != Device.dwFrame);
; 451  : 		T.Object->dbg_startframe	= Device.dwFrame;
; 452  : #endif
; 453  : 		T.Object->shedule_Update	(Elapsed);

	mov	ecx, DWORD PTR [edi+12]
	mov	eax, DWORD PTR _dwTime$[esp+20]
	sub	eax, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+8]
	push	eax
	call	edx

; 454  : 		T.dwTimeOfLastExecute		= dwTime;

	mov	eax, DWORD PTR _dwTime$[esp+20]
	mov	DWORD PTR [edi+4], eax
$LN7@Update@6:
	mov	ecx, DWORD PTR [esi+4]
	sub	ecx, DWORD PTR [esi]
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ebp, 1
	add	ecx, edx
	add	ebx, 20					; 00000014H
	cmp	ebp, ecx
	jb	$LL8@Update@6

; 425  : 	g_bSheduleInProgress			= TRUE;
; 426  : 
; 427  : #ifdef DEBUG_SCHEDULER
; 428  : 	Msg								("SCHEDULER: PROCESS STEP %d",Device.dwFrame);
; 429  : #endif // DEBUG_SCHEDULER
; 430  : 	// Realtime priority
; 431  : 	m_processing_now				= true;
; 432  : 	u32	dwTime						= Device.dwTimeGlobal;
; 433  : 	for (u32 it=0; it<ItemsRT.size(); it++)

	xor	ebx, ebx
$LN6@Update@6:

; 455  : 	}
; 456  : 
; 457  : 	// Normal (sheduled)
; 458  : 	ProcessStep						();

	mov	ecx, esi
	call	?ProcessStep@CSheduler@@QAEXXZ		; CSheduler::ProcessStep

; 459  : 	m_processing_now				= false;
; 460  : #ifdef DEBUG_SCHEDULER
; 461  : 	Msg								("SCHEDULER: PROCESS STEP FINISHED %d",Device.dwFrame);
; 462  : #endif // DEBUG_SCHEDULER
; 463  : 	clamp							(psShedulerTarget,3.f,66.f);

	movss	xmm1, DWORD PTR _drop_angle
	mov	BYTE PTR [esi+52], 0
	movss	xmm0, DWORD PTR ?psShedulerTarget@@3MA
	comiss	xmm1, xmm0
	pop	edi
	pop	ebp
	ja	SHORT $LN55@Update@6
	movss	xmm1, DWORD PTR __real@42840000
	comiss	xmm0, xmm1
	jbe	SHORT $LN43@Update@6
$LN55@Update@6:
	movaps	xmm0, xmm1
	movss	DWORD PTR ?psShedulerTarget@@3MA, xmm0
$LN43@Update@6:

; 464  : 	psShedulerCurrent				= 0.9f*psShedulerCurrent + 0.1f*psShedulerTarget;

	movss	xmm1, DWORD PTR ?psShedulerCurrent@@3MA
	mulss	xmm0, DWORD PTR _psShedulerReaction
	mulss	xmm1, DWORD PTR __real@3f666666

; 465  : 	Device.Statistic->fShedulerLoad	= psShedulerCurrent;

	mov	edx, DWORD PTR ?Device@@3VCRenderDevice@@A+920
	addss	xmm0, xmm1

; 466  : 
; 467  : 	// Finalize
; 468  : 	g_bSheduleInProgress			= FALSE;
; 469  : 	internal_Registration			();

	mov	ecx, esi
	movss	DWORD PTR ?psShedulerCurrent@@3MA, xmm0
	movss	DWORD PTR [edx+256], xmm0
	mov	DWORD PTR ?g_bSheduleInProgress@@3HA, ebx ; g_bSheduleInProgress
	call	?internal_Registration@CSheduler@@AAEXXZ ; CSheduler::internal_Registration

; 470  : 	Device.Statistic->Sheduler.End	();

	mov	esi, DWORD PTR ?Device@@3VCRenderDevice@@A+920
	mov	eax, DWORD PTR __imp_?g_bEnableStatGather@@3HA
	add	esi, 336				; 00000150H
	cmp	DWORD PTR [eax], ebx
	je	SHORT $LN49@Update@6
	mov	ecx, esi
	call	DWORD PTR __imp_?GetElapsed_ticks@CTimer@@QBE_KXZ
	add	DWORD PTR [esi+56], eax
	adc	DWORD PTR [esi+60], edx
$LN49@Update@6:
	pop	esi
	pop	ebx

; 471  : }

	pop	ecx
	ret	0
?Update@CSheduler@@QAEXXZ ENDP				; CSheduler::Update
END

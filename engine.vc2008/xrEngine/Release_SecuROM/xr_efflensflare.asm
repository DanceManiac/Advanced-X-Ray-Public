; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	D:\CLEARSKY\sources\engine\xrEngine\xr_efflensflare.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	?mem_usage@CBoneData@@UAEIXZ			; CBoneData::mem_usage
PUBLIC	??_ECBoneData@@UAEPAXI@Z			; CBoneData::`vector deleting destructor'
PUBLIC	?hi_limit@CBoneData@@EBGME@Z			; CBoneData::hi_limit
PUBLIC	?lo_limit@CBoneData@@EBGME@Z			; CBoneData::lo_limit
PUBLIC	?GetParentID@CBoneData@@UBGGXZ			; CBoneData::GetParentID
PUBLIC	?get_game_mtl_idx@CBoneData@@EBGGXZ		; CBoneData::get_game_mtl_idx
PUBLIC	?get_mass@CBoneData@@EBGMXZ			; CBoneData::get_mass
PUBLIC	?get_center_of_mass@CBoneData@@EBGABU?$_vector3@M@@XZ ; CBoneData::get_center_of_mass
PUBLIC	?get_obb@CBoneData@@EBGABU?$_obb@M@@XZ		; CBoneData::get_obb
PUBLIC	?get_shape@CBoneData@@EBGABUSBoneShape@@XZ	; CBoneData::get_shape
PUBLIC	?get_bind_transform@CBoneData@@EBGABU?$_matrix@M@@XZ ; CBoneData::get_bind_transform
PUBLIC	?get_IK_data@CBoneData@@EBGABUSJointIKData@@XZ	; CBoneData::get_IK_data
PUBLIC	?GetSelfID@CBoneData@@UBGGXZ			; CBoneData::GetSelfID
PUBLIC	??_R4CBoneData@@6B@				; CBoneData::`RTTI Complete Object Locator'
PUBLIC	??_R3CBoneData@@8				; CBoneData::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CBoneData@@8				; CBoneData::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CBoneData@@8			; CBoneData::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCBoneData@@@8				; CBoneData `RTTI Type Descriptor'
PUBLIC	??_R4IBoneData@@6B@				; IBoneData::`RTTI Complete Object Locator'
PUBLIC	??_R3IBoneData@@8				; IBoneData::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IBoneData@@8				; IBoneData::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@IBoneData@@8			; IBoneData::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVIBoneData@@@8				; IBoneData `RTTI Type Descriptor'
PUBLIC	?size@?$vector@PAVCBoneData@@V?$xalloc@PAVCBoneData@@@@@stlp_std@@QBEIXZ ; stlp_std::vector<CBoneData *,xalloc<CBoneData *> >::size
PUBLIC	?size@?$xr_vector@PAVCBoneData@@V?$xalloc@PAVCBoneData@@@@@@QBEIXZ ; xr_vector<CBoneData *,xalloc<CBoneData *> >::size
PUBLIC	?end@?$vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@stlp_std@@QAEPAV?$xr_vector@GV?$xalloc@G@@@@XZ ; stlp_std::vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::end
PUBLIC	??0IBoneData@@QAE@ABV0@@Z			; IBoneData::IBoneData
PUBLIC	??0?$vector@PAVCBoneData@@V?$xalloc@PAVCBoneData@@@@@stlp_std@@QAE@ABV01@@Z ; stlp_std::vector<CBoneData *,xalloc<CBoneData *> >::vector<CBoneData *,xalloc<CBoneData *> >
PUBLIC	??0?$xr_vector@PAVCBoneData@@V?$xalloc@PAVCBoneData@@@@@@QAE@ABV0@@Z ; xr_vector<CBoneData *,xalloc<CBoneData *> >::xr_vector<CBoneData *,xalloc<CBoneData *> >
PUBLIC	??0?$_Vector_base@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAE@IABV?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@Z ; stlp_std::priv::_Vector_base<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::_Vector_base<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >
PUBLIC	?get_allocator@?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QBE?AV?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@XZ ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::get_allocator
PUBLIC	?begin@?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QBEPBV?$xr_vector@GV?$xalloc@G@@@@XZ ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::begin
PUBLIC	?end@?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QBEPBV?$xr_vector@GV?$xalloc@G@@@@XZ ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::end
PUBLIC	??0?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAE@ABV012@@Z ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >
PUBLIC	??0?$vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@stlp_std@@QAE@ABV01@@Z ; stlp_std::vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >
PUBLIC	??0?$xr_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@@QAE@ABV0@@Z ; xr_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::xr_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >
PUBLIC	??4IBoneData@@QAEAAV0@ABV0@@Z			; IBoneData::operator=
PUBLIC	??4?$vector@PAVCBoneData@@V?$xalloc@PAVCBoneData@@@@@stlp_std@@QAEAAV01@ABV01@@Z ; stlp_std::vector<CBoneData *,xalloc<CBoneData *> >::operator=
PUBLIC	??4?$xr_vector@PAVCBoneData@@V?$xalloc@PAVCBoneData@@@@@@QAEAAV0@ABV0@@Z ; xr_vector<CBoneData *,xalloc<CBoneData *> >::operator=
PUBLIC	?size@?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QBEIXZ ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::size
PUBLIC	?capacity@?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QBEIXZ ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::capacity
PUBLIC	?_M_clear@?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@AAEXXZ ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::_M_clear
PUBLIC	??$xr_alloc@V?$xr_vector@GV?$xalloc@G@@@@@@YAPAV?$xr_vector@GV?$xalloc@G@@@@I@Z ; xr_alloc<xr_vector<unsigned short,xalloc<unsigned short> > >
PUBLIC	?allocate@?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@QBEPAV?$xr_vector@GV?$xalloc@G@@@@IPBX@Z ; xalloc<xr_vector<unsigned short,xalloc<unsigned short> > >::allocate
PUBLIC	?allocate@?$_STLP_alloc_proxy@PAV?$xr_vector@GV?$xalloc@G@@@@V1@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAEPAV?$xr_vector@GV?$xalloc@G@@@@I@Z ; stlp_std::priv::_STLP_alloc_proxy<xr_vector<unsigned short,xalloc<unsigned short> > *,xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::allocate
PUBLIC	?allocate@?$_STLP_alloc_proxy@PAV?$xr_vector@GV?$xalloc@G@@@@V1@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@AAEPAV?$xr_vector@GV?$xalloc@G@@@@IAAIABU__false_type@3@@Z ; stlp_std::priv::_STLP_alloc_proxy<xr_vector<unsigned short,xalloc<unsigned short> > *,xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::allocate
PUBLIC	?allocate@?$_STLP_alloc_proxy@PAV?$xr_vector@GV?$xalloc@G@@@@V1@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAEPAV?$xr_vector@GV?$xalloc@G@@@@IAAI@Z ; stlp_std::priv::_STLP_alloc_proxy<xr_vector<unsigned short,xalloc<unsigned short> > *,xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::allocate
PUBLIC	?_Answer@?$_BothPtrType@PBV?$xr_vector@GV?$xalloc@G@@@@PAV1@@stlp_std@@SA?AU__true_type@2@XZ ; stlp_std::_BothPtrType<xr_vector<unsigned short,xalloc<unsigned short> > const *,xr_vector<unsigned short,xalloc<unsigned short> > *>::_Answer
PUBLIC	??$_Param_Construct@V?$xr_vector@GV?$xalloc@G@@@@V1@@stlp_std@@YAXPAV?$xr_vector@GV?$xalloc@G@@@@ABV1@@Z ; stlp_std::_Param_Construct<xr_vector<unsigned short,xalloc<unsigned short> >,xr_vector<unsigned short,xalloc<unsigned short> > >
PUBLIC	??$__ucopy@PBV?$xr_vector@GV?$xalloc@G@@@@PAV1@H@priv@stlp_std@@YAPAV?$xr_vector@GV?$xalloc@G@@@@PBV2@0PAV2@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<xr_vector<unsigned short,xalloc<unsigned short> > const *,xr_vector<unsigned short,xalloc<unsigned short> > *,int>
PUBLIC	??$__ucopy_ptrs@PBV?$xr_vector@GV?$xalloc@G@@@@PAV1@@priv@stlp_std@@YAPAV?$xr_vector@GV?$xalloc@G@@@@PBV2@0PAV2@ABU__false_type@1@@Z ; stlp_std::priv::__ucopy_ptrs<xr_vector<unsigned short,xalloc<unsigned short> > const *,xr_vector<unsigned short,xalloc<unsigned short> > *>
PUBLIC	??$_UseTrivialUCopy@V?$xr_vector@GV?$xalloc@G@@@@V1@@stlp_std@@YA?AU?$_TrivialUCopy@V?$xr_vector@GV?$xalloc@G@@@@V1@@0@PAV?$xr_vector@GV?$xalloc@G@@@@0@Z ; stlp_std::_UseTrivialUCopy<xr_vector<unsigned short,xalloc<unsigned short> >,xr_vector<unsigned short,xalloc<unsigned short> > >
PUBLIC	?_Answer@?$_TrivialUCopy@V?$xr_vector@GV?$xalloc@G@@@@V1@@stlp_std@@SA?AU__false_type@2@XZ ; stlp_std::_TrivialUCopy<xr_vector<unsigned short,xalloc<unsigned short> >,xr_vector<unsigned short,xalloc<unsigned short> > >::_Answer
PUBLIC	??$__ucopy_aux@PBV?$xr_vector@GV?$xalloc@G@@@@PAV1@@priv@stlp_std@@YAPAV?$xr_vector@GV?$xalloc@G@@@@PBV2@0PAV2@ABU__true_type@1@@Z ; stlp_std::priv::__ucopy_aux<xr_vector<unsigned short,xalloc<unsigned short> > const *,xr_vector<unsigned short,xalloc<unsigned short> > *>
PUBLIC	??$uninitialized_copy@PBV?$xr_vector@GV?$xalloc@G@@@@PAV1@@stlp_std@@YAPAV?$xr_vector@GV?$xalloc@G@@@@PBV1@0PAV1@@Z ; stlp_std::uninitialized_copy<xr_vector<unsigned short,xalloc<unsigned short> > const *,xr_vector<unsigned short,xalloc<unsigned short> > *>
PUBLIC	??$_M_allocate_and_copy@PBV?$xr_vector@GV?$xalloc@G@@@@@?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@AAEPAV?$xr_vector@GV?$xalloc@G@@@@AAIPBV3@1@Z ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::_M_allocate_and_copy<xr_vector<unsigned short,xalloc<unsigned short> > const *>
PUBLIC	??$__copy@PBV?$xr_vector@GV?$xalloc@G@@@@PAV1@H@priv@stlp_std@@YAPAV?$xr_vector@GV?$xalloc@G@@@@PBV2@0PAV2@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__copy<xr_vector<unsigned short,xalloc<unsigned short> > const *,xr_vector<unsigned short,xalloc<unsigned short> > *,int>
PUBLIC	??$__copy_ptrs@PBV?$xr_vector@GV?$xalloc@G@@@@PAV1@@priv@stlp_std@@YAPAV?$xr_vector@GV?$xalloc@G@@@@PBV2@0PAV2@ABU__false_type@1@@Z ; stlp_std::priv::__copy_ptrs<xr_vector<unsigned short,xalloc<unsigned short> > const *,xr_vector<unsigned short,xalloc<unsigned short> > *>
PUBLIC	??$__destroy_range_aux@PAV?$xr_vector@GV?$xalloc@G@@@@V1@@stlp_std@@YAXPAV?$xr_vector@GV?$xalloc@G@@@@00ABU__false_type@0@@Z ; stlp_std::__destroy_range_aux<xr_vector<unsigned short,xalloc<unsigned short> > *,xr_vector<unsigned short,xalloc<unsigned short> > >
PUBLIC	??$__destroy_range@PAV?$xr_vector@GV?$xalloc@G@@@@V1@@stlp_std@@YAXPAV?$xr_vector@GV?$xalloc@G@@@@00@Z ; stlp_std::__destroy_range<xr_vector<unsigned short,xalloc<unsigned short> > *,xr_vector<unsigned short,xalloc<unsigned short> > >
PUBLIC	??$_Destroy_Range@PAV?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@YAXPAV?$xr_vector@GV?$xalloc@G@@@@0@Z ; stlp_std::_Destroy_Range<xr_vector<unsigned short,xalloc<unsigned short> > *>
PUBLIC	??4?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::operator=
PUBLIC	??4?$vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@stlp_std@@QAEAAV01@ABV01@@Z ; stlp_std::vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::operator=
PUBLIC	??4?$xr_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@@QAEAAV0@ABV0@@Z ; xr_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::operator=
PUBLIC	??$__destroy_mv_srcs@V?$reverse_iterator@PAUSFlare@CLensFlareDescriptor@@@stlp_std@@USFlare@CLensFlareDescriptor@@@stlp_std@@YAXV?$reverse_iterator@PAUSFlare@CLensFlareDescriptor@@@0@0PAUSFlare@CLensFlareDescriptor@@@Z ; stlp_std::__destroy_mv_srcs<stlp_std::reverse_iterator<CLensFlareDescriptor::SFlare *>,CLensFlareDescriptor::SFlare>
PUBLIC	??$_Destroy_Moved_Range@V?$reverse_iterator@PAUSFlare@CLensFlareDescriptor@@@stlp_std@@@stlp_std@@YAXV?$reverse_iterator@PAUSFlare@CLensFlareDescriptor@@@0@0@Z ; stlp_std::_Destroy_Moved_Range<stlp_std::reverse_iterator<CLensFlareDescriptor::SFlare *> >
PUBLIC	?_M_clear_after_move@?$_Impl_vector@USFlare@CLensFlareDescriptor@@V?$xalloc@USFlare@CLensFlareDescriptor@@@@@priv@stlp_std@@AAEXXZ ; stlp_std::priv::_Impl_vector<CLensFlareDescriptor::SFlare,xalloc<CLensFlareDescriptor::SFlare> >::_M_clear_after_move
PUBLIC	?_M_set@?$_Impl_vector@USFlare@CLensFlareDescriptor@@V?$xalloc@USFlare@CLensFlareDescriptor@@@@@priv@stlp_std@@AAEXPAUSFlare@CLensFlareDescriptor@@00@Z ; stlp_std::priv::_Impl_vector<CLensFlareDescriptor::SFlare,xalloc<CLensFlareDescriptor::SFlare> >::_M_set
PUBLIC	??$__ucopy@PAUSFlare@CLensFlareDescriptor@@PAU12@H@priv@stlp_std@@YAPAUSFlare@CLensFlareDescriptor@@PAU23@00ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<CLensFlareDescriptor::SFlare *,CLensFlareDescriptor::SFlare *,int>
PUBLIC	??$__ucopy_ptrs@PAUSFlare@CLensFlareDescriptor@@PAU12@@priv@stlp_std@@YAPAUSFlare@CLensFlareDescriptor@@PAU23@00ABU__false_type@1@@Z ; stlp_std::priv::__ucopy_ptrs<CLensFlareDescriptor::SFlare *,CLensFlareDescriptor::SFlare *>
PUBLIC	??$__uninitialized_move@PAUSFlare@CLensFlareDescriptor@@PAU12@U__false_type@stlp_std@@@priv@stlp_std@@YAPAUSFlare@CLensFlareDescriptor@@PAU23@00U__false_type@1@ABU41@@Z ; stlp_std::priv::__uninitialized_move<CLensFlareDescriptor::SFlare *,CLensFlareDescriptor::SFlare *,stlp_std::__false_type>
PUBLIC	??$__ufill@PAUSFlare@CLensFlareDescriptor@@U12@H@priv@stlp_std@@YAXPAUSFlare@CLensFlareDescriptor@@0ABU23@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ufill<CLensFlareDescriptor::SFlare *,CLensFlareDescriptor::SFlare,int>
PUBLIC	??$__uninitialized_fill_n@PAUSFlare@CLensFlareDescriptor@@IU12@@priv@stlp_std@@YAPAUSFlare@CLensFlareDescriptor@@PAU23@IABU23@@Z ; stlp_std::priv::__uninitialized_fill_n<CLensFlareDescriptor::SFlare *,unsigned int,CLensFlareDescriptor::SFlare>
PUBLIC	?_M_insert_overflow_aux@?$_Impl_vector@USFlare@CLensFlareDescriptor@@V?$xalloc@USFlare@CLensFlareDescriptor@@@@@priv@stlp_std@@AAEXPAUSFlare@CLensFlareDescriptor@@ABU45@ABU__false_type@3@I_N@Z ; stlp_std::priv::_Impl_vector<CLensFlareDescriptor::SFlare,xalloc<CLensFlareDescriptor::SFlare> >::_M_insert_overflow_aux
PUBLIC	?_M_insert_overflow@?$_Impl_vector@USFlare@CLensFlareDescriptor@@V?$xalloc@USFlare@CLensFlareDescriptor@@@@@priv@stlp_std@@AAEXPAUSFlare@CLensFlareDescriptor@@ABU45@ABU__false_type@3@I_N@Z ; stlp_std::priv::_Impl_vector<CLensFlareDescriptor::SFlare,xalloc<CLensFlareDescriptor::SFlare> >::_M_insert_overflow
PUBLIC	??$_Copy_Construct@USFlare@CLensFlareDescriptor@@@stlp_std@@YAXPAUSFlare@CLensFlareDescriptor@@ABU12@@Z ; stlp_std::_Copy_Construct<CLensFlareDescriptor::SFlare>
PUBLIC	?push_back@?$_Impl_vector@USFlare@CLensFlareDescriptor@@V?$xalloc@USFlare@CLensFlareDescriptor@@@@@priv@stlp_std@@QAEXABUSFlare@CLensFlareDescriptor@@@Z ; stlp_std::priv::_Impl_vector<CLensFlareDescriptor::SFlare,xalloc<CLensFlareDescriptor::SFlare> >::push_back
PUBLIC	?to_storage_type_cref@?$_CastTraits@USFlare@CLensFlareDescriptor@@U12@@priv@stlp_std@@SAABUSFlare@CLensFlareDescriptor@@ABU45@@Z ; stlp_std::priv::_CastTraits<CLensFlareDescriptor::SFlare,CLensFlareDescriptor::SFlare>::to_storage_type_cref
PUBLIC	?push_back@?$vector@USFlare@CLensFlareDescriptor@@V?$xalloc@USFlare@CLensFlareDescriptor@@@@@stlp_std@@QAEXABUSFlare@CLensFlareDescriptor@@@Z ; stlp_std::vector<CLensFlareDescriptor::SFlare,xalloc<CLensFlareDescriptor::SFlare> >::push_back
PUBLIC	?begin@?$vector@USFlare@CLensFlareDescriptor@@V?$xalloc@USFlare@CLensFlareDescriptor@@@@@stlp_std@@QAEPAUSFlare@CLensFlareDescriptor@@XZ ; stlp_std::vector<CLensFlareDescriptor::SFlare,xalloc<CLensFlareDescriptor::SFlare> >::begin
PUBLIC	?to_value_type_ptr@?$_CastTraits@USFlare@CLensFlareDescriptor@@U12@@priv@stlp_std@@SAPAUSFlare@CLensFlareDescriptor@@PAU45@@Z ; stlp_std::priv::_CastTraits<CLensFlareDescriptor::SFlare,CLensFlareDescriptor::SFlare>::to_value_type_ptr
PUBLIC	?end@?$vector@USFlare@CLensFlareDescriptor@@V?$xalloc@USFlare@CLensFlareDescriptor@@@@@stlp_std@@QAEPAUSFlare@CLensFlareDescriptor@@XZ ; stlp_std::vector<CLensFlareDescriptor::SFlare,xalloc<CLensFlareDescriptor::SFlare> >::end
PUBLIC	?identity@?$_matrix33@M@@QAEAAU1@XZ		; _matrix33<float>::identity
PUBLIC	?invalidate@?$_obb@M@@QAEAAU1@XZ		; _obb<float>::invalidate
PUBLIC	?invalidate@?$_cylinder@M@@QAEAAV1@XZ		; _cylinder<float>::invalidate
PUBLIC	?Reset@SBoneShape@@QAEXXZ			; SBoneShape::Reset
PUBLIC	??0SBoneShape@@QAE@XZ				; SBoneShape::SBoneShape
PUBLIC	??0SJointLimit@@QAE@XZ				; SJointLimit::SJointLimit
PUBLIC	?Reset@SJointLimit@@QAEXXZ			; SJointLimit::Reset
PUBLIC	?Reset@SJointIKData@@QAEXXZ			; SJointIKData::Reset
PUBLIC	??0SJointIKData@@QAE@XZ				; SJointIKData::SJointIKData
PUBLIC	??0IBoneData@@QAE@XZ				; IBoneData::IBoneData
PUBLIC	??0?$xalloc@PAVCBoneData@@@@QAE@XZ		; xalloc<CBoneData *>::xalloc<CBoneData *>
PUBLIC	??$?0PAVCBoneData@@@?$xalloc@PAX@@QAE@ABV?$xalloc@PAVCBoneData@@@@@Z ; xalloc<void *>::xalloc<void *><CBoneData *>
PUBLIC	??0?$vector@PAVCBoneData@@V?$xalloc@PAVCBoneData@@@@@stlp_std@@QAE@ABV?$xalloc@PAVCBoneData@@@@@Z ; stlp_std::vector<CBoneData *,xalloc<CBoneData *> >::vector<CBoneData *,xalloc<CBoneData *> >
PUBLIC	??0?$xr_vector@PAVCBoneData@@V?$xalloc@PAVCBoneData@@@@@@QAE@XZ ; xr_vector<CBoneData *,xalloc<CBoneData *> >::xr_vector<CBoneData *,xalloc<CBoneData *> >
PUBLIC	??0?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@QAE@XZ ; xalloc<xr_vector<unsigned short,xalloc<unsigned short> > >::xalloc<xr_vector<unsigned short,xalloc<unsigned short> > >
PUBLIC	??0?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@QAE@ABV0@@Z ; xalloc<xr_vector<unsigned short,xalloc<unsigned short> > >::xalloc<xr_vector<unsigned short,xalloc<unsigned short> > >
PUBLIC	??0?$_STLP_alloc_proxy@PAV?$xr_vector@GV?$xalloc@G@@@@V1@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAE@ABV?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@PAV?$xr_vector@GV?$xalloc@G@@@@@Z ; stlp_std::priv::_STLP_alloc_proxy<xr_vector<unsigned short,xalloc<unsigned short> > *,xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::_STLP_alloc_proxy<xr_vector<unsigned short,xalloc<unsigned short> > *,xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >
PUBLIC	??0?$_Vector_base@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAE@ABV?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@Z ; stlp_std::priv::_Vector_base<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::_Vector_base<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >
PUBLIC	??0?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAE@ABV?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@Z ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >
PUBLIC	??0?$vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@stlp_std@@QAE@ABV?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@Z ; stlp_std::vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >
PUBLIC	??0?$xr_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@@QAE@XZ ; xr_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::xr_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >
PUBLIC	??1?$vector@PAVCBoneData@@V?$xalloc@PAVCBoneData@@@@@stlp_std@@QAE@XZ ; stlp_std::vector<CBoneData *,xalloc<CBoneData *> >::~vector<CBoneData *,xalloc<CBoneData *> >
PUBLIC	??1?$xr_vector@PAVCBoneData@@V?$xalloc@PAVCBoneData@@@@@@QAE@XZ ; xr_vector<CBoneData *,xalloc<CBoneData *> >::~xr_vector<CBoneData *,xalloc<CBoneData *> >
PUBLIC	??$xr_free@V?$xr_vector@GV?$xalloc@G@@@@@@YAXAAPAV?$xr_vector@GV?$xalloc@G@@@@@Z ; xr_free<xr_vector<unsigned short,xalloc<unsigned short> > >
PUBLIC	?deallocate@?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@QBEXPAV?$xr_vector@GV?$xalloc@G@@@@I@Z ; xalloc<xr_vector<unsigned short,xalloc<unsigned short> > >::deallocate
PUBLIC	??1?$_Vector_base@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAE@XZ ; stlp_std::priv::_Vector_base<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::~_Vector_base<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >
PUBLIC	?end@?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAEPAV?$xr_vector@GV?$xalloc@G@@@@XZ ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::end
PUBLIC	?rbegin@?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@3@XZ ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::rbegin
PUBLIC	??0?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@QAE@PAV?$xr_vector@GV?$xalloc@G@@@@@Z ; stlp_std::reverse_iterator<xr_vector<unsigned short,xalloc<unsigned short> > *>::reverse_iterator<xr_vector<unsigned short,xalloc<unsigned short> > *>
PUBLIC	?rend@?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@3@XZ ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::rend
PUBLIC	??0?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@QAE@ABV01@@Z ; stlp_std::reverse_iterator<xr_vector<unsigned short,xalloc<unsigned short> > *>::reverse_iterator<xr_vector<unsigned short,xalloc<unsigned short> > *>
PUBLIC	??D?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@QBEAAV?$xr_vector@GV?$xalloc@G@@@@XZ ; stlp_std::reverse_iterator<xr_vector<unsigned short,xalloc<unsigned short> > *>::operator*
PUBLIC	??E?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@QAEAAV01@XZ ; stlp_std::reverse_iterator<xr_vector<unsigned short,xalloc<unsigned short> > *>::operator++
PUBLIC	?base@?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@QBEPAV?$xr_vector@GV?$xalloc@G@@@@XZ ; stlp_std::reverse_iterator<xr_vector<unsigned short,xalloc<unsigned short> > *>::base
PUBLIC	??$?8PAV?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@YA_NABV?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@0@0@Z ; stlp_std::operator==<xr_vector<unsigned short,xalloc<unsigned short> > *>
PUBLIC	??$?9PAV?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@YA_NABV?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@0@0@Z ; stlp_std::operator!=<xr_vector<unsigned short,xalloc<unsigned short> > *>
PUBLIC	??_G?$xr_vector@GV?$xalloc@G@@@@QAEPAXI@Z	; xr_vector<unsigned short,xalloc<unsigned short> >::`scalar deleting destructor'
PUBLIC	??$__destroy_aux@V?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@YAXPAV?$xr_vector@GV?$xalloc@G@@@@ABU__false_type@0@@Z ; stlp_std::__destroy_aux<xr_vector<unsigned short,xalloc<unsigned short> > >
PUBLIC	??$__destroy_range_aux@V?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@V?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@YAXV?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@0@0PAV?$xr_vector@GV?$xalloc@G@@@@ABU__false_type@0@@Z ; stlp_std::__destroy_range_aux<stlp_std::reverse_iterator<xr_vector<unsigned short,xalloc<unsigned short> > *>,xr_vector<unsigned short,xalloc<unsigned short> > >
PUBLIC	??$__destroy_range@V?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@V?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@YAXV?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@0@0PAV?$xr_vector@GV?$xalloc@G@@@@@Z ; stlp_std::__destroy_range<stlp_std::reverse_iterator<xr_vector<unsigned short,xalloc<unsigned short> > *>,xr_vector<unsigned short,xalloc<unsigned short> > >
PUBLIC	??$_Destroy_Range@V?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@@stlp_std@@YAXV?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@0@0@Z ; stlp_std::_Destroy_Range<stlp_std::reverse_iterator<xr_vector<unsigned short,xalloc<unsigned short> > *> >
PUBLIC	??1?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAE@XZ ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::~_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >
PUBLIC	??1?$vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@stlp_std@@QAE@XZ ; stlp_std::vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::~vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >
PUBLIC	??1?$xr_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@@QAE@XZ ; xr_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::~xr_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >
PUBLIC	?clear@?$vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@stlp_std@@QAEXXZ ; stlp_std::vector<CLensFlareDescriptor *,xalloc<CLensFlareDescriptor *> >::clear
PUBLIC	?clear_and_free@?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@QAEXXZ ; xr_vector<CLensFlareDescriptor *,xalloc<CLensFlareDescriptor *> >::clear_and_free
PUBLIC	?clear@?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@QAEXXZ ; xr_vector<CLensFlareDescriptor *,xalloc<CLensFlareDescriptor *> >::clear
PUBLIC	??$delete_data@$0A@@?$CHelper1@VCLensFlareDescriptor@@@CDestroyer@@SAXAAVCLensFlareDescriptor@@@Z ; CDestroyer::CHelper1<CLensFlareDescriptor>::delete_data<0>
PUBLIC	??$delete_data@$0A@@?$CHelper2@VCLensFlareDescriptor@@@CDestroyer@@SAXAAVCLensFlareDescriptor@@@Z ; CDestroyer::CHelper2<CLensFlareDescriptor>::delete_data<0>
PUBLIC	??$delete_data@$0A@@?$CHelper4@VCLensFlareDescriptor@@@CDestroyer@@SAXAAVCLensFlareDescriptor@@@Z ; CDestroyer::CHelper4<CLensFlareDescriptor>::delete_data<0>
PUBLIC	??$delete_data@VCLensFlareDescriptor@@@CDestroyer@@SAXAAVCLensFlareDescriptor@@@Z ; CDestroyer::delete_data<CLensFlareDescriptor>
PUBLIC	??_GCLensFlareDescriptor@@QAEPAXI@Z		; CLensFlareDescriptor::`scalar deleting destructor'
PUBLIC	??R?$xr_special_free@$0A@VCLensFlareDescriptor@@@@QAEXAAPAVCLensFlareDescriptor@@@Z ; xr_special_free<0,CLensFlareDescriptor>::operator()
PUBLIC	??$xr_delete@VCLensFlareDescriptor@@@@YAXAAPAVCLensFlareDescriptor@@@Z ; xr_delete<CLensFlareDescriptor>
PUBLIC	??$delete_data@$00@?$CHelper2@PAVCLensFlareDescriptor@@@CDestroyer@@SAXAAPAVCLensFlareDescriptor@@@Z ; CDestroyer::CHelper2<CLensFlareDescriptor *>::delete_data<1>
PUBLIC	??$delete_data@$0A@@?$CHelper4@PAVCLensFlareDescriptor@@@CDestroyer@@SAXAAPAVCLensFlareDescriptor@@@Z ; CDestroyer::CHelper4<CLensFlareDescriptor *>::delete_data<0>
PUBLIC	??$delete_data@PAVCLensFlareDescriptor@@@CDestroyer@@SAXAAPAVCLensFlareDescriptor@@@Z ; CDestroyer::delete_data<CLensFlareDescriptor *>
PUBLIC	??$delete_data@V?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@@CHelper3@CDestroyer@@SAXAAV?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@@Z ; CDestroyer::CHelper3::delete_data<xr_vector<CLensFlareDescriptor *,xalloc<CLensFlareDescriptor *> > >
PUBLIC	??$delete_data@$00@?$CHelper4@V?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@@CDestroyer@@SAXAAV?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@@Z ; CDestroyer::CHelper4<xr_vector<CLensFlareDescriptor *,xalloc<CLensFlareDescriptor *> > >::delete_data<1>
PUBLIC	??$delete_data@V?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@@CDestroyer@@SAXAAV?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@@Z ; CDestroyer::delete_data<xr_vector<CLensFlareDescriptor *,xalloc<CLensFlareDescriptor *> > >
PUBLIC	??$delete_data@V?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@@@YAXABV?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@@Z ; delete_data<xr_vector<CLensFlareDescriptor *,xalloc<CLensFlareDescriptor *> > >
PUBLIC	?set@?$_color@M@@QAEAAU1@I@Z			; _color<float>::set
PUBLIC	??0?$FactoryPtr@VILensFlareRender@@@@QAE@XZ	; FactoryPtr<ILensFlareRender>::FactoryPtr<ILensFlareRender>
PUBLIC	??0ray_cache@collide@@QAE@XZ			; collide::ray_cache::ray_cache
PUBLIC	??0?$xalloc@Urq_result@collide@@@@QAE@XZ	; xalloc<collide::rq_result>::xalloc<collide::rq_result>
PUBLIC	??0?$_Vector_base@Urq_result@collide@@V?$xalloc@Urq_result@collide@@@@@priv@stlp_std@@QAE@ABV?$xalloc@Urq_result@collide@@@@@Z ; stlp_std::priv::_Vector_base<collide::rq_result,xalloc<collide::rq_result> >::_Vector_base<collide::rq_result,xalloc<collide::rq_result> >
PUBLIC	??0?$_Impl_vector@Urq_result@collide@@V?$xalloc@Urq_result@collide@@@@@priv@stlp_std@@QAE@ABV?$xalloc@Urq_result@collide@@@@@Z ; stlp_std::priv::_Impl_vector<collide::rq_result,xalloc<collide::rq_result> >::_Impl_vector<collide::rq_result,xalloc<collide::rq_result> >
PUBLIC	??0?$vector@Urq_result@collide@@V?$xalloc@Urq_result@collide@@@@@stlp_std@@QAE@ABV?$xalloc@Urq_result@collide@@@@@Z ; stlp_std::vector<collide::rq_result,xalloc<collide::rq_result> >::vector<collide::rq_result,xalloc<collide::rq_result> >
PUBLIC	??0?$xr_vector@Urq_result@collide@@V?$xalloc@Urq_result@collide@@@@@@QAE@XZ ; xr_vector<collide::rq_result,xalloc<collide::rq_result> >::xr_vector<collide::rq_result,xalloc<collide::rq_result> >
PUBLIC	??0rq_results@collide@@QAE@XZ			; collide::rq_results::rq_results
PUBLIC	??0?$xalloc@PAVCLensFlareDescriptor@@@@QAE@XZ	; xalloc<CLensFlareDescriptor *>::xalloc<CLensFlareDescriptor *>
PUBLIC	??$?0PAVCLensFlareDescriptor@@@?$xalloc@PAX@@QAE@ABV?$xalloc@PAVCLensFlareDescriptor@@@@@Z ; xalloc<void *>::xalloc<void *><CLensFlareDescriptor *>
PUBLIC	??0?$vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@stlp_std@@QAE@ABV?$xalloc@PAVCLensFlareDescriptor@@@@@Z ; stlp_std::vector<CLensFlareDescriptor *,xalloc<CLensFlareDescriptor *> >::vector<CLensFlareDescriptor *,xalloc<CLensFlareDescriptor *> >
PUBLIC	??0?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@QAE@XZ ; xr_vector<CLensFlareDescriptor *,xalloc<CLensFlareDescriptor *> >::xr_vector<CLensFlareDescriptor *,xalloc<CLensFlareDescriptor *> >
PUBLIC	??$_Copy_Construct@G@stlp_std@@YAXPAGABG@Z	; stlp_std::_Copy_Construct<unsigned short>
PUBLIC	?push_back@?$_Impl_vector@GV?$xalloc@G@@@priv@stlp_std@@QAEXABG@Z ; stlp_std::priv::_Impl_vector<unsigned short,xalloc<unsigned short> >::push_back
PUBLIC	?push_back@?$vector@GV?$xalloc@G@@@stlp_std@@QAEXABG@Z ; stlp_std::vector<unsigned short,xalloc<unsigned short> >::push_back
PUBLIC	?begin@?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAEPAV?$xr_vector@GV?$xalloc@G@@@@XZ ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::begin
PUBLIC	?to_value_type_ptr@?$_CastTraits@V?$xr_vector@GV?$xalloc@G@@@@V1@@priv@stlp_std@@SAPAV?$xr_vector@GV?$xalloc@G@@@@PAV4@@Z ; stlp_std::priv::_CastTraits<xr_vector<unsigned short,xalloc<unsigned short> >,xr_vector<unsigned short,xalloc<unsigned short> > >::to_value_type_ptr
PUBLIC	?begin@?$vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@stlp_std@@QAEPAV?$xr_vector@GV?$xalloc@G@@@@XZ ; stlp_std::vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::begin
PUBLIC	??A?$xr_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@@QAEAAV?$xr_vector@GV?$xalloc@G@@@@I@Z ; xr_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::operator[]
PUBLIC	?mul@?$_vector3@M@@QAEAAU1@ABU1@M@Z		; _vector3<float>::mul
PUBLIC	?transform@?$_matrix@M@@QBEXAAU?$_vector3@M@@ABU2@@Z ; _matrix<float>::transform
PUBLIC	?set@?$_color@M@@QAEAAU1@MMMM@Z			; _color<float>::set
PUBLIC	?magnitude_sqr_rgb@?$_color@M@@QBEMXZ		; _color<float>::magnitude_sqr_rgb
PUBLIC	?magnitude_rgb@?$_color@M@@QBEMXZ		; _color<float>::magnitude_rgb
PUBLIC	?is@?$_flags@I@@QBEHI@Z				; _flags<unsigned int>::is
PUBLIC	?similar@ray_cache@collide@@QAEHABU?$_vector3@M@@0M@Z ; collide::ray_cache::similar
PUBLIC	??0ray_defs@collide@@QAE@ABU?$_vector3@M@@0MIW4rq_target@1@@Z ; collide::ray_defs::ray_defs
PUBLIC	?begin@?$vector@Urq_result@collide@@V?$xalloc@Urq_result@collide@@@@@stlp_std@@QAEPAUrq_result@collide@@XZ ; stlp_std::vector<collide::rq_result,xalloc<collide::rq_result> >::begin
PUBLIC	?end@?$vector@Urq_result@collide@@V?$xalloc@Urq_result@collide@@@@@stlp_std@@QAEPAUrq_result@collide@@XZ ; stlp_std::vector<collide::rq_result,xalloc<collide::rq_result> >::end
PUBLIC	??$__copy_ptrs@PAUrq_result@collide@@PAU12@@priv@stlp_std@@YAPAUrq_result@collide@@PAU23@00ABU__true_type@1@@Z ; stlp_std::priv::__copy_ptrs<collide::rq_result *,collide::rq_result *>
PUBLIC	?_M_erase@?$_Impl_vector@Urq_result@collide@@V?$xalloc@Urq_result@collide@@@@@priv@stlp_std@@AAEPAUrq_result@collide@@PAU45@0ABU__false_type@3@@Z ; stlp_std::priv::_Impl_vector<collide::rq_result,xalloc<collide::rq_result> >::_M_erase
PUBLIC	?erase@?$_Impl_vector@Urq_result@collide@@V?$xalloc@Urq_result@collide@@@@@priv@stlp_std@@QAEPAUrq_result@collide@@PAU45@0@Z ; stlp_std::priv::_Impl_vector<collide::rq_result,xalloc<collide::rq_result> >::erase
PUBLIC	?to_value_type_ptr@?$_CastTraits@Urq_result@collide@@U12@@priv@stlp_std@@SAPAUrq_result@collide@@PAU45@@Z ; stlp_std::priv::_CastTraits<collide::rq_result,collide::rq_result>::to_value_type_ptr
PUBLIC	?to_storage_type_ptr@?$_CastTraits@Urq_result@collide@@U12@@priv@stlp_std@@SAPAUrq_result@collide@@PAU45@@Z ; stlp_std::priv::_CastTraits<collide::rq_result,collide::rq_result>::to_storage_type_ptr
PUBLIC	?erase@?$vector@Urq_result@collide@@V?$xalloc@Urq_result@collide@@@@@stlp_std@@QAEPAUrq_result@collide@@PAU34@0@Z ; stlp_std::vector<collide::rq_result,xalloc<collide::rq_result> >::erase
PUBLIC	?clear_not_free@?$xr_vector@Urq_result@collide@@V?$xalloc@Urq_result@collide@@@@@@QAEXXZ ; xr_vector<collide::rq_result,xalloc<collide::rq_result> >::clear_not_free
PUBLIC	?r_clear@rq_results@collide@@QAEXXZ		; collide::rq_results::r_clear
PUBLIC	?crossproduct@?$_vector3@M@@QAEAAU1@ABU1@0@Z	; _vector3<float>::crossproduct
PUBLIC	?TestRayTri@CDB@@YA_NABU?$_vector3@M@@0PAU2@AAM22_N@Z ; CDB::TestRayTri
PUBLIC	??0STranspParam@@QAE@PAUray_cache@collide@@ABU?$_vector3@M@@1MM@Z ; STranspParam::STranspParam
PUBLIC	?set@ray_cache@collide@@QAEXABU?$_vector3@M@@0MH@Z ; collide::ray_cache::set
PUBLIC	?PKinematics@@YAPAVIKinematics@@PAVIRenderVisual@@@Z ; PKinematics
PUBLIC	?material_callback@@YAHAAUrq_result@collide@@PAX@Z ; material_callback
PUBLIC	?blend_lerp@@YAXAAMMMM@Z			; blend_lerp
PUBLIC	??C?$FactoryPtr@VILensFlareRender@@@@QBEPAVILensFlareRender@@XZ ; FactoryPtr<ILensFlareRender>::operator->
PUBLIC	??_C@_0L@IBFLOEPG@sun_shader?$AA@		; `string'
PUBLIC	??_C@_0M@DDOHGILI@sun_texture?$AA@		; `string'
PUBLIC	??_C@_0L@DPJEHLBG@sun_radius?$AA@		; `string'
PUBLIC	??_C@_0BB@KEICPONN@sun_ignore_color?$AA@	; `string'
PUBLIC	??_C@_06NKKJIDGL@flares?$AA@			; `string'
PUBLIC	??_C@_0N@PAPFMPDM@flare_shader?$AA@		; `string'
PUBLIC	??_C@_0P@FMDCEBMJ@flare_textures?$AA@		; `string'
PUBLIC	??_C@_0N@EODKFANM@flare_radius?$AA@		; `string'
PUBLIC	??_C@_0O@FCDMKCCA@flare_opacity?$AA@		; `string'
PUBLIC	??_C@_0P@GFNCFJFG@flare_position?$AA@		; `string'
PUBLIC	??_C@_08OAOFNDBJ@gradient?$AA@			; `string'
PUBLIC	??_C@_0BA@KGIFDEPG@gradient_shader?$AA@		; `string'
PUBLIC	??_C@_0BB@DDMALGGI@gradient_texture?$AA@	; `string'
PUBLIC	??_C@_0BA@BIEKKLBG@gradient_radius?$AA@		; `string'
PUBLIC	??_C@_0BB@CJNLPJHF@gradient_opacity?$AA@	; `string'
PUBLIC	??_C@_0BA@IABLKNCI@blend_rise_time?$AA@		; `string'
PUBLIC	??_C@_0BA@FPPMHPAN@blend_down_time?$AA@		; `string'
PUBLIC	??_C@_0BE@BKKMFBAJ@CLensFlare?3?3OnFrame?$AA@	; `string'
PUBLIC	??_C@_0DI@CJHPJF@D?3?2CLEARSKY?2sources?2engine?2xrEng@ ; `string'
PUBLIC	??_C@_0DN@GMMKOHAN@_valid?$CIg_pGamePersistent?9?$DOEnviro@ ; `string'
PUBLIC	??_C@_0BA@NBGGFCFO@_valid?$CIvSunDir?$CJ?$AA@	; `string'
PUBLIC	??_C@_0N@JEGHJCIB@_valid?$CIvecX?$CJ?$AA@	; `string'
PUBLIC	??_C@_0N@JFKFPILG@_valid?$CIvecY?$CJ?$AA@	; `string'
PUBLIC	??_C@_0N@NAKPNABC@_valid?$CITP?4P?$CJ?$AA@	; `string'
PUBLIC	??_C@_0N@MLIANLLO@_valid?$CITP?4D?$CJ?$AA@	; `string'
PUBLIC	??_7IBoneData@@6B@				; IBoneData::`vftable'
PUBLIC	??_7CBoneData@@6B@				; CBoneData::`vftable'
EXTRN	__imp_?IsBOOL@CInifile@@SAHPBD@Z:PROC
EXTRN	__imp_?r_bool@CInifile@@QBEHPBD0@Z:PROC
EXTRN	__imp_?RayQuery@CObjectSpace@@QAEHAAVrq_results@collide@@ABUray_defs@3@P6AHAAUrq_result@3@PAX@Z3P6AH1PAVCObject@@3@Z5@Z:PROC
EXTRN	__imp_?get_tris@MODEL@CDB@@QAEPAVTRI@2@XZ:PROC
EXTRN	__imp_?GetStaticTris@CObjectSpace@@QAEPAVTRI@CDB@@XZ:PROC
EXTRN	__imp_?get_verts@MODEL@CDB@@QAEPAU?$_vector3@M@@XZ:PROC
EXTRN	__imp_?GetStaticVerts@CObjectSpace@@QAEPAU?$_vector3@M@@XZ:PROC
;	COMDAT ?ignore_always@?7??OnFrame@CLensFlare@@QAEXVshared_str@@@Z@4_NA
_BSS	SEGMENT
?ignore_always@?7??OnFrame@CLensFlare@@QAEXVshared_str@@@Z@4_NA DB 01H DUP (?) ; `CLensFlare::OnFrame'::`8'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?M@??OnFrame@CLensFlare@@QAEXVshared_str@@@Z@4_NA
_BSS	SEGMENT
?ignore_always@?M@??OnFrame@CLensFlare@@QAEXVshared_str@@@Z@4_NA DB 01H DUP (?) ; `CLensFlare::OnFrame'::`12'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?CA@??OnFrame@CLensFlare@@QAEXVshared_str@@@Z@4_NA
_BSS	SEGMENT
?ignore_always@?CA@??OnFrame@CLensFlare@@QAEXVshared_str@@@Z@4_NA DB 01H DUP (?) ; `CLensFlare::OnFrame'::`32'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?CE@??OnFrame@CLensFlare@@QAEXVshared_str@@@Z@4_NA
_BSS	SEGMENT
?ignore_always@?CE@??OnFrame@CLensFlare@@QAEXVshared_str@@@Z@4_NA DB 01H DUP (?) ; `CLensFlare::OnFrame'::`36'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?CI@??OnFrame@CLensFlare@@QAEXVshared_str@@@Z@4_NA
_BSS	SEGMENT
?ignore_always@?CI@??OnFrame@CLensFlare@@QAEXVshared_str@@@Z@4_NA DB 01H DUP (?) ; `CLensFlare::OnFrame'::`40'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?CM@??OnFrame@CLensFlare@@QAEXVshared_str@@@Z@4_NA
_BSS	SEGMENT
?ignore_always@?CM@??OnFrame@CLensFlare@@QAEXVshared_str@@@Z@4_NA DB 01H DUP (?) ; `CLensFlare::OnFrame'::`44'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?DA@??OnFrame@CLensFlare@@QAEXVshared_str@@@Z@4_NA
_BSS	SEGMENT
?ignore_always@?DA@??OnFrame@CLensFlare@@QAEXVshared_str@@@Z@4_NA DB 01H DUP (?) ; `CLensFlare::OnFrame'::`48'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?DG@??OnFrame@CLensFlare@@QAEXVshared_str@@@Z@4_NA
_BSS	SEGMENT
?ignore_always@?DG@??OnFrame@CLensFlare@@QAEXVshared_str@@@Z@4_NA DB 01H DUP (?) ; `CLensFlare::OnFrame'::`54'::ignore_always
;	COMDAT ??_7CBoneData@@6B@
CONST	SEGMENT
??_7CBoneData@@6B@ DD FLAT:??_R4CBoneData@@6B@		; CBoneData::`vftable'
	DD	FLAT:?GetChild@CBoneData@@EBGABVIBoneData@@G@Z
	DD	FLAT:?GetChild@CBoneData@@EAGAAVIBoneData@@G@Z
	DD	FLAT:?GetSelfID@CBoneData@@UBGGXZ
	DD	FLAT:?GetNumChildren@CBoneData@@EBGGXZ
	DD	FLAT:?get_IK_data@CBoneData@@EBGABUSJointIKData@@XZ
	DD	FLAT:?get_bind_transform@CBoneData@@EBGABU?$_matrix@M@@XZ
	DD	FLAT:?get_shape@CBoneData@@EBGABUSBoneShape@@XZ
	DD	FLAT:?get_obb@CBoneData@@EBGABU?$_obb@M@@XZ
	DD	FLAT:?get_center_of_mass@CBoneData@@EBGABU?$_vector3@M@@XZ
	DD	FLAT:?get_mass@CBoneData@@EBGMXZ
	DD	FLAT:?get_game_mtl_idx@CBoneData@@EBGGXZ
	DD	FLAT:?GetParentID@CBoneData@@UBGGXZ
	DD	FLAT:?lo_limit@CBoneData@@EBGME@Z
	DD	FLAT:?hi_limit@CBoneData@@EBGME@Z
	DD	FLAT:??_ECBoneData@@UAEPAXI@Z
	DD	FLAT:?mem_usage@CBoneData@@UAEIXZ
CONST	ENDS
;	COMDAT ??_R4CBoneData@@6B@
rdata$r	SEGMENT
??_R4CBoneData@@6B@ DD 00H				; CBoneData::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCBoneData@@@8
	DD	FLAT:??_R3CBoneData@@8
rdata$r	ENDS
;	COMDAT ??_R3CBoneData@@8
rdata$r	SEGMENT
??_R3CBoneData@@8 DD 00H				; CBoneData::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CBoneData@@8
rdata$r	ENDS
;	COMDAT ??_R2CBoneData@@8
rdata$r	SEGMENT
??_R2CBoneData@@8 DD FLAT:??_R1A@?0A@EA@CBoneData@@8	; CBoneData::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IBoneData@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CBoneData@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CBoneData@@8 DD FLAT:??_R0?AVCBoneData@@@8 ; CBoneData::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CBoneData@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCBoneData@@@8
_DATA	SEGMENT
??_R0?AVCBoneData@@@8 DD FLAT:??_7type_info@@6B@	; CBoneData `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCBoneData@@', 00H
_DATA	ENDS
;	COMDAT ??_7IBoneData@@6B@
CONST	SEGMENT
??_7IBoneData@@6B@ DD FLAT:??_R4IBoneData@@6B@		; IBoneData::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_R4IBoneData@@6B@
rdata$r	SEGMENT
??_R4IBoneData@@6B@ DD 00H				; IBoneData::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVIBoneData@@@8
	DD	FLAT:??_R3IBoneData@@8
rdata$r	ENDS
;	COMDAT ??_R3IBoneData@@8
rdata$r	SEGMENT
??_R3IBoneData@@8 DD 00H				; IBoneData::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2IBoneData@@8
rdata$r	ENDS
;	COMDAT ??_R2IBoneData@@8
rdata$r	SEGMENT
??_R2IBoneData@@8 DD FLAT:??_R1A@?0A@EA@IBoneData@@8	; IBoneData::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@IBoneData@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IBoneData@@8 DD FLAT:??_R0?AVIBoneData@@@8 ; IBoneData::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IBoneData@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVIBoneData@@@8
_DATA	SEGMENT
??_R0?AVIBoneData@@@8 DD FLAT:??_7type_info@@6B@	; IBoneData `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVIBoneData@@', 00H
_DATA	ENDS
;	COMDAT ??_C@_0N@MLIANLLO@_valid?$CITP?4D?$CJ?$AA@
CONST	SEGMENT
??_C@_0N@MLIANLLO@_valid?$CITP?4D?$CJ?$AA@ DB '_valid(TP.D)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NAKPNABC@_valid?$CITP?4P?$CJ?$AA@
CONST	SEGMENT
??_C@_0N@NAKPNABC@_valid?$CITP?4P?$CJ?$AA@ DB '_valid(TP.P)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JFKFPILG@_valid?$CIvecY?$CJ?$AA@
CONST	SEGMENT
??_C@_0N@JFKFPILG@_valid?$CIvecY?$CJ?$AA@ DB '_valid(vecY)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JEGHJCIB@_valid?$CIvecX?$CJ?$AA@
CONST	SEGMENT
??_C@_0N@JEGHJCIB@_valid?$CIvecX?$CJ?$AA@ DB '_valid(vecX)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NBGGFCFO@_valid?$CIvSunDir?$CJ?$AA@
CONST	SEGMENT
??_C@_0BA@NBGGFCFO@_valid?$CIvSunDir?$CJ?$AA@ DB '_valid(vSunDir)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@GMMKOHAN@_valid?$CIg_pGamePersistent?9?$DOEnviro@
CONST	SEGMENT
??_C@_0DN@GMMKOHAN@_valid?$CIg_pGamePersistent?9?$DOEnviro@ DB '_valid(g_'
	DB	'pGamePersistent->Environment().CurrentEnv->sun_dir)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@CJHPJF@D?3?2CLEARSKY?2sources?2engine?2xrEng@
CONST	SEGMENT
??_C@_0DI@CJHPJF@D?3?2CLEARSKY?2sources?2engine?2xrEng@ DB 'D:\CLEARSKY\s'
	DB	'ources\engine\xrEngine\xr_efflensflare.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BKKMFBAJ@CLensFlare?3?3OnFrame?$AA@
CONST	SEGMENT
??_C@_0BE@BKKMFBAJ@CLensFlare?3?3OnFrame?$AA@ DB 'CLensFlare::OnFrame', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FPPMHPAN@blend_down_time?$AA@
CONST	SEGMENT
??_C@_0BA@FPPMHPAN@blend_down_time?$AA@ DB 'blend_down_time', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IABLKNCI@blend_rise_time?$AA@
CONST	SEGMENT
??_C@_0BA@IABLKNCI@blend_rise_time?$AA@ DB 'blend_rise_time', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CJNLPJHF@gradient_opacity?$AA@
CONST	SEGMENT
??_C@_0BB@CJNLPJHF@gradient_opacity?$AA@ DB 'gradient_opacity', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BIEKKLBG@gradient_radius?$AA@
CONST	SEGMENT
??_C@_0BA@BIEKKLBG@gradient_radius?$AA@ DB 'gradient_radius', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DDMALGGI@gradient_texture?$AA@
CONST	SEGMENT
??_C@_0BB@DDMALGGI@gradient_texture?$AA@ DB 'gradient_texture', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KGIFDEPG@gradient_shader?$AA@
CONST	SEGMENT
??_C@_0BA@KGIFDEPG@gradient_shader?$AA@ DB 'gradient_shader', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08OAOFNDBJ@gradient?$AA@
CONST	SEGMENT
??_C@_08OAOFNDBJ@gradient?$AA@ DB 'gradient', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GFNCFJFG@flare_position?$AA@
CONST	SEGMENT
??_C@_0P@GFNCFJFG@flare_position?$AA@ DB 'flare_position', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FCDMKCCA@flare_opacity?$AA@
CONST	SEGMENT
??_C@_0O@FCDMKCCA@flare_opacity?$AA@ DB 'flare_opacity', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EODKFANM@flare_radius?$AA@
CONST	SEGMENT
??_C@_0N@EODKFANM@flare_radius?$AA@ DB 'flare_radius', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FMDCEBMJ@flare_textures?$AA@
CONST	SEGMENT
??_C@_0P@FMDCEBMJ@flare_textures?$AA@ DB 'flare_textures', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PAPFMPDM@flare_shader?$AA@
CONST	SEGMENT
??_C@_0N@PAPFMPDM@flare_shader?$AA@ DB 'flare_shader', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06NKKJIDGL@flares?$AA@
CONST	SEGMENT
??_C@_06NKKJIDGL@flares?$AA@ DB 'flares', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KEICPONN@sun_ignore_color?$AA@
CONST	SEGMENT
??_C@_0BB@KEICPONN@sun_ignore_color?$AA@ DB 'sun_ignore_color', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DPJEHLBG@sun_radius?$AA@
CONST	SEGMENT
??_C@_0L@DPJEHLBG@sun_radius?$AA@ DB 'sun_radius', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DDOHGILI@sun_texture?$AA@
CONST	SEGMENT
??_C@_0M@DDOHGILI@sun_texture?$AA@ DB 'sun_texture', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IBFLOEPG@sun_shader?$AA@
CONST	SEGMENT
??_C@_0L@IBFLOEPG@sun_shader?$AA@ DB 'sun_shader', 00H	; `string'
_RayDeltas DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	0bf800000r			; -1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0bf800000r			; -1
	DD	000000000r			; 0
	DD	03f800000r			; 1
_EPS_S	DD	033d6bf95r			; 1e-007
_EPS	DD	03727c5acr			; 1e-005
_EPS_L	DD	03a83126fr			; 0.001
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrserverentities\object_destroyer.h
;	COMDAT ??$delete_data@$0A@@?$CHelper1@VCLensFlareDescriptor@@@CDestroyer@@SAXAAVCLensFlareDescriptor@@@Z
_TEXT	SEGMENT
??$delete_data@$0A@@?$CHelper1@VCLensFlareDescriptor@@@CDestroyer@@SAXAAVCLensFlareDescriptor@@@Z PROC ; CDestroyer::CHelper1<CLensFlareDescriptor>::delete_data<0>, COMDAT

; 87   : 		{
; 88   : 		}

	ret	0
??$delete_data@$0A@@?$CHelper1@VCLensFlareDescriptor@@@CDestroyer@@SAXAAVCLensFlareDescriptor@@@Z ENDP ; CDestroyer::CHelper1<CLensFlareDescriptor>::delete_data<0>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$delete_data@$0A@@?$CHelper2@VCLensFlareDescriptor@@@CDestroyer@@SAXAAVCLensFlareDescriptor@@@Z
_TEXT	SEGMENT
??$delete_data@$0A@@?$CHelper2@VCLensFlareDescriptor@@@CDestroyer@@SAXAAVCLensFlareDescriptor@@@Z PROC ; CDestroyer::CHelper2<CLensFlareDescriptor>::delete_data<0>, COMDAT

; 101  : 		{
; 102  : 			CHelper1<T>::delete_data<object_type_traits::is_base_and_derived<IPureDestroyableObject,T>::value>(data);
; 103  : 		}

	ret	0
??$delete_data@$0A@@?$CHelper2@VCLensFlareDescriptor@@@CDestroyer@@SAXAAVCLensFlareDescriptor@@@Z ENDP ; CDestroyer::CHelper2<CLensFlareDescriptor>::delete_data<0>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$delete_data@$0A@@?$CHelper4@VCLensFlareDescriptor@@@CDestroyer@@SAXAAVCLensFlareDescriptor@@@Z
_TEXT	SEGMENT
??$delete_data@$0A@@?$CHelper4@VCLensFlareDescriptor@@@CDestroyer@@SAXAAVCLensFlareDescriptor@@@Z PROC ; CDestroyer::CHelper4<CLensFlareDescriptor>::delete_data<0>, COMDAT

; 130  : 		{
; 131  : 			CHelper2<T>::delete_data<object_type_traits::is_pointer<T>::value>	(data);
; 132  : 		}

	ret	0
??$delete_data@$0A@@?$CHelper4@VCLensFlareDescriptor@@@CDestroyer@@SAXAAVCLensFlareDescriptor@@@Z ENDP ; CDestroyer::CHelper4<CLensFlareDescriptor>::delete_data<0>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$delete_data@VCLensFlareDescriptor@@@CDestroyer@@SAXAAVCLensFlareDescriptor@@@Z
_TEXT	SEGMENT
??$delete_data@VCLensFlareDescriptor@@@CDestroyer@@SAXAAVCLensFlareDescriptor@@@Z PROC ; CDestroyer::delete_data<CLensFlareDescriptor>, COMDAT

; 144  : 		CHelper4<T>::delete_data<object_type_traits::is_stl_container<T>::value>(data);
; 145  : 	}

	ret	0
??$delete_data@VCLensFlareDescriptor@@@CDestroyer@@SAXAAVCLensFlareDescriptor@@@Z ENDP ; CDestroyer::delete_data<CLensFlareDescriptor>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_iterator.h
_TEXT	ENDS
;	COMDAT ?base@?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@QBEPAV?$xr_vector@GV?$xalloc@G@@@@XZ
_TEXT	SEGMENT
?base@?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@QBEPAV?$xr_vector@GV?$xalloc@G@@@@XZ PROC ; stlp_std::reverse_iterator<xr_vector<unsigned short,xalloc<unsigned short> > *>::base, COMDAT
; _this$ = eax

; 75   :   iterator_type base() const { return current; }

	mov	eax, DWORD PTR [eax]
	ret	0
?base@?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@QBEPAV?$xr_vector@GV?$xalloc@G@@@@XZ ENDP ; stlp_std::reverse_iterator<xr_vector<unsigned short,xalloc<unsigned short> > *>::base
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?8PAV?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@YA_NABV?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@0@0@Z
_TEXT	SEGMENT
??$?8PAV?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@YA_NABV?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@0@0@Z PROC ; stlp_std::operator==<xr_vector<unsigned short,xalloc<unsigned short> > *>, COMDAT
; ___x$ = eax
; ___y$ = edx

; 116  : { return __x.base() == __y.base(); }

	mov	ecx, DWORD PTR [eax]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx]
	sete	al
	ret	0
??$?8PAV?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@YA_NABV?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@0@0@Z ENDP ; stlp_std::operator==<xr_vector<unsigned short,xalloc<unsigned short> > *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\type_traits.h
_TEXT	ENDS
;	COMDAT ??$_UseTrivialUCopy@V?$xr_vector@GV?$xalloc@G@@@@V1@@stlp_std@@YA?AU?$_TrivialUCopy@V?$xr_vector@GV?$xalloc@G@@@@V1@@0@PAV?$xr_vector@GV?$xalloc@G@@@@0@Z
_TEXT	SEGMENT
??$_UseTrivialUCopy@V?$xr_vector@GV?$xalloc@G@@@@V1@@stlp_std@@YA?AU?$_TrivialUCopy@V?$xr_vector@GV?$xalloc@G@@@@V1@@0@PAV?$xr_vector@GV?$xalloc@G@@@@0@Z PROC ; stlp_std::_UseTrivialUCopy<xr_vector<unsigned short,xalloc<unsigned short> >,xr_vector<unsigned short,xalloc<unsigned short> > >, COMDAT

; 489  : { return _TrivialUCopy<_Src, _Dst>(); }

	xor	al, al
	ret	0
??$_UseTrivialUCopy@V?$xr_vector@GV?$xalloc@G@@@@V1@@stlp_std@@YA?AU?$_TrivialUCopy@V?$xr_vector@GV?$xalloc@G@@@@V1@@0@PAV?$xr_vector@GV?$xalloc@G@@@@0@Z ENDP ; stlp_std::_UseTrivialUCopy<xr_vector<unsigned short,xalloc<unsigned short> >,xr_vector<unsigned short,xalloc<unsigned short> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Answer@?$_TrivialUCopy@V?$xr_vector@GV?$xalloc@G@@@@V1@@stlp_std@@SA?AU__false_type@2@XZ
_TEXT	SEGMENT
?_Answer@?$_TrivialUCopy@V?$xr_vector@GV?$xalloc@G@@@@V1@@stlp_std@@SA?AU__false_type@2@XZ PROC ; stlp_std::_TrivialUCopy<xr_vector<unsigned short,xalloc<unsigned short> >,xr_vector<unsigned short,xalloc<unsigned short> > >::_Answer, COMDAT

; 407  :   static _Ret _Answer() { return _Ret(); }

	xor	al, al
	ret	0
?_Answer@?$_TrivialUCopy@V?$xr_vector@GV?$xalloc@G@@@@V1@@stlp_std@@SA?AU__false_type@2@XZ ENDP ; stlp_std::_TrivialUCopy<xr_vector<unsigned short,xalloc<unsigned short> >,xr_vector<unsigned short,xalloc<unsigned short> > >::_Answer
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_iterator.h
_TEXT	ENDS
;	COMDAT ??$?9PAV?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@YA_NABV?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@0@0@Z
_TEXT	SEGMENT
??$?9PAV?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@YA_NABV?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@0@0@Z PROC ; stlp_std::operator!=<xr_vector<unsigned short,xalloc<unsigned short> > *>, COMDAT
; ___x$ = eax
; ___y$ = edx

; 127  : { return !(__x == __y); }

	mov	ecx, DWORD PTR [eax]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx]
	setne	al
	ret	0
??$?9PAV?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@YA_NABV?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@0@0@Z ENDP ; stlp_std::operator!=<xr_vector<unsigned short,xalloc<unsigned short> > *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\type_traits.h
_TEXT	ENDS
;	COMDAT ?_Answer@?$_BothPtrType@PBV?$xr_vector@GV?$xalloc@G@@@@PAV1@@stlp_std@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT
?_Answer@?$_BothPtrType@PBV?$xr_vector@GV?$xalloc@G@@@@PAV1@@stlp_std@@SA?AU__true_type@2@XZ PROC ; stlp_std::_BothPtrType<xr_vector<unsigned short,xalloc<unsigned short> > const *,xr_vector<unsigned short,xalloc<unsigned short> > *>::_Answer, COMDAT

; 468  :   static _Ret _Answer() { return _Ret(); }

	xor	al, al
	ret	0
?_Answer@?$_BothPtrType@PBV?$xr_vector@GV?$xalloc@G@@@@PAV1@@stlp_std@@SA?AU__true_type@2@XZ ENDP ; stlp_std::_BothPtrType<xr_vector<unsigned short,xalloc<unsigned short> > const *,xr_vector<unsigned short,xalloc<unsigned short> > *>::_Answer
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_iterator.h
_TEXT	ENDS
;	COMDAT ??E?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@QAEAAV01@XZ PROC ; stlp_std::reverse_iterator<xr_vector<unsigned short,xalloc<unsigned short> > *>::operator++, COMDAT
; _this$ = eax

; 82   :     --current;

	add	DWORD PTR [eax], -12			; fffffff4H

; 83   :     return *this;
; 84   :   }

	ret	0
??E?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@QAEAAV01@XZ ENDP ; stlp_std::reverse_iterator<xr_vector<unsigned short,xalloc<unsigned short> > *>::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??D?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@QBEAAV?$xr_vector@GV?$xalloc@G@@@@XZ
_TEXT	SEGMENT
??D?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@QBEAAV?$xr_vector@GV?$xalloc@G@@@@XZ PROC ; stlp_std::reverse_iterator<xr_vector<unsigned short,xalloc<unsigned short> > *>::operator*, COMDAT
; _this$ = eax

; 77   :     _Iterator __tmp = current;
; 78   :     return *--__tmp;

	mov	eax, DWORD PTR [eax]
	sub	eax, 12					; 0000000cH

; 79   :   }

	ret	0
??D?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@QBEAAV?$xr_vector@GV?$xalloc@G@@@@XZ ENDP ; stlp_std::reverse_iterator<xr_vector<unsigned short,xalloc<unsigned short> > *>::operator*
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@QAE@ABV01@@Z PROC ; stlp_std::reverse_iterator<xr_vector<unsigned short,xalloc<unsigned short> > *>::reverse_iterator<xr_vector<unsigned short,xalloc<unsigned short> > *>, COMDAT
; _this$ = eax
; ___x$ = ecx

; 66   :   reverse_iterator(const _Self& __x) : current(__x.current) {}

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	ret	0
??0?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@QAE@ABV01@@Z ENDP ; stlp_std::reverse_iterator<xr_vector<unsigned short,xalloc<unsigned short> > *>::reverse_iterator<xr_vector<unsigned short,xalloc<unsigned short> > *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ?capacity@?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QBEIXZ PROC ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::capacity, COMDAT
; _this$ = eax

; 187  :   size_type capacity() const    { return size_type(this->_M_end_of_storage._M_data - this->_M_start); }

	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR [eax]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	ret	0
?capacity@?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QBEIXZ ENDP ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::capacity
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_M_set@?$_Impl_vector@USFlare@CLensFlareDescriptor@@V?$xalloc@USFlare@CLensFlareDescriptor@@@@@priv@stlp_std@@AAEXPAUSFlare@CLensFlareDescriptor@@00@Z
_TEXT	SEGMENT
___e$ = 8						; size = 4
?_M_set@?$_Impl_vector@USFlare@CLensFlareDescriptor@@V?$xalloc@USFlare@CLensFlareDescriptor@@@@@priv@stlp_std@@AAEXPAUSFlare@CLensFlareDescriptor@@00@Z PROC ; stlp_std::priv::_Impl_vector<CLensFlareDescriptor::SFlare,xalloc<CLensFlareDescriptor::SFlare> >::_M_set, COMDAT
; _this$ = eax
; ___s$ = ecx
; ___f$ = edx

; 626  :     this->_M_start = __s;

	mov	DWORD PTR [eax], ecx

; 627  :     this->_M_finish = __f;
; 628  :     this->_M_end_of_storage._M_data = __e;

	mov	ecx, DWORD PTR ___e$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], ecx

; 629  :   }

	ret	4
?_M_set@?$_Impl_vector@USFlare@CLensFlareDescriptor@@V?$xalloc@USFlare@CLensFlareDescriptor@@@@@priv@stlp_std@@AAEXPAUSFlare@CLensFlareDescriptor@@00@Z ENDP ; stlp_std::priv::_Impl_vector<CLensFlareDescriptor::SFlare,xalloc<CLensFlareDescriptor::SFlare> >::_M_set
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\xrmemory.h
_TEXT	ENDS
;	COMDAT ??$xr_alloc@V?$xr_vector@GV?$xalloc@G@@@@@@YAPAV?$xr_vector@GV?$xalloc@G@@@@I@Z
_TEXT	SEGMENT
??$xr_alloc@V?$xr_vector@GV?$xalloc@G@@@@@@YAPAV?$xr_vector@GV?$xalloc@G@@@@I@Z PROC ; xr_alloc<xr_vector<unsigned short,xalloc<unsigned short> > >, COMDAT
; _count$ = eax

; 109  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	eax, DWORD PTR [eax+eax*2]
	add	eax, eax
	add	eax, eax
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@V?$xr_vector@GV?$xalloc@G@@@@@@YAPAV?$xr_vector@GV?$xalloc@G@@@@I@Z ENDP ; xr_alloc<xr_vector<unsigned short,xalloc<unsigned short> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$xr_free@V?$xr_vector@GV?$xalloc@G@@@@@@YAXAAPAV?$xr_vector@GV?$xalloc@G@@@@@Z
_TEXT	SEGMENT
??$xr_free@V?$xr_vector@GV?$xalloc@G@@@@@@YAXAAPAV?$xr_vector@GV?$xalloc@G@@@@@Z PROC ; xr_free<xr_vector<unsigned short,xalloc<unsigned short> > >, COMDAT
; _P$ = esi

; 111  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN1@xr_free@26
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN1@xr_free@26:
	ret	0
??$xr_free@V?$xr_vector@GV?$xalloc@G@@@@@@YAXAAPAV?$xr_vector@GV?$xalloc@G@@@@@Z ENDP ; xr_free<xr_vector<unsigned short,xalloc<unsigned short> > >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ??$?0PAVCBoneData@@@?$xalloc@PAX@@QAE@ABV?$xalloc@PAVCBoneData@@@@@Z
_TEXT	SEGMENT
??$?0PAVCBoneData@@@?$xalloc@PAX@@QAE@ABV?$xalloc@PAVCBoneData@@@@@Z PROC ; xalloc<void *>::xalloc<void *><CBoneData *>, COMDAT
; _this$ = eax

; 79   : 	template<class _Other>							xalloc			(const xalloc<_Other>&)					{	}

	ret	0
??$?0PAVCBoneData@@@?$xalloc@PAX@@QAE@ABV?$xalloc@PAVCBoneData@@@@@Z ENDP ; xalloc<void *>::xalloc<void *><CBoneData *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0PAVCLensFlareDescriptor@@@?$xalloc@PAX@@QAE@ABV?$xalloc@PAVCLensFlareDescriptor@@@@@Z
_TEXT	SEGMENT
??$?0PAVCLensFlareDescriptor@@@?$xalloc@PAX@@QAE@ABV?$xalloc@PAVCLensFlareDescriptor@@@@@Z PROC ; xalloc<void *>::xalloc<void *><CLensFlareDescriptor *>, COMDAT
; _this$ = eax

; 79   : 	template<class _Other>							xalloc			(const xalloc<_Other>&)					{	}

	ret	0
??$?0PAVCLensFlareDescriptor@@@?$xalloc@PAX@@QAE@ABV?$xalloc@PAVCLensFlareDescriptor@@@@@Z ENDP ; xalloc<void *>::xalloc<void *><CLensFlareDescriptor *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@QBEPAV?$xr_vector@GV?$xalloc@G@@@@IPBX@Z
_TEXT	SEGMENT
?allocate@?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@QBEPAV?$xr_vector@GV?$xalloc@G@@@@IPBX@Z PROC ; xalloc<xr_vector<unsigned short,xalloc<unsigned short> > >::allocate, COMDAT
; _n$ = eax

; 81   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	eax, DWORD PTR [eax+eax*2]
	add	eax, eax
	add	eax, eax
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
?allocate@?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@QBEPAV?$xr_vector@GV?$xalloc@G@@@@IPBX@Z ENDP ; xalloc<xr_vector<unsigned short,xalloc<unsigned short> > >::allocate
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_alloc.h
_TEXT	ENDS
;	COMDAT ?allocate@?$_STLP_alloc_proxy@PAV?$xr_vector@GV?$xalloc@G@@@@V1@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAEPAV?$xr_vector@GV?$xalloc@G@@@@I@Z
_TEXT	SEGMENT
?allocate@?$_STLP_alloc_proxy@PAV?$xr_vector@GV?$xalloc@G@@@@V1@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAEPAV?$xr_vector@GV?$xalloc@G@@@@I@Z PROC ; stlp_std::priv::_STLP_alloc_proxy<xr_vector<unsigned short,xalloc<unsigned short> > *,xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::allocate, COMDAT
; ___n$ = eax

; 633  :   { return _Base::allocate(__n); }

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	eax, DWORD PTR [eax+eax*2]
	add	eax, eax
	add	eax, eax
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
?allocate@?$_STLP_alloc_proxy@PAV?$xr_vector@GV?$xalloc@G@@@@V1@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAEPAV?$xr_vector@GV?$xalloc@G@@@@I@Z ENDP ; stlp_std::priv::_STLP_alloc_proxy<xr_vector<unsigned short,xalloc<unsigned short> > *,xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::allocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$_STLP_alloc_proxy@PAV?$xr_vector@GV?$xalloc@G@@@@V1@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@AAEPAV?$xr_vector@GV?$xalloc@G@@@@IAAIABU__false_type@3@@Z
_TEXT	SEGMENT
?allocate@?$_STLP_alloc_proxy@PAV?$xr_vector@GV?$xalloc@G@@@@V1@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@AAEPAV?$xr_vector@GV?$xalloc@G@@@@IAAIABU__false_type@3@@Z PROC ; stlp_std::priv::_STLP_alloc_proxy<xr_vector<unsigned short,xalloc<unsigned short> > *,xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::allocate, COMDAT
; ___n$ = eax
; ___allocated_n$ = ecx

; 640  :   { __allocated_n = __n; return allocate(__n); }

	lea	edx, DWORD PTR [eax+eax*2]
	add	edx, edx
	add	edx, edx
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edx
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
?allocate@?$_STLP_alloc_proxy@PAV?$xr_vector@GV?$xalloc@G@@@@V1@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@AAEPAV?$xr_vector@GV?$xalloc@G@@@@IAAIABU__false_type@3@@Z ENDP ; stlp_std::priv::_STLP_alloc_proxy<xr_vector<unsigned short,xalloc<unsigned short> > *,xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::allocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$_STLP_alloc_proxy@PAV?$xr_vector@GV?$xalloc@G@@@@V1@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAEPAV?$xr_vector@GV?$xalloc@G@@@@IAAI@Z
_TEXT	SEGMENT
?allocate@?$_STLP_alloc_proxy@PAV?$xr_vector@GV?$xalloc@G@@@@V1@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAEPAV?$xr_vector@GV?$xalloc@G@@@@IAAI@Z PROC ; stlp_std::priv::_STLP_alloc_proxy<xr_vector<unsigned short,xalloc<unsigned short> > *,xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::allocate, COMDAT
; ___n$ = eax
; ___allocated_n$ = ecx

; 611  : #if !defined (__BORLANDC__)
; 612  :     typedef typename _IsSTLportClass<_MaybeReboundAlloc>::_Ret _STLportAlloc;
; 613  : #else
; 614  :     typedef typename __bool2type<_IsSTLportClass<_MaybeReboundAlloc>::_Is>::_Ret _STLportAlloc;
; 615  : #endif
; 616  :     return allocate(__n, __allocated_n, _STLportAlloc());

	lea	edx, DWORD PTR [eax+eax*2]
	add	edx, edx
	add	edx, edx
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edx
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 617  :   }

	ret	0
?allocate@?$_STLP_alloc_proxy@PAV?$xr_vector@GV?$xalloc@G@@@@V1@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAEPAV?$xr_vector@GV?$xalloc@G@@@@IAAI@Z ENDP ; stlp_std::priv::_STLP_alloc_proxy<xr_vector<unsigned short,xalloc<unsigned short> > *,xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::allocate
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ??0?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
??0?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@QAE@ABV0@@Z PROC ; xalloc<xr_vector<unsigned short,xalloc<unsigned short> > >::xalloc<xr_vector<unsigned short,xalloc<unsigned short> > >, COMDAT
; _this$ = eax

; 78   : 													xalloc			(const xalloc<T>&)						{	}

	ret	0
??0?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@QAE@ABV0@@Z ENDP ; xalloc<xr_vector<unsigned short,xalloc<unsigned short> > >::xalloc<xr_vector<unsigned short,xalloc<unsigned short> > >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_iterator.h
_TEXT	ENDS
;	COMDAT ??0?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@QAE@PAV?$xr_vector@GV?$xalloc@G@@@@@Z
_TEXT	SEGMENT
??0?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@QAE@PAV?$xr_vector@GV?$xalloc@G@@@@@Z PROC ; stlp_std::reverse_iterator<xr_vector<unsigned short,xalloc<unsigned short> > *>::reverse_iterator<xr_vector<unsigned short,xalloc<unsigned short> > *>, COMDAT
; _this$ = eax
; ___x$ = ecx

; 65   :   explicit reverse_iterator(iterator_type __x) : current(__x) {}

	mov	DWORD PTR [eax], ecx
	ret	0
??0?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@QAE@PAV?$xr_vector@GV?$xalloc@G@@@@@Z ENDP ; stlp_std::reverse_iterator<xr_vector<unsigned short,xalloc<unsigned short> > *>::reverse_iterator<xr_vector<unsigned short,xalloc<unsigned short> > *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_tools.h
_TEXT	ENDS
;	COMDAT ?to_storage_type_ptr@?$_CastTraits@Urq_result@collide@@U12@@priv@stlp_std@@SAPAUrq_result@collide@@PAU45@@Z
_TEXT	SEGMENT
?to_storage_type_ptr@?$_CastTraits@Urq_result@collide@@U12@@priv@stlp_std@@SAPAUrq_result@collide@@PAU45@@Z PROC ; stlp_std::priv::_CastTraits<collide::rq_result,collide::rq_result>::to_storage_type_ptr, COMDAT
; ___ptr$ = eax

; 248  :   { return __ptr; }

	ret	0
?to_storage_type_ptr@?$_CastTraits@Urq_result@collide@@U12@@priv@stlp_std@@SAPAUrq_result@collide@@PAU45@@Z ENDP ; stlp_std::priv::_CastTraits<collide::rq_result,collide::rq_result>::to_storage_type_ptr
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ?size@?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QBEIXZ PROC ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::size, COMDAT
; _this$ = eax

; 180  :   size_type size() const        { return size_type(this->_M_finish - this->_M_start); }

	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR [eax]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	ret	0
?size@?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QBEIXZ ENDP ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QBEPBV?$xr_vector@GV?$xalloc@G@@@@XZ
_TEXT	SEGMENT
?end@?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QBEPBV?$xr_vector@GV?$xalloc@G@@@@XZ PROC ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::end, COMDAT
; _this$ = eax

; 173  :   const_iterator end() const   { return this->_M_finish; }

	mov	eax, DWORD PTR [eax+4]
	ret	0
?end@?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QBEPBV?$xr_vector@GV?$xalloc@G@@@@XZ ENDP ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QBEPBV?$xr_vector@GV?$xalloc@G@@@@XZ
_TEXT	SEGMENT
?begin@?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QBEPBV?$xr_vector@GV?$xalloc@G@@@@XZ PROC ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::begin, COMDAT
; _this$ = eax

; 171  :   const_iterator begin() const { return this->_M_start; }

	mov	eax, DWORD PTR [eax]
	ret	0
?begin@?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QBEPBV?$xr_vector@GV?$xalloc@G@@@@XZ ENDP ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::begin
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?get_allocator@?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QBE?AV?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@XZ
_TEXT	SEGMENT
?get_allocator@?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QBE?AV?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@XZ PROC ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::get_allocator, COMDAT
; ___$ReturnUdt$ = eax

; 134  :   { return _STLP_CONVERT_ALLOCATOR((const allocator_type&)this->_M_end_of_storage, _Tp); }

	ret	0
?get_allocator@?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QBE?AV?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@XZ ENDP ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::get_allocator
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ?deallocate@?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@QBEXPAV?$xr_vector@GV?$xalloc@G@@@@I@Z
_TEXT	SEGMENT
?deallocate@?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@QBEXPAV?$xr_vector@GV?$xalloc@G@@@@I@Z PROC ; xalloc<xr_vector<unsigned short,xalloc<unsigned short> > >::deallocate, COMDAT
; _p$ = eax

; 83   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	test	eax, eax
	je	SHORT $LN3@deallocate@18
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN3@deallocate@18:
	ret	0
?deallocate@?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@QBEXPAV?$xr_vector@GV?$xalloc@G@@@@I@Z ENDP ; xalloc<xr_vector<unsigned short,xalloc<unsigned short> > >::deallocate
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_tools.h
_TEXT	ENDS
;	COMDAT ?to_value_type_ptr@?$_CastTraits@V?$xr_vector@GV?$xalloc@G@@@@V1@@priv@stlp_std@@SAPAV?$xr_vector@GV?$xalloc@G@@@@PAV4@@Z
_TEXT	SEGMENT
?to_value_type_ptr@?$_CastTraits@V?$xr_vector@GV?$xalloc@G@@@@V1@@priv@stlp_std@@SAPAV?$xr_vector@GV?$xalloc@G@@@@PAV4@@Z PROC ; stlp_std::priv::_CastTraits<xr_vector<unsigned short,xalloc<unsigned short> >,xr_vector<unsigned short,xalloc<unsigned short> > >::to_value_type_ptr, COMDAT
; ___ptr$ = eax

; 237  :   { return __ptr; }

	ret	0
?to_value_type_ptr@?$_CastTraits@V?$xr_vector@GV?$xalloc@G@@@@V1@@priv@stlp_std@@SAPAV?$xr_vector@GV?$xalloc@G@@@@PAV4@@Z ENDP ; stlp_std::priv::_CastTraits<xr_vector<unsigned short,xalloc<unsigned short> >,xr_vector<unsigned short,xalloc<unsigned short> > >::to_value_type_ptr
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?to_storage_type_cref@?$_CastTraits@USFlare@CLensFlareDescriptor@@U12@@priv@stlp_std@@SAABUSFlare@CLensFlareDescriptor@@ABU45@@Z
_TEXT	SEGMENT
?to_storage_type_cref@?$_CastTraits@USFlare@CLensFlareDescriptor@@U12@@priv@stlp_std@@SAABUSFlare@CLensFlareDescriptor@@ABU45@@Z PROC ; stlp_std::priv::_CastTraits<CLensFlareDescriptor::SFlare,CLensFlareDescriptor::SFlare>::to_storage_type_cref, COMDAT
; ___ref$ = eax

; 254  :   { return __ref; }

	ret	0
?to_storage_type_cref@?$_CastTraits@USFlare@CLensFlareDescriptor@@U12@@priv@stlp_std@@SAABUSFlare@CLensFlareDescriptor@@ABU45@@Z ENDP ; stlp_std::priv::_CastTraits<CLensFlareDescriptor::SFlare,CLensFlareDescriptor::SFlare>::to_storage_type_cref
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?to_value_type_ptr@?$_CastTraits@USFlare@CLensFlareDescriptor@@U12@@priv@stlp_std@@SAPAUSFlare@CLensFlareDescriptor@@PAU45@@Z
_TEXT	SEGMENT
?to_value_type_ptr@?$_CastTraits@USFlare@CLensFlareDescriptor@@U12@@priv@stlp_std@@SAPAUSFlare@CLensFlareDescriptor@@PAU45@@Z PROC ; stlp_std::priv::_CastTraits<CLensFlareDescriptor::SFlare,CLensFlareDescriptor::SFlare>::to_value_type_ptr, COMDAT
; ___ptr$ = eax

; 237  :   { return __ptr; }

	ret	0
?to_value_type_ptr@?$_CastTraits@USFlare@CLensFlareDescriptor@@U12@@priv@stlp_std@@SAPAUSFlare@CLensFlareDescriptor@@PAU45@@Z ENDP ; stlp_std::priv::_CastTraits<CLensFlareDescriptor::SFlare,CLensFlareDescriptor::SFlare>::to_value_type_ptr
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?to_value_type_ptr@?$_CastTraits@Urq_result@collide@@U12@@priv@stlp_std@@SAPAUrq_result@collide@@PAU45@@Z
_TEXT	SEGMENT
?to_value_type_ptr@?$_CastTraits@Urq_result@collide@@U12@@priv@stlp_std@@SAPAUrq_result@collide@@PAU45@@Z PROC ; stlp_std::priv::_CastTraits<collide::rq_result,collide::rq_result>::to_value_type_ptr, COMDAT
; ___ptr$ = eax

; 237  :   { return __ptr; }

	ret	0
?to_value_type_ptr@?$_CastTraits@Urq_result@collide@@U12@@priv@stlp_std@@SAPAUrq_result@collide@@PAU45@@Z ENDP ; stlp_std::priv::_CastTraits<collide::rq_result,collide::rq_result>::to_value_type_ptr
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ??1?$_Vector_base@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_base@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAE@XZ PROC ; stlp_std::priv::_Vector_base<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::~_Vector_base<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >, COMDAT
; _this$ = eax

; 85   :     if (_M_start != _STLP_DEFAULT_CONSTRUCTED(pointer))

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN6@Vector_bas@10

; 86   :       _M_end_of_storage.deallocate(_M_start, _M_end_of_storage._M_data - _M_start);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN6@Vector_bas@10:

; 87   :   }

	ret	0
??1?$_Vector_base@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAE@XZ ENDP ; stlp_std::priv::_Vector_base<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::~_Vector_base<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAEPAV?$xr_vector@GV?$xalloc@G@@@@XZ
_TEXT	SEGMENT
?end@?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAEPAV?$xr_vector@GV?$xalloc@G@@@@XZ PROC ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::end, COMDAT
; _this$ = eax

; 172  :   iterator end()               { return this->_M_finish; }

	mov	eax, DWORD PTR [eax+4]
	ret	0
?end@?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAEPAV?$xr_vector@GV?$xalloc@G@@@@XZ ENDP ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAEPAV?$xr_vector@GV?$xalloc@G@@@@XZ
_TEXT	SEGMENT
?begin@?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAEPAV?$xr_vector@GV?$xalloc@G@@@@XZ PROC ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::begin, COMDAT
; _this$ = eax

; 170  :   iterator begin()             { return this->_M_start; }

	mov	eax, DWORD PTR [eax]
	ret	0
?begin@?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAEPAV?$xr_vector@GV?$xalloc@G@@@@XZ ENDP ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::begin
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ??0?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@QAE@XZ PROC	; xalloc<xr_vector<unsigned short,xalloc<unsigned short> > >::xalloc<xr_vector<unsigned short,xalloc<unsigned short> > >, COMDAT
; _this$ = eax

; 77   : 													xalloc			()										{	}

	ret	0
??0?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@QAE@XZ ENDP	; xalloc<xr_vector<unsigned short,xalloc<unsigned short> > >::xalloc<xr_vector<unsigned short,xalloc<unsigned short> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$xalloc@PAVCBoneData@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@PAVCBoneData@@@@QAE@XZ PROC			; xalloc<CBoneData *>::xalloc<CBoneData *>, COMDAT
; _this$ = eax

; 77   : 													xalloc			()										{	}

	ret	0
??0?$xalloc@PAVCBoneData@@@@QAE@XZ ENDP			; xalloc<CBoneData *>::xalloc<CBoneData *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_matrix33.h
_TEXT	ENDS
;	COMDAT ?identity@?$_matrix33@M@@QAEAAU1@XZ
_TEXT	SEGMENT
?identity@?$_matrix33@M@@QAEAAU1@XZ PROC		; _matrix33<float>::identity, COMDAT
; _this$ = eax

; 46   :     	_11=1.f; _12=0.f; _13=0.f;

	xorps	xmm0, xmm0
	movss	xmm1, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax], xmm1
	movss	DWORD PTR [eax+4], xmm0
	movss	DWORD PTR [eax+8], xmm0

; 47   :     	_21=0.f; _22=1.f; _23=0.f;

	movss	DWORD PTR [eax+12], xmm0
	movss	DWORD PTR [eax+16], xmm1
	movss	DWORD PTR [eax+20], xmm0

; 48   :     	_31=0.f; _32=0.f; _33=1.f;

	movss	DWORD PTR [eax+24], xmm0
	movss	DWORD PTR [eax+28], xmm0
	movss	DWORD PTR [eax+32], xmm1

; 49   : 		return *this;
; 50   : 	}

	ret	0
?identity@?$_matrix33@M@@QAEAAU1@XZ ENDP		; _matrix33<float>::identity
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ??0?$xalloc@PAVCLensFlareDescriptor@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@PAVCLensFlareDescriptor@@@@QAE@XZ PROC	; xalloc<CLensFlareDescriptor *>::xalloc<CLensFlareDescriptor *>, COMDAT
; _this$ = eax

; 77   : 													xalloc			()										{	}

	ret	0
??0?$xalloc@PAVCLensFlareDescriptor@@@@QAE@XZ ENDP	; xalloc<CLensFlareDescriptor *>::xalloc<CLensFlareDescriptor *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$xalloc@Urq_result@collide@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@Urq_result@collide@@@@QAE@XZ PROC		; xalloc<collide::rq_result>::xalloc<collide::rq_result>, COMDAT
; _this$ = eax

; 77   : 													xalloc			()										{	}

	ret	0
??0?$xalloc@Urq_result@collide@@@@QAE@XZ ENDP		; xalloc<collide::rq_result>::xalloc<collide::rq_result>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_color.h
_TEXT	ENDS
;	COMDAT ?magnitude_sqr_rgb@?$_color@M@@QBEMXZ
_TEXT	SEGMENT
?magnitude_sqr_rgb@?$_color@M@@QBEMXZ PROC		; _color<float>::magnitude_sqr_rgb, COMDAT
; _this$ = eax

; 196  : 		return r*r + g*g + b*b;

	movss	xmm3, DWORD PTR [eax]
	movss	xmm2, DWORD PTR [eax+4]
	movss	xmm1, DWORD PTR [eax+8]
	movaps	xmm0, xmm3
	mulss	xmm0, xmm3
	movaps	xmm3, xmm2
	mulss	xmm3, xmm2
	movaps	xmm2, xmm1
	addss	xmm0, xmm3
	mulss	xmm2, xmm1
	addss	xmm0, xmm2

; 197  : 	}

	ret	0
?magnitude_sqr_rgb@?$_color@M@@QBEMXZ ENDP		; _color<float>::magnitude_sqr_rgb
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ?end@?$vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@stlp_std@@QAEPAV?$xr_vector@GV?$xalloc@G@@@@XZ
_TEXT	SEGMENT
?end@?$vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@stlp_std@@QAEPAV?$xr_vector@GV?$xalloc@G@@@@XZ PROC ; stlp_std::vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::end, COMDAT
; _this$ = eax

; 81   :   iterator end()               { return cast_traits::to_value_type_ptr(_M_impl.end()); }

	mov	eax, DWORD PTR [eax+4]
	ret	0
?end@?$vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@stlp_std@@QAEPAV?$xr_vector@GV?$xalloc@G@@@@XZ ENDP ; stlp_std::vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@stlp_std@@QAEPAV?$xr_vector@GV?$xalloc@G@@@@XZ
_TEXT	SEGMENT
?begin@?$vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@stlp_std@@QAEPAV?$xr_vector@GV?$xalloc@G@@@@XZ PROC ; stlp_std::vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::begin, COMDAT
; _this$ = eax

; 79   :   iterator begin()             { return cast_traits::to_value_type_ptr(_M_impl.begin()); }

	mov	eax, DWORD PTR [eax]
	ret	0
?begin@?$vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@stlp_std@@QAEPAV?$xr_vector@GV?$xalloc@G@@@@XZ ENDP ; stlp_std::vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::begin
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ??A?$xr_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@@QAEAAV?$xr_vector@GV?$xalloc@G@@@@I@Z
_TEXT	SEGMENT
??A?$xr_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@@QAEAAV?$xr_vector@GV?$xalloc@G@@@@I@Z PROC ; xr_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::operator[], COMDAT
; _this$ = ecx
; __Pos$ = eax

; 139  : 	reference operator[]		(size_type _Pos)					{ {VERIFY2(_Pos<size(),make_string("index is out of range: index requested[%d], size of container[%d]", _Pos, size()).c_str());} return (*(begin() + _Pos)); }

	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [edx+eax*4]
	ret	0
??A?$xr_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@@QAEAAV?$xr_vector@GV?$xalloc@G@@@@I@Z ENDP ; xr_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::operator[]
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\include\xrrender\factoryptr.h
_TEXT	ENDS
;	COMDAT ??C?$FactoryPtr@VILensFlareRender@@@@QBEPAVILensFlareRender@@XZ
_TEXT	SEGMENT
??C?$FactoryPtr@VILensFlareRender@@@@QBEPAVILensFlareRender@@XZ PROC ; FactoryPtr<ILensFlareRender>::operator->, COMDAT
; _this$ = eax

; 40   : 	T* operator->() const {return m_pObject;}

	mov	eax, DWORD PTR [eax]
	ret	0
??C?$FactoryPtr@VILensFlareRender@@@@QBEPAVILensFlareRender@@XZ ENDP ; FactoryPtr<ILensFlareRender>::operator->
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_flags.h
_TEXT	ENDS
;	COMDAT ?is@?$_flags@I@@QBEHI@Z
_TEXT	SEGMENT
?is@?$_flags@I@@QBEHI@Z PROC				; _flags<unsigned int>::is, COMDAT
; _this$ = ecx
; _mask$ = eax

; 23   : 	IC 	BOOL	is		(const T mask)						const	{ return mask==(flags&mask);			}

	mov	edx, DWORD PTR [ecx]
	and	edx, eax
	xor	ecx, ecx
	cmp	eax, edx
	sete	cl
	mov	eax, ecx
	ret	0
?is@?$_flags@I@@QBEHI@Z ENDP				; _flags<unsigned int>::is
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_color.h
_TEXT	ENDS
;	COMDAT ?set@?$_color@M@@QAEAAU1@MMMM@Z
_TEXT	SEGMENT
__g$ = 8						; size = 4
__b$ = 12						; size = 4
?set@?$_color@M@@QAEAAU1@MMMM@Z PROC			; _color<float>::set, COMDAT
; _this$ = eax
; __r$ = xmm0s

; 45   : 		r = _r; g = _g; b = _b; a = _a;		

	movss	DWORD PTR [eax], xmm0
	movss	xmm0, DWORD PTR __g$[esp-4]
	movss	DWORD PTR [eax+4], xmm0
	movss	xmm0, DWORD PTR __b$[esp-4]
	movss	DWORD PTR [eax+8], xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+12], xmm0

; 46   : 		return *this;
; 47   : 	};

	ret	8
?set@?$_color@M@@QAEAAU1@MMMM@Z ENDP			; _color<float>::set
_TEXT	ENDS
PUBLIC	__real@3b808081
;	COMDAT __real@3b808081
CONST	SEGMENT
__real@3b808081 DD 03b808081r			; 0.00392157
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?set@?$_color@M@@QAEAAU1@I@Z
_TEXT	SEGMENT
tv158 = -4						; size = 4
tv157 = -4						; size = 4
tv156 = -4						; size = 4
tv155 = -4						; size = 4
?set@?$_color@M@@QAEAAU1@I@Z PROC			; _color<float>::set, COMDAT
; _this$ = eax
; _dw$ = ecx

; 35   : 	{

	push	ecx

; 36   : 		const T f = T(1.0) / T(255.0);
; 37   : 		a = f * T((dw >> 24)& 0xff);

	mov	edx, ecx
	shr	edx, 24					; 00000018H
	test	edx, edx
	mov	DWORD PTR tv158[esp+4], edx
	fild	DWORD PTR tv158[esp+4]
	jge	SHORT $LN3@set@5
	fadd	DWORD PTR __real@4f800000
$LN3@set@5:
	fld	DWORD PTR __real@3b808081

; 38   : 		r = f * T((dw >> 16)& 0xff);

	mov	edx, ecx
	fmul	ST(1), ST(0)
	shr	edx, 16					; 00000010H
	and	edx, 255				; 000000ffH
	fxch	ST(1)
	mov	DWORD PTR tv157[esp+4], edx
	fstp	DWORD PTR [eax+12]

; 39   : 		g = f * T((dw >>  8)& 0xff);

	mov	edx, ecx
	fild	DWORD PTR tv157[esp+4]
	shr	edx, 8
	and	edx, 255				; 000000ffH
	mov	DWORD PTR tv156[esp+4], edx
	fmul	ST(0), ST(1)

; 40   : 		b = f * T((dw >>  0)& 0xff);

	movzx	ecx, cl
	fstp	DWORD PTR [eax]
	fild	DWORD PTR tv156[esp+4]
	mov	DWORD PTR tv155[esp+4], ecx
	fmul	ST(0), ST(1)
	fstp	DWORD PTR [eax+4]
	fimul	DWORD PTR tv155[esp+4]
	fstp	DWORD PTR [eax+8]

; 41   : 		return *this;
; 42   : 	};

	pop	ecx
	ret	0
?set@?$_color@M@@QAEAAU1@I@Z ENDP			; _color<float>::set
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_matrix.h
_TEXT	ENDS
;	COMDAT ?transform@?$_matrix@M@@QBEXAAU?$_vector3@M@@ABU2@@Z
_TEXT	SEGMENT
?transform@?$_matrix@M@@QBEXAAU?$_vector3@M@@ABU2@@Z PROC ; _matrix<float>::transform, COMDAT
; _this$ = eax
; _dest$ = edx
; _v$ = ecx

; 528  : 		T iw	= 1.f/(v.x*_14 + v.y*_24 + v.z*_34 + _44);

	movss	xmm2, DWORD PTR [ecx+4]
	movss	xmm3, DWORD PTR [ecx]
	movss	xmm1, DWORD PTR [ecx+8]
	movss	xmm4, DWORD PTR [eax+12]
	movss	xmm0, DWORD PTR [eax+28]

; 529  : 		dest.x	= (v.x*_11 + v.y*_21 + v.z*_31 + _41)*iw;

	movss	xmm5, DWORD PTR [eax+32]
	mulss	xmm4, xmm3
	mulss	xmm0, xmm2
	addss	xmm4, xmm0
	movss	xmm0, DWORD PTR [eax+44]
	mulss	xmm0, xmm1
	addss	xmm4, xmm0
	addss	xmm4, DWORD PTR [eax+60]
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, xmm4
	movss	xmm4, DWORD PTR [eax+16]
	mulss	xmm4, xmm2
	mulss	xmm5, xmm1
	addss	xmm4, xmm5
	movaps	xmm5, xmm3
	mulss	xmm5, DWORD PTR [eax]
	addss	xmm4, xmm5
	addss	xmm4, DWORD PTR [eax+48]

; 530  : 		dest.y	= (v.x*_12 + v.y*_22 + v.z*_32 + _42)*iw;

	movss	xmm5, DWORD PTR [eax+20]
	mulss	xmm4, xmm0
	movss	DWORD PTR [edx], xmm4
	movss	xmm4, DWORD PTR [eax+4]
	mulss	xmm4, xmm3
	mulss	xmm5, xmm2
	addss	xmm4, xmm5
	movss	xmm5, DWORD PTR [eax+36]
	mulss	xmm5, xmm1
	addss	xmm4, xmm5
	addss	xmm4, DWORD PTR [eax+52]
	mulss	xmm4, xmm0
	movss	DWORD PTR [edx+4], xmm4

; 531  : 		dest.z	= (v.x*_13 + v.y*_23 + v.z*_33 + _43)*iw;

	movss	xmm4, DWORD PTR [eax+8]
	mulss	xmm4, xmm3
	movss	xmm3, DWORD PTR [eax+24]
	mulss	xmm3, xmm2
	movss	xmm2, DWORD PTR [eax+40]
	addss	xmm4, xmm3
	mulss	xmm2, xmm1
	addss	xmm4, xmm2
	addss	xmm4, DWORD PTR [eax+56]
	mulss	xmm4, xmm0
	movss	DWORD PTR [edx+8], xmm4

; 532  : 	}

	ret	0
?transform@?$_matrix@M@@QBEXAAU?$_vector3@M@@ABU2@@Z ENDP ; _matrix<float>::transform
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_vector3d.h
_TEXT	ENDS
;	COMDAT ?crossproduct@?$_vector3@M@@QAEAAU1@ABU1@0@Z
_TEXT	SEGMENT
?crossproduct@?$_vector3@M@@QAEAAU1@ABU1@0@Z PROC	; _vector3<float>::crossproduct, COMDAT
; _this$ = eax
; _v1$ = edx
; _v2$ = ecx

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movss	xmm0, DWORD PTR [ecx+8]
	mulss	xmm0, DWORD PTR [edx+4]
	movss	xmm1, DWORD PTR [edx+8]
	mulss	xmm1, DWORD PTR [ecx+4]
	subss	xmm0, xmm1
	movss	DWORD PTR [eax], xmm0

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movss	xmm0, DWORD PTR [edx+8]
	mulss	xmm0, DWORD PTR [ecx]
	movss	xmm1, DWORD PTR [edx]
	mulss	xmm1, DWORD PTR [ecx+8]
	subss	xmm0, xmm1
	movss	DWORD PTR [eax+4], xmm0

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	movss	xmm0, DWORD PTR [edx]
	movss	xmm1, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR [ecx+4]
	mulss	xmm1, DWORD PTR [edx+4]
	subss	xmm0, xmm1
	movss	DWORD PTR [eax+8], xmm0

; 276  : 		return *this;	
; 277  : 	}

	ret	0
?crossproduct@?$_vector3@M@@QAEAAU1@ABU1@0@Z ENDP	; _vector3<float>::crossproduct
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?mul@?$_vector3@M@@QAEAAU1@ABU1@M@Z
_TEXT	SEGMENT
?mul@?$_vector3@M@@QAEAAU1@ABU1@M@Z PROC		; _vector3<float>::mul, COMDAT
; _this$ = eax
; _a$ = ecx
; _s$ = xmm0s

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movss	xmm1, DWORD PTR [ecx]
	mulss	xmm1, xmm0
	movss	DWORD PTR [eax], xmm1
	movss	xmm1, DWORD PTR [ecx+4]
	mulss	xmm1, xmm0
	movss	DWORD PTR [eax+4], xmm1
	movss	xmm1, DWORD PTR [ecx+8]
	mulss	xmm1, xmm0
	movss	DWORD PTR [eax+8], xmm1
	ret	0
?mul@?$_vector3@M@@QAEAAU1@ABU1@M@Z ENDP		; _vector3<float>::mul
_TEXT	ENDS
PUBLIC	?Render@CLensFlare@@QAIXHHH@Z			; CLensFlare::Render
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\xr_efflensflare.cpp
;	COMDAT ?Render@CLensFlare@@QAIXHHH@Z
_TEXT	SEGMENT
_bFlares$ = 8						; size = 4
_bGradient$ = 12					; size = 4
?Render@CLensFlare@@QAIXHHH@Z PROC			; CLensFlare::Render, COMDAT
; _this$ = ecx
; _bSun$ = edx

; 463  : {

	mov	eax, ecx

; 464  : 	if (!bRender)		return;

	cmp	DWORD PTR [eax+448], 0
	je	SHORT $LN6@Render

; 465  : 	if(!m_Current)		return;

	cmp	DWORD PTR [eax+488], 0
	je	SHORT $LN6@Render

; 466  : 	VERIFY				(m_Current);
; 467  : 
; 468  : 	m_pRender->Render(*this, bSun, bFlares, bGradient);

	mov	ecx, DWORD PTR [eax+472]
	push	esi
	mov	esi, DWORD PTR [ecx]
	push	edi
	mov	edi, DWORD PTR _bGradient$[esp+4]
	push	edi
	mov	edi, DWORD PTR _bFlares$[esp+8]
	push	edi
	push	edx
	push	eax
	mov	eax, DWORD PTR [esi+8]
	call	eax
	pop	edi
	pop	esi
$LN6@Render:

; 469  : 
; 470  : 	/*
; 471  : 	Fcolor				dwLight;
; 472  : 	Fcolor				color;
; 473  : 	Fvector				vec, vecSx, vecSy;
; 474  : 	Fvector				vecDx, vecDy;
; 475  : 
; 476  : 	dwLight.set							( LightColor );
; 477  : 	svector<ref_shader,MAX_Flares>		_2render;
; 478  : 
; 479  : 	u32									VS_Offset;
; 480  : 	FVF::LIT *pv						= (FVF::LIT*) RCache.Vertex.Lock(MAX_Flares*4,hGeom.stride(),VS_Offset);
; 481  : 
; 482  : 	float 	fDistance		= FAR_DIST*0.75f;
; 483  : 
; 484  : 	if (bSun){
; 485  :     	if (m_Current->m_Flags.is(CLensFlareDescriptor::flSource)){
; 486  :             vecSx.mul			(vecX, m_Current->m_Source.fRadius*fDistance);
; 487  :             vecSy.mul			(vecY, m_Current->m_Source.fRadius*fDistance);
; 488  :             if (m_Current->m_Source.ignore_color) 	color.set(1.f,1.f,1.f,1.f);
; 489  :             else									color.set(dwLight);
; 490  : 	        color.a				*= m_StateBlend;
; 491  :             u32 c				= color.get();
; 492  :             pv->set				(vecLight.x+vecSx.x-vecSy.x, vecLight.y+vecSx.y-vecSy.y, vecLight.z+vecSx.z-vecSy.z, c, 0, 0); pv++;
; 493  :             pv->set				(vecLight.x+vecSx.x+vecSy.x, vecLight.y+vecSx.y+vecSy.y, vecLight.z+vecSx.z+vecSy.z, c, 0, 1); pv++;
; 494  :             pv->set				(vecLight.x-vecSx.x-vecSy.x, vecLight.y-vecSx.y-vecSy.y, vecLight.z-vecSx.z-vecSy.z, c, 1, 0); pv++;
; 495  :             pv->set				(vecLight.x-vecSx.x+vecSy.x, vecLight.y-vecSx.y+vecSy.y, vecLight.z-vecSx.z+vecSy.z, c, 1, 1); pv++;
; 496  :             _2render.push_back	(m_Current->m_Source.hShader);
; 497  :         }
; 498  : 	}
; 499  : 	if (fBlend>=EPS_L)
; 500  : 	{
; 501  : 		if(bFlares){
; 502  : 			vecDx.normalize		(vecAxis);
; 503  : 			vecDy.crossproduct	(vecDx, vecDir);
; 504  : 	    	if (m_Current->m_Flags.is(CLensFlareDescriptor::flFlare)){
; 505  :                 for (CLensFlareDescriptor::FlareIt it=m_Current->m_Flares.begin(); it!=m_Current->m_Flares.end(); it++){
; 506  :                     CLensFlareDescriptor::SFlare&	F = *it;
; 507  :                     vec.mul				(vecAxis, F.fPosition);
; 508  :                     vec.add				(vecCenter);
; 509  :                     vecSx.mul			(vecDx, F.fRadius*fDistance);
; 510  :                     vecSy.mul			(vecDy, F.fRadius*fDistance);
; 511  :                     float    cl			= F.fOpacity * fBlend * m_StateBlend;
; 512  :                     color.set			( dwLight );
; 513  :                     color.mul_rgba		( cl );
; 514  :                     u32 c				= color.get();
; 515  :                     pv->set				(vec.x+vecSx.x-vecSy.x, vec.y+vecSx.y-vecSy.y, vec.z+vecSx.z-vecSy.z, c, 0, 0); pv++;
; 516  :                     pv->set				(vec.x+vecSx.x+vecSy.x, vec.y+vecSx.y+vecSy.y, vec.z+vecSx.z+vecSy.z, c, 0, 1); pv++;
; 517  :                     pv->set				(vec.x-vecSx.x-vecSy.x, vec.y-vecSx.y-vecSy.y, vec.z-vecSx.z-vecSy.z, c, 1, 0); pv++;
; 518  :                     pv->set				(vec.x-vecSx.x+vecSy.x, vec.y-vecSx.y+vecSy.y, vec.z-vecSx.z+vecSy.z, c, 1, 1); pv++;
; 519  :                     _2render.push_back	(it->hShader);
; 520  :                 }
; 521  :             }
; 522  : 		}
; 523  : 		// gradient
; 524  : 		if (bGradient&&(fGradientValue>=EPS_L)){
; 525  :             if (m_Current->m_Flags.is(CLensFlareDescriptor::flGradient)){
; 526  :                 vecSx.mul			(vecX, m_Current->m_Gradient.fRadius*fGradientValue*fDistance);
; 527  :                 vecSy.mul			(vecY, m_Current->m_Gradient.fRadius*fGradientValue*fDistance);
; 528  : 
; 529  :                 color.set			( dwLight );
; 530  :                 color.mul_rgba		( fGradientValue*m_StateBlend );
; 531  : 
; 532  :                 u32 c				= color.get	();
; 533  :                 pv->set				(vecLight.x+vecSx.x-vecSy.x, vecLight.y+vecSx.y-vecSy.y, vecLight.z+vecSx.z-vecSy.z, c, 0, 0); pv++;
; 534  :                 pv->set				(vecLight.x+vecSx.x+vecSy.x, vecLight.y+vecSx.y+vecSy.y, vecLight.z+vecSx.z+vecSy.z, c, 0, 1); pv++;
; 535  :                 pv->set				(vecLight.x-vecSx.x-vecSy.x, vecLight.y-vecSx.y-vecSy.y, vecLight.z-vecSx.z-vecSy.z, c, 1, 0); pv++;
; 536  :                 pv->set				(vecLight.x-vecSx.x+vecSy.x, vecLight.y-vecSx.y+vecSy.y, vecLight.z-vecSx.z+vecSy.z, c, 1, 1); pv++;
; 537  :                 _2render.push_back	(m_Current->m_Gradient.hShader);
; 538  :             }
; 539  : 		}
; 540  : 	}
; 541  : 	RCache.Vertex.Unlock	(_2render.size()*4,hGeom.stride());
; 542  : 
; 543  : 	RCache.set_xform_world	(Fidentity);
; 544  : 	RCache.set_Geometry		(hGeom);
; 545  : 	for (u32 i=0; i<_2render.size(); i++)
; 546  : 	{
; 547  :     	if (_2render[i])
; 548  : 		{
; 549  : 			u32						vBase	= i*4+VS_Offset;
; 550  : 			RCache.set_Shader		(_2render[i]);
; 551  : 			RCache.Render			(D3DPT_TRIANGLELIST,vBase, 0,4,0,2);
; 552  : 	    }
; 553  : 	}
; 554  : 	*/
; 555  : }

	ret	8
?Render@CLensFlare@@QAIXHHH@Z ENDP			; CLensFlare::Render
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0STranspParam@@QAE@PAUray_cache@collide@@ABU?$_vector3@M@@1MM@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
??0STranspParam@@QAE@PAUray_cache@collide@@ABU?$_vector3@M@@1MM@Z PROC ; STranspParam::STranspParam, COMDAT
; _this$ = eax
; __P$ = edx
; __D$ = ecx

; 184  : 	STranspParam		(collide::ray_cache	*p, const Fvector& _P, const Fvector& _D, float _f, float _vis_threshold):P(_P),D(_D),f(_f),pray_cache(p),vis(1.f),vis_threshold(_vis_threshold){}

	movss	xmm0, DWORD PTR _fuzzy_update_novis
	push	esi
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+16], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _p$[esp]
	movss	DWORD PTR [eax+24], xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+32], xmm0
	movss	xmm0, DWORD PTR _EPS_L
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+28], edx
	movss	DWORD PTR [eax+36], xmm0
	pop	esi
	ret	4
??0STranspParam@@QAE@PAUray_cache@collide@@ABU?$_vector3@M@@1MM@Z ENDP ; STranspParam::STranspParam
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\include\xrrender\kinematics.h
_TEXT	ENDS
;	COMDAT ?PKinematics@@YAPAVIKinematics@@PAVIRenderVisual@@@Z
_TEXT	SEGMENT
?PKinematics@@YAPAVIKinematics@@PAVIRenderVisual@@@Z PROC ; PKinematics, COMDAT
; _V$ = eax

; 93   : IC IKinematics* PKinematics (IRenderVisual* V) { return V?V->dcast_PKinematics():0;}

	test	eax, eax
	je	SHORT $LN3@PKinematic
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+12]
	push	eax
	call	edx
	ret	0
$LN3@PKinematic:
	xor	eax, eax
	ret	0
?PKinematics@@YAPAVIKinematics@@PAVIRenderVisual@@@Z ENDP ; PKinematics
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4IBoneData@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
??4IBoneData@@QAEAAV0@ABV0@@Z PROC			; IBoneData::operator=, COMDAT
; _this$ = eax
	ret	0
??4IBoneData@@QAEAAV0@ABV0@@Z ENDP			; IBoneData::operator=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0IBoneData@@QAE@ABV0@@Z
_TEXT	SEGMENT
??0IBoneData@@QAE@ABV0@@Z PROC				; IBoneData::IBoneData, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], OFFSET ??_7IBoneData@@6B@
	ret	0
??0IBoneData@@QAE@ABV0@@Z ENDP				; IBoneData::IBoneData
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0IBoneData@@QAE@XZ
_TEXT	SEGMENT
??0IBoneData@@QAE@XZ PROC				; IBoneData::IBoneData, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], OFFSET ??_7IBoneData@@6B@
	ret	0
??0IBoneData@@QAE@XZ ENDP				; IBoneData::IBoneData
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\bone.h
_TEXT	ENDS
;	COMDAT ?hi_limit@CBoneData@@EBGME@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_k$ = 12						; size = 1
?hi_limit@CBoneData@@EBGME@Z PROC			; CBoneData::hi_limit, COMDAT

; 505  : 				float			_BCL	hi_limit			( u8 k )	const	{return IK_data.limits[k].limit.y;}

	movzx	eax, BYTE PTR _k$[esp-4]
	mov	ecx, DWORD PTR _this$[esp-4]
	shl	eax, 4
	fld	DWORD PTR [eax+ecx+326]
	ret	8
?hi_limit@CBoneData@@EBGME@Z ENDP			; CBoneData::hi_limit
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?lo_limit@CBoneData@@EBGME@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_k$ = 12						; size = 1
?lo_limit@CBoneData@@EBGME@Z PROC			; CBoneData::lo_limit, COMDAT

; 504  : 				float			_BCL	lo_limit			( u8 k )	const	{return IK_data.limits[k].limit.x;}

	movzx	eax, BYTE PTR _k$[esp-4]
	mov	ecx, DWORD PTR _this$[esp-4]
	shl	eax, 4
	fld	DWORD PTR [eax+ecx+322]
	ret	8
?lo_limit@CBoneData@@EBGME@Z ENDP			; CBoneData::lo_limit
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?get_game_mtl_idx@CBoneData@@EBGGXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?get_game_mtl_idx@CBoneData@@EBGGXZ PROC		; CBoneData::get_game_mtl_idx, COMDAT

; 503  : 				u16				_BCL	get_game_mtl_idx	( )			const	{return game_mtl_idx;}

	mov	eax, DWORD PTR _this$[esp-4]
	mov	ax, WORD PTR [eax+316]
	ret	4
?get_game_mtl_idx@CBoneData@@EBGGXZ ENDP		; CBoneData::get_game_mtl_idx
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?get_mass@CBoneData@@EBGMXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?get_mass@CBoneData@@EBGMXZ PROC			; CBoneData::get_mass, COMDAT

; 502  : 				float			_BCL	get_mass			( )			const	{return mass;}

	mov	eax, DWORD PTR _this$[esp-4]
	fld	DWORD PTR [eax+396]
	ret	4
?get_mass@CBoneData@@EBGMXZ ENDP			; CBoneData::get_mass
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?get_center_of_mass@CBoneData@@EBGABU?$_vector3@M@@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?get_center_of_mass@CBoneData@@EBGABU?$_vector3@M@@XZ PROC ; CBoneData::get_center_of_mass, COMDAT

; 501  : 		const	Fvector&		_BCL	get_center_of_mass	( )			const	{return center_of_mass;}

	mov	eax, DWORD PTR _this$[esp-4]
	add	eax, 400				; 00000190H
	ret	4
?get_center_of_mass@CBoneData@@EBGABU?$_vector3@M@@XZ ENDP ; CBoneData::get_center_of_mass
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?get_obb@CBoneData@@EBGABU?$_obb@M@@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?get_obb@CBoneData@@EBGABU?$_obb@M@@XZ PROC		; CBoneData::get_obb, COMDAT

; 500  : 		const	Fobb&			_BCL	get_obb				( )			const	{return obb;}

	mov	eax, DWORD PTR _this$[esp-4]
	add	eax, 12					; 0000000cH
	ret	4
?get_obb@CBoneData@@EBGABU?$_obb@M@@XZ ENDP		; CBoneData::get_obb
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?get_shape@CBoneData@@EBGABUSBoneShape@@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?get_shape@CBoneData@@EBGABUSBoneShape@@XZ PROC		; CBoneData::get_shape, COMDAT

; 499  : 		const	SBoneShape&		_BCL	get_shape			( )			const	{return shape;}

	mov	eax, DWORD PTR _this$[esp-4]
	add	eax, 200				; 000000c8H
	ret	4
?get_shape@CBoneData@@EBGABUSBoneShape@@XZ ENDP		; CBoneData::get_shape
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?get_bind_transform@CBoneData@@EBGABU?$_matrix@M@@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?get_bind_transform@CBoneData@@EBGABU?$_matrix@M@@XZ PROC ; CBoneData::get_bind_transform, COMDAT

; 498  : 		const	Fmatrix&		_BCL	get_bind_transform	( )			const	{return	bind_transform;}

	mov	eax, DWORD PTR _this$[esp-4]
	add	eax, 72					; 00000048H
	ret	4
?get_bind_transform@CBoneData@@EBGABU?$_matrix@M@@XZ ENDP ; CBoneData::get_bind_transform
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?get_IK_data@CBoneData@@EBGABUSJointIKData@@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?get_IK_data@CBoneData@@EBGABUSJointIKData@@XZ PROC	; CBoneData::get_IK_data, COMDAT

; 497  : 		const	SJointIKData&	_BCL	get_IK_data			( )			const	{return	IK_data;}

	mov	eax, DWORD PTR _this$[esp-4]
	add	eax, 318				; 0000013eH
	ret	4
?get_IK_data@CBoneData@@EBGABUSJointIKData@@XZ ENDP	; CBoneData::get_IK_data
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetParentID@CBoneData@@UBGGXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?GetParentID@CBoneData@@UBGGXZ PROC			; CBoneData::GetParentID, COMDAT

; 484  : 	IC u16		_BCL	GetParentID		() const {return ParentID;}

	mov	eax, DWORD PTR _this$[esp-4]
	mov	ax, WORD PTR [eax+6]
	ret	4
?GetParentID@CBoneData@@UBGGXZ ENDP			; CBoneData::GetParentID
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetSelfID@CBoneData@@UBGGXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?GetSelfID@CBoneData@@UBGGXZ PROC			; CBoneData::GetSelfID, COMDAT

; 483  : 	IC u16		_BCL	GetSelfID		() const {return SelfID;}

	mov	eax, DWORD PTR _this$[esp-4]
	mov	ax, WORD PTR [eax+4]
	ret	4
?GetSelfID@CBoneData@@UBGGXZ ENDP			; CBoneData::GetSelfID
_TEXT	ENDS
PUBLIC	?SetParentID@CBoneData@@QAEXG@Z			; CBoneData::SetParentID
; Function compile flags: /Ogtpy
;	COMDAT ?SetParentID@CBoneData@@QAEXG@Z
_TEXT	SEGMENT
_id$ = 8						; size = 2
?SetParentID@CBoneData@@QAEXG@Z PROC			; CBoneData::SetParentID, COMDAT
; _this$ = ecx

; 481  : 	IC void				SetParentID		(u16 id){ParentID=id;}

	mov	ax, WORD PTR _id$[esp-4]
	mov	WORD PTR [ecx+6], ax
	ret	4
?SetParentID@CBoneData@@QAEXG@Z ENDP			; CBoneData::SetParentID
_TEXT	ENDS
PUBLIC	??4vertBoned4W@@QAEAAU0@ABU0@@Z			; vertBoned4W::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4vertBoned4W@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4vertBoned4W@@QAEAAU0@ABU0@@Z PROC			; vertBoned4W::operator=, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, DWORD PTR ___that$[esp]
	push	edi
	mov	eax, ecx
	mov	ecx, 19					; 00000013H
	mov	edi, eax
	rep movsd
	pop	edi
	pop	esi
	ret	4
??4vertBoned4W@@QAEAAU0@ABU0@@Z ENDP			; vertBoned4W::operator=
_TEXT	ENDS
PUBLIC	??4vertBoned3W@@QAEAAU0@ABU0@@Z			; vertBoned3W::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4vertBoned3W@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4vertBoned3W@@QAEAAU0@ABU0@@Z PROC			; vertBoned3W::operator=, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, DWORD PTR ___that$[esp]
	push	edi
	mov	eax, ecx
	mov	ecx, 17					; 00000011H
	mov	edi, eax
	rep movsd
	movsw
	pop	edi
	pop	esi
	ret	4
??4vertBoned3W@@QAEAAU0@ABU0@@Z ENDP			; vertBoned3W::operator=
_TEXT	ENDS
PUBLIC	??4vertBoned2W@@QAEAAU0@ABU0@@Z			; vertBoned2W::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4vertBoned2W@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4vertBoned2W@@QAEAAU0@ABU0@@Z PROC			; vertBoned2W::operator=, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, DWORD PTR ___that$[esp]
	push	edi
	mov	eax, ecx
	mov	ecx, 16					; 00000010H
	mov	edi, eax
	rep movsd
	pop	edi
	pop	esi
	ret	4
??4vertBoned2W@@QAEAAU0@ABU0@@Z ENDP			; vertBoned2W::operator=
_TEXT	ENDS
PUBLIC	??4vertBoned1W@@QAEAAU0@ABU0@@Z			; vertBoned1W::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4vertBoned1W@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4vertBoned1W@@QAEAAU0@ABU0@@Z PROC			; vertBoned1W::operator=, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, DWORD PTR ___that$[esp]
	push	edi
	mov	eax, ecx
	mov	ecx, 15					; 0000000fH
	mov	edi, eax
	rep movsd
	pop	edi
	pop	esi
	ret	4
??4vertBoned1W@@QAEAAU0@ABU0@@Z ENDP			; vertBoned1W::operator=
_TEXT	ENDS
PUBLIC	??4CBoneInstance@@QAEAAV0@ABV0@@Z		; CBoneInstance::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4CBoneInstance@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4CBoneInstance@@QAEAAV0@ABV0@@Z PROC			; CBoneInstance::operator=, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, DWORD PTR ___that$[esp]
	push	edi
	mov	eax, ecx
	mov	ecx, 40					; 00000028H
	mov	edi, eax
	rep movsd
	pop	edi
	pop	esi
	ret	4
??4CBoneInstance@@QAEAAV0@ABV0@@Z ENDP			; CBoneInstance::operator=
_TEXT	ENDS
PUBLIC	?mem_usage@CBoneInstance@@QAEIXZ		; CBoneInstance::mem_usage
; Function compile flags: /Ogtpy
;	COMDAT ?mem_usage@CBoneInstance@@QAEIXZ
_TEXT	SEGMENT
?mem_usage@CBoneInstance@@QAEIXZ PROC			; CBoneInstance::mem_usage, COMDAT
; _this$ = ecx

; 65   : 	u32					mem_usage		(){return sizeof(*this);}

	mov	eax, 160				; 000000a0H
	ret	0
?mem_usage@CBoneInstance@@QAEIXZ ENDP			; CBoneInstance::mem_usage
_TEXT	ENDS
PUBLIC	?set_callback_overwrite@CBoneInstance@@QAGXH@Z	; CBoneInstance::set_callback_overwrite
; Function compile flags: /Ogtpy
;	COMDAT ?set_callback_overwrite@CBoneInstance@@QAGXH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_v$ = 12						; size = 4
?set_callback_overwrite@CBoneInstance@@QAGXH@Z PROC	; CBoneInstance::set_callback_overwrite, COMDAT

; 60   : 	void		_BCL		set_callback_overwrite(BOOL v){ Callback_overwrite = v; }

	mov	eax, DWORD PTR _this$[esp-4]
	mov	ecx, DWORD PTR _v$[esp-4]
	mov	DWORD PTR [eax+136], ecx
	ret	8
?set_callback_overwrite@CBoneInstance@@QAGXH@Z ENDP	; CBoneInstance::set_callback_overwrite
_TEXT	ENDS
PUBLIC	?reset_callback@CBoneInstance@@QAGXXZ		; CBoneInstance::reset_callback
; Function compile flags: /Ogtpy
;	COMDAT ?reset_callback@CBoneInstance@@QAGXXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?reset_callback@CBoneInstance@@QAGXXZ PROC		; CBoneInstance::reset_callback, COMDAT

; 55   : 		Callback			= 0; 

	mov	eax, DWORD PTR _this$[esp-4]
	xor	ecx, ecx
	mov	DWORD PTR [eax+128], ecx

; 56   : 		Callback_Param		= 0; 

	mov	DWORD PTR [eax+132], ecx

; 57   : 		Callback_overwrite	= FALSE;

	mov	DWORD PTR [eax+136], ecx

; 58   : 		Callback_type		= 0;

	mov	DWORD PTR [eax+140], ecx

; 59   : 	}

	ret	4
?reset_callback@CBoneInstance@@QAGXXZ ENDP		; CBoneInstance::reset_callback
_TEXT	ENDS
PUBLIC	?set_callback@CBoneInstance@@QAGXIP6GXPAV1@@ZPAXH@Z ; CBoneInstance::set_callback
; Function compile flags: /Ogtpy
;	COMDAT ?set_callback@CBoneInstance@@QAGXIP6GXPAV1@@ZPAXH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_Type$ = 12						; size = 4
_C$ = 16						; size = 4
_Param$ = 20						; size = 4
_overwrite$ = 24					; size = 4
?set_callback@CBoneInstance@@QAGXIP6GXPAV1@@ZPAXH@Z PROC ; CBoneInstance::set_callback, COMDAT

; 47   : 		Callback			= C; 

	mov	eax, DWORD PTR _this$[esp-4]
	mov	ecx, DWORD PTR _C$[esp-4]

; 48   : 		Callback_Param		= Param; 

	mov	edx, DWORD PTR _Param$[esp-4]
	mov	DWORD PTR [eax+128], ecx

; 49   : 		Callback_overwrite	= overwrite;

	mov	ecx, DWORD PTR _overwrite$[esp-4]
	mov	DWORD PTR [eax+132], edx

; 50   : 		Callback_type		= Type;

	mov	edx, DWORD PTR _Type$[esp-4]
	mov	DWORD PTR [eax+136], ecx
	mov	DWORD PTR [eax+140], edx

; 51   : 	}

	ret	20					; 00000014H
?set_callback@CBoneInstance@@QAGXIP6GXPAV1@@ZPAXH@Z ENDP ; CBoneInstance::set_callback
_TEXT	ENDS
PUBLIC	?callback_type@CBoneInstance@@QAGIXZ		; CBoneInstance::callback_type
; Function compile flags: /Ogtpy
;	COMDAT ?callback_type@CBoneInstance@@QAGIXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?callback_type@CBoneInstance@@QAGIXZ PROC		; CBoneInstance::callback_type, COMDAT

; 41   : 	IC	u32				_BCL	callback_type()				{ return Callback_type; }	

	mov	eax, DWORD PTR _this$[esp-4]
	mov	eax, DWORD PTR [eax+140]
	ret	4
?callback_type@CBoneInstance@@QAGIXZ ENDP		; CBoneInstance::callback_type
_TEXT	ENDS
PUBLIC	?callback_overwrite@CBoneInstance@@QAGHXZ	; CBoneInstance::callback_overwrite
; Function compile flags: /Ogtpy
;	COMDAT ?callback_overwrite@CBoneInstance@@QAGHXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?callback_overwrite@CBoneInstance@@QAGHXZ PROC		; CBoneInstance::callback_overwrite, COMDAT

; 40   : 	IC	BOOL			_BCL	callback_overwrite()		{ return Callback_overwrite; }					// performance hint - don't calc anims

	mov	eax, DWORD PTR _this$[esp-4]
	mov	eax, DWORD PTR [eax+136]
	ret	4
?callback_overwrite@CBoneInstance@@QAGHXZ ENDP		; CBoneInstance::callback_overwrite
_TEXT	ENDS
PUBLIC	?callback_param@CBoneInstance@@QAGPAXXZ		; CBoneInstance::callback_param
; Function compile flags: /Ogtpy
;	COMDAT ?callback_param@CBoneInstance@@QAGPAXXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?callback_param@CBoneInstance@@QAGPAXXZ PROC		; CBoneInstance::callback_param, COMDAT

; 39   : 	IC	void*			_BCL	callback_param()			{ return Callback_Param;	}

	mov	eax, DWORD PTR _this$[esp-4]
	mov	eax, DWORD PTR [eax+132]
	ret	4
?callback_param@CBoneInstance@@QAGPAXXZ ENDP		; CBoneInstance::callback_param
_TEXT	ENDS
PUBLIC	?callback@CBoneInstance@@QAGP6GXPAV1@@ZXZ	; CBoneInstance::callback
; Function compile flags: /Ogtpy
;	COMDAT ?callback@CBoneInstance@@QAGP6GXPAV1@@ZXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?callback@CBoneInstance@@QAGP6GXPAV1@@ZXZ PROC		; CBoneInstance::callback, COMDAT

; 38   : 	IC	BoneCallback	_BCL	callback()					{ return  Callback; }

	mov	eax, DWORD PTR _this$[esp-4]
	mov	eax, DWORD PTR [eax+128]
	ret	4
?callback@CBoneInstance@@QAGP6GXPAV1@@ZXZ ENDP		; CBoneInstance::callback
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcdb\xr_collide_defs.h
_TEXT	ENDS
;	COMDAT ??0ray_defs@collide@@QAE@ABU?$_vector3@M@@0MIW4rq_target@1@@Z
_TEXT	SEGMENT
__tgt$ = 8						; size = 4
??0ray_defs@collide@@QAE@ABU?$_vector3@M@@0MIW4rq_target@1@@Z PROC ; collide::ray_defs::ray_defs, COMDAT
; _this$ = eax
; __start$ = edx
; __dir$ = ecx
; __range$ = xmm0s

; 73   : 		ray_defs	(const Fvector& _start, const Fvector& _dir, float _range, u32 _flags, rq_target _tgt)

	push	esi

; 74   : 		{
; 75   : 			start	= _start;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx

; 76   : 			dir		= _dir;

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+16], edx
	mov	ecx, DWORD PTR [ecx+8]

; 77   : 			range	= _range;
; 78   : 			flags	= _flags;
; 79   : 			tgt		= _tgt;

	mov	edx, DWORD PTR __tgt$[esp]
	mov	DWORD PTR [eax+20], ecx
	movss	DWORD PTR [eax+24], xmm0
	mov	DWORD PTR [eax+28], 1
	mov	DWORD PTR [eax+32], edx
	pop	esi

; 80   : 		}

	ret	4
??0ray_defs@collide@@QAE@ABU?$_vector3@M@@0MIW4rq_target@1@@Z ENDP ; collide::ray_defs::ray_defs
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?set@ray_cache@collide@@QAEXABU?$_vector3@M@@0MH@Z
_TEXT	SEGMENT
__result$ = 8						; size = 4
?set@ray_cache@collide@@QAEXABU?$_vector3@M@@0MH@Z PROC	; collide::ray_cache::set, COMDAT
; _this$ = eax
; __start$ = edx
; __dir$ = ecx
; __range$ = xmm0s

; 43   : 		{

	push	esi

; 44   : 			start	= _start;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx

; 45   : 			dir		= _dir;

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+16], edx
	mov	ecx, DWORD PTR [ecx+8]

; 46   : 			range	= _range;
; 47   : 			result	= _result;

	mov	edx, DWORD PTR __result$[esp]
	mov	DWORD PTR [eax+20], ecx
	movss	DWORD PTR [eax+24], xmm0
	mov	DWORD PTR [eax+28], edx
	pop	esi

; 48   : 		}

	ret	4
?set@ray_cache@collide@@QAEXABU?$_vector3@M@@0MH@Z ENDP	; collide::ray_cache::set
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_algobase.h
;	COMDAT ??$__copy_ptrs@PAUrq_result@collide@@PAU12@@priv@stlp_std@@YAPAUrq_result@collide@@PAU23@00ABU__true_type@1@@Z
_TEXT	SEGMENT
??$__copy_ptrs@PAUrq_result@collide@@PAU12@@priv@stlp_std@@YAPAUrq_result@collide@@PAU23@00ABU__true_type@1@@Z PROC ; stlp_std::priv::__copy_ptrs<collide::rq_result *,collide::rq_result *>, COMDAT
; ___first$ = edx
; ___last$ = ecx
; ___result$ = eax

; 255  :   // we know they all pointers, so this cast is OK
; 256  :   //  return (_OutputIter)__copy_trivial(&(*__first), &(*__last), &(*__result));
; 257  :   return (_OutputIter)__copy_trivial(__first, __last, __result);

	sub	ecx, edx
	push	esi
	mov	esi, ecx
	je	SHORT $LN6@copy_ptrs@16
	push	esi
	push	edx
	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	add	eax, esi
$LN6@copy_ptrs@16:
	pop	esi

; 258  : }

	ret	0
??$__copy_ptrs@PAUrq_result@collide@@PAU12@@priv@stlp_std@@YAPAUrq_result@collide@@PAU23@00ABU__true_type@1@@Z ENDP ; stlp_std::priv::__copy_ptrs<collide::rq_result *,collide::rq_result *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_construct.h
_TEXT	ENDS
;	COMDAT ??$_Copy_Construct@G@stlp_std@@YAXPAGABG@Z
_TEXT	SEGMENT
??$_Copy_Construct@G@stlp_std@@YAXPAGABG@Z PROC		; stlp_std::_Copy_Construct<unsigned short>, COMDAT
; ___p$ = eax
; ___val$ = ecx

; 110  : #if defined (_STLP_DEBUG_UNINITIALIZED)
; 111  :   memset((char*)__p, _STLP_SHRED_BYTE, sizeof(_Tp));
; 112  : #endif
; 113  :   _STLP_PLACEMENT_NEW (__p) _Tp(__val);

	test	eax, eax
	je	SHORT $LN3@Copy_Const@13
	mov	dx, WORD PTR [ecx]
	mov	WORD PTR [eax], dx
$LN3@Copy_Const@13:

; 114  : }

	ret	0
??$_Copy_Construct@G@stlp_std@@YAXPAGABG@Z ENDP		; stlp_std::_Copy_Construct<unsigned short>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_alloc.h
_TEXT	ENDS
;	COMDAT ??0?$_STLP_alloc_proxy@PAV?$xr_vector@GV?$xalloc@G@@@@V1@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAE@ABV?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@PAV?$xr_vector@GV?$xalloc@G@@@@@Z
_TEXT	SEGMENT
??0?$_STLP_alloc_proxy@PAV?$xr_vector@GV?$xalloc@G@@@@V1@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAE@ABV?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@PAV?$xr_vector@GV?$xalloc@G@@@@@Z PROC ; stlp_std::priv::_STLP_alloc_proxy<xr_vector<unsigned short,xalloc<unsigned short> > *,xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::_STLP_alloc_proxy<xr_vector<unsigned short,xalloc<unsigned short> > *,xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >, COMDAT
; _this$ = eax

; 571  :     _MaybeReboundAlloc(__a), _M_data(__p) {}

	mov	DWORD PTR [eax], 0
	ret	0
??0?$_STLP_alloc_proxy@PAV?$xr_vector@GV?$xalloc@G@@@@V1@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAE@ABV?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@PAV?$xr_vector@GV?$xalloc@G@@@@@Z ENDP ; stlp_std::priv::_STLP_alloc_proxy<xr_vector<unsigned short,xalloc<unsigned short> > *,xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::_STLP_alloc_proxy<xr_vector<unsigned short,xalloc<unsigned short> > *,xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ??0?$_Vector_base@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAE@ABV?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@Z
_TEXT	SEGMENT
??0?$_Vector_base@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAE@ABV?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@Z PROC ; stlp_std::priv::_Vector_base<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::_Vector_base<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >, COMDAT
; _this$ = eax

; 67   :     : _M_start(0), _M_finish(0), _M_end_of_storage(__a, 0) {}

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$_Vector_base@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAE@ABV?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@Z ENDP ; stlp_std::priv::_Vector_base<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::_Vector_base<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_M_erase@?$_Impl_vector@Urq_result@collide@@V?$xalloc@Urq_result@collide@@@@@priv@stlp_std@@AAEPAUrq_result@collide@@PAU45@0ABU__false_type@3@@Z
_TEXT	SEGMENT
?_M_erase@?$_Impl_vector@Urq_result@collide@@V?$xalloc@Urq_result@collide@@@@@priv@stlp_std@@AAEPAUrq_result@collide@@PAU45@0ABU__false_type@3@@Z PROC ; stlp_std::priv::_Impl_vector<collide::rq_result,xalloc<collide::rq_result> >::_M_erase, COMDAT
; _this$ = ebx
; ___first$ = edi
; ___last$ = eax

; 578  :   iterator _M_erase(iterator __first, iterator __last, const __false_type& /*_Movable*/) {

	push	esi

; 579  :     pointer __i = _STLP_PRIV __copy_ptrs(__last, this->_M_finish, __first, _TrivialCopy());

	mov	esi, DWORD PTR [ebx+4]
	sub	esi, eax
	je	SHORT $LN7@M_erase@13
	push	esi
	push	eax
	push	edi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	add	eax, esi

; 580  :     _STLP_STD::_Destroy_Range(__i, this->_M_finish);
; 581  :     this->_M_finish = __i;

	mov	DWORD PTR [ebx+4], eax

; 582  :     return __first;

	mov	eax, edi
	pop	esi

; 583  :   }

	ret	0

; 579  :     pointer __i = _STLP_PRIV __copy_ptrs(__last, this->_M_finish, __first, _TrivialCopy());

$LN7@M_erase@13:

; 580  :     _STLP_STD::_Destroy_Range(__i, this->_M_finish);
; 581  :     this->_M_finish = __i;

	mov	DWORD PTR [ebx+4], edi

; 582  :     return __first;

	mov	eax, edi
	pop	esi

; 583  :   }

	ret	0
?_M_erase@?$_Impl_vector@Urq_result@collide@@V?$xalloc@Urq_result@collide@@@@@priv@stlp_std@@AAEPAUrq_result@collide@@PAU45@0ABU__false_type@3@@Z ENDP ; stlp_std::priv::_Impl_vector<collide::rq_result,xalloc<collide::rq_result> >::_M_erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_base@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAE@IABV?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@Z
_TEXT	SEGMENT
??0?$_Vector_base@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAE@IABV?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@Z PROC ; stlp_std::priv::_Vector_base<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::_Vector_base<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >, COMDAT
; _this$ = esi
; ___n$ = eax

; 70   :     : _M_start(0), _M_finish(0), _M_end_of_storage(__a, 0) {

	push	edi
	xor	ecx, ecx

; 71   :     _M_start = _M_end_of_storage.allocate(__n, __n);

	lea	edi, DWORD PTR [eax+eax*2]
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [esi+4], ecx
	add	edi, edi
	mov	DWORD PTR [esi+8], ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	add	edi, edi
	push	edi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 72   :     _M_finish = _M_start;
; 73   :     _M_end_of_storage._M_data = _M_start + __n;

	add	edi, eax
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], edi

; 74   :     _STLP_MPWFIX_TRY _STLP_MPWFIX_CATCH
; 75   :   }

	mov	eax, esi
	pop	edi
	ret	0
??0?$_Vector_base@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAE@IABV?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@Z ENDP ; stlp_std::priv::_Vector_base<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::_Vector_base<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAE@ABV?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@Z
_TEXT	SEGMENT
??0?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAE@ABV?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@Z PROC ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >, COMDAT
; _this$ = eax

; 208  :     : _STLP_PRIV _Vector_base<_Tp, _Alloc>(__a) {}

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAE@ABV?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@Z ENDP ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?erase@?$_Impl_vector@Urq_result@collide@@V?$xalloc@Urq_result@collide@@@@@priv@stlp_std@@QAEPAUrq_result@collide@@PAU45@0@Z
_TEXT	SEGMENT
?erase@?$_Impl_vector@Urq_result@collide@@V?$xalloc@Urq_result@collide@@@@@priv@stlp_std@@QAEPAUrq_result@collide@@PAU45@0@Z PROC ; stlp_std::priv::_Impl_vector<collide::rq_result,xalloc<collide::rq_result> >::erase, COMDAT
; _this$ = ebx
; ___first$ = edi
; ___last$ = eax

; 590  :     if (__first == __last)

	cmp	edi, eax

; 591  :       return __first;

	je	SHORT $LN12@erase@15
	push	esi

; 592  :     return _M_erase(__first, __last, _Movable());

	mov	esi, DWORD PTR [ebx+4]
	sub	esi, eax
	je	SHORT $LN10@erase@15
	push	esi
	push	eax
	push	edi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	add	eax, esi
	mov	DWORD PTR [ebx+4], eax
	pop	esi
	mov	eax, edi

; 593  :   }

	ret	0

; 592  :     return _M_erase(__first, __last, _Movable());

$LN10@erase@15:
	mov	eax, edi
	mov	DWORD PTR [ebx+4], eax
	pop	esi
$LN12@erase@15:
	mov	eax, edi

; 593  :   }

	ret	0
?erase@?$_Impl_vector@Urq_result@collide@@V?$xalloc@Urq_result@collide@@@@@priv@stlp_std@@QAEPAUrq_result@collide@@PAU45@0@Z ENDP ; stlp_std::priv::_Impl_vector<collide::rq_result,xalloc<collide::rq_result> >::erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?rend@?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@3@XZ
_TEXT	SEGMENT
?rend@?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@3@XZ PROC ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::rend, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 177  :   reverse_iterator rend()                { return reverse_iterator(begin()); }

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	ret	0
?rend@?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@3@XZ ENDP ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::rend
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?rbegin@?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@3@XZ
_TEXT	SEGMENT
?rbegin@?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@3@XZ PROC ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::rbegin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 175  :   reverse_iterator rbegin()              { return reverse_iterator(end()); }

	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	ret	0
?rbegin@?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@3@XZ ENDP ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::rbegin
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVCBoneData@@V?$xalloc@PAVCBoneData@@@@@stlp_std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCBoneData@@V?$xalloc@PAVCBoneData@@@@@stlp_std@@QBEIXZ PROC ; stlp_std::vector<CBoneData *,xalloc<CBoneData *> >::size, COMDAT
; _this$ = ecx

; 89   :   size_type size() const        { return _M_impl.size(); }

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	ret	0
?size@?$vector@PAVCBoneData@@V?$xalloc@PAVCBoneData@@@@@stlp_std@@QBEIXZ ENDP ; stlp_std::vector<CBoneData *,xalloc<CBoneData *> >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?erase@?$vector@Urq_result@collide@@V?$xalloc@Urq_result@collide@@@@@stlp_std@@QAEPAUrq_result@collide@@PAU34@0@Z
_TEXT	SEGMENT
?erase@?$vector@Urq_result@collide@@V?$xalloc@Urq_result@collide@@@@@stlp_std@@QAEPAUrq_result@collide@@PAU34@0@Z PROC ; stlp_std::vector<collide::rq_result,xalloc<collide::rq_result> >::erase, COMDAT
; _this$ = ebx
; ___first$ = edi
; ___last$ = eax

; 208  :     return cast_traits::to_value_type_ptr(_M_impl.erase(cast_traits::to_storage_type_ptr(__first),
; 209  :                                                         cast_traits::to_storage_type_ptr(__last)));

	cmp	edi, eax
	je	SHORT $LN20@erase@16
	push	esi
	mov	esi, DWORD PTR [ebx+4]
	sub	esi, eax
	je	SHORT $LN16@erase@16
	push	esi
	push	eax
	push	edi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	add	eax, esi
	mov	DWORD PTR [ebx+4], eax
	pop	esi
	mov	eax, edi

; 210  :   }

	ret	0

; 208  :     return cast_traits::to_value_type_ptr(_M_impl.erase(cast_traits::to_storage_type_ptr(__first),
; 209  :                                                         cast_traits::to_storage_type_ptr(__last)));

$LN16@erase@16:
	mov	eax, edi
	mov	DWORD PTR [ebx+4], eax
	pop	esi
$LN20@erase@16:
	mov	eax, edi

; 210  :   }

	ret	0
?erase@?$vector@Urq_result@collide@@V?$xalloc@Urq_result@collide@@@@@stlp_std@@QAEPAUrq_result@collide@@PAU34@0@Z ENDP ; stlp_std::vector<collide::rq_result,xalloc<collide::rq_result> >::erase
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ?size@?$xr_vector@PAVCBoneData@@V?$xalloc@PAVCBoneData@@@@@@QBEIXZ
_TEXT	SEGMENT
?size@?$xr_vector@PAVCBoneData@@V?$xalloc@PAVCBoneData@@@@@@QBEIXZ PROC ; xr_vector<CBoneData *,xalloc<CBoneData *> >::size, COMDAT
; _this$ = ecx

; 126  : 	u32		size				() const							{ return (u32)inherited::size();} 

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	ret	0
?size@?$xr_vector@PAVCBoneData@@V?$xalloc@PAVCBoneData@@@@@@QBEIXZ ENDP ; xr_vector<CBoneData *,xalloc<CBoneData *> >::size
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_cylinder.h
_TEXT	ENDS
;	COMDAT ?invalidate@?$_cylinder@M@@QAEAAV1@XZ
_TEXT	SEGMENT
?invalidate@?$_cylinder@M@@QAEAAV1@XZ PROC		; _cylinder<float>::invalidate, COMDAT
; _this$ = eax

; 18   : 	IC SelfRef	invalidate	()	{ m_center.set(0,0,0); m_direction.set(0,0,0); m_height=0; m_radius=0; return *this; }

	xorps	xmm0, xmm0
	movss	DWORD PTR [eax], xmm0
	movss	DWORD PTR [eax+4], xmm0
	movss	DWORD PTR [eax+8], xmm0
	movss	DWORD PTR [eax+12], xmm0
	movss	DWORD PTR [eax+16], xmm0
	movss	DWORD PTR [eax+20], xmm0
	movss	DWORD PTR [eax+24], xmm0
	movss	DWORD PTR [eax+28], xmm0
	ret	0
?invalidate@?$_cylinder@M@@QAEAAV1@XZ ENDP		; _cylinder<float>::invalidate
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_obb.h
_TEXT	ENDS
;	COMDAT ?invalidate@?$_obb@M@@QAEAAU1@XZ
_TEXT	SEGMENT
?invalidate@?$_obb@M@@QAEAAU1@XZ PROC			; _obb<float>::invalidate, COMDAT
; _this$ = eax

; 51   : 		m_rotate.identity	();

	xorps	xmm0, xmm0
	movss	xmm1, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax], xmm1
	movss	DWORD PTR [eax+4], xmm0
	movss	DWORD PTR [eax+8], xmm0
	movss	DWORD PTR [eax+12], xmm0
	movss	DWORD PTR [eax+16], xmm1
	movss	DWORD PTR [eax+20], xmm0
	movss	DWORD PTR [eax+24], xmm0
	movss	DWORD PTR [eax+28], xmm0
	movss	DWORD PTR [eax+32], xmm1

; 52   : 		m_translate.set		(0,0,0);

	movss	DWORD PTR [eax+36], xmm0
	movss	DWORD PTR [eax+40], xmm0
	movss	DWORD PTR [eax+44], xmm0

; 53   : 		m_halfsize.set		(0,0,0);

	movss	DWORD PTR [eax+48], xmm0
	movss	DWORD PTR [eax+52], xmm0
	movss	DWORD PTR [eax+56], xmm0

; 54   : 		return *this;
; 55   : 	}

	ret	0
?invalidate@?$_obb@M@@QAEAAU1@XZ ENDP			; _obb<float>::invalidate
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ?end@?$vector@USFlare@CLensFlareDescriptor@@V?$xalloc@USFlare@CLensFlareDescriptor@@@@@stlp_std@@QAEPAUSFlare@CLensFlareDescriptor@@XZ
_TEXT	SEGMENT
?end@?$vector@USFlare@CLensFlareDescriptor@@V?$xalloc@USFlare@CLensFlareDescriptor@@@@@stlp_std@@QAEPAUSFlare@CLensFlareDescriptor@@XZ PROC ; stlp_std::vector<CLensFlareDescriptor::SFlare,xalloc<CLensFlareDescriptor::SFlare> >::end, COMDAT
; _this$ = eax

; 81   :   iterator end()               { return cast_traits::to_value_type_ptr(_M_impl.end()); }

	mov	eax, DWORD PTR [eax+4]
	ret	0
?end@?$vector@USFlare@CLensFlareDescriptor@@V?$xalloc@USFlare@CLensFlareDescriptor@@@@@stlp_std@@QAEPAUSFlare@CLensFlareDescriptor@@XZ ENDP ; stlp_std::vector<CLensFlareDescriptor::SFlare,xalloc<CLensFlareDescriptor::SFlare> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@USFlare@CLensFlareDescriptor@@V?$xalloc@USFlare@CLensFlareDescriptor@@@@@stlp_std@@QAEPAUSFlare@CLensFlareDescriptor@@XZ
_TEXT	SEGMENT
?begin@?$vector@USFlare@CLensFlareDescriptor@@V?$xalloc@USFlare@CLensFlareDescriptor@@@@@stlp_std@@QAEPAUSFlare@CLensFlareDescriptor@@XZ PROC ; stlp_std::vector<CLensFlareDescriptor::SFlare,xalloc<CLensFlareDescriptor::SFlare> >::begin, COMDAT
; _this$ = eax

; 79   :   iterator begin()             { return cast_traits::to_value_type_ptr(_M_impl.begin()); }

	mov	eax, DWORD PTR [eax]
	ret	0
?begin@?$vector@USFlare@CLensFlareDescriptor@@V?$xalloc@USFlare@CLensFlareDescriptor@@@@@stlp_std@@QAEPAUSFlare@CLensFlareDescriptor@@XZ ENDP ; stlp_std::vector<CLensFlareDescriptor::SFlare,xalloc<CLensFlareDescriptor::SFlare> >::begin
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@Urq_result@collide@@V?$xalloc@Urq_result@collide@@@@@stlp_std@@QAEPAUrq_result@collide@@XZ
_TEXT	SEGMENT
?end@?$vector@Urq_result@collide@@V?$xalloc@Urq_result@collide@@@@@stlp_std@@QAEPAUrq_result@collide@@XZ PROC ; stlp_std::vector<collide::rq_result,xalloc<collide::rq_result> >::end, COMDAT
; _this$ = eax

; 81   :   iterator end()               { return cast_traits::to_value_type_ptr(_M_impl.end()); }

	mov	eax, DWORD PTR [eax+4]
	ret	0
?end@?$vector@Urq_result@collide@@V?$xalloc@Urq_result@collide@@@@@stlp_std@@QAEPAUrq_result@collide@@XZ ENDP ; stlp_std::vector<collide::rq_result,xalloc<collide::rq_result> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@Urq_result@collide@@V?$xalloc@Urq_result@collide@@@@@stlp_std@@QAEPAUrq_result@collide@@XZ
_TEXT	SEGMENT
?begin@?$vector@Urq_result@collide@@V?$xalloc@Urq_result@collide@@@@@stlp_std@@QAEPAUrq_result@collide@@XZ PROC ; stlp_std::vector<collide::rq_result,xalloc<collide::rq_result> >::begin, COMDAT
; _this$ = eax

; 79   :   iterator begin()             { return cast_traits::to_value_type_ptr(_M_impl.begin()); }

	mov	eax, DWORD PTR [eax]
	ret	0
?begin@?$vector@Urq_result@collide@@V?$xalloc@Urq_result@collide@@@@@stlp_std@@QAEPAUrq_result@collide@@XZ ENDP ; stlp_std::vector<collide::rq_result,xalloc<collide::rq_result> >::begin
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ?clear_not_free@?$xr_vector@Urq_result@collide@@V?$xalloc@Urq_result@collide@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear_not_free@?$xr_vector@Urq_result@collide@@V?$xalloc@Urq_result@collide@@@@@@QAEXXZ PROC ; xr_vector<collide::rq_result,xalloc<collide::rq_result> >::clear_not_free, COMDAT
; _this$ = edi

; 129  : 	void	clear_not_free		()									{ erase(begin(),end());			}

	mov	ecx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edi]
	cmp	eax, ecx
	je	SHORT $LN22@clear_not_@3
	push	esi
	mov	esi, ecx
	sub	esi, ecx
	je	SHORT $LN30@clear_not_@3
	push	esi
	push	ecx
	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	add	eax, esi
$LN30@clear_not_@3:
	mov	DWORD PTR [edi+4], eax
	pop	esi
$LN22@clear_not_@3:
	ret	0
?clear_not_free@?$xr_vector@Urq_result@collide@@V?$xalloc@Urq_result@collide@@@@@@QAEXXZ ENDP ; xr_vector<collide::rq_result,xalloc<collide::rq_result> >::clear_not_free
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\include\xrrender\factoryptr.h
_TEXT	ENDS
;	COMDAT ??0?$FactoryPtr@VILensFlareRender@@@@QAE@XZ
_TEXT	SEGMENT
??0?$FactoryPtr@VILensFlareRender@@@@QAE@XZ PROC	; FactoryPtr<ILensFlareRender>::FactoryPtr<ILensFlareRender>, COMDAT
; _this$ = esi

; 24   : 	FactoryPtr() { CreateObject();}

	mov	eax, DWORD PTR __imp_?RenderFactory@@3PAVIRenderFactory@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+96]
	call	eax
	mov	DWORD PTR [esi], eax
	mov	eax, esi
	ret	0
??0?$FactoryPtr@VILensFlareRender@@@@QAE@XZ ENDP	; FactoryPtr<ILensFlareRender>::FactoryPtr<ILensFlareRender>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_color.h
_TEXT	ENDS
;	COMDAT ?magnitude_rgb@?$_color@M@@QBEMXZ
_TEXT	SEGMENT
?magnitude_rgb@?$_color@M@@QBEMXZ PROC			; _color<float>::magnitude_rgb, COMDAT
; _this$ = eax

; 199  : 	IC	T	magnitude_rgb	(void) 		const	{

	push	ecx

; 200  : 		return _sqrt(magnitude_sqr_rgb());

	movss	xmm2, DWORD PTR [eax]
	movss	xmm1, DWORD PTR [eax+4]
	movss	xmm0, DWORD PTR [eax+8]
	movaps	xmm3, xmm2
	mulss	xmm3, xmm2
	movaps	xmm2, xmm1
	mulss	xmm2, xmm1
	movaps	xmm1, xmm0
	addss	xmm3, xmm2
	mulss	xmm1, xmm0
	push	ecx
	addss	xmm3, xmm1
	movss	DWORD PTR [esp], xmm3
	call	_sqrtf
	add	esp, 4
	pop	ecx

; 201  : 	}

	ret	0
?magnitude_rgb@?$_color@M@@QBEMXZ ENDP			; _color<float>::magnitude_rgb
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\xr_efflensflare.cpp
_TEXT	ENDS
;	COMDAT ?blend_lerp@@YAXAAMMMM@Z
_TEXT	SEGMENT
_diff$ = -12						; size = 4
_diff_a$ = -8						; size = 4
tv129 = -4						; size = 4
_dt$ = 8						; size = 4
?blend_lerp@@YAXAAMMMM@Z PROC				; blend_lerp, COMDAT
; _cur$ = esi
; _tgt$ = xmm0s

; 213  : {

	sub	esp, 16					; 00000010H

; 214  : 	float diff		= tgt - cur;

	movss	xmm1, DWORD PTR [esi]
	subss	xmm0, xmm1
	movss	DWORD PTR _diff$[esp+16], xmm0

; 215  : 	float diff_a	= _abs(diff);

	fld	DWORD PTR _diff$[esp+16]
	push	ecx
	fstp	DWORD PTR [esp]
	movss	DWORD PTR tv129[esp+20], xmm1
	call	_fabsf
	fst	DWORD PTR _diff_a$[esp+20]

; 216  : 	if (diff_a<EPS_S)	return;

	fld	DWORD PTR _EPS_S
	add	esp, 4
	fcomip	ST(1)
	fstp	ST(0)
	ja	SHORT $LN3@blend_lerp

; 217  : 	float mot		= speed*dt;

	movss	xmm1, DWORD PTR _dt$[esp+12]
	mulss	xmm1, DWORD PTR __real@40800000

; 218  : 	if (mot>diff_a) mot=diff_a;

	movss	xmm2, DWORD PTR _diff_a$[esp+16]
	comiss	xmm1, xmm2
	jbe	SHORT $LN1@blend_lerp
	movaps	xmm1, xmm2
$LN1@blend_lerp:

; 219  : 	cur				+= (diff/diff_a)*mot;

	movss	xmm0, DWORD PTR _diff$[esp+16]
	divss	xmm0, xmm2
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR tv129[esp+16]
	movss	DWORD PTR [esi], xmm0
$LN3@blend_lerp:

; 220  : }

	add	esp, 16					; 00000010H
	ret	0
?blend_lerp@@YAXAAMMMM@Z ENDP				; blend_lerp
_TEXT	ENDS
PUBLIC	?OnDeviceDestroy@CLensFlareDescriptor@@QAEXXZ	; CLensFlareDescriptor::OnDeviceDestroy
; Function compile flags: /Ogtpy
;	COMDAT ?OnDeviceDestroy@CLensFlareDescriptor@@QAEXXZ
_TEXT	SEGMENT
?OnDeviceDestroy@CLensFlareDescriptor@@QAEXXZ PROC	; CLensFlareDescriptor::OnDeviceDestroy, COMDAT
; _this$ = ecx

; 127  : {

	push	esi
	push	edi
	mov	edi, ecx

; 128  : 	// shaders
; 129  : 	m_Gradient.m_pRender->DestroyShader();

	mov	ecx, DWORD PTR [edi+64]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
	call	edx

; 130  : 	m_Source.m_pRender->DestroyShader();

	mov	ecx, DWORD PTR [edi+36]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
	call	edx

; 131  : 	for (FlareIt it=m_Flares.begin(); it!=m_Flares.end(); it++)

	mov	esi, DWORD PTR [edi]
	cmp	esi, DWORD PTR [edi+4]
	je	SHORT $LN1@OnDeviceDe
	npad	1
$LL3@OnDeviceDe:

; 132  : 		it->m_pRender->DestroyShader();

	mov	ecx, DWORD PTR [esi+20]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	add	esi, 24					; 00000018H
	cmp	esi, DWORD PTR [edi+4]
	jne	SHORT $LL3@OnDeviceDe
$LN1@OnDeviceDe:
	pop	edi
	pop	esi

; 133  : 	/*
; 134  :     m_Gradient.hShader.destroy	();
; 135  :     m_Source.hShader.destroy	();
; 136  :     for (FlareIt it=m_Flares.begin(); it!=m_Flares.end(); it++) it->hShader.destroy();
; 137  : 	*/
; 138  : }

	ret	0
?OnDeviceDestroy@CLensFlareDescriptor@@QAEXXZ ENDP	; CLensFlareDescriptor::OnDeviceDestroy
_TEXT	ENDS
PUBLIC	?OnDeviceCreate@CLensFlareDescriptor@@QAEXXZ	; CLensFlareDescriptor::OnDeviceCreate
; Function compile flags: /Ogtpy
;	COMDAT ?OnDeviceCreate@CLensFlareDescriptor@@QAEXXZ
_TEXT	SEGMENT
?OnDeviceCreate@CLensFlareDescriptor@@QAEXXZ PROC	; CLensFlareDescriptor::OnDeviceCreate, COMDAT
; _this$ = ecx

; 113  : {

	push	esi
	push	edi
	mov	edi, ecx

; 114  : 	// shaders
; 115  : 	m_Gradient.m_pRender->CreateShader(*m_Gradient.shader,*m_Gradient.texture);

	mov	eax, DWORD PTR [edi+56]
	test	eax, eax
	mov	ecx, DWORD PTR [edi+64]
	je	SHORT $LN10@OnDeviceCr
	lea	edx, DWORD PTR [eax+16]
	jmp	SHORT $LN11@OnDeviceCr
$LN10@OnDeviceCr:
	xor	edx, edx
$LN11@OnDeviceCr:
	mov	eax, DWORD PTR [edi+60]
	test	eax, eax
	je	SHORT $LN14@OnDeviceCr
	add	eax, 16					; 00000010H
	jmp	SHORT $LN15@OnDeviceCr
$LN14@OnDeviceCr:
	xor	eax, eax
$LN15@OnDeviceCr:
	mov	esi, DWORD PTR [ecx]
	push	edx
	push	eax
	mov	eax, DWORD PTR [esi+8]
	call	eax

; 116  : 	m_Source.m_pRender->CreateShader(*m_Source.shader,*m_Source.texture);

	mov	eax, DWORD PTR [edi+28]
	test	eax, eax
	mov	ecx, DWORD PTR [edi+36]
	je	SHORT $LN20@OnDeviceCr
	lea	edx, DWORD PTR [eax+16]
	jmp	SHORT $LN21@OnDeviceCr
$LN20@OnDeviceCr:
	xor	edx, edx
$LN21@OnDeviceCr:
	mov	eax, DWORD PTR [edi+32]
	test	eax, eax
	je	SHORT $LN24@OnDeviceCr
	add	eax, 16					; 00000010H
	jmp	SHORT $LN25@OnDeviceCr
$LN24@OnDeviceCr:
	xor	eax, eax
$LN25@OnDeviceCr:
	mov	esi, DWORD PTR [ecx]
	push	edx
	mov	edx, DWORD PTR [esi+8]
	push	eax
	call	edx

; 117  : 	for (FlareIt it=m_Flares.begin(); it!=m_Flares.end(); it++) 

	mov	esi, DWORD PTR [edi]
	cmp	esi, DWORD PTR [edi+4]
	je	SHORT $LN1@OnDeviceCr
	push	ebx
	npad	4
$LL3@OnDeviceCr:

; 118  : 		it->m_pRender->CreateShader(*it->shader,*it->texture);

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	mov	ecx, DWORD PTR [esi+20]
	je	SHORT $LN42@OnDeviceCr
	lea	edx, DWORD PTR [eax+16]
	jmp	SHORT $LN43@OnDeviceCr
$LN42@OnDeviceCr:
	xor	edx, edx
$LN43@OnDeviceCr:
	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN46@OnDeviceCr
	add	eax, 16					; 00000010H
	jmp	SHORT $LN47@OnDeviceCr
$LN46@OnDeviceCr:
	xor	eax, eax
$LN47@OnDeviceCr:
	mov	ebx, DWORD PTR [ecx]
	push	edx
	push	eax
	mov	eax, DWORD PTR [ebx+8]
	call	eax
	add	esi, 24					; 00000018H
	cmp	esi, DWORD PTR [edi+4]
	jne	SHORT $LL3@OnDeviceCr
	pop	ebx
$LN1@OnDeviceCr:
	pop	edi
	pop	esi

; 119  : 	/*
; 120  : 	m_Gradient.hShader	= CreateShader	(*m_Gradient.texture,*m_Gradient.shader);
; 121  : 	m_Source.hShader	= CreateShader	(*m_Source.texture,*m_Source.shader);
; 122  :     for (FlareIt it=m_Flares.begin(); it!=m_Flares.end(); it++) it->hShader = CreateShader(*it->texture,*it->shader);
; 123  : 	*/
; 124  : }

	ret	0
?OnDeviceCreate@CLensFlareDescriptor@@QAEXXZ ENDP	; CLensFlareDescriptor::OnDeviceCreate
_TEXT	ENDS
PUBLIC	__real@b727c5ac
;	COMDAT __real@b727c5ac
; File d:\clearsky\sources\engine\xrcore\_vector3d.h
CONST	SEGMENT
__real@b727c5ac DD 0b727c5acr			; -1e-005
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\cl_intersect.h
CONST	ENDS
;	COMDAT ?TestRayTri@CDB@@YA_NABU?$_vector3@M@@0PAU2@AAM22_N@Z
_TEXT	SEGMENT
_inv_det$ = -40						; size = 4
_edge1$ = -36						; size = 12
_edge2$ = -24						; size = 12
_pvec$ = -12						; size = 12
_u$ = 8							; size = 4
_v$ = 12						; size = 4
_range$ = 16						; size = 4
?TestRayTri@CDB@@YA_NABU?$_vector3@M@@0PAU2@AAM22_N@Z PROC ; CDB::TestRayTri, COMDAT
; _C$ = edx
; _D$ = ecx
; _p$ = eax

; 68   : 	{

	sub	esp, 40					; 00000028H

; 69   : 		Fvector edge1, edge2, tvec, pvec, qvec;
; 70   : 		float det,inv_det;
; 71   : 		// find vectors for two edges sharing vert0
; 72   : 		edge1.sub(p[1], p[0]);

	movss	xmm0, DWORD PTR [eax]
	movss	xmm1, DWORD PTR [eax+12]
	movss	xmm2, DWORD PTR [eax+16]
	movss	xmm5, DWORD PTR [eax+8]

; 73   : 		edge2.sub(p[2], p[0]);

	movss	xmm3, DWORD PTR [eax+28]
	movss	xmm4, DWORD PTR [eax+32]

; 74   : 		// begin calculating determinant - also used to calculate U parameter
; 75   : 		pvec.crossproduct(D, edge2);

	movss	xmm7, DWORD PTR [ecx+4]
	subss	xmm1, xmm0
	movss	DWORD PTR _edge1$[esp+40], xmm1
	movss	xmm1, DWORD PTR [eax+4]
	subss	xmm2, xmm1
	movss	DWORD PTR _edge1$[esp+44], xmm2
	movss	xmm2, DWORD PTR [eax+20]
	subss	xmm2, xmm5
	subss	xmm3, xmm1
	movss	xmm1, DWORD PTR [ecx+8]
	movss	DWORD PTR _edge1$[esp+48], xmm2
	movss	xmm2, DWORD PTR [eax+24]
	subss	xmm2, xmm0
	subss	xmm4, xmm5
	movaps	xmm0, xmm1
	mulss	xmm1, xmm2
	movaps	xmm5, xmm7
	mulss	xmm0, xmm3
	mulss	xmm5, xmm4
	subss	xmm5, xmm0
	movss	xmm0, DWORD PTR [ecx]
	movaps	xmm6, xmm0
	mulss	xmm6, xmm4
	subss	xmm1, xmm6
	mulss	xmm7, xmm2
	movss	DWORD PTR _edge2$[esp+40], xmm2
	movaps	xmm6, xmm0
	movss	DWORD PTR _pvec$[esp+44], xmm1

; 76   : 		// if determinant is near zero, ray lies in plane of triangle
; 77   : 		det = edge1.dotproduct(pvec);

	mulss	xmm1, DWORD PTR _edge1$[esp+44]
	mulss	xmm6, xmm3
	subss	xmm6, xmm7
	movaps	xmm2, xmm6
	mulss	xmm2, DWORD PTR _edge1$[esp+48]
	addss	xmm1, xmm2
	movaps	xmm2, xmm5
	mulss	xmm2, DWORD PTR _edge1$[esp+40]
	addss	xmm1, xmm2

; 78   : 		if (bCull){						// define TEST_CULL if culling is desired
; 79   : 			if (det < EPS)  return false;
; 80   : 			tvec.sub(C, p[0]);							// calculate distance from vert0 to ray origin
; 81   : 			u = tvec.dotproduct(pvec);			// calculate U parameter and test bounds
; 82   : 			if (u < 0.0f || u > det) return false;
; 83   : 			qvec.crossproduct(tvec, edge1);				// prepare to test V parameter
; 84   : 			v = D.dotproduct(qvec);			// calculate V parameter and test bounds
; 85   : 			if (v < 0.0f || u + v > det) return false;
; 86   : 			range = edge2.dotproduct(qvec);		// calculate t, scale parameters, ray intersects triangle
; 87   : 			inv_det = 1.0f / det;
; 88   : 			range *= inv_det;
; 89   : 			u *= inv_det;
; 90   : 			v *= inv_det;
; 91   : 		}else{											// the non-culling branch
; 92   : 			if (det > -EPS && det < EPS) return false;

	comiss	xmm1, DWORD PTR __real@b727c5ac
	movss	DWORD PTR _edge2$[esp+44], xmm3
	movss	DWORD PTR _edge2$[esp+48], xmm4
	jbe	SHORT $LN5@TestRayTri
	movss	xmm2, DWORD PTR _EPS
	comiss	xmm2, xmm1
	ja	$LN3@TestRayTri
$LN5@TestRayTri:

; 93   : 			inv_det = 1.0f / det;

	movss	xmm2, DWORD PTR __real@3f800000

; 94   : 			tvec.sub(C, p[0]);							// calculate distance from vert0 to ray origin

	movss	xmm3, DWORD PTR [edx+4]
	subss	xmm3, DWORD PTR [eax+4]
	divss	xmm2, xmm1
	movss	xmm1, DWORD PTR [edx]
	movss	DWORD PTR _inv_det$[esp+40], xmm2
	movss	xmm2, DWORD PTR [eax]
	subss	xmm1, xmm2
	movss	xmm2, DWORD PTR [edx+8]
	subss	xmm2, DWORD PTR [eax+8]

; 95   : 			u = tvec.dotproduct(pvec)*inv_det;	// calculate U parameter and test bounds

	mov	eax, DWORD PTR _u$[esp+36]
	movaps	xmm4, xmm2
	mulss	xmm4, xmm6
	movaps	xmm6, xmm3
	mulss	xmm6, DWORD PTR _pvec$[esp+44]
	addss	xmm4, xmm6
	movaps	xmm6, xmm1
	mulss	xmm6, xmm5

; 96   : 			if (u < 0.0f || u > 1.0f)    return false;

	xorps	xmm5, xmm5
	addss	xmm4, xmm6
	mulss	xmm4, DWORD PTR _inv_det$[esp+40]
	comiss	xmm5, xmm4
	movss	DWORD PTR [eax], xmm4
	ja	$LN3@TestRayTri
	comiss	xmm4, DWORD PTR __real@3f800000
	ja	$LN3@TestRayTri

; 97   : 			qvec.crossproduct(tvec, edge1);				// prepare to test V parameter

	movaps	xmm5, xmm3
	mulss	xmm3, DWORD PTR _edge1$[esp+40]
	mulss	xmm5, DWORD PTR _edge1$[esp+48]
	movaps	xmm6, xmm2
	mulss	xmm6, DWORD PTR _edge1$[esp+44]
	mulss	xmm2, DWORD PTR _edge1$[esp+40]
	subss	xmm5, xmm6
	movaps	xmm6, xmm1
	mulss	xmm1, DWORD PTR _edge1$[esp+44]
	mulss	xmm6, DWORD PTR _edge1$[esp+48]
	subss	xmm1, xmm3

; 98   : 			v = D.dotproduct(qvec)*inv_det;	// calculate V parameter and test bounds

	mulss	xmm0, xmm5
	movaps	xmm3, xmm1
	mulss	xmm3, DWORD PTR [ecx+8]
	addss	xmm0, xmm3
	subss	xmm2, xmm6

; 99   : 			if (v < 0.0f || u + v > 1.0f) return false;

	xorps	xmm6, xmm6
	movaps	xmm3, xmm2
	mulss	xmm3, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _v$[esp+36]
	addss	xmm0, xmm3
	movss	xmm3, DWORD PTR _inv_det$[esp+40]
	mulss	xmm0, xmm3
	comiss	xmm6, xmm0
	movss	DWORD PTR [ecx], xmm0
	ja	SHORT $LN3@TestRayTri
	addss	xmm0, xmm4
	comiss	xmm0, DWORD PTR __real@3f800000
	ja	SHORT $LN3@TestRayTri

; 100  : 			range = edge2.dotproduct(qvec)*inv_det;// calculate t, ray intersects triangle

	mulss	xmm1, DWORD PTR _edge2$[esp+48]
	mulss	xmm5, DWORD PTR _edge2$[esp+40]
	mulss	xmm2, DWORD PTR _edge2$[esp+44]
	mov	edx, DWORD PTR _range$[esp+36]
	addss	xmm1, xmm5
	addss	xmm1, xmm2
	mulss	xmm1, xmm3
	movss	DWORD PTR [edx], xmm1

; 101  : 		}
; 102  : 		return true;

	mov	al, 1

; 103  : 	}

	add	esp, 40					; 00000028H
	ret	0
$LN3@TestRayTri:

; 96   : 			if (u < 0.0f || u > 1.0f)    return false;

	xor	al, al

; 103  : 	}

	add	esp, 40					; 00000028H
	ret	0
?TestRayTri@CDB@@YA_NABU?$_vector3@M@@0PAU2@AAM22_N@Z ENDP ; CDB::TestRayTri
_TEXT	ENDS
PUBLIC	?construct@CBoneInstance@@QAGXXZ		; CBoneInstance::construct
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\bone.h
;	COMDAT ?construct@CBoneInstance@@QAGXXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?construct@CBoneInstance@@QAGXXZ PROC			; CBoneInstance::construct, COMDAT

; 529  : 	ZeroMemory					(this,sizeof(*this));

	mov	eax, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ecx, DWORD PTR [eax+12]
	push	esi
	mov	esi, DWORD PTR _this$[esp]
	push	160					; 000000a0H
	push	0
	push	esi
	call	ecx

; 530  : 	mTransform.identity			();

	xorps	xmm0, xmm0
	movss	xmm1, DWORD PTR __real@3f800000
	movss	DWORD PTR [esi], xmm1
	movss	DWORD PTR [esi+4], xmm0
	movss	DWORD PTR [esi+8], xmm0
	movss	DWORD PTR [esi+12], xmm0
	movss	DWORD PTR [esi+16], xmm0
	movss	DWORD PTR [esi+20], xmm1
	movss	DWORD PTR [esi+24], xmm0
	movss	DWORD PTR [esi+28], xmm0
	movss	DWORD PTR [esi+32], xmm0
	movss	DWORD PTR [esi+36], xmm0
	movss	DWORD PTR [esi+40], xmm1
	movss	DWORD PTR [esi+44], xmm0
	movss	DWORD PTR [esi+48], xmm0
	movss	DWORD PTR [esi+52], xmm0
	movss	DWORD PTR [esi+56], xmm0
	movss	DWORD PTR [esi+60], xmm1

; 531  : 
; 532  : 	mRenderTransform.identity	();

	movss	DWORD PTR [esi+64], xmm1
	movss	DWORD PTR [esi+68], xmm0
	movss	DWORD PTR [esi+72], xmm0
	movss	DWORD PTR [esi+76], xmm0
	movss	DWORD PTR [esi+80], xmm0
	movss	DWORD PTR [esi+84], xmm1
	movss	DWORD PTR [esi+88], xmm0
	movss	DWORD PTR [esi+92], xmm0
	movss	DWORD PTR [esi+96], xmm0
	movss	DWORD PTR [esi+100], xmm0
	movss	DWORD PTR [esi+104], xmm1
	movss	DWORD PTR [esi+108], xmm0
	movss	DWORD PTR [esi+112], xmm0
	movss	DWORD PTR [esi+116], xmm0
	movss	DWORD PTR [esi+120], xmm0
	movss	DWORD PTR [esi+124], xmm1

; 533  : 	Callback_overwrite			= FALSE;

	mov	DWORD PTR [esi+136], 0
	pop	esi

; 534  : }

	ret	4
?construct@CBoneInstance@@QAGXXZ ENDP			; CBoneInstance::construct
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Reset@SBoneShape@@QAEXXZ
_TEXT	SEGMENT
?Reset@SBoneShape@@QAEXXZ PROC				; SBoneShape::Reset, COMDAT
; _this$ = eax

; 184  : 		flags.zero	();
; 185  :     	type		= stNone;
; 186  :         box.invalidate();

	xorps	xmm0, xmm0
	movss	xmm1, DWORD PTR __real@3f800000
	mov	WORD PTR [eax+2], 0
	mov	WORD PTR [eax], 0
	movss	DWORD PTR [eax+4], xmm1
	movss	DWORD PTR [eax+8], xmm0
	movss	DWORD PTR [eax+12], xmm0
	movss	DWORD PTR [eax+16], xmm0
	movss	DWORD PTR [eax+20], xmm1
	movss	DWORD PTR [eax+24], xmm0
	movss	DWORD PTR [eax+28], xmm0
	movss	DWORD PTR [eax+32], xmm0
	movss	DWORD PTR [eax+36], xmm1
	movss	DWORD PTR [eax+40], xmm0
	movss	DWORD PTR [eax+44], xmm0
	movss	DWORD PTR [eax+48], xmm0
	movss	DWORD PTR [eax+52], xmm0
	movss	DWORD PTR [eax+56], xmm0
	movss	DWORD PTR [eax+60], xmm0

; 187  :         sphere.P.set(0.f,0.f,0.f); sphere.R = 0.f;

	movss	DWORD PTR [eax+64], xmm0
	movss	DWORD PTR [eax+68], xmm0
	movss	DWORD PTR [eax+72], xmm0
	movss	DWORD PTR [eax+76], xmm0

; 188  :         cylinder.invalidate();

	movss	DWORD PTR [eax+80], xmm0
	movss	DWORD PTR [eax+84], xmm0
	movss	DWORD PTR [eax+88], xmm0
	movss	DWORD PTR [eax+92], xmm0
	movss	DWORD PTR [eax+96], xmm0
	movss	DWORD PTR [eax+100], xmm0
	movss	DWORD PTR [eax+104], xmm0
	movss	DWORD PTR [eax+108], xmm0

; 189  :     }

	ret	0
?Reset@SBoneShape@@QAEXXZ ENDP				; SBoneShape::Reset
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0SBoneShape@@QAE@XZ
_TEXT	SEGMENT
??0SBoneShape@@QAE@XZ PROC				; SBoneShape::SBoneShape, COMDAT
; _this$ = eax

; 181  :     SBoneShape		(){Reset();}

	xorps	xmm0, xmm0
	movss	xmm1, DWORD PTR __real@3f800000
	mov	WORD PTR [eax+2], 0
	mov	WORD PTR [eax], 0
	movss	DWORD PTR [eax+4], xmm1
	movss	DWORD PTR [eax+8], xmm0
	movss	DWORD PTR [eax+12], xmm0
	movss	DWORD PTR [eax+16], xmm0
	movss	DWORD PTR [eax+20], xmm1
	movss	DWORD PTR [eax+24], xmm0
	movss	DWORD PTR [eax+28], xmm0
	movss	DWORD PTR [eax+32], xmm0
	movss	DWORD PTR [eax+36], xmm1
	movss	DWORD PTR [eax+40], xmm0
	movss	DWORD PTR [eax+44], xmm0
	movss	DWORD PTR [eax+48], xmm0
	movss	DWORD PTR [eax+52], xmm0
	movss	DWORD PTR [eax+56], xmm0
	movss	DWORD PTR [eax+60], xmm0
	movss	DWORD PTR [eax+64], xmm0
	movss	DWORD PTR [eax+68], xmm0
	movss	DWORD PTR [eax+72], xmm0
	movss	DWORD PTR [eax+76], xmm0
	movss	DWORD PTR [eax+80], xmm0
	movss	DWORD PTR [eax+84], xmm0
	movss	DWORD PTR [eax+88], xmm0
	movss	DWORD PTR [eax+92], xmm0
	movss	DWORD PTR [eax+96], xmm0
	movss	DWORD PTR [eax+100], xmm0
	movss	DWORD PTR [eax+104], xmm0
	movss	DWORD PTR [eax+108], xmm0
	ret	0
??0SBoneShape@@QAE@XZ ENDP				; SBoneShape::SBoneShape
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Reset@SJointLimit@@QAEXXZ
_TEXT	SEGMENT
?Reset@SJointLimit@@QAEXXZ PROC				; SJointLimit::Reset, COMDAT
; _this$ = esi

; 152  :     	limit.set		(0.f,0.f);

	fldz
	sub	esp, 8
	fst	DWORD PTR [esp+4]
	mov	ecx, esi
	fstp	DWORD PTR [esp]
	call	?set@?$_vector2@M@@QAEAAU1@MM@Z		; _vector2<float>::set

; 153  :         spring_factor 	= 1.f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esi+8], xmm0

; 154  :         damping_factor  = 1.f;

	movss	DWORD PTR [esi+12], xmm0

; 155  :     }

	ret	0
?Reset@SJointLimit@@QAEXXZ ENDP				; SJointLimit::Reset
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0SJointLimit@@QAE@XZ
_TEXT	SEGMENT
??0SJointLimit@@QAE@XZ PROC				; SJointLimit::SJointLimit, COMDAT
; _this$ = ecx

; 149  :     SJointLimit		(){Reset();}

	fldz
	push	esi
	sub	esp, 8
	fst	DWORD PTR [esp+4]
	fstp	DWORD PTR [esp]
	mov	esi, ecx
	call	?set@?$_vector2@M@@QAEAAU1@MM@Z		; _vector2<float>::set
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esi+8], xmm0
	movss	DWORD PTR [esi+12], xmm0
	mov	eax, esi
	pop	esi
	ret	0
??0SJointLimit@@QAE@XZ ENDP				; SJointLimit::SJointLimit
_TEXT	ENDS
PUBLIC	?get_pos@vertBoned4W@@QAEXAAU?$_vector3@M@@@Z	; vertBoned4W::get_pos
; Function compile flags: /Ogtpy
;	COMDAT ?get_pos@vertBoned4W@@QAEXAAU?$_vector3@M@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?get_pos@vertBoned4W@@QAEXAAU?$_vector3@M@@@Z PROC	; vertBoned4W::get_pos, COMDAT
; _this$ = ecx

; 124  : 	void	get_pos( Fvector& p ) { p.set(P); }

	fld	DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _p$[esp-4]
	fstp	DWORD PTR [eax]
	fld	DWORD PTR [ecx+12]
	fstp	DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+16]
	fstp	DWORD PTR [eax+8]
	ret	4
?get_pos@vertBoned4W@@QAEXAAU?$_vector3@M@@@Z ENDP	; vertBoned4W::get_pos
_TEXT	ENDS
PUBLIC	?get_pos@vertBoned3W@@QAEXAAU?$_vector3@M@@@Z	; vertBoned3W::get_pos
; Function compile flags: /Ogtpy
;	COMDAT ?get_pos@vertBoned3W@@QAEXAAU?$_vector3@M@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?get_pos@vertBoned3W@@QAEXAAU?$_vector3@M@@@Z PROC	; vertBoned3W::get_pos, COMDAT
; _this$ = ecx

; 109  : 	void	get_pos( Fvector& p ) { p.set(P); }

	fld	DWORD PTR [ecx+6]
	mov	eax, DWORD PTR _p$[esp-4]
	fstp	DWORD PTR [eax]
	fld	DWORD PTR [ecx+10]
	fstp	DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+14]
	fstp	DWORD PTR [eax+8]
	ret	4
?get_pos@vertBoned3W@@QAEXAAU?$_vector3@M@@@Z ENDP	; vertBoned3W::get_pos
_TEXT	ENDS
PUBLIC	?get_pos@vertBoned2W@@QAEXAAU?$_vector3@M@@@Z	; vertBoned2W::get_pos
; Function compile flags: /Ogtpy
;	COMDAT ?get_pos@vertBoned2W@@QAEXAAU?$_vector3@M@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?get_pos@vertBoned2W@@QAEXAAU?$_vector3@M@@@Z PROC	; vertBoned2W::get_pos, COMDAT
; _this$ = ecx

; 94   : 	void	get_pos( Fvector& p ) { p.set(P); }

	fld	DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _p$[esp-4]
	fstp	DWORD PTR [eax]
	fld	DWORD PTR [ecx+8]
	fstp	DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+12]
	fstp	DWORD PTR [eax+8]
	ret	4
?get_pos@vertBoned2W@@QAEXAAU?$_vector3@M@@@Z ENDP	; vertBoned2W::get_pos
_TEXT	ENDS
PUBLIC	?get_pos@vertBoned1W@@QBEXAAU?$_vector3@M@@@Z	; vertBoned1W::get_pos
; Function compile flags: /Ogtpy
;	COMDAT ?get_pos@vertBoned1W@@QBEXAAU?$_vector3@M@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?get_pos@vertBoned1W@@QBEXAAU?$_vector3@M@@@Z PROC	; vertBoned1W::get_pos, COMDAT
; _this$ = ecx

; 78   : 	void	get_pos( Fvector& p ) const { p.set(P); }

	fld	DWORD PTR [ecx]
	mov	eax, DWORD PTR _p$[esp-4]
	fstp	DWORD PTR [eax]
	fld	DWORD PTR [ecx+4]
	fstp	DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+8]
	fstp	DWORD PTR [eax+8]
	ret	4
?get_pos@vertBoned1W@@QBEXAAU?$_vector3@M@@@Z ENDP	; vertBoned1W::get_pos
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcdb\xr_collide_defs.h
_TEXT	ENDS
;	COMDAT ?r_clear@rq_results@collide@@QAEXXZ
_TEXT	SEGMENT
?r_clear@rq_results@collide@@QAEXXZ PROC		; collide::rq_results::r_clear, COMDAT
; _this$ = edi

; 134  : 		IC void			r_clear			()	{ results.clear_not_free();	}

	mov	ecx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edi]
	cmp	eax, ecx
	je	SHORT $LN24@r_clear
	push	esi
	mov	esi, ecx
	sub	esi, ecx
	je	SHORT $LN32@r_clear
	push	esi
	push	ecx
	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	add	eax, esi
$LN32@r_clear:
	mov	DWORD PTR [edi+4], eax
	pop	esi
$LN24@r_clear:
	ret	0
?r_clear@rq_results@collide@@QAEXXZ ENDP		; collide::rq_results::r_clear
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0ray_cache@collide@@QAE@XZ
_TEXT	SEGMENT
??0ray_cache@collide@@QAE@XZ PROC			; collide::ray_cache::ray_cache, COMDAT
; _this$ = ecx

; 33   : 		{
; 34   : 			start.set	(0,0,0);

	xorps	xmm0, xmm0
	mov	eax, ecx
	movss	DWORD PTR [eax], xmm0
	movss	DWORD PTR [eax+4], xmm0
	movss	DWORD PTR [eax+8], xmm0

; 35   : 			dir.set		(0,0,0);

	movss	DWORD PTR [eax+12], xmm0
	movss	DWORD PTR [eax+16], xmm0
	movss	DWORD PTR [eax+20], xmm0

; 36   : 			range		= 0;

	movss	DWORD PTR [eax+24], xmm0

; 37   : 			result		= FALSE;

	mov	DWORD PTR [eax+28], 0

; 38   : 			verts[0].set(0,0,0);

	movss	DWORD PTR [eax+32], xmm0
	movss	DWORD PTR [eax+36], xmm0
	movss	DWORD PTR [eax+40], xmm0

; 39   : 			verts[1].set(0,0,0);

	movss	DWORD PTR [eax+44], xmm0
	movss	DWORD PTR [eax+48], xmm0
	movss	DWORD PTR [eax+52], xmm0

; 40   : 			verts[2].set(0,0,0);

	movss	DWORD PTR [eax+56], xmm0
	movss	DWORD PTR [eax+60], xmm0
	movss	DWORD PTR [eax+64], xmm0

; 41   : 		}

	ret	0
??0ray_cache@collide@@QAE@XZ ENDP			; collide::ray_cache::ray_cache
; Function compile flags: /Ogtpy
;	COMDAT ??_G?$xr_vector@GV?$xalloc@G@@@@QAEPAXI@Z
_TEXT	SEGMENT
??_G?$xr_vector@GV?$xalloc@G@@@@QAEPAXI@Z PROC		; xr_vector<unsigned short,xalloc<unsigned short> >::`scalar deleting destructor', COMDAT
; _this$ = esi
	mov	ecx, esi
	call	??1?$_Impl_vector@GV?$xalloc@G@@@priv@stlp_std@@QAE@XZ ; stlp_std::priv::_Impl_vector<unsigned short,xalloc<unsigned short> >::~_Impl_vector<unsigned short,xalloc<unsigned short> >
	mov	eax, esi
	ret	0
??_G?$xr_vector@GV?$xalloc@G@@@@QAEPAXI@Z ENDP		; xr_vector<unsigned short,xalloc<unsigned short> >::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_construct.h
_TEXT	ENDS
;	COMDAT ??$__destroy_aux@V?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@YAXPAV?$xr_vector@GV?$xalloc@G@@@@ABU__false_type@0@@Z
_TEXT	SEGMENT
??$__destroy_aux@V?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@YAXPAV?$xr_vector@GV?$xalloc@G@@@@ABU__false_type@0@@Z PROC ; stlp_std::__destroy_aux<xr_vector<unsigned short,xalloc<unsigned short> > >, COMDAT
; ___pointer$ = ecx

; 53   : { __pointer->~_Tp(); }

	jmp	??1?$_Impl_vector@GV?$xalloc@G@@@priv@stlp_std@@QAE@XZ ; stlp_std::priv::_Impl_vector<unsigned short,xalloc<unsigned short> >::~_Impl_vector<unsigned short,xalloc<unsigned short> >
??$__destroy_aux@V?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@YAXPAV?$xr_vector@GV?$xalloc@G@@@@ABU__false_type@0@@Z ENDP ; stlp_std::__destroy_aux<xr_vector<unsigned short,xalloc<unsigned short> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$__destroy_range_aux@PAV?$xr_vector@GV?$xalloc@G@@@@V1@@stlp_std@@YAXPAV?$xr_vector@GV?$xalloc@G@@@@00ABU__false_type@0@@Z
_TEXT	SEGMENT
??$__destroy_range_aux@PAV?$xr_vector@GV?$xalloc@G@@@@V1@@stlp_std@@YAXPAV?$xr_vector@GV?$xalloc@G@@@@00ABU__false_type@0@@Z PROC ; stlp_std::__destroy_range_aux<xr_vector<unsigned short,xalloc<unsigned short> > *,xr_vector<unsigned short,xalloc<unsigned short> > >, COMDAT
; ___first$ = eax
; ___last$ = edi

; 151  : __destroy_range_aux(_ForwardIterator __first, _ForwardIterator __last, _Tp*, const __false_type& /*_Trivial_destructor*/) {

	push	esi
	mov	esi, eax

; 152  :   for ( ; __first != __last; ++__first) {

	cmp	esi, edi
	je	SHORT $LN1@destroy_ra@6
$LL3@destroy_ra@6:

; 153  :     __destroy_aux(&(*__first), __false_type());

	mov	ecx, esi
	call	??1?$_Impl_vector@GV?$xalloc@G@@@priv@stlp_std@@QAE@XZ ; stlp_std::priv::_Impl_vector<unsigned short,xalloc<unsigned short> >::~_Impl_vector<unsigned short,xalloc<unsigned short> >
	add	esi, 12					; 0000000cH
	cmp	esi, edi
	jne	SHORT $LL3@destroy_ra@6
$LN1@destroy_ra@6:
	pop	esi

; 154  : #if defined (_STLP_DEBUG_UNINITIALIZED)
; 155  :     memset((char*)&(*__first), _STLP_SHRED_BYTE, sizeof(_Tp));
; 156  : #endif
; 157  :   }
; 158  : }

	ret	0
??$__destroy_range_aux@PAV?$xr_vector@GV?$xalloc@G@@@@V1@@stlp_std@@YAXPAV?$xr_vector@GV?$xalloc@G@@@@00ABU__false_type@0@@Z ENDP ; stlp_std::__destroy_range_aux<xr_vector<unsigned short,xalloc<unsigned short> > *,xr_vector<unsigned short,xalloc<unsigned short> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Param_Construct@V?$xr_vector@GV?$xalloc@G@@@@V1@@stlp_std@@YAXPAV?$xr_vector@GV?$xalloc@G@@@@ABV1@@Z
_TEXT	SEGMENT
??$_Param_Construct@V?$xr_vector@GV?$xalloc@G@@@@V1@@stlp_std@@YAXPAV?$xr_vector@GV?$xalloc@G@@@@ABV1@@Z PROC ; stlp_std::_Param_Construct<xr_vector<unsigned short,xalloc<unsigned short> >,xr_vector<unsigned short,xalloc<unsigned short> > >, COMDAT
; ___p$ = ecx
; ___val$ = eax

; 118  : #if defined (_STLP_DEBUG_UNINITIALIZED)
; 119  :   memset((char*)__p, _STLP_SHRED_BYTE, sizeof(_T1));
; 120  : #endif
; 121  :   _STLP_PLACEMENT_NEW (__p) _T1(__val);

	test	ecx, ecx
	je	SHORT $LN3@Param_Cons@14
	push	eax
	call	??0?$vector@GV?$xalloc@G@@@stlp_std@@QAE@ABV01@@Z ; stlp_std::vector<unsigned short,xalloc<unsigned short> >::vector<unsigned short,xalloc<unsigned short> >
$LN3@Param_Cons@14:

; 122  : }

	ret	0
??$_Param_Construct@V?$xr_vector@GV?$xalloc@G@@@@V1@@stlp_std@@YAXPAV?$xr_vector@GV?$xalloc@G@@@@ABV1@@Z ENDP ; stlp_std::_Param_Construct<xr_vector<unsigned short,xalloc<unsigned short> >,xr_vector<unsigned short,xalloc<unsigned short> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$__destroy_range_aux@V?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@V?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@YAXV?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@0@0PAV?$xr_vector@GV?$xalloc@G@@@@ABU__false_type@0@@Z
_TEXT	SEGMENT
___first$ = 8						; size = 4
___last$ = 12						; size = 4
??$__destroy_range_aux@V?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@V?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@YAXV?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@0@0PAV?$xr_vector@GV?$xalloc@G@@@@ABU__false_type@0@@Z PROC ; stlp_std::__destroy_range_aux<stlp_std::reverse_iterator<xr_vector<unsigned short,xalloc<unsigned short> > *>,xr_vector<unsigned short,xalloc<unsigned short> > >, COMDAT

; 152  :   for ( ; __first != __last; ++__first) {

	mov	eax, DWORD PTR ___first$[esp-4]
	push	edi
	mov	edi, DWORD PTR ___last$[esp]
	cmp	eax, edi
	je	SHORT $LN1@destroy_ra@7
	push	esi
	npad	2
$LL6@destroy_ra@7:
	lea	esi, DWORD PTR [eax-12]

; 153  :     __destroy_aux(&(*__first), __false_type());

	mov	ecx, esi
	call	??1?$_Impl_vector@GV?$xalloc@G@@@priv@stlp_std@@QAE@XZ ; stlp_std::priv::_Impl_vector<unsigned short,xalloc<unsigned short> >::~_Impl_vector<unsigned short,xalloc<unsigned short> >
	mov	eax, esi
	cmp	eax, edi
	jne	SHORT $LL6@destroy_ra@7
	pop	esi
$LN1@destroy_ra@7:
	pop	edi

; 154  : #if defined (_STLP_DEBUG_UNINITIALIZED)
; 155  :     memset((char*)&(*__first), _STLP_SHRED_BYTE, sizeof(_Tp));
; 156  : #endif
; 157  :   }
; 158  : }

	ret	0
??$__destroy_range_aux@V?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@V?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@YAXV?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@0@0PAV?$xr_vector@GV?$xalloc@G@@@@ABU__false_type@0@@Z ENDP ; stlp_std::__destroy_range_aux<stlp_std::reverse_iterator<xr_vector<unsigned short,xalloc<unsigned short> > *>,xr_vector<unsigned short,xalloc<unsigned short> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$__destroy_range@PAV?$xr_vector@GV?$xalloc@G@@@@V1@@stlp_std@@YAXPAV?$xr_vector@GV?$xalloc@G@@@@00@Z
_TEXT	SEGMENT
??$__destroy_range@PAV?$xr_vector@GV?$xalloc@G@@@@V1@@stlp_std@@YAXPAV?$xr_vector@GV?$xalloc@G@@@@00@Z PROC ; stlp_std::__destroy_range<xr_vector<unsigned short,xalloc<unsigned short> > *,xr_vector<unsigned short,xalloc<unsigned short> > >, COMDAT
; ___first$ = eax
; ___last$ = edi

; 174  : __destroy_range(_ForwardIterator __first, _ForwardIterator __last, _Tp *__ptr) {

	push	esi
	mov	esi, eax

; 175  :   typedef typename __type_traits<_Tp>::has_trivial_destructor _Trivial_destructor;
; 176  :   __destroy_range_aux(__first, __last, __ptr, _Trivial_destructor());

	cmp	esi, edi
	je	SHORT $LN3@destroy_ra@8
$LL5@destroy_ra@8:
	mov	ecx, esi
	call	??1?$_Impl_vector@GV?$xalloc@G@@@priv@stlp_std@@QAE@XZ ; stlp_std::priv::_Impl_vector<unsigned short,xalloc<unsigned short> >::~_Impl_vector<unsigned short,xalloc<unsigned short> >
	add	esi, 12					; 0000000cH
	cmp	esi, edi
	jne	SHORT $LL5@destroy_ra@8
$LN3@destroy_ra@8:
	pop	esi

; 177  : }

	ret	0
??$__destroy_range@PAV?$xr_vector@GV?$xalloc@G@@@@V1@@stlp_std@@YAXPAV?$xr_vector@GV?$xalloc@G@@@@00@Z ENDP ; stlp_std::__destroy_range<xr_vector<unsigned short,xalloc<unsigned short> > *,xr_vector<unsigned short,xalloc<unsigned short> > >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_uninitialized.h
_TEXT	ENDS
;	COMDAT ??$__ucopy@PBV?$xr_vector@GV?$xalloc@G@@@@PAV1@H@priv@stlp_std@@YAPAV?$xr_vector@GV?$xalloc@G@@@@PBV2@0PAV2@ABUrandom_access_iterator_tag@1@PAH@Z
_TEXT	SEGMENT
??$__ucopy@PBV?$xr_vector@GV?$xalloc@G@@@@PAV1@H@priv@stlp_std@@YAPAV?$xr_vector@GV?$xalloc@G@@@@PBV2@0PAV2@ABUrandom_access_iterator_tag@1@PAH@Z PROC ; stlp_std::priv::__ucopy<xr_vector<unsigned short,xalloc<unsigned short> > const *,xr_vector<unsigned short,xalloc<unsigned short> > *,int>, COMDAT
; ___first$ = ecx
; ___last$ = eax
; ___result$ = edx

; 83   :                            _OutputIter __result, const random_access_iterator_tag &, _Distance*) {

	push	ebx
	mov	ebx, ecx

; 84   :   _OutputIter __cur = __result;
; 85   :   _STLP_TRY {
; 86   :     for (_Distance __n = __last - __first; __n > 0; --__n) {

	sub	eax, ebx
	push	esi
	mov	ecx, eax
	push	edi
	mov	edi, edx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	test	esi, esi
	jle	SHORT $LN36@ucopy@9
	npad	1
$LL3@ucopy@9:

; 87   :       _Param_Construct(&*__cur, *__first);

	test	edi, edi
	je	SHORT $LN8@ucopy@9
	push	ebx
	mov	ecx, edi
	call	??0?$vector@GV?$xalloc@G@@@stlp_std@@QAE@ABV01@@Z ; stlp_std::vector<unsigned short,xalloc<unsigned short> >::vector<unsigned short,xalloc<unsigned short> >
$LN8@ucopy@9:
	sub	esi, 1

; 88   :       ++__first;

	add	ebx, 12					; 0000000cH

; 89   :       ++__cur;

	add	edi, 12					; 0000000cH
	test	esi, esi
	jg	SHORT $LL3@ucopy@9
$LN36@ucopy@9:

; 90   :     }
; 91   :     return __cur;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 92   :   }
; 93   :   _STLP_UNWIND(_STLP_STD::_Destroy_Range(__result, __cur))
; 94   :   _STLP_RET_AFTER_THROW(__cur)
; 95   : }

	ret	0
??$__ucopy@PBV?$xr_vector@GV?$xalloc@G@@@@PAV1@H@priv@stlp_std@@YAPAV?$xr_vector@GV?$xalloc@G@@@@PBV2@0PAV2@ABUrandom_access_iterator_tag@1@PAH@Z ENDP ; stlp_std::priv::__ucopy<xr_vector<unsigned short,xalloc<unsigned short> > const *,xr_vector<unsigned short,xalloc<unsigned short> > *,int>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_construct.h
_TEXT	ENDS
;	COMDAT ??$__destroy_range@V?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@V?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@YAXV?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@0@0PAV?$xr_vector@GV?$xalloc@G@@@@@Z
_TEXT	SEGMENT
___first$ = 8						; size = 4
___last$ = 12						; size = 4
??$__destroy_range@V?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@V?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@YAXV?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@0@0PAV?$xr_vector@GV?$xalloc@G@@@@@Z PROC ; stlp_std::__destroy_range<stlp_std::reverse_iterator<xr_vector<unsigned short,xalloc<unsigned short> > *>,xr_vector<unsigned short,xalloc<unsigned short> > >, COMDAT

; 175  :   typedef typename __type_traits<_Tp>::has_trivial_destructor _Trivial_destructor;
; 176  :   __destroy_range_aux(__first, __last, __ptr, _Trivial_destructor());

	mov	eax, DWORD PTR ___first$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR ___last$[esp+4]
	cmp	eax, edi
	je	SHORT $LN7@destroy_ra@9
	npad	2
$LL12@destroy_ra@9:
	lea	esi, DWORD PTR [eax-12]
	mov	ecx, esi
	call	??1?$_Impl_vector@GV?$xalloc@G@@@priv@stlp_std@@QAE@XZ ; stlp_std::priv::_Impl_vector<unsigned short,xalloc<unsigned short> >::~_Impl_vector<unsigned short,xalloc<unsigned short> >
	mov	eax, esi
	cmp	eax, edi
	jne	SHORT $LL12@destroy_ra@9
$LN7@destroy_ra@9:

; 177  : }

	pop	edi
	pop	esi
	ret	0
??$__destroy_range@V?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@V?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@YAXV?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@0@0PAV?$xr_vector@GV?$xalloc@G@@@@@Z ENDP ; stlp_std::__destroy_range<stlp_std::reverse_iterator<xr_vector<unsigned short,xalloc<unsigned short> > *>,xr_vector<unsigned short,xalloc<unsigned short> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_Range@PAV?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@YAXPAV?$xr_vector@GV?$xalloc@G@@@@0@Z
_TEXT	SEGMENT
??$_Destroy_Range@PAV?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@YAXPAV?$xr_vector@GV?$xalloc@G@@@@0@Z PROC ; stlp_std::_Destroy_Range<xr_vector<unsigned short,xalloc<unsigned short> > *>, COMDAT
; ___first$ = eax
; ___last$ = edi

; 180  : inline void _Destroy_Range(_ForwardIterator __first, _ForwardIterator __last) {

	push	esi
	mov	esi, eax

; 181  :   __destroy_range(__first, __last, _STLP_VALUE_TYPE(__first, _ForwardIterator));

	cmp	esi, edi
	je	SHORT $LN5@Destroy_Ra
$LL7@Destroy_Ra:
	mov	ecx, esi
	call	??1?$_Impl_vector@GV?$xalloc@G@@@priv@stlp_std@@QAE@XZ ; stlp_std::priv::_Impl_vector<unsigned short,xalloc<unsigned short> >::~_Impl_vector<unsigned short,xalloc<unsigned short> >
	add	esi, 12					; 0000000cH
	cmp	esi, edi
	jne	SHORT $LL7@Destroy_Ra
$LN5@Destroy_Ra:
	pop	esi

; 182  : }

	ret	0
??$_Destroy_Range@PAV?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@YAXPAV?$xr_vector@GV?$xalloc@G@@@@0@Z ENDP ; stlp_std::_Destroy_Range<xr_vector<unsigned short,xalloc<unsigned short> > *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_uninitialized.h
_TEXT	ENDS
;	COMDAT ??$__ucopy_ptrs@PBV?$xr_vector@GV?$xalloc@G@@@@PAV1@@priv@stlp_std@@YAPAV?$xr_vector@GV?$xalloc@G@@@@PBV2@0PAV2@ABU__false_type@1@@Z
_TEXT	SEGMENT
??$__ucopy_ptrs@PBV?$xr_vector@GV?$xalloc@G@@@@PAV1@@priv@stlp_std@@YAPAV?$xr_vector@GV?$xalloc@G@@@@PBV2@0PAV2@ABU__false_type@1@@Z PROC ; stlp_std::priv::__ucopy_ptrs<xr_vector<unsigned short,xalloc<unsigned short> > const *,xr_vector<unsigned short,xalloc<unsigned short> > *>, COMDAT
; ___first$ = ecx
; ___last$ = eax
; ___result$ = edx

; 113  : { return __ucopy(__first, __last, __result, random_access_iterator_tag(), (ptrdiff_t*)0); }

	jmp	??$__ucopy@PBV?$xr_vector@GV?$xalloc@G@@@@PAV1@H@priv@stlp_std@@YAPAV?$xr_vector@GV?$xalloc@G@@@@PBV2@0PAV2@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<xr_vector<unsigned short,xalloc<unsigned short> > const *,xr_vector<unsigned short,xalloc<unsigned short> > *,int>
??$__ucopy_ptrs@PBV?$xr_vector@GV?$xalloc@G@@@@PAV1@@priv@stlp_std@@YAPAV?$xr_vector@GV?$xalloc@G@@@@PBV2@0PAV2@ABU__false_type@1@@Z ENDP ; stlp_std::priv::__ucopy_ptrs<xr_vector<unsigned short,xalloc<unsigned short> > const *,xr_vector<unsigned short,xalloc<unsigned short> > *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_construct.h
_TEXT	ENDS
;	COMDAT ??$_Destroy_Range@V?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@@stlp_std@@YAXV?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@0@0@Z
_TEXT	SEGMENT
___first$ = 8						; size = 4
___last$ = 12						; size = 4
??$_Destroy_Range@V?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@@stlp_std@@YAXV?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@0@0@Z PROC ; stlp_std::_Destroy_Range<stlp_std::reverse_iterator<xr_vector<unsigned short,xalloc<unsigned short> > *> >, COMDAT

; 181  :   __destroy_range(__first, __last, _STLP_VALUE_TYPE(__first, _ForwardIterator));

	mov	eax, DWORD PTR ___first$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR ___last$[esp+4]
	cmp	eax, edi
	je	SHORT $LN13@Destroy_Ra@2
	npad	2
$LL18@Destroy_Ra@2:
	lea	esi, DWORD PTR [eax-12]
	mov	ecx, esi
	call	??1?$_Impl_vector@GV?$xalloc@G@@@priv@stlp_std@@QAE@XZ ; stlp_std::priv::_Impl_vector<unsigned short,xalloc<unsigned short> >::~_Impl_vector<unsigned short,xalloc<unsigned short> >
	mov	eax, esi
	cmp	eax, edi
	jne	SHORT $LL18@Destroy_Ra@2
$LN13@Destroy_Ra@2:

; 182  : }

	pop	edi
	pop	esi
	ret	0
??$_Destroy_Range@V?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@stlp_std@@@stlp_std@@YAXV?$reverse_iterator@PAV?$xr_vector@GV?$xalloc@G@@@@@0@0@Z ENDP ; stlp_std::_Destroy_Range<stlp_std::reverse_iterator<xr_vector<unsigned short,xalloc<unsigned short> > *> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ??0?$_Vector_base@Urq_result@collide@@V?$xalloc@Urq_result@collide@@@@@priv@stlp_std@@QAE@ABV?$xalloc@Urq_result@collide@@@@@Z
_TEXT	SEGMENT
??0?$_Vector_base@Urq_result@collide@@V?$xalloc@Urq_result@collide@@@@@priv@stlp_std@@QAE@ABV?$xalloc@Urq_result@collide@@@@@Z PROC ; stlp_std::priv::_Vector_base<collide::rq_result,xalloc<collide::rq_result> >::_Vector_base<collide::rq_result,xalloc<collide::rq_result> >, COMDAT
; _this$ = eax

; 67   :     : _M_start(0), _M_finish(0), _M_end_of_storage(__a, 0) {}

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$_Vector_base@Urq_result@collide@@V?$xalloc@Urq_result@collide@@@@@priv@stlp_std@@QAE@ABV?$xalloc@Urq_result@collide@@@@@Z ENDP ; stlp_std::priv::_Vector_base<collide::rq_result,xalloc<collide::rq_result> >::_Vector_base<collide::rq_result,xalloc<collide::rq_result> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Impl_vector@Urq_result@collide@@V?$xalloc@Urq_result@collide@@@@@priv@stlp_std@@QAE@ABV?$xalloc@Urq_result@collide@@@@@Z
_TEXT	SEGMENT
??0?$_Impl_vector@Urq_result@collide@@V?$xalloc@Urq_result@collide@@@@@priv@stlp_std@@QAE@ABV?$xalloc@Urq_result@collide@@@@@Z PROC ; stlp_std::priv::_Impl_vector<collide::rq_result,xalloc<collide::rq_result> >::_Impl_vector<collide::rq_result,xalloc<collide::rq_result> >, COMDAT
; _this$ = eax

; 208  :     : _STLP_PRIV _Vector_base<_Tp, _Alloc>(__a) {}

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$_Impl_vector@Urq_result@collide@@V?$xalloc@Urq_result@collide@@@@@priv@stlp_std@@QAE@ABV?$xalloc@Urq_result@collide@@@@@Z ENDP ; stlp_std::priv::_Impl_vector<collide::rq_result,xalloc<collide::rq_result> >::_Impl_vector<collide::rq_result,xalloc<collide::rq_result> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAE@ABV012@@Z
_TEXT	SEGMENT
??0?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAE@ABV012@@Z PROC ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >, COMDAT
; _this$ = esi
; ___x$ = ebx

; 236  :   { this->_M_finish = _STLP_PRIV __ucopy_ptrs(__x.begin(), __x.end(), this->_M_start, _TrivialUCopy()); }

	mov	ecx, DWORD PTR [ebx+4]
	sub	ecx, DWORD PTR [ebx]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	push	edi
	shr	eax, 31					; 0000001fH
	add	eax, edx
	xor	ecx, ecx
	lea	edi, DWORD PTR [eax+eax*2]
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [esi+4], ecx
	add	edi, edi
	mov	DWORD PTR [esi+8], ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	add	edi, edi
	push	edi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	mov	edx, eax
	add	edi, edx
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [esi+4], edx
	mov	DWORD PTR [esi+8], edi
	mov	eax, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [ebx]
	call	??$__ucopy@PBV?$xr_vector@GV?$xalloc@G@@@@PAV1@H@priv@stlp_std@@YAPAV?$xr_vector@GV?$xalloc@G@@@@PBV2@0PAV2@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<xr_vector<unsigned short,xalloc<unsigned short> > const *,xr_vector<unsigned short,xalloc<unsigned short> > *,int>
	mov	DWORD PTR [esi+4], eax
	mov	eax, esi
	pop	edi
	ret	0
??0?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAE@ABV012@@Z ENDP ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ??0?$vector@PAVCBoneData@@V?$xalloc@PAVCBoneData@@@@@stlp_std@@QAE@ABV?$xalloc@PAVCBoneData@@@@@Z
_TEXT	SEGMENT
??0?$vector@PAVCBoneData@@V?$xalloc@PAVCBoneData@@@@@stlp_std@@QAE@ABV?$xalloc@PAVCBoneData@@@@@Z PROC ; stlp_std::vector<CBoneData *,xalloc<CBoneData *> >::vector<CBoneData *,xalloc<CBoneData *> >, COMDAT
; _this$ = eax

; 106  :   explicit vector(const allocator_type& __a = allocator_type())

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$vector@PAVCBoneData@@V?$xalloc@PAVCBoneData@@@@@stlp_std@@QAE@ABV?$xalloc@PAVCBoneData@@@@@Z ENDP ; stlp_std::vector<CBoneData *,xalloc<CBoneData *> >::vector<CBoneData *,xalloc<CBoneData *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@stlp_std@@QAE@ABV?$xalloc@PAVCLensFlareDescriptor@@@@@Z
_TEXT	SEGMENT
??0?$vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@stlp_std@@QAE@ABV?$xalloc@PAVCLensFlareDescriptor@@@@@Z PROC ; stlp_std::vector<CLensFlareDescriptor *,xalloc<CLensFlareDescriptor *> >::vector<CLensFlareDescriptor *,xalloc<CLensFlareDescriptor *> >, COMDAT
; _this$ = eax

; 106  :   explicit vector(const allocator_type& __a = allocator_type())

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@stlp_std@@QAE@ABV?$xalloc@PAVCLensFlareDescriptor@@@@@Z ENDP ; stlp_std::vector<CLensFlareDescriptor *,xalloc<CLensFlareDescriptor *> >::vector<CLensFlareDescriptor *,xalloc<CLensFlareDescriptor *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$vector@Urq_result@collide@@V?$xalloc@Urq_result@collide@@@@@stlp_std@@QAE@ABV?$xalloc@Urq_result@collide@@@@@Z
_TEXT	SEGMENT
??0?$vector@Urq_result@collide@@V?$xalloc@Urq_result@collide@@@@@stlp_std@@QAE@ABV?$xalloc@Urq_result@collide@@@@@Z PROC ; stlp_std::vector<collide::rq_result,xalloc<collide::rq_result> >::vector<collide::rq_result,xalloc<collide::rq_result> >, COMDAT
; _this$ = eax

; 106  :   explicit vector(const allocator_type& __a = allocator_type())

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$vector@Urq_result@collide@@V?$xalloc@Urq_result@collide@@@@@stlp_std@@QAE@ABV?$xalloc@Urq_result@collide@@@@@Z ENDP ; stlp_std::vector<collide::rq_result,xalloc<collide::rq_result> >::vector<collide::rq_result,xalloc<collide::rq_result> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ??1?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAE@XZ PROC ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::~_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >, COMDAT
; _this$ = ebx

; 286  :   ~vector() { _STLP_STD::_Destroy_Range(rbegin(), rend()); }

	mov	eax, DWORD PTR [ebx+4]
	push	esi
	push	edi
	mov	edi, DWORD PTR [ebx]
	cmp	eax, edi
	je	SHORT $LN27@Impl_vecto@37
	npad	5
$LL32@Impl_vecto@37:
	lea	esi, DWORD PTR [eax-12]
	mov	ecx, esi
	call	??1?$_Impl_vector@GV?$xalloc@G@@@priv@stlp_std@@QAE@XZ ; stlp_std::priv::_Impl_vector<unsigned short,xalloc<unsigned short> >::~_Impl_vector<unsigned short,xalloc<unsigned short> >
	mov	eax, esi
	cmp	eax, edi
	jne	SHORT $LL32@Impl_vecto@37
$LN27@Impl_vecto@37:
	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN63@Impl_vecto@37
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN63@Impl_vecto@37:
	pop	edi
	pop	esi
	ret	0
??1?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAE@XZ ENDP ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::~_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ??0?$vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@stlp_std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@stlp_std@@QAE@ABV01@@Z PROC ; stlp_std::vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >, COMDAT
; _this$ = esi
; ___x$ = ebx

; 123  :   vector(const _Self& __x)

	mov	ecx, DWORD PTR [ebx+4]
	sub	ecx, DWORD PTR [ebx]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	push	edi
	shr	eax, 31					; 0000001fH
	add	eax, edx
	xor	ecx, ecx
	lea	edi, DWORD PTR [eax+eax*2]
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [esi+4], ecx
	add	edi, edi
	mov	DWORD PTR [esi+8], ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	add	edi, edi
	push	edi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	mov	edx, eax
	add	edi, edx
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [esi+4], edx
	mov	DWORD PTR [esi+8], edi
	mov	eax, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [ebx]
	call	??$__ucopy@PBV?$xr_vector@GV?$xalloc@G@@@@PAV1@H@priv@stlp_std@@YAPAV?$xr_vector@GV?$xalloc@G@@@@PBV2@0PAV2@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<xr_vector<unsigned short,xalloc<unsigned short> > const *,xr_vector<unsigned short,xalloc<unsigned short> > *,int>
	mov	DWORD PTR [esi+4], eax
	mov	eax, esi
	pop	edi
	ret	0
??0?$vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@stlp_std@@QAE@ABV01@@Z ENDP ; stlp_std::vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ??0?$xr_vector@Urq_result@collide@@V?$xalloc@Urq_result@collide@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@Urq_result@collide@@V?$xalloc@Urq_result@collide@@@@@@QAE@XZ PROC ; xr_vector<collide::rq_result,xalloc<collide::rq_result> >::xr_vector<collide::rq_result,xalloc<collide::rq_result> >, COMDAT
; _this$ = eax

; 123  : 			xr_vector			()									: inherited	()					{}

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$xr_vector@Urq_result@collide@@V?$xalloc@Urq_result@collide@@@@@@QAE@XZ ENDP ; xr_vector<collide::rq_result,xalloc<collide::rq_result> >::xr_vector<collide::rq_result,xalloc<collide::rq_result> >
_TEXT	ENDS
PUBLIC	?OnDeviceDestroy@CLensFlare@@QAEXXZ		; CLensFlare::OnDeviceDestroy
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\xr_efflensflare.cpp
;	COMDAT ?OnDeviceDestroy@CLensFlare@@QAEXXZ
_TEXT	SEGMENT
?OnDeviceDestroy@CLensFlare@@QAEXXZ PROC		; CLensFlare::OnDeviceDestroy, COMDAT
; _this$ = ecx

; 579  : {

	push	ebx
	push	ebp
	mov	ebp, ecx

; 580  : 	// palette
; 581  :     for (LensFlareDescIt it=m_Palette.begin(); it!=m_Palette.end(); it++)

	mov	eax, DWORD PTR [ebp+476]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	mov	ebx, eax
	mov	eax, DWORD PTR [ebp+480]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 8
	cmp	ebx, eax
	je	SHORT $LN1@OnDeviceDe@2
	push	esi
	push	edi
$LL3@OnDeviceDe@2:

; 582  :         (*it)->OnDeviceDestroy();

	mov	edi, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [edi+64]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	ecx, DWORD PTR [edi+36]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	esi, DWORD PTR [edi]
	cmp	esi, DWORD PTR [edi+4]
	je	SHORT $LN2@OnDeviceDe@2
$LL24@OnDeviceDe@2:
	mov	ecx, DWORD PTR [esi+20]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	add	esi, 24					; 00000018H
	cmp	esi, DWORD PTR [edi+4]
	jne	SHORT $LL24@OnDeviceDe@2
$LN2@OnDeviceDe@2:

; 580  : 	// palette
; 581  :     for (LensFlareDescIt it=m_Palette.begin(); it!=m_Palette.end(); it++)

	mov	eax, DWORD PTR [ebp+480]
	push	eax
	add	ebx, 4
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 4
	cmp	ebx, eax
	jne	SHORT $LL3@OnDeviceDe@2
	pop	edi
	pop	esi
$LN1@OnDeviceDe@2:

; 583  : 
; 584  : 	// VS
; 585  : 	//hGeom.destroy();
; 586  : 	m_pRender->OnDeviceDestroy();

	mov	ecx, DWORD PTR [ebp+472]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	pop	ebp
	pop	ebx
	jmp	edx
?OnDeviceDestroy@CLensFlare@@QAEXXZ ENDP		; CLensFlare::OnDeviceDestroy
_TEXT	ENDS
PUBLIC	?OnDeviceCreate@CLensFlare@@QAEXXZ		; CLensFlare::OnDeviceCreate
; Function compile flags: /Ogtpy
;	COMDAT ?OnDeviceCreate@CLensFlare@@QAEXXZ
_TEXT	SEGMENT
?OnDeviceCreate@CLensFlare@@QAEXXZ PROC			; CLensFlare::OnDeviceCreate, COMDAT
; _this$ = ecx

; 568  : {

	push	esi
	push	edi
	mov	edi, ecx

; 569  : 	// VS
; 570  : 	//hGeom.create		(FVF::F_LIT,RCache.Vertex.Buffer(),RCache.QuadIB);
; 571  : 	m_pRender->OnDeviceCreate();

	mov	ecx, DWORD PTR [edi+472]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
	call	edx

; 572  : 
; 573  : 	// palette
; 574  :     for (LensFlareDescIt it=m_Palette.begin(); it!=m_Palette.end(); it++)

	mov	eax, DWORD PTR [edi+476]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	mov	esi, eax
	mov	eax, DWORD PTR [edi+480]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 8
	cmp	esi, eax
	je	SHORT $LN1@OnDeviceCr@2
$LL3@OnDeviceCr@2:

; 575  :         (*it)->OnDeviceCreate();

	mov	ecx, DWORD PTR [esi]
	call	?OnDeviceCreate@CLensFlareDescriptor@@QAEXXZ ; CLensFlareDescriptor::OnDeviceCreate
	mov	eax, DWORD PTR [edi+480]
	push	eax
	add	esi, 4
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 4
	cmp	esi, eax
	jne	SHORT $LL3@OnDeviceCr@2
$LN1@OnDeviceCr@2:
	pop	edi
	pop	esi

; 576  : }

	ret	0
?OnDeviceCreate@CLensFlare@@QAEXXZ ENDP			; CLensFlare::OnDeviceCreate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?material_callback@@YAHAAUrq_result@collide@@PAX@Z
_TEXT	SEGMENT
_vis$ = 8						; size = 4
_result$ = 8						; size = 4
_params$ = 12						; size = 4
?material_callback@@YAHAAUrq_result@collide@@PAX@Z PROC	; material_callback, COMDAT

; 187  : {

	push	esi

; 188  : 	STranspParam* fp= (STranspParam*)params;
; 189  : 	float vis		= 1.f;
; 190  : 	if (result.O){

	mov	esi, DWORD PTR _params$[esp]
	push	edi
	mov	edi, DWORD PTR _result$[esp+4]
	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN4@material_c@2

; 191  : 		vis			= 0.f;
; 192  : 		//CKinematics*K=PKinematics(result.O->renderable.visual);
; 193  : 		IKinematics*K=PKinematics(result.O->renderable.visual);

	mov	eax, DWORD PTR [eax+144]
	test	eax, eax
	xorps	xmm0, xmm0
	movss	DWORD PTR _vis$[esp+4], xmm0
	je	$LN38@material_c@2
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+12]
	push	eax
	call	edx

; 194  : 		if (K&&(result.element>0))

	test	eax, eax
	je	$LN38@material_c@2
	cmp	DWORD PTR [edi+8], 0
	jle	$LN38@material_c@2

; 195  : 			vis		= g_pGamePersistent->MtlTransparent(K->LL_GetData(u16(result.element)).game_mtl_idx);

	mov	ecx, DWORD PTR ?g_pGamePersistent@@3PAVIGame_Persistent@@A ; g_pGamePersistent
	mov	edx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx+40]
	push	ebx
	mov	ebx, DWORD PTR [ecx]
	movzx	ecx, WORD PTR [edi+8]
	push	ecx
	push	eax
	call	edx
	movzx	eax, WORD PTR [eax+316]
	mov	ecx, DWORD PTR ?g_pGamePersistent@@3PAVIGame_Persistent@@A ; g_pGamePersistent
	mov	edx, DWORD PTR [ebx+64]
	push	eax
	call	edx
	pop	ebx
	fstp	DWORD PTR _vis$[esp+4]

; 196  : 	}else{

	jmp	$LN38@material_c@2
$LN4@material_c@2:

; 197  : 		CDB::TRI* T	= g_pGameLevel->ObjectSpace.GetStaticTris()+result.element;

	mov	edi, DWORD PTR [edi+8]
	mov	eax, DWORD PTR ?g_pGameLevel@@3PAVIGame_Level@@A ; g_pGameLevel

; 198  : 		vis			= g_pGamePersistent->MtlTransparent(T->material);

	mov	ecx, DWORD PTR ?g_pGamePersistent@@3PAVIGame_Persistent@@A ; g_pGamePersistent
	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+64]
	shl	edi, 4
	add	edi, DWORD PTR [eax+262308]
	mov	eax, DWORD PTR [edi+12]
	and	eax, 16383				; 00003fffH
	push	eax
	call	edx
	fst	DWORD PTR _vis$[esp+4]

; 199  : 		if (fis_zero(vis)){

	push	ecx
	fstp	DWORD PTR [esp]
	call	_fabsf
	fld	DWORD PTR _EPS_S
	add	esp, 4
	fcomip	ST(1)
	fstp	ST(0)
	jbe	$LN38@material_c@2

; 200  : 			Fvector* V	= g_pGameLevel->ObjectSpace.GetStaticVerts();

	mov	eax, DWORD PTR ?g_pGameLevel@@3PAVIGame_Level@@A ; g_pGameLevel
	mov	ecx, DWORD PTR [eax+262316]

; 201  : 			fp->pray_cache->set				(fp->P,fp->D,fp->f,TRUE);

	mov	eax, DWORD PTR [esi+28]
	mov	edx, DWORD PTR [esi]
	movss	xmm0, DWORD PTR [esi+24]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+16], edx
	mov	edx, DWORD PTR [esi+20]
	mov	DWORD PTR [eax+20], edx
	movss	DWORD PTR [eax+24], xmm0
	mov	DWORD PTR [eax+28], 1

; 202  : 			fp->pray_cache->verts[0].set	(V[T->verts[0]]);

	mov	eax, DWORD PTR [edi]
	lea	eax, DWORD PTR [eax+eax*2]
	fld	DWORD PTR [ecx+eax*4]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [esi+28]
	fstp	DWORD PTR [eax+32]
	fld	DWORD PTR [edx+4]
	add	eax, 32					; 00000020H
	fstp	DWORD PTR [eax+4]
	fld	DWORD PTR [edx+8]
	fstp	DWORD PTR [eax+8]

; 203  : 			fp->pray_cache->verts[1].set	(V[T->verts[1]]);

	mov	eax, DWORD PTR [edi+4]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [esi+28]
	fld	DWORD PTR [ecx+edx*4]
	fstp	DWORD PTR [eax+44]
	lea	edx, DWORD PTR [ecx+edx*4]
	fld	DWORD PTR [edx+4]
	add	eax, 44					; 0000002cH
	fstp	DWORD PTR [eax+4]
	fld	DWORD PTR [edx+8]
	fstp	DWORD PTR [eax+8]

; 204  : 			fp->pray_cache->verts[2].set	(V[T->verts[2]]);

	mov	edi, DWORD PTR [edi+8]
	lea	eax, DWORD PTR [edi+edi*2]
	fld	DWORD PTR [ecx+eax*4]
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [esi+28]
	fstp	DWORD PTR [eax+56]
	fld	DWORD PTR [ecx+4]
	add	eax, 56					; 00000038H
	fstp	DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+8]
	fstp	DWORD PTR [eax+8]
$LN38@material_c@2:

; 205  : 		}
; 206  : 	}
; 207  : 	fp->vis			*=vis;

	movss	xmm0, DWORD PTR _vis$[esp+4]
	mulss	xmm0, DWORD PTR [esi+32]

; 208  : 	return (fp->vis>fp->vis_threshold); 

	comiss	xmm0, DWORD PTR [esi+36]
	pop	edi
	movss	DWORD PTR [esi+32], xmm0
	pop	esi
	jbe	SHORT $LN7@material_c@2
	mov	eax, 1

; 209  : }

	ret	0
$LN7@material_c@2:

; 208  : 	return (fp->vis>fp->vis_threshold); 

	xor	eax, eax

; 209  : }

	ret	0
?material_callback@@YAHAAUrq_result@collide@@PAX@Z ENDP	; material_callback
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0rq_results@collide@@QAE@XZ
_TEXT	SEGMENT
??0rq_results@collide@@QAE@XZ PROC			; collide::rq_results::rq_results, COMDAT
; _this$ = eax
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0rq_results@collide@@QAE@XZ ENDP			; collide::rq_results::rq_results
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@stlp_std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@stlp_std@@QAE@XZ PROC ; stlp_std::vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::~vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >, COMDAT
; _this$ = ebx
	mov	eax, DWORD PTR [ebx+4]
	push	esi
	push	edi
	mov	edi, DWORD PTR [ebx]
	cmp	eax, edi
	je	SHORT $LN29@vector@33
	npad	5
$LL34@vector@33:
	lea	esi, DWORD PTR [eax-12]
	mov	ecx, esi
	call	??1?$_Impl_vector@GV?$xalloc@G@@@priv@stlp_std@@QAE@XZ ; stlp_std::priv::_Impl_vector<unsigned short,xalloc<unsigned short> >::~_Impl_vector<unsigned short,xalloc<unsigned short> >
	mov	eax, esi
	cmp	eax, edi
	jne	SHORT $LL34@vector@33
$LN29@vector@33:
	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN65@vector@33
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN65@vector@33:
	pop	edi
	pop	esi
	ret	0
??1?$vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@stlp_std@@QAE@XZ ENDP ; stlp_std::vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::~vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$vector@PAVCBoneData@@V?$xalloc@PAVCBoneData@@@@@stlp_std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCBoneData@@V?$xalloc@PAVCBoneData@@@@@stlp_std@@QAE@XZ PROC ; stlp_std::vector<CBoneData *,xalloc<CBoneData *> >::~vector<CBoneData *,xalloc<CBoneData *> >, COMDAT
; _this$ = eax
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN36@vector@34
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN36@vector@34:
	ret	0
??1?$vector@PAVCBoneData@@V?$xalloc@PAVCBoneData@@@@@stlp_std@@QAE@XZ ENDP ; stlp_std::vector<CBoneData *,xalloc<CBoneData *> >::~vector<CBoneData *,xalloc<CBoneData *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$xr_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
??0?$xr_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@@QAE@ABV0@@Z PROC ; xr_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::xr_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >, COMDAT
; _this$ = esi
; ___that$ = ebx
	mov	ecx, DWORD PTR [ebx+4]
	sub	ecx, DWORD PTR [ebx]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	push	edi
	shr	eax, 31					; 0000001fH
	add	eax, edx
	xor	ecx, ecx
	lea	edi, DWORD PTR [eax+eax*2]
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [esi+4], ecx
	add	edi, edi
	mov	DWORD PTR [esi+8], ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	add	edi, edi
	push	edi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	mov	edx, eax
	add	edi, edx
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [esi+4], edx
	mov	DWORD PTR [esi+8], edi
	mov	eax, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [ebx]
	call	??$__ucopy@PBV?$xr_vector@GV?$xalloc@G@@@@PAV1@H@priv@stlp_std@@YAPAV?$xr_vector@GV?$xalloc@G@@@@PBV2@0PAV2@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<xr_vector<unsigned short,xalloc<unsigned short> > const *,xr_vector<unsigned short,xalloc<unsigned short> > *,int>
	mov	DWORD PTR [esi+4], eax
	mov	eax, esi
	pop	edi
	ret	0
??0?$xr_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@@QAE@ABV0@@Z ENDP ; xr_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::xr_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$xr_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@@QAE@XZ PROC ; xr_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::~xr_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >, COMDAT
; _this$ = ebx
	mov	eax, DWORD PTR [ebx+4]
	push	esi
	push	edi
	mov	edi, DWORD PTR [ebx]
	cmp	eax, edi
	je	SHORT $LN31@xr_vector@24
	npad	5
$LL36@xr_vector@24:
	lea	esi, DWORD PTR [eax-12]
	mov	ecx, esi
	call	??1?$_Impl_vector@GV?$xalloc@G@@@priv@stlp_std@@QAE@XZ ; stlp_std::priv::_Impl_vector<unsigned short,xalloc<unsigned short> >::~_Impl_vector<unsigned short,xalloc<unsigned short> >
	mov	eax, esi
	cmp	eax, edi
	jne	SHORT $LL36@xr_vector@24
$LN31@xr_vector@24:
	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN67@xr_vector@24
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN67@xr_vector@24:
	pop	edi
	pop	esi
	ret	0
??1?$xr_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@@QAE@XZ ENDP ; xr_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::~xr_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$xr_vector@PAVCBoneData@@V?$xalloc@PAVCBoneData@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@PAVCBoneData@@V?$xalloc@PAVCBoneData@@@@@@QAE@XZ PROC ; xr_vector<CBoneData *,xalloc<CBoneData *> >::~xr_vector<CBoneData *,xalloc<CBoneData *> >, COMDAT
; _this$ = eax
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN38@xr_vector@25
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN38@xr_vector@25:
	ret	0
??1?$xr_vector@PAVCBoneData@@V?$xalloc@PAVCBoneData@@@@@@QAE@XZ ENDP ; xr_vector<CBoneData *,xalloc<CBoneData *> >::~xr_vector<CBoneData *,xalloc<CBoneData *> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\bone.h
_TEXT	ENDS
;	COMDAT ?mem_usage@CBoneData@@UAEIXZ
_TEXT	SEGMENT
?mem_usage@CBoneData@@UAEIXZ PROC			; CBoneData::mem_usage, COMDAT
; _this$ = ecx

; 508  : 	{

	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 509  : 		u32 sz			= sizeof(*this)+sizeof(vecBones::value_type)*children.size();

	mov	ebx, DWORD PTR [edi+416]
	sub	ebx, DWORD PTR [edi+412]

; 510  : 		for (ChildFacesVecIt c_it=child_faces.begin(); c_it!=child_faces.end(); c_it++)

	mov	esi, DWORD PTR [edi+424]
	sar	ebx, 2
	cmp	esi, DWORD PTR [edi+428]
	lea	ebx, DWORD PTR [ebx*4+436]
	je	SHORT $LN32@mem_usage@3
	npad	7
$LL3@mem_usage@3:

; 511  : 			sz			+= c_it->size()*sizeof(FacesVec::value_type)+sizeof(*c_it);

	mov	ecx, esi
	call	?size@?$_Impl_vector@GV?$xalloc@G@@@priv@stlp_std@@QBEIXZ ; stlp_std::priv::_Impl_vector<unsigned short,xalloc<unsigned short> >::size
	add	esi, 12					; 0000000cH
	cmp	esi, DWORD PTR [edi+428]
	lea	ebx, DWORD PTR [ebx+eax*2+12]
	jne	SHORT $LL3@mem_usage@3
$LN32@mem_usage@3:
	pop	edi
	pop	esi

; 512  : 		return			sz;

	mov	eax, ebx
	pop	ebx

; 513  : 	}

	ret	0
?mem_usage@CBoneData@@UAEIXZ ENDP			; CBoneData::mem_usage
_TEXT	ENDS
PUBLIC	??1CBoneData@@UAE@XZ				; CBoneData::~CBoneData
; Function compile flags: /Ogtpy
;	COMDAT ??1CBoneData@@UAE@XZ
_TEXT	SEGMENT
??1CBoneData@@UAE@XZ PROC				; CBoneData::~CBoneData, COMDAT
; _this$ = ecx

; 476  : 	virtual				~CBoneData		()					{}

	push	ebx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CBoneData@@6B@
	mov	ebx, DWORD PTR [esi+424]
	mov	eax, DWORD PTR [esi+428]
	cmp	eax, ebx
	push	edi
	je	SHORT $LN33@CBoneData
	npad	5
$LL38@CBoneData:
	lea	edi, DWORD PTR [eax-12]
	mov	ecx, edi
	call	??1?$_Impl_vector@GV?$xalloc@G@@@priv@stlp_std@@QAE@XZ ; stlp_std::priv::_Impl_vector<unsigned short,xalloc<unsigned short> >::~_Impl_vector<unsigned short,xalloc<unsigned short> >
	mov	eax, edi
	cmp	eax, ebx
	jne	SHORT $LL38@CBoneData
$LN33@CBoneData:
	mov	eax, DWORD PTR [esi+424]
	mov	edi, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	xor	ebx, ebx
	cmp	eax, ebx
	je	SHORT $LN69@CBoneData
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
$LN69@CBoneData:
	mov	eax, DWORD PTR [esi+412]
	cmp	eax, ebx
	je	SHORT $LN109@CBoneData
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
$LN109@CBoneData:
	mov	eax, DWORD PTR [esi+312]
	cmp	eax, ebx
	je	SHORT $LN114@CBoneData
	add	DWORD PTR [eax], -1
	mov	eax, DWORD PTR [esi+312]
	cmp	DWORD PTR [eax], ebx
	jne	SHORT $LN114@CBoneData
	mov	DWORD PTR [esi+312], ebx
$LN114@CBoneData:
	mov	eax, DWORD PTR [esi+8]
	cmp	eax, ebx
	je	SHORT $LN120@CBoneData
	add	DWORD PTR [eax], -1
	mov	ecx, DWORD PTR [esi+8]
	cmp	DWORD PTR [ecx], ebx
	jne	SHORT $LN120@CBoneData
	mov	DWORD PTR [esi+8], ebx
$LN120@CBoneData:
	pop	edi
	pop	esi
	pop	ebx
	ret	0
??1CBoneData@@UAE@XZ ENDP				; CBoneData::~CBoneData
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Reset@SJointIKData@@QAEXXZ
_TEXT	SEGMENT
?Reset@SJointIKData@@QAEXXZ PROC			; SJointIKData::Reset, COMDAT
; _this$ = esi

; 219  :     	limits[0].Reset	();

	fldz
	push	edi
	sub	esp, 8
	fst	DWORD PTR [esp+4]
	lea	edi, DWORD PTR [esi+4]
	fstp	DWORD PTR [esp]
	mov	ecx, edi
	call	?set@?$_vector2@M@@QAEAAU1@MM@Z		; _vector2<float>::set

; 220  :     	limits[1].Reset	();

	fldz
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edi+8], xmm0
	movss	DWORD PTR [edi+12], xmm0
	sub	esp, 8
	lea	edi, DWORD PTR [esi+20]
	fst	DWORD PTR [esp+4]
	mov	ecx, edi
	fstp	DWORD PTR [esp]
	call	?set@?$_vector2@M@@QAEAAU1@MM@Z		; _vector2<float>::set

; 221  :     	limits[2].Reset	();

	fldz
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edi+8], xmm0
	movss	DWORD PTR [edi+12], xmm0
	sub	esp, 8
	lea	edi, DWORD PTR [esi+36]
	fst	DWORD PTR [esp+4]
	mov	ecx, edi
	fstp	DWORD PTR [esp]
	call	?set@?$_vector2@M@@QAEAAU1@MM@Z		; _vector2<float>::set
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edi+8], xmm0
	movss	DWORD PTR [edi+12], xmm0

; 222  :         type			= jtRigid;
; 223  :         spring_factor	= 1.f;

	movss	DWORD PTR [esi+52], xmm0

; 224  :         damping_factor	= 1.f;

	movss	DWORD PTR [esi+56], xmm0

; 225  :         ik_flags.zero	();
; 226  :     	break_force		= 0.f;

	xorps	xmm0, xmm0
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+60], 0
	movss	DWORD PTR [esi+64], xmm0

; 227  :     	break_torque	= 0.f;

	movss	DWORD PTR [esi+68], xmm0
	pop	edi

; 228  :     }

	ret	0
?Reset@SJointIKData@@QAEXXZ ENDP			; SJointIKData::Reset
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0SJointIKData@@QAE@XZ
_TEXT	SEGMENT
??0SJointIKData@@QAE@XZ PROC				; SJointIKData::SJointIKData, COMDAT
; _this$ = eax

; 216  :     SJointIKData	(){ Reset();}

	push	ebx
	push	esi
	mov	esi, eax
	push	edi
	lea	edi, DWORD PTR [esi+4]
	mov	ebx, 2
	npad	3
$LL15@SJointIKDa:
	fldz
	sub	esp, 8
	fst	DWORD PTR [esp+4]
	mov	ecx, edi
	fstp	DWORD PTR [esp]
	call	?set@?$_vector2@M@@QAEAAU1@MM@Z		; _vector2<float>::set
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edi+8], xmm0
	movss	DWORD PTR [edi+12], xmm0
	add	edi, 16					; 00000010H
	sub	ebx, 1
	jns	SHORT $LL15@SJointIKDa
	call	?Reset@SJointIKData@@QAEXXZ		; SJointIKData::Reset
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	0
??0SJointIKData@@QAE@XZ ENDP				; SJointIKData::SJointIKData
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcdb\xr_collide_defs.h
_TEXT	ENDS
;	COMDAT ?similar@ray_cache@collide@@QAEHABU?$_vector3@M@@0M@Z
_TEXT	SEGMENT
__range$ = 8						; size = 4
?similar@ray_cache@collide@@QAEHABU?$_vector3@M@@0M@Z PROC ; collide::ray_cache::similar, COMDAT
; _this$ = esi
; __dir$ = eax

; 51   : 			if (!_start.similar(start))					return FALSE;
; 52   : 			if (!fsimilar(1.f,dir.dotproduct(_dir)))	return FALSE;

	movss	xmm0, DWORD PTR [esi+20]
	mulss	xmm0, DWORD PTR [eax+8]
	movss	xmm1, DWORD PTR [esi+16]
	mulss	xmm1, DWORD PTR [eax+4]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR [esi+12]
	mulss	xmm1, DWORD PTR [eax]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR __real@3f800000
	push	ecx
	subss	xmm1, xmm0
	movss	DWORD PTR [esp], xmm1
	call	_fabsf
	fld	DWORD PTR _EPS
	add	esp, 4
	fcomip	ST(1)
	fstp	ST(0)
	ja	SHORT $LN2@similar@2
$LN30@similar@2:
	xor	eax, eax

; 55   : 		}

	ret	4
$LN2@similar@2:

; 53   : 			if (!fsimilar(_range,range))				return FALSE;

	movss	xmm0, DWORD PTR __range$[esp-4]
	subss	xmm0, DWORD PTR [esi+24]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_fabsf
	fld	DWORD PTR _EPS
	add	esp, 4
	fcomip	ST(1)
	fstp	ST(0)
	jbe	SHORT $LN30@similar@2

; 54   : 			return			TRUE;

	mov	eax, 1

; 55   : 		}

	ret	4
?similar@ray_cache@collide@@QAEHABU?$_vector3@M@@0M@Z ENDP ; collide::ray_cache::similar
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_uninitialized.h
;	COMDAT ??$__ucopy_aux@PBV?$xr_vector@GV?$xalloc@G@@@@PAV1@@priv@stlp_std@@YAPAV?$xr_vector@GV?$xalloc@G@@@@PBV2@0PAV2@ABU__true_type@1@@Z
_TEXT	SEGMENT
??$__ucopy_aux@PBV?$xr_vector@GV?$xalloc@G@@@@PAV1@@priv@stlp_std@@YAPAV?$xr_vector@GV?$xalloc@G@@@@PBV2@0PAV2@ABU__true_type@1@@Z PROC ; stlp_std::priv::__ucopy_aux<xr_vector<unsigned short,xalloc<unsigned short> > const *,xr_vector<unsigned short,xalloc<unsigned short> > *>, COMDAT
; ___first$ = ecx
; ___last$ = eax
; ___result$ = edx

; 126  :   return __ucopy_ptrs(__first, __last, __result,
; 127  :                       _UseTrivialUCopy(_STLP_VALUE_TYPE(__first, _InputIter),
; 128  :                                        _STLP_VALUE_TYPE(__result, _OutputIter))._Answer());

	jmp	??$__ucopy@PBV?$xr_vector@GV?$xalloc@G@@@@PAV1@H@priv@stlp_std@@YAPAV?$xr_vector@GV?$xalloc@G@@@@PBV2@0PAV2@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<xr_vector<unsigned short,xalloc<unsigned short> > const *,xr_vector<unsigned short,xalloc<unsigned short> > *,int>
??$__ucopy_aux@PBV?$xr_vector@GV?$xalloc@G@@@@PAV1@@priv@stlp_std@@YAPAV?$xr_vector@GV?$xalloc@G@@@@PBV2@0PAV2@ABU__true_type@1@@Z ENDP ; stlp_std::priv::__ucopy_aux<xr_vector<unsigned short,xalloc<unsigned short> > const *,xr_vector<unsigned short,xalloc<unsigned short> > *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_algobase.h
_TEXT	ENDS
;	COMDAT ??$__copy@PBV?$xr_vector@GV?$xalloc@G@@@@PAV1@H@priv@stlp_std@@YAPAV?$xr_vector@GV?$xalloc@G@@@@PBV2@0PAV2@ABUrandom_access_iterator_tag@1@PAH@Z
_TEXT	SEGMENT
??$__copy@PBV?$xr_vector@GV?$xalloc@G@@@@PAV1@H@priv@stlp_std@@YAPAV?$xr_vector@GV?$xalloc@G@@@@PBV2@0PAV2@ABUrandom_access_iterator_tag@1@PAH@Z PROC ; stlp_std::priv::__copy<xr_vector<unsigned short,xalloc<unsigned short> > const *,xr_vector<unsigned short,xalloc<unsigned short> > *,int>, COMDAT
; ___first$ = edx
; ___last$ = eax
; ___result$ = ecx

; 200  :        _OutputIter __result, const random_access_iterator_tag &, _Distance*) {

	push	ebx
	push	esi
	push	edi
	mov	edi, edx

; 201  :   for (_Distance __n = __last - __first; __n > 0; --__n) {

	sub	eax, edi
	mov	ebx, ecx
	mov	ecx, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	test	esi, esi
	jle	SHORT $LN12@copy@19
	npad	1
$LL3@copy@19:

; 202  :     *__result = *__first;

	push	edi
	mov	ecx, ebx
	call	??4?$vector@GV?$xalloc@G@@@stlp_std@@QAEAAV01@ABV01@@Z ; stlp_std::vector<unsigned short,xalloc<unsigned short> >::operator=
	sub	esi, 1

; 203  :     ++__first;

	add	edi, 12					; 0000000cH

; 204  :     ++__result;

	add	ebx, 12					; 0000000cH
	test	esi, esi
	jg	SHORT $LL3@copy@19
$LN12@copy@19:
	pop	edi
	pop	esi

; 205  :   }
; 206  :   return __result;

	mov	eax, ebx
	pop	ebx

; 207  : }

	ret	0
??$__copy@PBV?$xr_vector@GV?$xalloc@G@@@@PAV1@H@priv@stlp_std@@YAPAV?$xr_vector@GV?$xalloc@G@@@@PBV2@0PAV2@ABUrandom_access_iterator_tag@1@PAH@Z ENDP ; stlp_std::priv::__copy<xr_vector<unsigned short,xalloc<unsigned short> > const *,xr_vector<unsigned short,xalloc<unsigned short> > *,int>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_uninitialized.h
_TEXT	ENDS
;	COMDAT ??$uninitialized_copy@PBV?$xr_vector@GV?$xalloc@G@@@@PAV1@@stlp_std@@YAPAV?$xr_vector@GV?$xalloc@G@@@@PBV1@0PAV1@@Z
_TEXT	SEGMENT
??$uninitialized_copy@PBV?$xr_vector@GV?$xalloc@G@@@@PAV1@@stlp_std@@YAPAV?$xr_vector@GV?$xalloc@G@@@@PBV1@0PAV1@@Z PROC ; stlp_std::uninitialized_copy<xr_vector<unsigned short,xalloc<unsigned short> > const *,xr_vector<unsigned short,xalloc<unsigned short> > *>, COMDAT
; ___first$ = ecx
; ___last$ = eax
; ___result$ = edx

; 144  : { return _STLP_PRIV __ucopy_aux(__first, __last, __result, _BothPtrType< _InputIter, _ForwardIter>::_Answer()); }

	jmp	??$__ucopy@PBV?$xr_vector@GV?$xalloc@G@@@@PAV1@H@priv@stlp_std@@YAPAV?$xr_vector@GV?$xalloc@G@@@@PBV2@0PAV2@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<xr_vector<unsigned short,xalloc<unsigned short> > const *,xr_vector<unsigned short,xalloc<unsigned short> > *,int>
??$uninitialized_copy@PBV?$xr_vector@GV?$xalloc@G@@@@PAV1@@stlp_std@@YAPAV?$xr_vector@GV?$xalloc@G@@@@PBV1@0PAV1@@Z ENDP ; stlp_std::uninitialized_copy<xr_vector<unsigned short,xalloc<unsigned short> > const *,xr_vector<unsigned short,xalloc<unsigned short> > *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_algobase.h
_TEXT	ENDS
;	COMDAT ??$__copy_ptrs@PBV?$xr_vector@GV?$xalloc@G@@@@PAV1@@priv@stlp_std@@YAPAV?$xr_vector@GV?$xalloc@G@@@@PBV2@0PAV2@ABU__false_type@1@@Z
_TEXT	SEGMENT
??$__copy_ptrs@PBV?$xr_vector@GV?$xalloc@G@@@@PAV1@@priv@stlp_std@@YAPAV?$xr_vector@GV?$xalloc@G@@@@PBV2@0PAV2@ABU__false_type@1@@Z PROC ; stlp_std::priv::__copy_ptrs<xr_vector<unsigned short,xalloc<unsigned short> > const *,xr_vector<unsigned short,xalloc<unsigned short> > *>, COMDAT
; ___first$ = edx
; ___last$ = eax
; ___result$ = ecx

; 249  :                                const __false_type& /*IsOKToMemCpy*/) {

	push	ebx
	push	esi
	mov	ebx, edx

; 250  :   return __copy(__first, __last, __result, random_access_iterator_tag(), (ptrdiff_t*)0);

	sub	eax, ebx
	push	edi
	mov	edi, ecx
	mov	ecx, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	test	esi, esi
	jle	SHORT $LN14@copy_ptrs@43
	sub	ebx, edi
$LL5@copy_ptrs@43:
	lea	eax, DWORD PTR [ebx+edi]
	push	eax
	mov	ecx, edi
	call	??4?$vector@GV?$xalloc@G@@@stlp_std@@QAEAAV01@ABV01@@Z ; stlp_std::vector<unsigned short,xalloc<unsigned short> >::operator=
	sub	esi, 1
	add	edi, 12					; 0000000cH
	test	esi, esi
	jg	SHORT $LL5@copy_ptrs@43
$LN14@copy_ptrs@43:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 251  : }

	ret	0
??$__copy_ptrs@PBV?$xr_vector@GV?$xalloc@G@@@@PAV1@@priv@stlp_std@@YAPAV?$xr_vector@GV?$xalloc@G@@@@PBV2@0PAV2@ABU__false_type@1@@Z ENDP ; stlp_std::priv::__copy_ptrs<xr_vector<unsigned short,xalloc<unsigned short> > const *,xr_vector<unsigned short,xalloc<unsigned short> > *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ??$_M_allocate_and_copy@PBV?$xr_vector@GV?$xalloc@G@@@@@?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@AAEPAV?$xr_vector@GV?$xalloc@G@@@@AAIPBV3@1@Z
_TEXT	SEGMENT
___first$ = 8						; size = 4
___last$ = 12						; size = 4
??$_M_allocate_and_copy@PBV?$xr_vector@GV?$xalloc@G@@@@@?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@AAEPAV?$xr_vector@GV?$xalloc@G@@@@AAIPBV3@1@Z PROC ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::_M_allocate_and_copy<xr_vector<unsigned short,xalloc<unsigned short> > const *>, COMDAT
; ___n$ = eax

; 634  :                                _ForwardIterator __first, _ForwardIterator __last)
; 635  : #else /* _STLP_MEMBER_TEMPLATES */
; 636  :   pointer _M_allocate_and_copy(size_type& __n,
; 637  :                                const_pointer __first, const_pointer __last)
; 638  : #endif /* _STLP_MEMBER_TEMPLATES */
; 639  :   {
; 640  :     pointer __result = this->_M_end_of_storage.allocate(__n, __n);

	mov	eax, DWORD PTR [eax]
	lea	ecx, DWORD PTR [eax+eax*2]
	add	ecx, ecx
	add	ecx, ecx
	push	esi
	push	ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 641  :     _STLP_TRY {
; 642  :       uninitialized_copy(__first, __last, __result);

	mov	ecx, DWORD PTR ___first$[esp]
	mov	esi, eax
	mov	eax, DWORD PTR ___last$[esp]
	mov	edx, esi
	call	??$__ucopy@PBV?$xr_vector@GV?$xalloc@G@@@@PAV1@H@priv@stlp_std@@YAPAV?$xr_vector@GV?$xalloc@G@@@@PBV2@0PAV2@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<xr_vector<unsigned short,xalloc<unsigned short> > const *,xr_vector<unsigned short,xalloc<unsigned short> > *,int>

; 643  :       return __result;

	mov	eax, esi
	pop	esi

; 644  :     }
; 645  :     _STLP_UNWIND(this->_M_end_of_storage.deallocate(__result, __n))
; 646  :     _STLP_RET_AFTER_THROW(__result)
; 647  :   }

	ret	8
??$_M_allocate_and_copy@PBV?$xr_vector@GV?$xalloc@G@@@@@?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@AAEPAV?$xr_vector@GV?$xalloc@G@@@@AAIPBV3@1@Z ENDP ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::_M_allocate_and_copy<xr_vector<unsigned short,xalloc<unsigned short> > const *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_M_clear@?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@AAEXXZ
_TEXT	SEGMENT
?_M_clear@?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@AAEXXZ PROC ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::_M_clear, COMDAT
; _this$ = ebx

; 616  :     _STLP_STD::_Destroy_Range(rbegin(), rend());

	mov	eax, DWORD PTR [ebx+4]
	push	esi
	push	edi
	mov	edi, DWORD PTR [ebx]
	cmp	eax, edi
	je	SHORT $LN27@M_clear@25
	npad	5
$LL32@M_clear@25:
	lea	esi, DWORD PTR [eax-12]
	mov	ecx, esi
	call	??1?$_Impl_vector@GV?$xalloc@G@@@priv@stlp_std@@QAE@XZ ; stlp_std::priv::_Impl_vector<unsigned short,xalloc<unsigned short> >::~_Impl_vector<unsigned short,xalloc<unsigned short> >
	mov	eax, esi
	cmp	eax, edi
	jne	SHORT $LL32@M_clear@25
$LN27@M_clear@25:

; 617  :     this->_M_end_of_storage.deallocate(this->_M_start, this->_M_end_of_storage._M_data - this->_M_start);

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN60@M_clear@25
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN60@M_clear@25:

; 618  :   }

	pop	edi
	pop	esi
	ret	0
?_M_clear@?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@AAEXXZ ENDP ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::_M_clear
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.c
_TEXT	ENDS
;	COMDAT ??4?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z
_TEXT	SEGMENT
___result$381845 = -4					; size = 4
tv291 = 8						; size = 4
___x$ = 8						; size = 4
??4?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z PROC ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::operator=, COMDAT
; _this$ = eax

; 177  : vector<_Tp, _Alloc>& vector<_Tp, _Alloc>::operator = (const vector<_Tp, _Alloc>& __x) {

	push	ecx
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR ___x$[esp+8]
	mov	ebx, eax

; 178  :   if (&__x != this) {

	cmp	ebp, ebx
	je	$LN5@operator@87

; 179  :     const size_type __xlen = __x.size();

	mov	ecx, DWORD PTR [ebp+4]
	push	esi
	push	edi
	mov	edi, DWORD PTR [ebp]
	mov	DWORD PTR tv291[esp+16], ecx
	sub	ecx, edi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx

; 180  :     if (__xlen > capacity()) {

	mov	ecx, DWORD PTR [ebx]
	sar	edx, 1
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	mov	edx, DWORD PTR [ebx+8]
	sub	edx, ecx
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	esi, eax
	jbe	SHORT $LN4@operator@87

; 181  :       size_type __len = __xlen;
; 182  :       pointer __tmp = _M_allocate_and_copy(__len, __CONST_CAST(const_pointer, __x._M_start) + 0,
; 183  :                                                   __CONST_CAST(const_pointer, __x._M_finish) + 0);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	ebp, DWORD PTR [esi+esi*2]
	add	ebp, ebp
	add	ebp, ebp
	push	ebp
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	mov	DWORD PTR ___result$381845[esp+20], eax
	mov	edx, eax
	mov	eax, DWORD PTR tv291[esp+16]
	mov	ecx, edi
	call	??$__ucopy@PBV?$xr_vector@GV?$xalloc@G@@@@PAV1@H@priv@stlp_std@@YAPAV?$xr_vector@GV?$xalloc@G@@@@PBV2@0PAV2@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<xr_vector<unsigned short,xalloc<unsigned short> > const *,xr_vector<unsigned short,xalloc<unsigned short> > *,int>

; 184  :       _M_clear();

	call	?_M_clear@?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@AAEXXZ ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::_M_clear

; 185  :       this->_M_start = __tmp;

	mov	eax, DWORD PTR ___result$381845[esp+20]

; 186  :       this->_M_end_of_storage._M_data = this->_M_start + __len;

	add	ebp, eax
	mov	DWORD PTR [ebx], eax
	mov	DWORD PTR [ebx+8], ebp
	jmp	SHORT $LN65@operator@87
$LN4@operator@87:

; 187  :     } else if (size() >= __xlen) {

	mov	edx, DWORD PTR [ebx+4]
	sub	edx, ecx
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, esi
	jb	SHORT $LN2@operator@87

; 188  :       pointer __i = _STLP_PRIV __copy_ptrs(__CONST_CAST(const_pointer, __x._M_start) + 0,
; 189  :                                            __CONST_CAST(const_pointer, __x._M_finish) + 0, this->_M_start, _TrivialCopy());

	mov	eax, DWORD PTR tv291[esp+16]
	mov	edx, edi
	call	??$__copy_ptrs@PBV?$xr_vector@GV?$xalloc@G@@@@PAV1@@priv@stlp_std@@YAPAV?$xr_vector@GV?$xalloc@G@@@@PBV2@0PAV2@ABU__false_type@1@@Z ; stlp_std::priv::__copy_ptrs<xr_vector<unsigned short,xalloc<unsigned short> > const *,xr_vector<unsigned short,xalloc<unsigned short> > *>

; 190  :       _STLP_STD::_Destroy_Range(__i, this->_M_finish);

	mov	ebp, DWORD PTR [ebx+4]
	cmp	eax, ebp
	mov	edi, eax
	je	SHORT $LN65@operator@87
	npad	2
$LL44@operator@87:
	mov	ecx, edi
	call	??1?$_Impl_vector@GV?$xalloc@G@@@priv@stlp_std@@QAE@XZ ; stlp_std::priv::_Impl_vector<unsigned short,xalloc<unsigned short> >::~_Impl_vector<unsigned short,xalloc<unsigned short> >
	add	edi, 12					; 0000000cH
	cmp	edi, ebp
	jne	SHORT $LL44@operator@87

; 191  :     } else {

	jmp	SHORT $LN65@operator@87
$LN2@operator@87:

; 192  :       _STLP_PRIV __copy_ptrs(__CONST_CAST(const_pointer, __x._M_start),
; 193  :                              __CONST_CAST(const_pointer, __x._M_start) + size(), this->_M_start, _TrivialCopy());

	lea	edx, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [edi+edx*4]
	mov	edx, edi
	call	??$__copy_ptrs@PBV?$xr_vector@GV?$xalloc@G@@@@PAV1@@priv@stlp_std@@YAPAV?$xr_vector@GV?$xalloc@G@@@@PBV2@0PAV2@ABU__false_type@1@@Z ; stlp_std::priv::__copy_ptrs<xr_vector<unsigned short,xalloc<unsigned short> > const *,xr_vector<unsigned short,xalloc<unsigned short> > *>

; 194  :       _STLP_PRIV __ucopy_ptrs(__CONST_CAST(const_pointer, __x._M_start) + size(),
; 195  :                               __CONST_CAST(const_pointer, __x._M_finish) + 0, this->_M_finish, _TrivialUCopy());

	mov	edi, DWORD PTR [ebx+4]
	mov	ecx, edi
	sub	ecx, DWORD PTR [ebx]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	mov	ecx, DWORD PTR [ebp]
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	lea	eax, DWORD PTR [eax+eax*2]
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [ebp+4]
	mov	edx, edi
	call	??$__ucopy@PBV?$xr_vector@GV?$xalloc@G@@@@PAV1@H@priv@stlp_std@@YAPAV?$xr_vector@GV?$xalloc@G@@@@PBV2@0PAV2@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<xr_vector<unsigned short,xalloc<unsigned short> > const *,xr_vector<unsigned short,xalloc<unsigned short> > *,int>
$LN65@operator@87:

; 196  :     }
; 197  :     this->_M_finish = this->_M_start + __xlen;

	mov	eax, DWORD PTR [ebx]
	lea	edx, DWORD PTR [esi+esi*2]
	lea	ecx, DWORD PTR [eax+edx*4]
	pop	edi
	mov	DWORD PTR [ebx+4], ecx

; 198  :   }
; 199  :   return *this;

	mov	eax, ebx
	pop	esi
$LN5@operator@87:
	pop	ebp
	pop	ebx

; 200  : }

	pop	ecx
	ret	4
??4?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ENDP ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::operator=
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ??0?$vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@stlp_std@@QAE@ABV?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@Z
_TEXT	SEGMENT
??0?$vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@stlp_std@@QAE@ABV?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@Z PROC ; stlp_std::vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >, COMDAT
; _this$ = eax

; 106  :   explicit vector(const allocator_type& __a = allocator_type())

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@stlp_std@@QAE@ABV?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@Z ENDP ; stlp_std::vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4?$vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@stlp_std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
??4?$vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@stlp_std@@QAEAAV01@ABV01@@Z PROC ; stlp_std::vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::operator=, COMDAT
; _this$ = esi
; ___x$ = eax

; 149  :   _Self& operator=(const _Self& __x) { _M_impl = __x._M_impl; return *this; }

	push	eax
	mov	eax, esi
	call	??4?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::operator=
	mov	eax, esi
	ret	0
??4?$vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@stlp_std@@QAEAAV01@ABV01@@Z ENDP ; stlp_std::vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::operator=
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ??0?$xr_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@@QAE@XZ PROC ; xr_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::xr_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >, COMDAT
; _this$ = eax

; 123  : 			xr_vector			()									: inherited	()					{}

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$xr_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@@QAE@XZ ENDP ; xr_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::xr_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ??4?$vector@PAVCBoneData@@V?$xalloc@PAVCBoneData@@@@@stlp_std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
??4?$vector@PAVCBoneData@@V?$xalloc@PAVCBoneData@@@@@stlp_std@@QAEAAV01@ABV01@@Z PROC ; stlp_std::vector<CBoneData *,xalloc<CBoneData *> >::operator=, COMDAT
; _this$ = ecx
; ___x$ = eax

; 149  :   _Self& operator=(const _Self& __x) { _M_impl = __x._M_impl; return *this; }

	push	ebx
	mov	ebx, ecx
	push	eax
	call	??4?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::operator=
	mov	eax, ebx
	pop	ebx
	ret	0
??4?$vector@PAVCBoneData@@V?$xalloc@PAVCBoneData@@@@@stlp_std@@QAEAAV01@ABV01@@Z ENDP ; stlp_std::vector<CBoneData *,xalloc<CBoneData *> >::operator=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$vector@PAVCBoneData@@V?$xalloc@PAVCBoneData@@@@@stlp_std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$vector@PAVCBoneData@@V?$xalloc@PAVCBoneData@@@@@stlp_std@@QAE@ABV01@@Z PROC ; stlp_std::vector<CBoneData *,xalloc<CBoneData *> >::vector<CBoneData *,xalloc<CBoneData *> >, COMDAT
; _this$ = esi
; ___x$ = eax

; 123  :   vector(const _Self& __x)

	push	eax
	mov	ecx, esi
	call	??0?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAE@ABV012@@Z ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::_Impl_vector<void *,xalloc<void *> >
	mov	eax, esi
	ret	0
??0?$vector@PAVCBoneData@@V?$xalloc@PAVCBoneData@@@@@stlp_std@@QAE@ABV01@@Z ENDP ; stlp_std::vector<CBoneData *,xalloc<CBoneData *> >::vector<CBoneData *,xalloc<CBoneData *> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ??0?$xr_vector@PAVCBoneData@@V?$xalloc@PAVCBoneData@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@PAVCBoneData@@V?$xalloc@PAVCBoneData@@@@@@QAE@XZ PROC ; xr_vector<CBoneData *,xalloc<CBoneData *> >::xr_vector<CBoneData *,xalloc<CBoneData *> >, COMDAT
; _this$ = eax

; 123  : 			xr_vector			()									: inherited	()					{}

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$xr_vector@PAVCBoneData@@V?$xalloc@PAVCBoneData@@@@@@QAE@XZ ENDP ; xr_vector<CBoneData *,xalloc<CBoneData *> >::xr_vector<CBoneData *,xalloc<CBoneData *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@QAE@XZ PROC ; xr_vector<CLensFlareDescriptor *,xalloc<CLensFlareDescriptor *> >::xr_vector<CLensFlareDescriptor *,xalloc<CLensFlareDescriptor *> >, COMDAT
; _this$ = eax

; 123  : 			xr_vector			()									: inherited	()					{}

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@QAE@XZ ENDP ; xr_vector<CLensFlareDescriptor *,xalloc<CLensFlareDescriptor *> >::xr_vector<CLensFlareDescriptor *,xalloc<CLensFlareDescriptor *> >
_TEXT	ENDS
PUBLIC	??0CLensFlare@@QAE@XZ				; CLensFlare::CLensFlare
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\xr_efflensflare.cpp
;	COMDAT ??0CLensFlare@@QAE@XZ
_TEXT	SEGMENT
??0CLensFlare@@QAE@XZ PROC				; CLensFlare::CLensFlare, COMDAT
; _this$ = ecx

; 142  : {

	xorps	xmm0, xmm0
	push	esi
	mov	esi, ecx
	push	edi
	xor	edi, edi
	mov	DWORD PTR [esi], OFFSET ??_7CLensFlare@@6B@
	lea	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi+12], edi
	lea	edx, DWORD PTR [edi+4]
	lea	eax, DWORD PTR [ecx+20]
$LL23@CLensFlare:
	movss	DWORD PTR [ecx], xmm0
	movss	DWORD PTR [eax-16], xmm0
	movss	DWORD PTR [eax-12], xmm0
	movss	DWORD PTR [eax-8], xmm0
	movss	DWORD PTR [eax-4], xmm0
	movss	DWORD PTR [eax], xmm0
	movss	DWORD PTR [eax+4], xmm0
	mov	DWORD PTR [eax+8], edi
	movss	DWORD PTR [eax+12], xmm0
	movss	DWORD PTR [eax+16], xmm0
	movss	DWORD PTR [eax+20], xmm0
	movss	DWORD PTR [eax+24], xmm0
	movss	DWORD PTR [eax+28], xmm0
	movss	DWORD PTR [eax+32], xmm0
	movss	DWORD PTR [eax+36], xmm0
	movss	DWORD PTR [eax+40], xmm0
	movss	DWORD PTR [eax+44], xmm0
	add	ecx, 68					; 00000044H
	add	eax, 68					; 00000044H
	sub	edx, 1
	jns	SHORT $LL23@CLensFlare
	mov	eax, DWORD PTR __imp_?RenderFactory@@3PAVIRenderFactory@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+96]
	call	eax

; 143  : 	// Device
; 144  : 	dwFrame						= 0xfffffffe;
; 145  : 
; 146  : 	fBlend						= 0.f;

	xorps	xmm0, xmm0

; 147  : 
; 148  :     LightColor.set				( 0xFFFFFFFF );

	movss	xmm1, DWORD PTR __real@3f800000
	mov	DWORD PTR [esi+472], eax
	mov	DWORD PTR [esi+476], edi
	mov	DWORD PTR [esi+480], edi
	mov	DWORD PTR [esi+484], edi
	mov	DWORD PTR [esi+360], -2			; fffffffeH
	movss	DWORD PTR [esi+356], xmm0
	movss	DWORD PTR [esi+464], xmm1
	movss	DWORD PTR [esi+452], xmm1
	movss	DWORD PTR [esi+456], xmm1
	movss	DWORD PTR [esi+460], xmm1

; 149  : 	fGradientValue				= 0.f;

	movss	DWORD PTR [esi+468], xmm0

; 150  : 
; 151  :     //hGeom						= 0;
; 152  : 	m_Current					= 0;

	mov	DWORD PTR [esi+488], edi

; 153  : 
; 154  :     m_State						= lfsNone;

	mov	DWORD PTR [esi+492], edi

; 155  :     m_StateBlend				= 0.f;

	movss	DWORD PTR [esi+496], xmm0

; 156  : 
; 157  : #ifndef _EDITOR
; 158  : 	for( int i=0; i<MAX_RAYS; ++i)
; 159  : 	{
; 160  : 		m_ray_cache[i].verts[0].set	(0,0,0);

	movss	DWORD PTR [esi+48], xmm0
	movss	DWORD PTR [esi+52], xmm0
	movss	DWORD PTR [esi+56], xmm0

; 161  : 		m_ray_cache[i].verts[1].set	(0,0,0);

	movss	DWORD PTR [esi+60], xmm0
	movss	DWORD PTR [esi+64], xmm0
	movss	DWORD PTR [esi+68], xmm0

; 162  : 		m_ray_cache[i].verts[2].set	(0,0,0);

	movss	DWORD PTR [esi+72], xmm0
	movss	DWORD PTR [esi+76], xmm0
	movss	DWORD PTR [esi+80], xmm0
	movss	DWORD PTR [esi+116], xmm0
	movss	DWORD PTR [esi+120], xmm0
	movss	DWORD PTR [esi+124], xmm0
	movss	DWORD PTR [esi+128], xmm0
	movss	DWORD PTR [esi+132], xmm0
	movss	DWORD PTR [esi+136], xmm0
	movss	DWORD PTR [esi+140], xmm0
	movss	DWORD PTR [esi+144], xmm0
	movss	DWORD PTR [esi+148], xmm0
	movss	DWORD PTR [esi+184], xmm0
	movss	DWORD PTR [esi+188], xmm0
	movss	DWORD PTR [esi+192], xmm0
	movss	DWORD PTR [esi+196], xmm0
	movss	DWORD PTR [esi+200], xmm0
	movss	DWORD PTR [esi+204], xmm0
	movss	DWORD PTR [esi+208], xmm0
	movss	DWORD PTR [esi+212], xmm0
	movss	DWORD PTR [esi+216], xmm0
	movss	DWORD PTR [esi+252], xmm0
	movss	DWORD PTR [esi+256], xmm0
	movss	DWORD PTR [esi+260], xmm0
	movss	DWORD PTR [esi+264], xmm0
	movss	DWORD PTR [esi+268], xmm0
	movss	DWORD PTR [esi+272], xmm0
	movss	DWORD PTR [esi+276], xmm0
	movss	DWORD PTR [esi+280], xmm0
	movss	DWORD PTR [esi+284], xmm0
	movss	DWORD PTR [esi+320], xmm0
	movss	DWORD PTR [esi+324], xmm0
	movss	DWORD PTR [esi+328], xmm0
	movss	DWORD PTR [esi+332], xmm0
	movss	DWORD PTR [esi+336], xmm0
	movss	DWORD PTR [esi+340], xmm0
	movss	DWORD PTR [esi+344], xmm0
	movss	DWORD PTR [esi+348], xmm0

; 163  : 	}
; 164  : #endif
; 165  : 
; 166  : 	OnDeviceCreate				();	

	mov	ecx, esi
	movss	DWORD PTR [esi+352], xmm0
	call	?OnDeviceCreate@CLensFlare@@QAEXXZ	; CLensFlare::OnDeviceCreate
	pop	edi

; 167  : }

	mov	eax, esi
	pop	esi
	ret	0
??0CLensFlare@@QAE@XZ ENDP				; CLensFlare::CLensFlare
_TEXT	ENDS
PUBLIC	?SetGradient@CLensFlareDescriptor@@QAEXMMPBD0@Z	; CLensFlareDescriptor::SetGradient
; Function compile flags: /Ogtpy
;	COMDAT ?SetGradient@CLensFlareDescriptor@@QAEXMMPBD0@Z
_TEXT	SEGMENT
_fMaxRadius$ = 8					; size = 4
_fOpacity$ = 12						; size = 4
_tex_name$ = 16						; size = 4
_sh_name$ = 20						; size = 4
?SetGradient@CLensFlareDescriptor@@QAEXMMPBD0@Z PROC	; CLensFlareDescriptor::SetGradient, COMDAT
; _this$ = ecx

; 44   : 	m_Gradient.fRadius	= fMaxRadius;

	movss	xmm0, DWORD PTR _fMaxRadius$[esp-4]

; 45   : 	m_Gradient.fOpacity	= fOpacity;
; 46   :     m_Gradient.shader	= sh_name;

	mov	eax, DWORD PTR _sh_name$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR __imp_?g_pStringContainer@@3PAVstr_container@@A
	mov	ecx, DWORD PTR [ecx]
	push	edi
	mov	edi, DWORD PTR __imp_?dock@str_container@@QAEPAUstr_value@@PBD@Z
	movss	DWORD PTR [esi+48], xmm0
	movss	xmm0, DWORD PTR _fOpacity$[esp+4]
	push	eax
	movss	DWORD PTR [esi+44], xmm0
	call	edi
	test	eax, eax
	je	SHORT $LN5@SetGradien
	add	DWORD PTR [eax], 1
$LN5@SetGradien:
	mov	ecx, DWORD PTR [esi+60]
	test	ecx, ecx
	je	SHORT $LN8@SetGradien
	add	DWORD PTR [ecx], -1
	mov	edx, DWORD PTR [esi+60]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN8@SetGradien
	mov	DWORD PTR [esi+60], 0
$LN8@SetGradien:

; 47   :     m_Gradient.texture	= tex_name;

	mov	ecx, DWORD PTR __imp_?g_pStringContainer@@3PAVstr_container@@A
	mov	DWORD PTR [esi+60], eax
	mov	eax, DWORD PTR _tex_name$[esp+4]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	call	edi
	test	eax, eax
	je	SHORT $LN14@SetGradien
	add	DWORD PTR [eax], 1
$LN14@SetGradien:
	mov	ecx, DWORD PTR [esi+56]
	test	ecx, ecx
	je	SHORT $LN22@SetGradien
	add	DWORD PTR [ecx], -1
	mov	edx, DWORD PTR [esi+56]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN22@SetGradien
	mov	DWORD PTR [esi+56], 0
$LN22@SetGradien:
	pop	edi
	mov	DWORD PTR [esi+56], eax
	pop	esi

; 48   : }

	ret	16					; 00000010H
?SetGradient@CLensFlareDescriptor@@QAEXMMPBD0@Z ENDP	; CLensFlareDescriptor::SetGradient
_TEXT	ENDS
PUBLIC	?SetSource@CLensFlareDescriptor@@QAEXMHPBD0@Z	; CLensFlareDescriptor::SetSource
; Function compile flags: /Ogtpy
;	COMDAT ?SetSource@CLensFlareDescriptor@@QAEXMHPBD0@Z
_TEXT	SEGMENT
_fRadius$ = 8						; size = 4
_ign_color$ = 12					; size = 4
_tex_name$ = 16						; size = 4
_sh_name$ = 20						; size = 4
?SetSource@CLensFlareDescriptor@@QAEXMHPBD0@Z PROC	; CLensFlareDescriptor::SetSource, COMDAT
; _this$ = ecx

; 36   : 	m_Source.fRadius	= fRadius;

	movss	xmm0, DWORD PTR _fRadius$[esp-4]

; 37   :     m_Source.shader		= sh_name;

	mov	eax, DWORD PTR _sh_name$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR __imp_?g_pStringContainer@@3PAVstr_container@@A
	push	edi
	mov	edi, DWORD PTR __imp_?dock@str_container@@QAEPAUstr_value@@PBD@Z
	movss	DWORD PTR [esi+20], xmm0
	mov	ecx, DWORD PTR [ecx]
	push	eax
	call	edi
	test	eax, eax
	je	SHORT $LN5@SetSource
	add	DWORD PTR [eax], 1
$LN5@SetSource:
	mov	ecx, DWORD PTR [esi+32]
	test	ecx, ecx
	je	SHORT $LN8@SetSource
	add	DWORD PTR [ecx], -1
	mov	edx, DWORD PTR [esi+32]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN8@SetSource
	mov	DWORD PTR [esi+32], 0
$LN8@SetSource:

; 38   :     m_Source.texture	= tex_name;

	mov	ecx, DWORD PTR __imp_?g_pStringContainer@@3PAVstr_container@@A
	mov	DWORD PTR [esi+32], eax
	mov	eax, DWORD PTR _tex_name$[esp+4]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	call	edi
	test	eax, eax
	je	SHORT $LN14@SetSource
	add	DWORD PTR [eax], 1
$LN14@SetSource:
	mov	ecx, DWORD PTR [esi+28]
	test	ecx, ecx
	je	SHORT $LN22@SetSource
	add	DWORD PTR [ecx], -1
	mov	edx, DWORD PTR [esi+28]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN21@SetSource
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi+28], eax

; 39   :     m_Source.ignore_color=ign_color;

	mov	eax, DWORD PTR _ign_color$[esp+4]
	pop	edi
	mov	DWORD PTR [esi+40], eax
	pop	esi

; 40   : }

	ret	16					; 00000010H
$LN21@SetSource:

; 39   :     m_Source.ignore_color=ign_color;

	mov	ecx, DWORD PTR _ign_color$[esp+4]
	mov	DWORD PTR [esi+28], eax
	pop	edi
	mov	DWORD PTR [esi+40], ecx
	pop	esi

; 40   : }

	ret	16					; 00000010H
$LN22@SetSource:

; 39   :     m_Source.ignore_color=ign_color;

	mov	edx, DWORD PTR _ign_color$[esp+4]
	mov	DWORD PTR [esi+28], eax
	pop	edi
	mov	DWORD PTR [esi+40], edx
	pop	esi

; 40   : }

	ret	16					; 00000010H
?SetSource@CLensFlareDescriptor@@QAEXMHPBD0@Z ENDP	; CLensFlareDescriptor::SetSource
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4?$xr_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
??4?$xr_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@@QAEAAV0@ABV0@@Z PROC ; xr_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::operator=, COMDAT
; _this$ = esi
; ___that$ = eax
	push	eax
	mov	eax, esi
	call	??4?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::operator=
	mov	eax, esi
	ret	0
??4?$xr_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@@QAEAAV0@ABV0@@Z ENDP ; xr_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::operator=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4?$xr_vector@PAVCBoneData@@V?$xalloc@PAVCBoneData@@@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
??4?$xr_vector@PAVCBoneData@@V?$xalloc@PAVCBoneData@@@@@@QAEAAV0@ABV0@@Z PROC ; xr_vector<CBoneData *,xalloc<CBoneData *> >::operator=, COMDAT
; _this$ = ecx
; ___that$ = eax
	push	ebx
	mov	ebx, ecx
	push	eax
	call	??4?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::operator=
	mov	eax, ebx
	pop	ebx
	ret	0
??4?$xr_vector@PAVCBoneData@@V?$xalloc@PAVCBoneData@@@@@@QAEAAV0@ABV0@@Z ENDP ; xr_vector<CBoneData *,xalloc<CBoneData *> >::operator=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$xr_vector@PAVCBoneData@@V?$xalloc@PAVCBoneData@@@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
??0?$xr_vector@PAVCBoneData@@V?$xalloc@PAVCBoneData@@@@@@QAE@ABV0@@Z PROC ; xr_vector<CBoneData *,xalloc<CBoneData *> >::xr_vector<CBoneData *,xalloc<CBoneData *> >, COMDAT
; _this$ = esi
; ___that$ = eax
	push	eax
	mov	ecx, esi
	call	??0?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAE@ABV012@@Z ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::_Impl_vector<void *,xalloc<void *> >
	mov	eax, esi
	ret	0
??0?$xr_vector@PAVCBoneData@@V?$xalloc@PAVCBoneData@@@@@@QAE@ABV0@@Z ENDP ; xr_vector<CBoneData *,xalloc<CBoneData *> >::xr_vector<CBoneData *,xalloc<CBoneData *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_ECBoneData@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_ECBoneData@@UAEPAXI@Z PROC				; CBoneData::`vector deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 2
	push	ebp
	mov	ebp, ecx
	je	SHORT $LN3@vector@72
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR [ebp-4]
	lea	ebx, DWORD PTR [ebp-4]
	mov	esi, edi
	imul	esi, 436				; 000001b4H
	add	esi, ebp
	sub	edi, 1
	js	SHORT $LN6@vector@72
$LL7@vector@72:
	sub	esi, 436				; 000001b4H
	mov	ecx, esi
	call	??1CBoneData@@UAE@XZ			; CBoneData::~CBoneData
	sub	edi, 1
	jns	SHORT $LL7@vector@72
$LN6@vector@72:
	test	BYTE PTR ___flags$[esp+12], 1
	je	SHORT $LN12@vector@72
	test	ebx, ebx
	je	SHORT $LN12@vector@72
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	ebx
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN12@vector@72:
	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx
	pop	ebp
	ret	4
$LN3@vector@72:
	call	??1CBoneData@@UAE@XZ			; CBoneData::~CBoneData
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN17@vector@72
	test	ebp, ebp
	je	SHORT $LN17@vector@72
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	ebp
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN17@vector@72:
	mov	eax, ebp
	pop	ebp
	ret	4
??_ECBoneData@@UAEPAXI@Z ENDP				; CBoneData::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_GCBoneData@@UAEPAXI@Z			; CBoneData::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GCBoneData@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCBoneData@@UAEPAXI@Z PROC				; CBoneData::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CBoneData@@UAE@XZ			; CBoneData::~CBoneData
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN10@scalar@46
	test	esi, esi
	je	SHORT $LN10@scalar@46
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN10@scalar@46:
	mov	eax, esi
	pop	esi
	ret	4
??_GCBoneData@@UAEPAXI@Z ENDP				; CBoneData::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??4CBoneData@@QAEAAV0@ABV0@@Z			; CBoneData::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4CBoneData@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4CBoneData@@QAEAAV0@ABV0@@Z PROC			; CBoneData::operator=, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	ebx
	push	ebp
	mov	ebp, ecx
	mov	cx, WORD PTR [eax+4]
	mov	WORD PTR [ebp+4], cx
	mov	dx, WORD PTR [eax+6]
	mov	WORD PTR [ebp+6], dx
	mov	edx, DWORD PTR [eax+8]
	xor	ebx, ebx
	cmp	edx, ebx
	push	esi
	push	edi
	je	SHORT $LN7@operator@88
	add	DWORD PTR [edx], 1
$LN7@operator@88:
	mov	ecx, DWORD PTR [ebp+8]
	cmp	ecx, ebx
	je	SHORT $LN10@operator@88
	add	DWORD PTR [ecx], -1
	mov	ecx, DWORD PTR [ebp+8]
	cmp	DWORD PTR [ecx], ebx
	jne	SHORT $LN10@operator@88
	mov	DWORD PTR [ebp+8], ebx
$LN10@operator@88:
	mov	DWORD PTR [ebp+8], edx
	lea	esi, DWORD PTR [eax+12]
	lea	edi, DWORD PTR [ebp+12]
	mov	ecx, 15					; 0000000fH
	rep movsd
	lea	esi, DWORD PTR [eax+72]
	lea	edi, DWORD PTR [ebp+72]
	mov	ecx, 16					; 00000010H
	rep movsd
	lea	esi, DWORD PTR [eax+136]
	lea	edi, DWORD PTR [ebp+136]
	mov	ecx, 16					; 00000010H
	rep movsd
	lea	esi, DWORD PTR [eax+200]
	lea	edi, DWORD PTR [ebp+200]
	mov	ecx, 28					; 0000001cH
	rep movsd
	mov	ecx, DWORD PTR [eax+312]
	cmp	ecx, ebx
	je	SHORT $LN16@operator@88
	add	DWORD PTR [ecx], 1
$LN16@operator@88:
	mov	edx, DWORD PTR [ebp+312]
	cmp	edx, ebx
	je	SHORT $LN19@operator@88
	add	DWORD PTR [edx], -1
	mov	edx, DWORD PTR [ebp+312]
	cmp	DWORD PTR [edx], ebx
	jne	SHORT $LN19@operator@88
	mov	DWORD PTR [ebp+312], ebx
$LN19@operator@88:
	mov	DWORD PTR [ebp+312], ecx
	mov	cx, WORD PTR [eax+316]
	mov	WORD PTR [ebp+316], cx
	lea	esi, DWORD PTR [eax+318]
	lea	edi, DWORD PTR [ebp+318]
	mov	ecx, 19					; 00000013H
	rep movsd
	fld	DWORD PTR [eax+396]
	fstp	DWORD PTR [ebp+396]
	mov	edx, DWORD PTR [eax+400]
	mov	DWORD PTR [ebp+400], edx
	mov	ecx, DWORD PTR [eax+404]
	mov	DWORD PTR [ebp+404], ecx
	mov	edx, DWORD PTR [eax+408]
	add	eax, 412				; 0000019cH
	push	eax
	lea	ebx, DWORD PTR [ebp+412]
	mov	DWORD PTR [ebp+408], edx
	call	??4?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::operator=
	mov	eax, DWORD PTR ___that$[esp+12]
	add	eax, 424				; 000001a8H
	push	eax
	lea	eax, DWORD PTR [ebp+424]
	call	??4?$_Impl_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::operator=
	pop	edi
	pop	esi
	mov	eax, ebp
	pop	ebp
	pop	ebx
	ret	4
??4CBoneData@@QAEAAV0@ABV0@@Z ENDP			; CBoneData::operator=
_TEXT	ENDS
PUBLIC	??0CBoneData@@QAE@ABV0@@Z			; CBoneData::CBoneData
; Function compile flags: /Ogtpy
;	COMDAT ??0CBoneData@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0CBoneData@@QAE@ABV0@@Z PROC				; CBoneData::CBoneData, COMDAT
; _this$ = ecx
	push	ebx
	mov	ebx, ecx
	push	ebp
	mov	ebp, DWORD PTR ___that$[esp+4]
	mov	DWORD PTR [ebx], OFFSET ??_7CBoneData@@6B@
	mov	ax, WORD PTR [ebp+4]
	mov	WORD PTR [ebx+4], ax
	mov	cx, WORD PTR [ebp+6]
	xor	edx, edx
	mov	WORD PTR [ebx+6], cx
	mov	DWORD PTR [ebx+8], edx
	mov	ecx, DWORD PTR [ebp+8]
	cmp	ecx, edx
	push	esi
	push	edi
	je	SHORT $LN7@CBoneData@2
	add	DWORD PTR [ecx], 1
$LN7@CBoneData@2:
	mov	eax, DWORD PTR [ebx+8]
	cmp	eax, edx
	je	SHORT $LN10@CBoneData@2
	add	DWORD PTR [eax], -1
	mov	eax, DWORD PTR [ebx+8]
	cmp	DWORD PTR [eax], edx
	jne	SHORT $LN10@CBoneData@2
	mov	DWORD PTR [ebx+8], edx
$LN10@CBoneData@2:
	mov	DWORD PTR [ebx+8], ecx
	lea	esi, DWORD PTR [ebp+12]
	lea	edi, DWORD PTR [ebx+12]
	mov	ecx, 15					; 0000000fH
	rep movsd
	lea	esi, DWORD PTR [ebp+72]
	lea	edi, DWORD PTR [ebx+72]
	mov	ecx, 16					; 00000010H
	rep movsd
	lea	esi, DWORD PTR [ebp+136]
	lea	edi, DWORD PTR [ebx+136]
	mov	ecx, 16					; 00000010H
	rep movsd
	lea	esi, DWORD PTR [ebp+200]
	lea	edi, DWORD PTR [ebx+200]
	mov	ecx, 28					; 0000001cH
	rep movsd
	mov	DWORD PTR [ebx+312], edx
	mov	eax, DWORD PTR [ebp+312]
	cmp	eax, edx
	je	SHORT $LN16@CBoneData@2
	add	DWORD PTR [eax], 1
$LN16@CBoneData@2:
	mov	ecx, DWORD PTR [ebx+312]
	cmp	ecx, edx
	je	SHORT $LN19@CBoneData@2
	add	DWORD PTR [ecx], -1
	mov	ecx, DWORD PTR [ebx+312]
	cmp	DWORD PTR [ecx], edx
	jne	SHORT $LN19@CBoneData@2
	mov	DWORD PTR [ebx+312], edx
$LN19@CBoneData@2:
	mov	DWORD PTR [ebx+312], eax
	mov	dx, WORD PTR [ebp+316]
	mov	WORD PTR [ebx+316], dx
	lea	esi, DWORD PTR [ebp+318]
	lea	edi, DWORD PTR [ebx+318]
	mov	ecx, 19					; 00000013H
	rep movsd
	fld	DWORD PTR [ebp+396]
	fstp	DWORD PTR [ebx+396]
	mov	eax, DWORD PTR [ebp+400]
	mov	DWORD PTR [ebx+400], eax
	mov	ecx, DWORD PTR [ebp+404]
	mov	DWORD PTR [ebx+404], ecx
	mov	edx, DWORD PTR [ebp+408]
	lea	eax, DWORD PTR [ebp+412]
	push	eax
	lea	ecx, DWORD PTR [ebx+412]
	mov	DWORD PTR [ebx+408], edx
	call	??0?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAE@ABV012@@Z ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::_Impl_vector<void *,xalloc<void *> >
	mov	ecx, DWORD PTR [ebp+428]
	sub	ecx, DWORD PTR [ebp+424]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	xor	ecx, ecx
	lea	esi, DWORD PTR [eax+eax*2]
	mov	DWORD PTR [ebx+424], ecx
	mov	DWORD PTR [ebx+428], ecx
	add	esi, esi
	mov	DWORD PTR [ebx+432], ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	add	esi, esi
	push	esi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	add	esi, eax
	mov	DWORD PTR [ebx+424], eax
	mov	DWORD PTR [ebx+428], eax
	mov	DWORD PTR [ebx+432], esi
	mov	esi, DWORD PTR [ebp+428]
	mov	ebp, DWORD PTR [ebp+424]
	mov	edx, eax
	mov	eax, esi
	mov	ecx, ebp
	call	??$__ucopy@PBV?$xr_vector@GV?$xalloc@G@@@@PAV1@H@priv@stlp_std@@YAPAV?$xr_vector@GV?$xalloc@G@@@@PBV2@0PAV2@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<xr_vector<unsigned short,xalloc<unsigned short> > const *,xr_vector<unsigned short,xalloc<unsigned short> > *,int>
	pop	edi
	pop	esi
	mov	DWORD PTR [ebx+428], eax
	pop	ebp
	mov	eax, ebx
	pop	ebx
	ret	4
??0CBoneData@@QAE@ABV0@@Z ENDP				; CBoneData::CBoneData
_TEXT	ENDS
PUBLIC	??0CBoneData@@QAE@G@Z				; CBoneData::CBoneData
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\bone.h
;	COMDAT ??0CBoneData@@QAE@G@Z
_TEXT	SEGMENT
_ID$ = 8						; size = 2
??0CBoneData@@QAE@G@Z PROC				; CBoneData::CBoneData, COMDAT
; _this$ = ecx

; 475  : 	CBoneData		(u16 ID):SelfID(ID)	{VERIFY(SelfID!=BI_NONE);}

	xorps	xmm0, xmm0
	mov	ax, WORD PTR _ID$[esp-4]
	movss	xmm1, DWORD PTR __real@3f800000
	push	esi
	mov	esi, ecx
	mov	WORD PTR [esi+4], ax
	mov	DWORD PTR [esi], OFFSET ??_7CBoneData@@6B@
	push	edi
	xor	edi, edi
	mov	DWORD PTR [esi+8], edi
	mov	WORD PTR [esi+202], di
	mov	WORD PTR [esi+200], di
	movss	DWORD PTR [esi+204], xmm1
	movss	DWORD PTR [esi+208], xmm0
	movss	DWORD PTR [esi+212], xmm0
	movss	DWORD PTR [esi+216], xmm0
	movss	DWORD PTR [esi+220], xmm1
	movss	DWORD PTR [esi+224], xmm0
	movss	DWORD PTR [esi+228], xmm0
	movss	DWORD PTR [esi+232], xmm0
	movss	DWORD PTR [esi+236], xmm1
	movss	DWORD PTR [esi+240], xmm0
	movss	DWORD PTR [esi+244], xmm0
	movss	DWORD PTR [esi+248], xmm0
	movss	DWORD PTR [esi+252], xmm0
	movss	DWORD PTR [esi+256], xmm0
	movss	DWORD PTR [esi+260], xmm0
	movss	DWORD PTR [esi+264], xmm0
	movss	DWORD PTR [esi+268], xmm0
	movss	DWORD PTR [esi+272], xmm0
	movss	DWORD PTR [esi+276], xmm0
	movss	DWORD PTR [esi+280], xmm0
	movss	DWORD PTR [esi+284], xmm0
	movss	DWORD PTR [esi+288], xmm0
	movss	DWORD PTR [esi+292], xmm0
	movss	DWORD PTR [esi+296], xmm0
	movss	DWORD PTR [esi+300], xmm0
	lea	eax, DWORD PTR [esi+318]
	movss	DWORD PTR [esi+304], xmm0
	movss	DWORD PTR [esi+308], xmm0
	mov	DWORD PTR [esi+312], edi
	call	??0SJointIKData@@QAE@XZ			; SJointIKData::SJointIKData
	mov	DWORD PTR [esi+412], edi
	mov	DWORD PTR [esi+416], edi
	mov	DWORD PTR [esi+420], edi
	mov	DWORD PTR [esi+424], edi
	mov	DWORD PTR [esi+428], edi
	mov	DWORD PTR [esi+432], edi
	pop	edi
	mov	eax, esi
	pop	esi
	ret	4
??0CBoneData@@QAE@G@Z ENDP				; CBoneData::CBoneData
; Function compile flags: /Ogtpy
;	COMDAT ??_GCLensFlareDescriptor@@QAEPAXI@Z
_TEXT	SEGMENT
??_GCLensFlareDescriptor@@QAEPAXI@Z PROC		; CLensFlareDescriptor::`scalar deleting destructor', COMDAT
; _this$ = esi
	mov	ecx, esi
	call	??1CLensFlareDescriptor@@QAE@XZ
	mov	eax, esi
	ret	0
??_GCLensFlareDescriptor@@QAEPAXI@Z ENDP		; CLensFlareDescriptor::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\xrmemory_subst_msvc.h
_TEXT	ENDS
;	COMDAT ??R?$xr_special_free@$0A@VCLensFlareDescriptor@@@@QAEXAAPAVCLensFlareDescriptor@@@Z
_TEXT	SEGMENT
??R?$xr_special_free@$0A@VCLensFlareDescriptor@@@@QAEXAAPAVCLensFlareDescriptor@@@Z PROC ; xr_special_free<0,CLensFlareDescriptor>::operator(), COMDAT
; _ptr$ = esi

; 143  : 		ptr->~T			();

	mov	ecx, DWORD PTR [esi]
	call	??1CLensFlareDescriptor@@QAE@XZ

; 144  : 		Memory.mem_free	(ptr);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 145  : 	}

	ret	0
??R?$xr_special_free@$0A@VCLensFlareDescriptor@@@@QAEXAAPAVCLensFlareDescriptor@@@Z ENDP ; xr_special_free<0,CLensFlareDescriptor>::operator()
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$xr_delete@VCLensFlareDescriptor@@@@YAXAAPAVCLensFlareDescriptor@@@Z
_TEXT	SEGMENT
??$xr_delete@VCLensFlareDescriptor@@@@YAXAAPAVCLensFlareDescriptor@@@Z PROC ; xr_delete<CLensFlareDescriptor>, COMDAT
; _ptr$ = esi

; 151  : 	if (ptr) 

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN1@xr_delete@38

; 152  : 	{
; 153  : 		xr_special_free<is_polymorphic<T>::result,T>()(ptr);

	call	??1CLensFlareDescriptor@@QAE@XZ
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 154  : 		ptr = NULL;

	mov	DWORD PTR [esi], 0
$LN1@xr_delete@38:

; 155  : 	}
; 156  : }

	ret	0
??$xr_delete@VCLensFlareDescriptor@@@@YAXAAPAVCLensFlareDescriptor@@@Z ENDP ; xr_delete<CLensFlareDescriptor>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrserverentities\object_destroyer.h
_TEXT	ENDS
;	COMDAT ??$delete_data@$00@?$CHelper2@PAVCLensFlareDescriptor@@@CDestroyer@@SAXAAPAVCLensFlareDescriptor@@@Z
_TEXT	SEGMENT
??$delete_data@$00@?$CHelper2@PAVCLensFlareDescriptor@@@CDestroyer@@SAXAAPAVCLensFlareDescriptor@@@Z PROC ; CDestroyer::CHelper2<CLensFlareDescriptor *>::delete_data<1>, COMDAT
; _data$ = esi

; 107  : 		{
; 108  : 			if (data)
; 109  : 				CDestroyer::delete_data	(*data);
; 110  : 			xr_delete					(data);

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN4@delete_dat@5
	call	??1CLensFlareDescriptor@@QAE@XZ
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN4@delete_dat@5:

; 111  : 		}

	ret	0
??$delete_data@$00@?$CHelper2@PAVCLensFlareDescriptor@@@CDestroyer@@SAXAAPAVCLensFlareDescriptor@@@Z ENDP ; CDestroyer::CHelper2<CLensFlareDescriptor *>::delete_data<1>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$delete_data@$0A@@?$CHelper4@PAVCLensFlareDescriptor@@@CDestroyer@@SAXAAPAVCLensFlareDescriptor@@@Z
_TEXT	SEGMENT
??$delete_data@$0A@@?$CHelper4@PAVCLensFlareDescriptor@@@CDestroyer@@SAXAAPAVCLensFlareDescriptor@@@Z PROC ; CDestroyer::CHelper4<CLensFlareDescriptor *>::delete_data<0>, COMDAT
; _data$ = esi

; 130  : 		{
; 131  : 			CHelper2<T>::delete_data<object_type_traits::is_pointer<T>::value>	(data);

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN6@delete_dat@6
	call	??1CLensFlareDescriptor@@QAE@XZ
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN6@delete_dat@6:

; 132  : 		}

	ret	0
??$delete_data@$0A@@?$CHelper4@PAVCLensFlareDescriptor@@@CDestroyer@@SAXAAPAVCLensFlareDescriptor@@@Z ENDP ; CDestroyer::CHelper4<CLensFlareDescriptor *>::delete_data<0>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$delete_data@PAVCLensFlareDescriptor@@@CDestroyer@@SAXAAPAVCLensFlareDescriptor@@@Z
_TEXT	SEGMENT
??$delete_data@PAVCLensFlareDescriptor@@@CDestroyer@@SAXAAPAVCLensFlareDescriptor@@@Z PROC ; CDestroyer::delete_data<CLensFlareDescriptor *>, COMDAT
; _data$ = esi

; 144  : 		CHelper4<T>::delete_data<object_type_traits::is_stl_container<T>::value>(data);

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN8@delete_dat@7
	call	??1CLensFlareDescriptor@@QAE@XZ
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN8@delete_dat@7:

; 145  : 	}

	ret	0
??$delete_data@PAVCLensFlareDescriptor@@@CDestroyer@@SAXAAPAVCLensFlareDescriptor@@@Z ENDP ; CDestroyer::delete_data<CLensFlareDescriptor *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ?clear@?$vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@stlp_std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@stlp_std@@QAEXXZ PROC ; stlp_std::vector<CLensFlareDescriptor *,xalloc<CLensFlareDescriptor *> >::clear, COMDAT
; _this$ = edi

; 223  :   void clear() { _M_impl.clear(); }

	mov	ecx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edi]
	cmp	eax, ecx
	je	SHORT $LN12@clear@51
	push	esi
	mov	esi, ecx
	sub	esi, ecx
	je	SHORT $LN18@clear@51
	push	esi
	push	ecx
	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	add	eax, esi
$LN18@clear@51:
	mov	DWORD PTR [edi+4], eax
	pop	esi
$LN12@clear@51:
	ret	0
?clear@?$vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@stlp_std@@QAEXXZ ENDP ; stlp_std::vector<CLensFlareDescriptor *,xalloc<CLensFlareDescriptor *> >::clear
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ?clear_and_free@?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear_and_free@?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@QAEXXZ PROC ; xr_vector<CLensFlareDescriptor *,xalloc<CLensFlareDescriptor *> >::clear_and_free, COMDAT
; _this$ = edi

; 128  : 	void	clear_and_free		()									{ inherited::clear();			}

	mov	ecx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edi]
	cmp	eax, ecx
	je	SHORT $LN14@clear_and_@17
	push	esi
	mov	esi, ecx
	sub	esi, ecx
	je	SHORT $LN20@clear_and_@17
	push	esi
	push	ecx
	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	add	eax, esi
$LN20@clear_and_@17:
	mov	DWORD PTR [edi+4], eax
	pop	esi
$LN14@clear_and_@17:
	ret	0
?clear_and_free@?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@QAEXXZ ENDP ; xr_vector<CLensFlareDescriptor *,xalloc<CLensFlareDescriptor *> >::clear_and_free
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?clear@?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@QAEXXZ PROC ; xr_vector<CLensFlareDescriptor *,xalloc<CLensFlareDescriptor *> >::clear, COMDAT
; _this$ = edi

; 133  : 	void	clear				()									{ clear_and_free	();			}

	mov	ecx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edi]
	cmp	eax, ecx
	je	SHORT $LN16@clear@52
	push	esi
	mov	esi, ecx
	sub	esi, ecx
	je	SHORT $LN22@clear@52
	push	esi
	push	ecx
	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	add	eax, esi
$LN22@clear@52:
	mov	DWORD PTR [edi+4], eax
	pop	esi
$LN16@clear@52:
	ret	0
?clear@?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@QAEXXZ ENDP ; xr_vector<CLensFlareDescriptor *,xalloc<CLensFlareDescriptor *> >::clear
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrserverentities\object_destroyer.h
_TEXT	ENDS
;	COMDAT ??$delete_data@V?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@@CHelper3@CDestroyer@@SAXAAV?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@@Z
_TEXT	SEGMENT
??$delete_data@V?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@@CHelper3@CDestroyer@@SAXAAV?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@@Z PROC ; CDestroyer::CHelper3::delete_data<xr_vector<CLensFlareDescriptor *,xalloc<CLensFlareDescriptor *> > >, COMDAT
; _data$ = ebx

; 118  : 			T::iterator					I = data.begin();

	mov	eax, DWORD PTR [ebx]
	push	esi
	push	edi
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	mov	esi, eax

; 119  : 			T::iterator					E = data.end();

	mov	eax, DWORD PTR [ebx+4]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	mov	edi, eax
	add	esp, 8

; 120  : 			for ( ; I != E; ++I)

	cmp	esi, edi
	je	SHORT $LN1@delete_dat@8
	push	ebp
	mov	ebp, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LL3@delete_dat@8:

; 121  : 				CDestroyer::delete_data	(*I);

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@delete_dat@8
	call	??1CLensFlareDescriptor@@QAE@XZ
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebp
	mov	DWORD PTR [esi], 0
$LN2@delete_dat@8:
	add	esi, 4
	cmp	esi, edi
	jne	SHORT $LL3@delete_dat@8
	pop	ebp
$LN1@delete_dat@8:

; 122  : 			data.clear					();

	mov	ecx, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [ebx]
	cmp	eax, ecx
	je	SHORT $LN57@delete_dat@8
	mov	esi, ecx
	sub	esi, ecx
	je	SHORT $LN63@delete_dat@8
	push	esi
	push	ecx
	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	add	eax, esi
$LN63@delete_dat@8:
	mov	DWORD PTR [ebx+4], eax
$LN57@delete_dat@8:
	pop	edi
	pop	esi

; 123  : 		}

	ret	0
??$delete_data@V?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@@CHelper3@CDestroyer@@SAXAAV?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@@Z ENDP ; CDestroyer::CHelper3::delete_data<xr_vector<CLensFlareDescriptor *,xalloc<CLensFlareDescriptor *> > >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_construct.h
_TEXT	ENDS
;	COMDAT ??$__destroy_mv_srcs@V?$reverse_iterator@PAUSFlare@CLensFlareDescriptor@@@stlp_std@@USFlare@CLensFlareDescriptor@@@stlp_std@@YAXV?$reverse_iterator@PAUSFlare@CLensFlareDescriptor@@@0@0PAUSFlare@CLensFlareDescriptor@@@Z
_TEXT	SEGMENT
___first$ = 8						; size = 4
___last$ = 12						; size = 4
??$__destroy_mv_srcs@V?$reverse_iterator@PAUSFlare@CLensFlareDescriptor@@@stlp_std@@USFlare@CLensFlareDescriptor@@@stlp_std@@YAXV?$reverse_iterator@PAUSFlare@CLensFlareDescriptor@@@0@0PAUSFlare@CLensFlareDescriptor@@@Z PROC ; stlp_std::__destroy_mv_srcs<stlp_std::reverse_iterator<CLensFlareDescriptor::SFlare *>,CLensFlareDescriptor::SFlare>, COMDAT

; 193  :   typedef typename __move_traits<_Tp>::complete _CompleteMove;
; 194  :   __destroy_range_aux(__first, __last, __ptr, _CompleteMove());

	mov	edx, DWORD PTR ___first$[esp-4]
	push	ecx
	mov	ecx, DWORD PTR ___last$[esp]
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	push	ecx
	mov	eax, esp
	mov	DWORD PTR [eax], edx
	call	??$__destroy_range_aux@V?$reverse_iterator@PAUSFlare@CLensFlareDescriptor@@@stlp_std@@USFlare@CLensFlareDescriptor@@@stlp_std@@YAXV?$reverse_iterator@PAUSFlare@CLensFlareDescriptor@@@0@0PAUSFlare@CLensFlareDescriptor@@ABU__false_type@0@@Z ; stlp_std::__destroy_range_aux<stlp_std::reverse_iterator<CLensFlareDescriptor::SFlare *>,CLensFlareDescriptor::SFlare>
	add	esp, 8

; 195  : }

	ret	0
??$__destroy_mv_srcs@V?$reverse_iterator@PAUSFlare@CLensFlareDescriptor@@@stlp_std@@USFlare@CLensFlareDescriptor@@@stlp_std@@YAXV?$reverse_iterator@PAUSFlare@CLensFlareDescriptor@@@0@0PAUSFlare@CLensFlareDescriptor@@@Z ENDP ; stlp_std::__destroy_mv_srcs<stlp_std::reverse_iterator<CLensFlareDescriptor::SFlare *>,CLensFlareDescriptor::SFlare>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrserverentities\object_destroyer.h
_TEXT	ENDS
;	COMDAT ??$delete_data@$00@?$CHelper4@V?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@@CDestroyer@@SAXAAV?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@@Z
_TEXT	SEGMENT
??$delete_data@$00@?$CHelper4@V?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@@CDestroyer@@SAXAAV?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@@Z PROC ; CDestroyer::CHelper4<xr_vector<CLensFlareDescriptor *,xalloc<CLensFlareDescriptor *> > >::delete_data<1>, COMDAT
; _data$ = ebx

; 136  : 		{
; 137  : 			CHelper3::delete_data	(data);

	jmp	??$delete_data@V?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@@CHelper3@CDestroyer@@SAXAAV?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@@Z ; CDestroyer::CHelper3::delete_data<xr_vector<CLensFlareDescriptor *,xalloc<CLensFlareDescriptor *> > >
??$delete_data@$00@?$CHelper4@V?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@@CDestroyer@@SAXAAV?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@@Z ENDP ; CDestroyer::CHelper4<xr_vector<CLensFlareDescriptor *,xalloc<CLensFlareDescriptor *> > >::delete_data<1>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_construct.h
_TEXT	ENDS
;	COMDAT ??$_Destroy_Moved_Range@V?$reverse_iterator@PAUSFlare@CLensFlareDescriptor@@@stlp_std@@@stlp_std@@YAXV?$reverse_iterator@PAUSFlare@CLensFlareDescriptor@@@0@0@Z
_TEXT	SEGMENT
___first$ = 8						; size = 4
___last$ = 12						; size = 4
??$_Destroy_Moved_Range@V?$reverse_iterator@PAUSFlare@CLensFlareDescriptor@@@stlp_std@@@stlp_std@@YAXV?$reverse_iterator@PAUSFlare@CLensFlareDescriptor@@@0@0@Z PROC ; stlp_std::_Destroy_Moved_Range<stlp_std::reverse_iterator<CLensFlareDescriptor::SFlare *> >, COMDAT

; 199  :   __destroy_mv_srcs(__first, __last, _STLP_VALUE_TYPE(__first, _ForwardIterator));

	mov	edx, DWORD PTR ___first$[esp-4]
	push	ecx
	mov	ecx, DWORD PTR ___last$[esp]
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	push	ecx
	mov	eax, esp
	mov	DWORD PTR [eax], edx
	call	??$__destroy_range_aux@V?$reverse_iterator@PAUSFlare@CLensFlareDescriptor@@@stlp_std@@USFlare@CLensFlareDescriptor@@@stlp_std@@YAXV?$reverse_iterator@PAUSFlare@CLensFlareDescriptor@@@0@0PAUSFlare@CLensFlareDescriptor@@ABU__false_type@0@@Z ; stlp_std::__destroy_range_aux<stlp_std::reverse_iterator<CLensFlareDescriptor::SFlare *>,CLensFlareDescriptor::SFlare>
	add	esp, 8

; 200  : }

	ret	0
??$_Destroy_Moved_Range@V?$reverse_iterator@PAUSFlare@CLensFlareDescriptor@@@stlp_std@@@stlp_std@@YAXV?$reverse_iterator@PAUSFlare@CLensFlareDescriptor@@@0@0@Z ENDP ; stlp_std::_Destroy_Moved_Range<stlp_std::reverse_iterator<CLensFlareDescriptor::SFlare *> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrserverentities\object_destroyer.h
_TEXT	ENDS
;	COMDAT ??$delete_data@V?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@@CDestroyer@@SAXAAV?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@@Z
_TEXT	SEGMENT
??$delete_data@V?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@@CDestroyer@@SAXAAV?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@@Z PROC ; CDestroyer::delete_data<xr_vector<CLensFlareDescriptor *,xalloc<CLensFlareDescriptor *> > >, COMDAT
; _data$ = ebx

; 144  : 		CHelper4<T>::delete_data<object_type_traits::is_stl_container<T>::value>(data);

	jmp	??$delete_data@V?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@@CHelper3@CDestroyer@@SAXAAV?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@@Z ; CDestroyer::CHelper3::delete_data<xr_vector<CLensFlareDescriptor *,xalloc<CLensFlareDescriptor *> > >
??$delete_data@V?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@@CDestroyer@@SAXAAV?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@@Z ENDP ; CDestroyer::delete_data<xr_vector<CLensFlareDescriptor *,xalloc<CLensFlareDescriptor *> > >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ?_M_clear_after_move@?$_Impl_vector@USFlare@CLensFlareDescriptor@@V?$xalloc@USFlare@CLensFlareDescriptor@@@@@priv@stlp_std@@AAEXXZ
_TEXT	SEGMENT
?_M_clear_after_move@?$_Impl_vector@USFlare@CLensFlareDescriptor@@V?$xalloc@USFlare@CLensFlareDescriptor@@@@@priv@stlp_std@@AAEXXZ PROC ; stlp_std::priv::_Impl_vector<CLensFlareDescriptor::SFlare,xalloc<CLensFlareDescriptor::SFlare> >::_M_clear_after_move, COMDAT
; _this$ = eax

; 620  :   void _M_clear_after_move() {

	push	esi
	mov	esi, eax

; 621  :     _STLP_STD::_Destroy_Moved_Range(rbegin(), rend());

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi]
	push	ecx
	mov	edx, esp
	mov	DWORD PTR [edx], eax
	push	ecx
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	call	??$__destroy_range_aux@V?$reverse_iterator@PAUSFlare@CLensFlareDescriptor@@@stlp_std@@USFlare@CLensFlareDescriptor@@@stlp_std@@YAXV?$reverse_iterator@PAUSFlare@CLensFlareDescriptor@@@0@0PAUSFlare@CLensFlareDescriptor@@ABU__false_type@0@@Z ; stlp_std::__destroy_range_aux<stlp_std::reverse_iterator<CLensFlareDescriptor::SFlare *>,CLensFlareDescriptor::SFlare>

; 622  :     this->_M_end_of_storage.deallocate(this->_M_start, this->_M_end_of_storage._M_data - this->_M_start);

	mov	esi, DWORD PTR [esi]
	add	esp, 8
	test	esi, esi
	je	SHORT $LN29@M_clear_af@6
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN29@M_clear_af@6:

; 623  :   }

	pop	esi
	ret	0
?_M_clear_after_move@?$_Impl_vector@USFlare@CLensFlareDescriptor@@V?$xalloc@USFlare@CLensFlareDescriptor@@@@@priv@stlp_std@@AAEXXZ ENDP ; stlp_std::priv::_Impl_vector<CLensFlareDescriptor::SFlare,xalloc<CLensFlareDescriptor::SFlare> >::_M_clear_after_move
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_construct.h
_TEXT	ENDS
;	COMDAT ??$_Copy_Construct@USFlare@CLensFlareDescriptor@@@stlp_std@@YAXPAUSFlare@CLensFlareDescriptor@@ABU12@@Z
_TEXT	SEGMENT
??$_Copy_Construct@USFlare@CLensFlareDescriptor@@@stlp_std@@YAXPAUSFlare@CLensFlareDescriptor@@ABU12@@Z PROC ; stlp_std::_Copy_Construct<CLensFlareDescriptor::SFlare>, COMDAT
; ___p$ = eax
; ___val$ = edi

; 109  : inline void _Copy_Construct(_Tp* __p, const _Tp& __val) {

	push	esi
	mov	esi, eax

; 110  : #if defined (_STLP_DEBUG_UNINITIALIZED)
; 111  :   memset((char*)__p, _STLP_SHRED_BYTE, sizeof(_Tp));
; 112  : #endif
; 113  :   _STLP_PLACEMENT_NEW (__p) _Tp(__val);

	test	esi, esi
	je	SHORT $LN3@Copy_Const@33
	call	??0SFlare@CLensFlareDescriptor@@QAE@ABU01@@Z
$LN3@Copy_Const@33:
	pop	esi

; 114  : }

	ret	0
??$_Copy_Construct@USFlare@CLensFlareDescriptor@@@stlp_std@@YAXPAUSFlare@CLensFlareDescriptor@@ABU12@@Z ENDP ; stlp_std::_Copy_Construct<CLensFlareDescriptor::SFlare>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrserverentities\object_destroyer.h
_TEXT	ENDS
;	COMDAT ??$delete_data@V?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@@@YAXABV?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@@Z
_TEXT	SEGMENT
??$delete_data@V?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@@@YAXABV?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@@Z PROC ; delete_data<xr_vector<CLensFlareDescriptor *,xalloc<CLensFlareDescriptor *> > >, COMDAT
; _data$ = ebx

; 151  : 	T	*temp = const_cast<T*>(&data);
; 152  : 	CDestroyer::delete_data(*temp);

	jmp	??$delete_data@V?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@@CHelper3@CDestroyer@@SAXAAV?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@@Z ; CDestroyer::CHelper3::delete_data<xr_vector<CLensFlareDescriptor *,xalloc<CLensFlareDescriptor *> > >
??$delete_data@V?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@@@YAXABV?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@@Z ENDP ; delete_data<xr_vector<CLensFlareDescriptor *,xalloc<CLensFlareDescriptor *> > >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ?push_back@?$_Impl_vector@GV?$xalloc@G@@@priv@stlp_std@@QAEXABG@Z
_TEXT	SEGMENT
?push_back@?$_Impl_vector@GV?$xalloc@G@@@priv@stlp_std@@QAEXABG@Z PROC ; stlp_std::priv::_Impl_vector<unsigned short,xalloc<unsigned short> >::push_back, COMDAT
; _this$ = ecx
; ___x$ = eax

; 360  :   void push_back(const _Tp& __x) {

	push	edi
	mov	edi, ecx

; 361  : #endif /*!_STLP_DONT_SUP_DFLT_PARAM && !_STLP_NO_ANACHRONISMS*/
; 362  :     if (this->_M_finish != this->_M_end_of_storage._M_data) {

	mov	ecx, DWORD PTR [edi+4]
	cmp	ecx, DWORD PTR [edi+8]
	je	SHORT $LN2@push_back@50

; 363  :       _Copy_Construct(this->_M_finish, __x);

	test	ecx, ecx
	je	SHORT $LN7@push_back@50
	mov	ax, WORD PTR [eax]
	mov	WORD PTR [ecx], ax
$LN7@push_back@50:

; 364  :       ++this->_M_finish;

	add	DWORD PTR [edi+4], 2
	pop	edi

; 368  :   }

	ret	0
$LN2@push_back@50:

; 365  :     }
; 366  :     else
; 367  :       _M_insert_overflow(this->_M_finish, __x, _TrivialCopy(), 1UL, true);

	push	1
	push	1
	push	ecx
	call	?_M_insert_overflow@?$_Impl_vector@GV?$xalloc@G@@@priv@stlp_std@@AAEXPAGABGABU__true_type@3@I_N@Z ; stlp_std::priv::_Impl_vector<unsigned short,xalloc<unsigned short> >::_M_insert_overflow
	pop	edi

; 368  :   }

	ret	0
?push_back@?$_Impl_vector@GV?$xalloc@G@@@priv@stlp_std@@QAEXABG@Z ENDP ; stlp_std::priv::_Impl_vector<unsigned short,xalloc<unsigned short> >::push_back
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@GV?$xalloc@G@@@stlp_std@@QAEXABG@Z
_TEXT	SEGMENT
?push_back@?$vector@GV?$xalloc@G@@@stlp_std@@QAEXABG@Z PROC ; stlp_std::vector<unsigned short,xalloc<unsigned short> >::push_back, COMDAT
; _this$ = ecx
; ___x$ = eax

; 171  :   { _M_impl.push_back(cast_traits::to_storage_type_cref(__x)); }

	push	edi
	mov	edi, ecx
	mov	ecx, DWORD PTR [edi+4]
	cmp	ecx, DWORD PTR [edi+8]
	je	SHORT $LN6@push_back@51
	test	ecx, ecx
	je	SHORT $LN11@push_back@51
	mov	ax, WORD PTR [eax]
	mov	WORD PTR [ecx], ax
$LN11@push_back@51:
	add	DWORD PTR [edi+4], 2
	pop	edi
	ret	0
$LN6@push_back@51:
	push	1
	push	1
	push	ecx
	call	?_M_insert_overflow@?$_Impl_vector@GV?$xalloc@G@@@priv@stlp_std@@AAEXPAGABGABU__true_type@3@I_N@Z ; stlp_std::priv::_Impl_vector<unsigned short,xalloc<unsigned short> >::_M_insert_overflow
	pop	edi
	ret	0
?push_back@?$vector@GV?$xalloc@G@@@stlp_std@@QAEXABG@Z ENDP ; stlp_std::vector<unsigned short,xalloc<unsigned short> >::push_back
_TEXT	ENDS
PUBLIC	??1CLensFlare@@UAE@XZ				; CLensFlare::~CLensFlare
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\xr_efflensflare.cpp
;	COMDAT ??1CLensFlare@@UAE@XZ
_TEXT	SEGMENT
??1CLensFlare@@UAE@XZ PROC				; CLensFlare::~CLensFlare, COMDAT
; _this$ = ecx

; 170  : {

	push	ebx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR [esi], OFFSET ??_7CLensFlare@@6B@

; 171  : 	OnDeviceDestroy				();

	call	?OnDeviceDestroy@CLensFlare@@QAEXXZ	; CLensFlare::OnDeviceDestroy

; 172  : 	delete_data(m_Palette);	

	lea	ebx, DWORD PTR [esi+476]
	call	??$delete_data@V?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@@CHelper3@CDestroyer@@SAXAAV?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@@Z ; CDestroyer::CHelper3::delete_data<xr_vector<CLensFlareDescriptor *,xalloc<CLensFlareDescriptor *> > >

; 173  : }

	mov	ebx, DWORD PTR [ebx]
	test	ebx, ebx
	mov	edi, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	je	SHORT $LN46@CLensFlare@3
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	ebx
	call	edi
$LN46@CLensFlare@3:
	mov	eax, DWORD PTR __imp_?RenderFactory@@3PAVIRenderFactory@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [esi+472]
	mov	edx, DWORD PTR [edx+100]
	push	eax
	call	edx
	mov	DWORD PTR [esi+472], 0
	mov	esi, DWORD PTR [esi+4]
	test	esi, esi
	je	SHORT $LN92@CLensFlare@3
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	edi
$LN92@CLensFlare@3:
	pop	edi
	pop	esi
	pop	ebx
	ret	0
??1CLensFlare@@UAE@XZ ENDP				; CLensFlare::~CLensFlare
_TEXT	ENDS
PUBLIC	?AppendFace@CBoneData@@QAEXGG@Z			; CBoneData::AppendFace
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\bone.h
;	COMDAT ?AppendFace@CBoneData@@QAEXGG@Z
_TEXT	SEGMENT
_child_idx$ = 8						; size = 2
_idx$ = 12						; size = 2
?AppendFace@CBoneData@@QAEXGG@Z PROC			; CBoneData::AppendFace, COMDAT
; _this$ = ecx

; 489  : 		child_faces[child_idx].push_back(idx);

	movzx	eax, WORD PTR _child_idx$[esp-4]
	mov	ecx, DWORD PTR [ecx+424]
	lea	eax, DWORD PTR [eax+eax*2]
	push	edi
	lea	edi, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edi+4]
	cmp	eax, DWORD PTR [edi+8]
	je	SHORT $LN19@AppendFace
	test	eax, eax
	je	SHORT $LN24@AppendFace
	mov	dx, WORD PTR _idx$[esp]
	mov	WORD PTR [eax], dx
$LN24@AppendFace:
	add	DWORD PTR [edi+4], 2
	pop	edi

; 490  : 	}

	ret	8

; 489  : 		child_faces[child_idx].push_back(idx);

$LN19@AppendFace:
	push	1
	push	1
	push	eax
	lea	eax, DWORD PTR _idx$[esp+12]
	call	?_M_insert_overflow@?$_Impl_vector@GV?$xalloc@G@@@priv@stlp_std@@AAEXPAGABGABU__true_type@3@I_N@Z ; stlp_std::priv::_Impl_vector<unsigned short,xalloc<unsigned short> >::_M_insert_overflow
	pop	edi

; 490  : 	}

	ret	8
?AppendFace@CBoneData@@QAEXGG@Z ENDP			; CBoneData::AppendFace
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_uninitialized.h
;	COMDAT ??$__ucopy@PAUSFlare@CLensFlareDescriptor@@PAU12@H@priv@stlp_std@@YAPAUSFlare@CLensFlareDescriptor@@PAU23@00ABUrandom_access_iterator_tag@1@PAH@Z
_TEXT	SEGMENT
??$__ucopy@PAUSFlare@CLensFlareDescriptor@@PAU12@H@priv@stlp_std@@YAPAUSFlare@CLensFlareDescriptor@@PAU23@00ABUrandom_access_iterator_tag@1@PAH@Z PROC ; stlp_std::priv::__ucopy<CLensFlareDescriptor::SFlare *,CLensFlareDescriptor::SFlare *,int>, COMDAT
; ___first$ = ecx
; ___last$ = eax
; ___result$ = edx

; 83   :                            _OutputIter __result, const random_access_iterator_tag &, _Distance*) {

	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 84   :   _OutputIter __cur = __result;
; 85   :   _STLP_TRY {
; 86   :     for (_Distance __n = __last - __first; __n > 0; --__n) {

	sub	eax, edi
	mov	ecx, eax
	mov	esi, edx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	ebx, edx
	shr	ebx, 31					; 0000001fH
	add	ebx, edx
	test	ebx, ebx
	jle	SHORT $LN14@ucopy@27
$LL3@ucopy@27:

; 87   :       _Param_Construct(&*__cur, *__first);

	test	esi, esi
	je	SHORT $LN8@ucopy@27
	call	??0SFlare@CLensFlareDescriptor@@QAE@ABU01@@Z
$LN8@ucopy@27:
	sub	ebx, 1

; 88   :       ++__first;

	add	edi, 24					; 00000018H

; 89   :       ++__cur;

	add	esi, 24					; 00000018H
	test	ebx, ebx
	jg	SHORT $LL3@ucopy@27
$LN14@ucopy@27:
	pop	edi

; 90   :     }
; 91   :     return __cur;

	mov	eax, esi
	pop	esi
	pop	ebx

; 92   :   }
; 93   :   _STLP_UNWIND(_STLP_STD::_Destroy_Range(__result, __cur))
; 94   :   _STLP_RET_AFTER_THROW(__cur)
; 95   : }

	ret	0
??$__ucopy@PAUSFlare@CLensFlareDescriptor@@PAU12@H@priv@stlp_std@@YAPAUSFlare@CLensFlareDescriptor@@PAU23@00ABUrandom_access_iterator_tag@1@PAH@Z ENDP ; stlp_std::priv::__ucopy<CLensFlareDescriptor::SFlare *,CLensFlareDescriptor::SFlare *,int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$__ufill@PAUSFlare@CLensFlareDescriptor@@U12@H@priv@stlp_std@@YAXPAUSFlare@CLensFlareDescriptor@@0ABU23@ABUrandom_access_iterator_tag@1@PAH@Z
_TEXT	SEGMENT
??$__ufill@PAUSFlare@CLensFlareDescriptor@@U12@H@priv@stlp_std@@YAXPAUSFlare@CLensFlareDescriptor@@0ABU23@ABUrandom_access_iterator_tag@1@PAH@Z PROC ; stlp_std::priv::__ufill<CLensFlareDescriptor::SFlare *,CLensFlareDescriptor::SFlare,int>, COMDAT
; ___first$ = edx
; ___last$ = eax
; ___x$ = ecx

; 246  :                     const _Tp& __x, const random_access_iterator_tag &, _Distance*) {

	push	ebx
	push	esi
	mov	esi, edx

; 247  :   _ForwardIter __cur = __first;
; 248  :   _STLP_TRY {
; 249  :     for (_Distance __n = __last - __first; __n > 0; --__n, ++__cur)

	sub	eax, esi
	push	edi
	mov	edi, ecx
	mov	ecx, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	ebx, edx
	shr	ebx, 31					; 0000001fH
	add	ebx, edx
	test	ebx, ebx
	jle	SHORT $LN1@ufill@18
$LL3@ufill@18:

; 250  :       _Param_Construct(&*__cur, __x);

	test	esi, esi
	je	SHORT $LN2@ufill@18
	call	??0SFlare@CLensFlareDescriptor@@QAE@ABU01@@Z
$LN2@ufill@18:

; 247  :   _ForwardIter __cur = __first;
; 248  :   _STLP_TRY {
; 249  :     for (_Distance __n = __last - __first; __n > 0; --__n, ++__cur)

	sub	ebx, 1
	add	esi, 24					; 00000018H
	test	ebx, ebx
	jg	SHORT $LL3@ufill@18
$LN1@ufill@18:
	pop	edi
	pop	esi
	pop	ebx

; 251  :   }
; 252  :   _STLP_UNWIND(_STLP_STD::_Destroy_Range(__first, __cur))
; 253  : }

	ret	0
??$__ufill@PAUSFlare@CLensFlareDescriptor@@U12@H@priv@stlp_std@@YAXPAUSFlare@CLensFlareDescriptor@@0ABU23@ABUrandom_access_iterator_tag@1@PAH@Z ENDP ; stlp_std::priv::__ufill<CLensFlareDescriptor::SFlare *,CLensFlareDescriptor::SFlare,int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$__ucopy_ptrs@PAUSFlare@CLensFlareDescriptor@@PAU12@@priv@stlp_std@@YAPAUSFlare@CLensFlareDescriptor@@PAU23@00ABU__false_type@1@@Z
_TEXT	SEGMENT
??$__ucopy_ptrs@PAUSFlare@CLensFlareDescriptor@@PAU12@@priv@stlp_std@@YAPAUSFlare@CLensFlareDescriptor@@PAU23@00ABU__false_type@1@@Z PROC ; stlp_std::priv::__ucopy_ptrs<CLensFlareDescriptor::SFlare *,CLensFlareDescriptor::SFlare *>, COMDAT
; ___first$ = ecx
; ___last$ = eax
; ___result$ = edx

; 113  : { return __ucopy(__first, __last, __result, random_access_iterator_tag(), (ptrdiff_t*)0); }

	jmp	??$__ucopy@PAUSFlare@CLensFlareDescriptor@@PAU12@H@priv@stlp_std@@YAPAUSFlare@CLensFlareDescriptor@@PAU23@00ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<CLensFlareDescriptor::SFlare *,CLensFlareDescriptor::SFlare *,int>
??$__ucopy_ptrs@PAUSFlare@CLensFlareDescriptor@@PAU12@@priv@stlp_std@@YAPAUSFlare@CLensFlareDescriptor@@PAU23@00ABU__false_type@1@@Z ENDP ; stlp_std::priv::__ucopy_ptrs<CLensFlareDescriptor::SFlare *,CLensFlareDescriptor::SFlare *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$__uninitialized_fill_n@PAUSFlare@CLensFlareDescriptor@@IU12@@priv@stlp_std@@YAPAUSFlare@CLensFlareDescriptor@@PAU23@IABU23@@Z
_TEXT	SEGMENT
??$__uninitialized_fill_n@PAUSFlare@CLensFlareDescriptor@@IU12@@priv@stlp_std@@YAPAUSFlare@CLensFlareDescriptor@@PAU23@IABU23@@Z PROC ; stlp_std::priv::__uninitialized_fill_n<CLensFlareDescriptor::SFlare *,unsigned int,CLensFlareDescriptor::SFlare>, COMDAT
; ___first$ = eax
; ___n$ = ecx
; ___x$ = edx

; 313  : inline _ForwardIter __uninitialized_fill_n(_ForwardIter __first, _Size __n, const _Tp& __x) {

	push	ebx

; 314  :   _ForwardIter __last = __first + __n;

	lea	ecx, DWORD PTR [ecx+ecx*2]
	push	ebp
	lea	ebp, DWORD PTR [eax+ecx*8]
	push	esi

; 315  :   __ufill(__first, __last, __x, random_access_iterator_tag(), (ptrdiff_t*)0);

	mov	ecx, ebp
	sub	ecx, eax
	mov	esi, eax
	push	edi
	mov	edi, edx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	ebx, edx
	shr	ebx, 31					; 0000001fH
	add	ebx, edx
	test	ebx, ebx
	jle	SHORT $LN16@uninitiali@37
$LL5@uninitiali@37:
	test	esi, esi
	je	SHORT $LN4@uninitiali@37
	call	??0SFlare@CLensFlareDescriptor@@QAE@ABU01@@Z
$LN4@uninitiali@37:
	sub	ebx, 1
	add	esi, 24					; 00000018H
	test	ebx, ebx
	jg	SHORT $LL5@uninitiali@37
$LN16@uninitiali@37:
	pop	edi
	pop	esi

; 316  :   return __last;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 317  : }

	ret	0
??$__uninitialized_fill_n@PAUSFlare@CLensFlareDescriptor@@IU12@@priv@stlp_std@@YAPAUSFlare@CLensFlareDescriptor@@PAU23@IABU23@@Z ENDP ; stlp_std::priv::__uninitialized_fill_n<CLensFlareDescriptor::SFlare *,unsigned int,CLensFlareDescriptor::SFlare>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$__uninitialized_move@PAUSFlare@CLensFlareDescriptor@@PAU12@U__false_type@stlp_std@@@priv@stlp_std@@YAPAUSFlare@CLensFlareDescriptor@@PAU23@00U__false_type@1@ABU41@@Z
_TEXT	SEGMENT
___trivial_ucpy$ = 8					; size = 1
??$__uninitialized_move@PAUSFlare@CLensFlareDescriptor@@PAU12@U__false_type@stlp_std@@@priv@stlp_std@@YAPAUSFlare@CLensFlareDescriptor@@PAU23@00U__false_type@1@ABU41@@Z PROC ; stlp_std::priv::__uninitialized_move<CLensFlareDescriptor::SFlare *,CLensFlareDescriptor::SFlare *,stlp_std::__false_type>, COMDAT
; ___first$ = ecx
; ___last$ = eax
; ___result$ = edx

; 414  : { return __ucopy_ptrs(__first, __last, __result, __trivial_ucpy); }

	jmp	??$__ucopy@PAUSFlare@CLensFlareDescriptor@@PAU12@H@priv@stlp_std@@YAPAUSFlare@CLensFlareDescriptor@@PAU23@00ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<CLensFlareDescriptor::SFlare *,CLensFlareDescriptor::SFlare *,int>
??$__uninitialized_move@PAUSFlare@CLensFlareDescriptor@@PAU12@U__false_type@stlp_std@@@priv@stlp_std@@YAPAUSFlare@CLensFlareDescriptor@@PAU23@00U__false_type@1@ABU41@@Z ENDP ; stlp_std::priv::__uninitialized_move<CLensFlareDescriptor::SFlare *,CLensFlareDescriptor::SFlare *,stlp_std::__false_type>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.c
_TEXT	ENDS
;	COMDAT ?_M_insert_overflow_aux@?$_Impl_vector@USFlare@CLensFlareDescriptor@@V?$xalloc@USFlare@CLensFlareDescriptor@@@@@priv@stlp_std@@AAEXPAUSFlare@CLensFlareDescriptor@@ABU45@ABU__false_type@3@I_N@Z
_TEXT	SEGMENT
___old_size$ = -12					; size = 4
___fill_len$ = -8					; size = 4
___new_start$ = -4					; size = 4
___pos$ = 8						; size = 4
___x$ = 12						; size = 4
?_M_insert_overflow_aux@?$_Impl_vector@USFlare@CLensFlareDescriptor@@V?$xalloc@USFlare@CLensFlareDescriptor@@@@@priv@stlp_std@@AAEXPAUSFlare@CLensFlareDescriptor@@ABU45@ABU__false_type@3@I_N@Z PROC ; stlp_std::priv::_Impl_vector<CLensFlareDescriptor::SFlare,xalloc<CLensFlareDescriptor::SFlare> >::_M_insert_overflow_aux, COMDAT
; _this$ = ebx

; 84   :                                                  size_type __fill_len, bool __atend ) {

	sub	esp, 12					; 0000000cH

; 85   :   const size_type __old_size = size();

	mov	ecx, DWORD PTR [ebx+4]
	sub	ecx, DWORD PTR [ebx]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	push	ebp
	mov	eax, edx
	push	esi
	shr	eax, 31					; 0000001fH
	push	edi
	add	eax, edx

; 86   :   size_type __len = __old_size + (max)(__old_size, __fill_len);

	lea	ecx, DWORD PTR ___fill_len$[esp+24]
	push	ecx
	lea	edx, DWORD PTR ___old_size$[esp+28]
	push	edx
	mov	DWORD PTR ___fill_len$[esp+32], 1
	mov	DWORD PTR ___old_size$[esp+32], eax
	call	??$max@I@stlp_std@@YAABIABI0@Z		; stlp_std::max<unsigned int>
	mov	eax, DWORD PTR [eax]
	add	eax, DWORD PTR ___old_size$[esp+32]

; 87   : 
; 88   :   pointer __new_start = this->_M_end_of_storage.allocate(__len, __len);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	ebp, DWORD PTR [eax+eax*2]
	add	ebp, ebp
	add	ebp, ebp
	add	esp, 8
	add	ebp, ebp
	push	ebp
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 89   :   pointer __new_finish = __new_start;
; 90   :   _STLP_TRY {
; 91   :     __new_finish = _STLP_PRIV __uninitialized_move(this->_M_start, __pos, __new_start, _TrivialUCopy(), _Movable());

	mov	ecx, DWORD PTR [ebx]
	mov	edi, eax
	mov	eax, DWORD PTR ___pos$[esp+20]
	mov	edx, edi
	mov	DWORD PTR ___new_start$[esp+24], edi
	call	??$__ucopy@PAUSFlare@CLensFlareDescriptor@@PAU12@H@priv@stlp_std@@YAPAUSFlare@CLensFlareDescriptor@@PAU23@00ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<CLensFlareDescriptor::SFlare *,CLensFlareDescriptor::SFlare *,int>

; 92   :     // handle insertion
; 93   :     if (__fill_len == 1) {

	mov	ecx, DWORD PTR ___fill_len$[esp+24]
	cmp	ecx, 1
	mov	esi, eax
	jne	SHORT $LN3@M_insert_o@30

; 94   :       _Copy_Construct(__new_finish, __x);

	test	esi, esi
	je	SHORT $LN28@M_insert_o@30
	mov	edi, DWORD PTR ___x$[esp+20]
	call	??0SFlare@CLensFlareDescriptor@@QAE@ABU01@@Z
	mov	edi, DWORD PTR ___new_start$[esp+24]
$LN28@M_insert_o@30:

; 95   :       ++__new_finish;

	add	esi, 24					; 00000018H

; 96   :     } else

	jmp	SHORT $LN1@M_insert_o@30
$LN3@M_insert_o@30:

; 97   :       __new_finish = _STLP_PRIV __uninitialized_fill_n(__new_finish, __fill_len, __x);

	mov	edx, DWORD PTR ___x$[esp+20]
	call	??$__uninitialized_fill_n@PAUSFlare@CLensFlareDescriptor@@IU12@@priv@stlp_std@@YAPAUSFlare@CLensFlareDescriptor@@PAU23@IABU23@@Z ; stlp_std::priv::__uninitialized_fill_n<CLensFlareDescriptor::SFlare *,unsigned int,CLensFlareDescriptor::SFlare>
	mov	esi, eax
$LN1@M_insert_o@30:

; 98   :     if (!__atend)
; 99   :       __new_finish = _STLP_PRIV __uninitialized_move(__pos, this->_M_finish, __new_finish, _TrivialUCopy(), _Movable()); // copy remainder
; 100  :   }
; 101  :   _STLP_UNWIND((_STLP_STD::_Destroy_Range(__new_start,__new_finish),
; 102  :                this->_M_end_of_storage.deallocate(__new_start,__len)))
; 103  :   _M_clear_after_move();

	mov	ecx, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [ebx]
	push	ecx
	mov	edx, esp
	mov	DWORD PTR [edx], eax
	push	ecx
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	call	??$__destroy_range_aux@V?$reverse_iterator@PAUSFlare@CLensFlareDescriptor@@@stlp_std@@USFlare@CLensFlareDescriptor@@@stlp_std@@YAXV?$reverse_iterator@PAUSFlare@CLensFlareDescriptor@@@0@0PAUSFlare@CLensFlareDescriptor@@ABU__false_type@0@@Z ; stlp_std::__destroy_range_aux<stlp_std::reverse_iterator<CLensFlareDescriptor::SFlare *>,CLensFlareDescriptor::SFlare>
	mov	eax, DWORD PTR [ebx]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN64@M_insert_o@30
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN64@M_insert_o@30:

; 104  :   _M_set(__new_start, __new_finish, __new_start + __len);

	add	ebp, edi
	mov	DWORD PTR [ebx], edi

; 105  : }

	pop	edi
	mov	DWORD PTR [ebx+4], esi
	pop	esi
	mov	DWORD PTR [ebx+8], ebp
	pop	ebp
	add	esp, 12					; 0000000cH
	ret	8
?_M_insert_overflow_aux@?$_Impl_vector@USFlare@CLensFlareDescriptor@@V?$xalloc@USFlare@CLensFlareDescriptor@@@@@priv@stlp_std@@AAEXPAUSFlare@CLensFlareDescriptor@@ABU45@ABU__false_type@3@I_N@Z ENDP ; stlp_std::priv::_Impl_vector<CLensFlareDescriptor::SFlare,xalloc<CLensFlareDescriptor::SFlare> >::_M_insert_overflow_aux
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ?_M_insert_overflow@?$_Impl_vector@USFlare@CLensFlareDescriptor@@V?$xalloc@USFlare@CLensFlareDescriptor@@@@@priv@stlp_std@@AAEXPAUSFlare@CLensFlareDescriptor@@ABU45@ABU__false_type@3@I_N@Z
_TEXT	SEGMENT
?_M_insert_overflow@?$_Impl_vector@USFlare@CLensFlareDescriptor@@V?$xalloc@USFlare@CLensFlareDescriptor@@@@@priv@stlp_std@@AAEXPAUSFlare@CLensFlareDescriptor@@ABU45@ABU__false_type@3@I_N@Z PROC ; stlp_std::priv::_Impl_vector<CLensFlareDescriptor::SFlare,xalloc<CLensFlareDescriptor::SFlare> >::_M_insert_overflow, COMDAT
; _this$ = ebx
; ___pos$ = ecx
; ___x$ = eax

; 161  :   { _M_insert_overflow_aux(__pos, __x, _Movable(), __fill_len, __atend); }

	push	eax
	push	ecx
	call	?_M_insert_overflow_aux@?$_Impl_vector@USFlare@CLensFlareDescriptor@@V?$xalloc@USFlare@CLensFlareDescriptor@@@@@priv@stlp_std@@AAEXPAUSFlare@CLensFlareDescriptor@@ABU45@ABU__false_type@3@I_N@Z ; stlp_std::priv::_Impl_vector<CLensFlareDescriptor::SFlare,xalloc<CLensFlareDescriptor::SFlare> >::_M_insert_overflow_aux
	ret	0
?_M_insert_overflow@?$_Impl_vector@USFlare@CLensFlareDescriptor@@V?$xalloc@USFlare@CLensFlareDescriptor@@@@@priv@stlp_std@@AAEXPAUSFlare@CLensFlareDescriptor@@ABU45@ABU__false_type@3@I_N@Z ENDP ; stlp_std::priv::_Impl_vector<CLensFlareDescriptor::SFlare,xalloc<CLensFlareDescriptor::SFlare> >::_M_insert_overflow
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?push_back@?$_Impl_vector@USFlare@CLensFlareDescriptor@@V?$xalloc@USFlare@CLensFlareDescriptor@@@@@priv@stlp_std@@QAEXABUSFlare@CLensFlareDescriptor@@@Z
_TEXT	SEGMENT
?push_back@?$_Impl_vector@USFlare@CLensFlareDescriptor@@V?$xalloc@USFlare@CLensFlareDescriptor@@@@@priv@stlp_std@@QAEXABUSFlare@CLensFlareDescriptor@@@Z PROC ; stlp_std::priv::_Impl_vector<CLensFlareDescriptor::SFlare,xalloc<CLensFlareDescriptor::SFlare> >::push_back, COMDAT
; _this$ = ecx
; ___x$ = eax

; 360  :   void push_back(const _Tp& __x) {

	push	ebx
	mov	ebx, ecx
	push	esi

; 361  : #endif /*!_STLP_DONT_SUP_DFLT_PARAM && !_STLP_NO_ANACHRONISMS*/
; 362  :     if (this->_M_finish != this->_M_end_of_storage._M_data) {

	mov	esi, DWORD PTR [ebx+4]
	cmp	esi, DWORD PTR [ebx+8]
	push	edi
	mov	edi, eax
	je	SHORT $LN2@push_back@60

; 363  :       _Copy_Construct(this->_M_finish, __x);

	test	esi, esi
	je	SHORT $LN7@push_back@60
	call	??0SFlare@CLensFlareDescriptor@@QAE@ABU01@@Z
$LN7@push_back@60:

; 364  :       ++this->_M_finish;

	add	DWORD PTR [ebx+4], 24			; 00000018H
	pop	edi
	pop	esi
	pop	ebx

; 368  :   }

	ret	0
$LN2@push_back@60:

; 365  :     }
; 366  :     else
; 367  :       _M_insert_overflow(this->_M_finish, __x, _TrivialCopy(), 1UL, true);

	push	edi
	push	esi
	call	?_M_insert_overflow_aux@?$_Impl_vector@USFlare@CLensFlareDescriptor@@V?$xalloc@USFlare@CLensFlareDescriptor@@@@@priv@stlp_std@@AAEXPAUSFlare@CLensFlareDescriptor@@ABU45@ABU__false_type@3@I_N@Z ; stlp_std::priv::_Impl_vector<CLensFlareDescriptor::SFlare,xalloc<CLensFlareDescriptor::SFlare> >::_M_insert_overflow_aux
	pop	edi
	pop	esi
	pop	ebx

; 368  :   }

	ret	0
?push_back@?$_Impl_vector@USFlare@CLensFlareDescriptor@@V?$xalloc@USFlare@CLensFlareDescriptor@@@@@priv@stlp_std@@QAEXABUSFlare@CLensFlareDescriptor@@@Z ENDP ; stlp_std::priv::_Impl_vector<CLensFlareDescriptor::SFlare,xalloc<CLensFlareDescriptor::SFlare> >::push_back
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@USFlare@CLensFlareDescriptor@@V?$xalloc@USFlare@CLensFlareDescriptor@@@@@stlp_std@@QAEXABUSFlare@CLensFlareDescriptor@@@Z
_TEXT	SEGMENT
?push_back@?$vector@USFlare@CLensFlareDescriptor@@V?$xalloc@USFlare@CLensFlareDescriptor@@@@@stlp_std@@QAEXABUSFlare@CLensFlareDescriptor@@@Z PROC ; stlp_std::vector<CLensFlareDescriptor::SFlare,xalloc<CLensFlareDescriptor::SFlare> >::push_back, COMDAT
; _this$ = ecx
; ___x$ = eax

; 171  :   { _M_impl.push_back(cast_traits::to_storage_type_cref(__x)); }

	push	ebx
	mov	ebx, ecx
	push	esi
	mov	esi, DWORD PTR [ebx+4]
	cmp	esi, DWORD PTR [ebx+8]
	push	edi
	mov	edi, eax
	je	SHORT $LN6@push_back@61
	test	esi, esi
	je	SHORT $LN11@push_back@61
	call	??0SFlare@CLensFlareDescriptor@@QAE@ABU01@@Z
$LN11@push_back@61:
	add	DWORD PTR [ebx+4], 24			; 00000018H
	pop	edi
	pop	esi
	pop	ebx
	ret	0
$LN6@push_back@61:
	push	edi
	push	esi
	call	?_M_insert_overflow_aux@?$_Impl_vector@USFlare@CLensFlareDescriptor@@V?$xalloc@USFlare@CLensFlareDescriptor@@@@@priv@stlp_std@@AAEXPAUSFlare@CLensFlareDescriptor@@ABU45@ABU__false_type@3@I_N@Z ; stlp_std::priv::_Impl_vector<CLensFlareDescriptor::SFlare,xalloc<CLensFlareDescriptor::SFlare> >::_M_insert_overflow_aux
	pop	edi
	pop	esi
	pop	ebx
	ret	0
?push_back@?$vector@USFlare@CLensFlareDescriptor@@V?$xalloc@USFlare@CLensFlareDescriptor@@@@@stlp_std@@QAEXABUSFlare@CLensFlareDescriptor@@@Z ENDP ; stlp_std::vector<CLensFlareDescriptor::SFlare,xalloc<CLensFlareDescriptor::SFlare> >::push_back
_TEXT	ENDS
PUBLIC	?AddFlare@CLensFlareDescriptor@@QAEXMMMPBD0@Z	; CLensFlareDescriptor::AddFlare
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\xr_efflensflare.cpp
;	COMDAT ?AddFlare@CLensFlareDescriptor@@QAEXMMMPBD0@Z
_TEXT	SEGMENT
_v$494549 = -32						; size = 4
_v$494574 = -28						; size = 4
_F$ = -24						; size = 24
_fRadius$ = 8						; size = 4
_fOpacity$ = 12						; size = 4
_fPosition$ = 16					; size = 4
_tex_name$ = 20						; size = 4
_sh_name$ = 24						; size = 4
?AddFlare@CLensFlareDescriptor@@QAEXMMMPBD0@Z PROC	; CLensFlareDescriptor::AddFlare, COMDAT
; _this$ = ecx

; 51   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 36					; 00000024H

; 52   : 	SFlare F;

	mov	eax, DWORD PTR __imp_?RenderFactory@@3PAVIRenderFactory@@A
	push	ebx
	mov	ebx, ecx
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+120]
	push	esi
	push	edi
	call	eax

; 53   : 	F.fRadius	= fRadius;

	movss	xmm0, DWORD PTR _fRadius$[ebp]

; 54   : 	F.fOpacity	= fOpacity;
; 55   :     F.fPosition	= fPosition;
; 56   :     F.shader	= sh_name;

	mov	ecx, DWORD PTR _sh_name$[ebp]
	mov	edx, DWORD PTR __imp_?g_pStringContainer@@3PAVstr_container@@A
	mov	esi, DWORD PTR __imp_?dock@str_container@@QAEPAUstr_value@@PBD@Z
	movss	DWORD PTR _F$[esp+52], xmm0
	movss	xmm0, DWORD PTR _fOpacity$[ebp]
	movss	DWORD PTR _F$[esp+48], xmm0
	movss	xmm0, DWORD PTR _fPosition$[ebp]
	push	ecx
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR _F$[esp+72], eax
	movss	DWORD PTR _F$[esp+60], xmm0
	call	esi
	mov	edi, eax
	test	edi, edi
	mov	DWORD PTR _v$494549[esp+48], edi
	je	SHORT $LN18@AddFlare
	add	DWORD PTR [edi], 1
$LN18@AddFlare:

; 57   :     F.texture	= tex_name;

	mov	eax, DWORD PTR _tex_name$[ebp]
	mov	ecx, DWORD PTR __imp_?g_pStringContainer@@3PAVstr_container@@A
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	DWORD PTR _F$[esp+68], edi
	call	esi
	mov	esi, eax
	test	esi, esi
	mov	DWORD PTR _v$494574[esp+48], esi
	je	SHORT $LN27@AddFlare
	add	DWORD PTR [esi], 1
$LN27@AddFlare:

; 58   : 	m_Flares.push_back	(F);

	mov	eax, DWORD PTR [ebx+4]
	cmp	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR _F$[esp+60], esi
	je	SHORT $LN36@AddFlare
	test	eax, eax
	je	SHORT $LN41@AddFlare
	lea	edi, DWORD PTR _F$[esp+48]
	mov	esi, eax
	call	??0SFlare@CLensFlareDescriptor@@QAE@ABU01@@Z
	mov	edi, DWORD PTR _v$494549[esp+48]
	mov	esi, DWORD PTR _v$494574[esp+48]
$LN41@AddFlare:
	add	DWORD PTR [ebx+4], 24			; 00000018H
	jmp	SHORT $LN45@AddFlare
$LN36@AddFlare:
	lea	edx, DWORD PTR _F$[esp+48]
	push	edx
	push	eax
	call	?_M_insert_overflow_aux@?$_Impl_vector@USFlare@CLensFlareDescriptor@@V?$xalloc@USFlare@CLensFlareDescriptor@@@@@priv@stlp_std@@AAEXPAUSFlare@CLensFlareDescriptor@@ABU45@ABU__false_type@3@I_N@Z ; stlp_std::priv::_Impl_vector<CLensFlareDescriptor::SFlare,xalloc<CLensFlareDescriptor::SFlare> >::_M_insert_overflow_aux
$LN45@AddFlare:

; 59   : }

	mov	eax, DWORD PTR __imp_?RenderFactory@@3PAVIRenderFactory@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _F$[esp+68]
	mov	edx, DWORD PTR [edx+124]
	push	eax
	call	edx
	test	edi, edi
	je	SHORT $LN55@AddFlare
	add	DWORD PTR [edi], -1
$LN55@AddFlare:
	test	esi, esi
	je	SHORT $LN61@AddFlare
	add	DWORD PTR [esi], -1
$LN61@AddFlare:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?AddFlare@CLensFlareDescriptor@@QAEXMMMPBD0@Z ENDP	; CLensFlareDescriptor::AddFlare
PUBLIC	?load@CLensFlareDescriptor@@QAEXPAVCInifile@@PBD@Z ; CLensFlareDescriptor::load
; Function compile flags: /Ogtpy
;	COMDAT ?load@CLensFlareDescriptor@@QAEXPAVCInifile@@PBD@Z
_TEXT	SEGMENT
_this$ = -296						; size = 4
$T532130 = -292						; size = 4
$T532122 = -292						; size = 4
_S$133042 = -292					; size = 4
_tcnt$133028 = -292					; size = 4
_T$133020 = -288					; size = 4
_S$133008 = -288					; size = 4
_O$133024 = -284					; size = 4
_T$133010 = -284					; size = 4
_R$133022 = -280					; size = 4
_r$133012 = -280					; size = 4
_r$133046 = -276					; size = 4
_r$133034 = -276					; size = 4
_S$133018 = -272					; size = 4
_P$133026 = -268					; size = 4
_p$133038 = -264					; size = 4
_o$133036 = -260					; size = 4
_name$133029 = -256					; size = 256
_pIni$ = 8						; size = 4
_sect$ = 12						; size = 4
?load@CLensFlareDescriptor@@QAEXPAVCInifile@@PBD@Z PROC	; CLensFlareDescriptor::load, COMDAT
; _this$ = ecx

; 71   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 300				; 0000012cH

; 72   : 	section		= sect;

	mov	eax, DWORD PTR __imp_?g_pStringContainer@@3PAVstr_container@@A
	push	ebx
	mov	ebx, DWORD PTR _sect$[ebp]
	push	esi
	push	edi
	mov	esi, ecx
	mov	ecx, DWORD PTR [eax]
	push	ebx
	mov	DWORD PTR _this$[esp+316], esi
	call	DWORD PTR __imp_?dock@str_container@@QAEPAUstr_value@@PBD@Z
	test	eax, eax
	je	SHORT $LN11@load@8
	add	DWORD PTR [eax], 1
$LN11@load@8:
	mov	ecx, DWORD PTR [esi+76]
	test	ecx, ecx
	je	SHORT $LN14@load@8
	add	DWORD PTR [ecx], -1
	mov	ecx, DWORD PTR [esi+76]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN14@load@8
	mov	DWORD PTR [esi+76], 0
$LN14@load@8:

; 73   : 	m_Flags.set	(flSource,pIni->r_bool(sect,"sun" ));

	mov	edi, DWORD PTR _pIni$[ebp]
	push	OFFSET ??_C@_03OHFMDAD@sun?$AA@
	mov	DWORD PTR [esi+76], eax
	push	ebx
	mov	ecx, edi
	add	esi, 12					; 0000000cH
	call	DWORD PTR __imp_?r_bool@CInifile@@QBEHPBD0@Z
	push	eax
	push	2
	mov	ecx, esi
	call	?set@?$_flags@I@@QAEAAU1@IH@Z		; _flags<unsigned int>::set

; 74   : 	if (m_Flags.is(flSource)){

	mov	edx, DWORD PTR [esi]

; 75   : 		LPCSTR S= pIni->r_string 	( sect,"sun_shader" );

	mov	esi, DWORD PTR __imp_?r_string@CInifile@@QBEPBDPBD0@Z
	and	edx, 2
	cmp	dl, 2
	jne	SHORT $LN6@load@8
	push	OFFSET ??_C@_0L@IBFLOEPG@sun_shader?$AA@
	push	ebx
	mov	ecx, edi
	call	esi

; 76   : 		LPCSTR T= pIni->r_string 	( sect,"sun_texture" );

	push	OFFSET ??_C@_0M@DDOHGILI@sun_texture?$AA@
	push	ebx
	mov	ecx, edi
	mov	DWORD PTR _S$133008[esp+320], eax
	call	esi

; 77   : 		float r = pIni->r_float		( sect,"sun_radius" );

	push	OFFSET ??_C@_0L@DPJEHLBG@sun_radius?$AA@
	push	ebx
	mov	ecx, edi
	mov	DWORD PTR _T$133010[esp+320], eax
	call	DWORD PTR __imp_?r_float@CInifile@@QBEMPBD0@Z
	fstp	DWORD PTR _r$133012[esp+312]

; 78   : 		BOOL i 	= pIni->r_bool		( sect,"sun_ignore_color" );

	push	OFFSET ??_C@_0BB@KEICPONN@sun_ignore_color?$AA@
	push	ebx
	mov	ecx, edi
	call	DWORD PTR __imp_?r_bool@CInifile@@QBEHPBD0@Z

; 79   : 		SetSource(r,i,T,S);

	fld	DWORD PTR _r$133012[esp+312]
	mov	ecx, DWORD PTR _S$133008[esp+312]
	mov	edx, DWORD PTR _T$133010[esp+312]
	push	ecx
	push	edx
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+328]
	fstp	DWORD PTR [esp]
	call	?SetSource@CLensFlareDescriptor@@QAEXMHPBD0@Z ; CLensFlareDescriptor::SetSource
$LN6@load@8:

; 80   : 	}
; 81   : 	m_Flags.set	(flFlare,pIni->r_bool ( sect,"flares" ));

	push	OFFSET ??_C@_06NKKJIDGL@flares?$AA@
	push	ebx
	mov	ecx, edi
	call	DWORD PTR __imp_?r_bool@CInifile@@QBEHPBD0@Z
	mov	ecx, DWORD PTR _this$[esp+312]
	push	eax
	push	1
	add	ecx, 12					; 0000000cH
	call	?set@?$_flags@I@@QAEAAU1@IH@Z		; _flags<unsigned int>::set

; 82   : 	if (m_Flags.is(flFlare)){

	mov	eax, DWORD PTR _this$[esp+312]
	add	eax, 12					; 0000000cH
	mov	eax, DWORD PTR [eax]
	and	eax, 1
	cmp	al, 1
	jne	$LN2@load@8

; 83   : 	    LPCSTR S= pIni->r_string 	( sect,"flare_shader" );

	push	OFFSET ??_C@_0N@PAPFMPDM@flare_shader?$AA@
	push	ebx
	mov	ecx, edi
	call	esi

; 84   : 		LPCSTR T= pIni->r_string 	( sect,"flare_textures" );

	push	OFFSET ??_C@_0P@FMDCEBMJ@flare_textures?$AA@
	push	ebx
	mov	ecx, edi
	mov	DWORD PTR _S$133018[esp+320], eax
	call	esi

; 85   : 		LPCSTR R= pIni->r_string 	( sect,"flare_radius" );

	push	OFFSET ??_C@_0N@EODKFANM@flare_radius?$AA@
	push	ebx
	mov	ecx, edi
	mov	DWORD PTR _T$133020[esp+320], eax
	call	esi

; 86   : 		LPCSTR O= pIni->r_string 	( sect,"flare_opacity");

	push	OFFSET ??_C@_0O@FCDMKCCA@flare_opacity?$AA@
	push	ebx
	mov	ecx, edi
	mov	DWORD PTR _R$133022[esp+320], eax
	call	esi

; 87   : 		LPCSTR P= pIni->r_string 	( sect,"flare_position");

	push	OFFSET ??_C@_0P@GFNCFJFG@flare_position?$AA@
	push	ebx
	mov	ecx, edi
	mov	DWORD PTR _O$133024[esp+320], eax
	call	esi

; 88   : 		u32 tcnt= _GetItemCount(T);

	mov	ecx, DWORD PTR _T$133020[esp+312]
	push	44					; 0000002cH
	push	ecx
	mov	DWORD PTR _P$133026[esp+320], eax
	call	DWORD PTR __imp_?_GetItemCount@@YAHPBDD@Z
	add	esp, 8

; 89   :         string256 name;
; 90   : 		for (u32 i=0; i<tcnt; i++){

	xor	esi, esi
	test	eax, eax
	mov	DWORD PTR _tcnt$133028[esp+312], eax
	jbe	$LN56@load@8
$LL4@load@8:

; 91   : 			_GetItem(R,i,name); float r=(float)atof(name);

	mov	eax, DWORD PTR _R$133022[esp+312]
	push	1
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	44					; 0000002cH
	push	256					; 00000100H
	lea	edx, DWORD PTR _name$133029[esp+328]
	push	edx
	push	esi
	push	eax
	call	DWORD PTR __imp_?_GetItem@@YAPADPBDHPADID0_N@Z
	lea	ecx, DWORD PTR _name$133029[esp+340]
	push	ecx
	call	DWORD PTR __imp__atof
	fstp	DWORD PTR _r$133034[esp+344]

; 92   : 			_GetItem(O,i,name); float o=(float)atof(name);

	mov	eax, DWORD PTR _O$133024[esp+344]
	push	1
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	44					; 0000002cH
	push	256					; 00000100H
	lea	edx, DWORD PTR _name$133029[esp+360]
	push	edx
	push	esi
	push	eax
	call	DWORD PTR __imp_?_GetItem@@YAPADPBDHPADID0_N@Z
	lea	ecx, DWORD PTR _name$133029[esp+372]
	push	ecx
	call	DWORD PTR __imp__atof
	fstp	DWORD PTR _o$133036[esp+376]

; 93   : 			_GetItem(P,i,name); float p=(float)atof(name);

	mov	eax, DWORD PTR _P$133026[esp+376]
	add	esp, 64					; 00000040H
	push	1
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	44					; 0000002cH
	push	256					; 00000100H
	lea	edx, DWORD PTR _name$133029[esp+328]
	push	edx
	push	esi
	push	eax
	call	DWORD PTR __imp_?_GetItem@@YAPADPBDHPADID0_N@Z
	lea	ecx, DWORD PTR _name$133029[esp+340]
	push	ecx
	call	DWORD PTR __imp__atof
	fstp	DWORD PTR _p$133038[esp+344]

; 94   : 			_GetItem(T,i,name);

	mov	eax, DWORD PTR _T$133020[esp+344]
	push	1
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	44					; 0000002cH
	push	256					; 00000100H
	lea	edx, DWORD PTR _name$133029[esp+360]
	push	edx
	push	esi
	push	eax
	call	DWORD PTR __imp_?_GetItem@@YAPADPBDHPADID0_N@Z

; 95   : 			AddFlare(r,o,p,name,S);

	fld	DWORD PTR _p$133038[esp+372]
	mov	ecx, DWORD PTR _S$133018[esp+372]
	add	esp, 60					; 0000003cH
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+316]
	lea	edx, DWORD PTR _name$133029[esp+316]
	push	edx
	sub	esp, 12					; 0000000cH
	fstp	DWORD PTR [esp+8]
	fld	DWORD PTR _o$133036[esp+332]
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR _r$133034[esp+332]
	fstp	DWORD PTR [esp]
	call	?AddFlare@CLensFlareDescriptor@@QAEXMMMPBD0@Z ; CLensFlareDescriptor::AddFlare
	add	esi, 1
	cmp	esi, DWORD PTR _tcnt$133028[esp+312]
	jb	$LL4@load@8
$LN56@load@8:

; 89   :         string256 name;
; 90   : 		for (u32 i=0; i<tcnt; i++){

	mov	esi, DWORD PTR __imp_?r_string@CInifile@@QBEPBDPBD0@Z
$LN2@load@8:

; 96   : 		}
; 97   : 	}
; 98   : 	m_Flags.set	(flGradient,CInifile::IsBOOL(pIni->r_string( sect, "gradient")));

	push	OFFSET ??_C@_08OAOFNDBJ@gradient?$AA@
	push	ebx
	mov	ecx, edi
	call	esi
	push	eax
	call	DWORD PTR __imp_?IsBOOL@CInifile@@SAHPBD@Z
	mov	ecx, DWORD PTR _this$[esp+316]
	add	esp, 4
	push	eax
	push	4
	add	ecx, 12					; 0000000cH
	call	?set@?$_flags@I@@QAEAAU1@IH@Z		; _flags<unsigned int>::set

; 99   : 	if (m_Flags.is(flGradient)){

	mov	eax, DWORD PTR _this$[esp+312]
	add	eax, 12					; 0000000cH
	mov	eax, DWORD PTR [eax]
	and	eax, 4
	cmp	al, 4
	jne	SHORT $LN57@load@8

; 100  : 		LPCSTR S= pIni->r_string 	( sect,"gradient_shader" );

	push	OFFSET ??_C@_0BA@KGIFDEPG@gradient_shader?$AA@
	push	ebx
	mov	ecx, edi
	call	esi

; 101  : 		LPCSTR T= pIni->r_string	( sect,"gradient_texture" );

	push	OFFSET ??_C@_0BB@DDMALGGI@gradient_texture?$AA@
	push	ebx
	mov	ecx, edi
	mov	DWORD PTR _S$133042[esp+320], eax
	call	esi

; 102  : 		float r	= pIni->r_float		( sect,"gradient_radius"  );

	push	OFFSET ??_C@_0BA@BIEKKLBG@gradient_radius?$AA@
	push	ebx
	mov	ecx, edi
	mov	esi, eax
	call	DWORD PTR __imp_?r_float@CInifile@@QBEMPBD0@Z
	fstp	DWORD PTR _r$133046[esp+312]

; 103  : 		float o = pIni->r_float		( sect,"gradient_opacity" );

	push	OFFSET ??_C@_0BB@CJNLPJHF@gradient_opacity?$AA@
	push	ebx
	mov	ecx, edi
	call	DWORD PTR __imp_?r_float@CInifile@@QBEMPBD0@Z

; 104  : 		SetGradient(r,o,T,S);

	mov	ecx, DWORD PTR _S$133042[esp+312]
	push	ecx
	push	esi
	mov	esi, DWORD PTR _this$[esp+320]
	sub	esp, 8
	fstp	DWORD PTR [esp+4]
	mov	ecx, esi
	fld	DWORD PTR _r$133046[esp+328]
	fstp	DWORD PTR [esp]
	call	?SetGradient@CLensFlareDescriptor@@QAEXMMPBD0@Z ; CLensFlareDescriptor::SetGradient
	jmp	SHORT $LN1@load@8
$LN57@load@8:
	mov	esi, DWORD PTR _this$[esp+312]
$LN1@load@8:

; 105  : 	}
; 106  :     m_StateBlendUpSpeed	= 1.f/(_max(pIni->r_float( sect,"blend_rise_time" ),0.f)+EPS_S);

	push	OFFSET ??_C@_0BA@IABLKNCI@blend_rise_time?$AA@
	push	ebx
	mov	ecx, edi
	call	DWORD PTR __imp_?r_float@CInifile@@QBEMPBD0@Z
	fst	DWORD PTR $T532122[esp+312]
	fldz
	fxch	ST(1)
	fcomip	ST(1)
	fstp	ST(0)
	jbe	SHORT $LN46@load@8
	movss	xmm0, DWORD PTR $T532122[esp+312]
	jmp	SHORT $LN47@load@8
$LN46@load@8:
	xorps	xmm0, xmm0
$LN47@load@8:
	addss	xmm0, DWORD PTR _EPS_S
	movss	xmm1, DWORD PTR __real@3f800000

; 107  :     m_StateBlendDnSpeed	= 1.f/(_max(pIni->r_float( sect,"blend_down_time" ),0.f)+EPS_S);

	push	OFFSET ??_C@_0BA@FPPMHPAN@blend_down_time?$AA@
	divss	xmm1, xmm0
	push	ebx
	mov	ecx, edi
	movss	DWORD PTR [esi+68], xmm1
	call	DWORD PTR __imp_?r_float@CInifile@@QBEMPBD0@Z
	fst	DWORD PTR $T532130[esp+312]
	fldz
	fxch	ST(1)
	fcomip	ST(1)
	fstp	ST(0)
	jbe	SHORT $LN50@load@8
	movss	xmm0, DWORD PTR $T532130[esp+312]
	jmp	SHORT $LN51@load@8
$LN50@load@8:
	xorps	xmm0, xmm0
$LN51@load@8:
	addss	xmm0, DWORD PTR _EPS_S
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm0

; 108  : 
; 109  : 	OnDeviceCreate();

	mov	ecx, esi
	movss	DWORD PTR [esi+72], xmm1
	call	?OnDeviceCreate@CLensFlareDescriptor@@QAEXXZ ; CLensFlareDescriptor::OnDeviceCreate

; 110  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?load@CLensFlareDescriptor@@QAEXPAVCInifile@@PBD@Z ENDP	; CLensFlareDescriptor::load
PUBLIC	?AppendDef@CLensFlare@@QAE?AVshared_str@@AAVCEnvironment@@PAVCInifile@@PBD@Z ; CLensFlare::AppendDef
; Function compile flags: /Ogtpy
;	COMDAT ?AppendDef@CLensFlare@@QAE?AVshared_str@@AAVCEnvironment@@PAVCInifile@@PBD@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_environment$ = 12					; size = 4
_pIni$ = 16						; size = 4
$T544413 = 20						; size = 4
_sect$ = 20						; size = 4
?AppendDef@CLensFlare@@QAE?AVshared_str@@AAVCEnvironment@@PAVCInifile@@PBD@Z PROC ; CLensFlare::AppendDef, COMDAT
; _this$ = ecx

; 558  : {

	push	ecx
	push	ebx

; 559  : 	if (!sect||(0==sect[0])) return "";

	mov	ebx, DWORD PTR _sect$[esp+4]
	test	ebx, ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx
	je	$LN5@AppendDef@2
	cmp	BYTE PTR [ebx], 0
	je	$LN5@AppendDef@2

; 560  :     for (LensFlareDescIt it=m_Palette.begin(); it!=m_Palette.end(); it++)

	mov	eax, DWORD PTR [edi+476]
	lea	ebp, DWORD PTR [edi+476]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	mov	esi, eax
	mov	eax, DWORD PTR [edi+480]
	add	esp, 4
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 4
	cmp	esi, eax
	je	SHORT $LN2@AppendDef@2
$LL4@AppendDef@2:

; 561  :     	if (0==xr_strcmp(*(*it)->section,sect)) return sect;

	mov	eax, DWORD PTR [esi]
	add	eax, 76					; 0000004cH
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN36@AppendDef@2
	add	eax, 16					; 00000010H
	jmp	SHORT $LN37@AppendDef@2
$LN36@AppendDef@2:
	xor	eax, eax
$LN37@AppendDef@2:
	mov	ecx, ebx
	npad	6
$LL76@AppendDef@2:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN77@AppendDef@2
	test	dl, dl
	je	SHORT $LN78@AppendDef@2
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN77@AppendDef@2
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL76@AppendDef@2
$LN78@AppendDef@2:
	xor	eax, eax
	jmp	SHORT $LN79@AppendDef@2
$LN77@AppendDef@2:
	sbb	eax, eax
	sbb	eax, -1
$LN79@AppendDef@2:
	test	eax, eax
	je	SHORT $LN74@AppendDef@2
	mov	eax, DWORD PTR [edi+480]
	push	eax
	add	esi, 4
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 4
	cmp	esi, eax
	jne	SHORT $LL4@AppendDef@2
$LN2@AppendDef@2:

; 562  : 
; 563  : 	environment.add_flare(m_Palette, sect); 

	mov	ecx, DWORD PTR __imp_?g_pStringContainer@@3PAVstr_container@@A
	mov	ecx, DWORD PTR [ecx]
	mov	edi, DWORD PTR __imp_?dock@str_container@@QAEPAUstr_value@@PBD@Z
	push	ebx
	call	edi
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN54@AppendDef@2
	add	DWORD PTR [esi], 1
$LN54@AppendDef@2:
	mov	ecx, DWORD PTR _environment$[esp+16]
	lea	edx, DWORD PTR $T544413[esp+16]
	push	edx
	push	ebp
	mov	DWORD PTR $T544413[esp+24], esi
	call	?add_flare@CEnvironment@@QAEPAVCLensFlareDescriptor@@AAV?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@ABVshared_str@@@Z ; CEnvironment::add_flare
	test	esi, esi
	je	SHORT $LN60@AppendDef@2
	add	DWORD PTR [esi], -1
$LN60@AppendDef@2:

; 564  :     return sect;

	mov	eax, DWORD PTR __imp_?g_pStringContainer@@3PAVstr_container@@A
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+16]
	mov	ecx, DWORD PTR [eax]
	push	ebx
	mov	DWORD PTR [esi], 0
	call	edi
	jmp	SHORT $LN87@AppendDef@2
$LN74@AppendDef@2:

; 561  :     	if (0==xr_strcmp(*(*it)->section,sect)) return sect;

	mov	eax, DWORD PTR __imp_?g_pStringContainer@@3PAVstr_container@@A
	mov	ecx, DWORD PTR [eax]
	push	ebx
	jmp	SHORT $LN86@AppendDef@2
$LN5@AppendDef@2:

; 559  : 	if (!sect||(0==sect[0])) return "";

	mov	ecx, DWORD PTR __imp_?g_pStringContainer@@3PAVstr_container@@A
	mov	ecx, DWORD PTR [ecx]
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN86@AppendDef@2:
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+20]
	mov	DWORD PTR [esi], 0
	call	DWORD PTR __imp_?dock@str_container@@QAEPAUstr_value@@PBD@Z
$LN87@AppendDef@2:
	test	eax, eax
	je	SHORT $LN11@AppendDef@2
	add	DWORD PTR [eax], 1
$LN11@AppendDef@2:
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN14@AppendDef@2
	add	DWORD PTR [ecx], -1
	jne	SHORT $LN14@AppendDef@2
	mov	DWORD PTR [esi], 0
$LN14@AppendDef@2:

; 565  : }

	pop	edi
	mov	DWORD PTR [esi], eax
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	16					; 00000010H
?AppendDef@CLensFlare@@QAE?AVshared_str@@AAVCEnvironment@@PAVCInifile@@PBD@Z ENDP ; CLensFlare::AppendDef
_TEXT	ENDS
PUBLIC	__real@40200000
PUBLIC	__real@3f800054
PUBLIC	?OnFrame@CLensFlare@@QAEXVshared_str@@@Z	; CLensFlare::OnFrame
;	COMDAT __real@40200000
; File d:\clearsky\sources\engine\xrcore\xrstring.h
CONST	SEGMENT
__real@40200000 DD 040200000r			; 2.5
CONST	ENDS
;	COMDAT __real@3f800054
CONST	SEGMENT
__real@3f800054 DD 03f800054r			; 1.00001
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\xr_efflensflare.cpp
CONST	ENDS
;	COMDAT ?OnFrame@CLensFlare@@QAEXVshared_str@@@Z
_TEXT	SEGMENT
tv2213 = -196						; size = 4
tv1720 = -196						; size = 4
tv1531 = -196						; size = 4
tv1378 = -196						; size = 4
_mag$544739 = -196					; size = 4
_tf$ = -196						; size = 4
tv1527 = -192						; size = 4
tv1374 = -192						; size = 4
tv1345 = -192						; size = 4
_kx$133256 = -192					; size = 4
_fVisResult$ = -192					; size = 4
tv2183 = -188						; size = 4
tv1523 = -188						; size = 4
tv1370 = -188						; size = 4
tv1341 = -188						; size = 4
tv1337 = -184						; size = 4
_mag$544827 = -184					; size = 4
_mag$544758 = -184					; size = 4
_ky$133257 = -184					; size = 4
__range$133248 = -184					; size = 4
_TP$ = -180						; size = 40
tv1728 = -140						; size = 4
_o_main$ = -140						; size = 4
_vecSx$ = -136						; size = 12
_vecPos$ = -136						; size = 12
_scr_pos$133255 = -124					; size = 12
_vecSy$ = -124						; size = 12
_matEffCamPos$ = -112					; size = 64
__v$133247 = -44					; size = 4
__u$133246 = -40					; size = 4
_RD$ = -36						; size = 36
_id$ = 8						; size = 4
?OnFrame@CLensFlare@@QAEXVshared_str@@@Z PROC		; CLensFlare::OnFrame, COMDAT
; _this$ = ecx

; 247  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 248  : 	if (dwFrame==Device.dwFrame)return;

	mov	eax, DWORD PTR ?Device@@3VCRenderDevice@@A+24
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx
	cmp	DWORD PTR [edi+360], eax
	je	$LN1@OnFrame@10

; 249  : #ifndef _EDITOR
; 250  : 	if (!g_pGameLevel)			return;

	cmp	DWORD PTR ?g_pGameLevel@@3PAVIGame_Level@@A, 0 ; g_pGameLevel
	je	$LN1@OnFrame@10

; 251  : #endif
; 252  : 	dwFrame			= Device.dwFrame;
; 253  : 
; 254  : 	R_ASSERT		( _valid(g_pGamePersistent->Environment().CurrentEnv->sun_dir) );

	mov	ebx, DWORD PTR __imp_?fail@xrDebug@@QAEXPBD0H0AA_N@Z
	mov	DWORD PTR [edi+360], eax
	cmp	BYTE PTR ?ignore_always@?7??OnFrame@CLensFlare@@QAEXVshared_str@@@Z@4_NA, 0
	jne	SHORT $LN57@OnFrame@10
	mov	eax, DWORD PTR ?g_pGamePersistent@@3PAVIGame_Persistent@@A ; g_pGamePersistent
	mov	eax, DWORD PTR [eax+1128]
	mov	esi, DWORD PTR [eax+120]
	add	esi, 152				; 00000098H
	call	??$_valid@M@@YAHABU?$_vector3@M@@@Z	; _valid<float>
	test	eax, eax
	jne	SHORT $LN57@OnFrame@10
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?7??OnFrame@CLensFlare@@QAEXVshared_str@@@Z@4_NA
	push	OFFSET ??_C@_0BE@BKKMFBAJ@CLensFlare?3?3OnFrame?$AA@
	push	254					; 000000feH
	push	OFFSET ??_C@_0DI@CJHPJF@D?3?2CLEARSKY?2sources?2engine?2xrEng@
	push	OFFSET ??_C@_0DN@GMMKOHAN@_valid?$CIg_pGamePersistent?9?$DOEnviro@
	call	ebx
$LN57@OnFrame@10:

; 255  : 	vSunDir.mul		(g_pGamePersistent->Environment().CurrentEnv->sun_dir,-1);

	mov	ecx, DWORD PTR ?g_pGamePersistent@@3PAVIGame_Persistent@@A ; g_pGamePersistent
	mov	edx, DWORD PTR [ecx+1128]
	mov	eax, DWORD PTR [edx+120]
	movss	xmm1, DWORD PTR [eax+152]
	movss	xmm0, DWORD PTR __real@bf800000
	add	eax, 152				; 00000098H
	mulss	xmm1, xmm0
	lea	esi, DWORD PTR [edi+364]
	movss	DWORD PTR [esi], xmm1
	movss	xmm1, DWORD PTR [eax+4]
	mulss	xmm1, xmm0
	movss	DWORD PTR [esi+4], xmm1
	movss	xmm1, DWORD PTR [eax+8]
	mulss	xmm1, xmm0
	movss	DWORD PTR [esi+8], xmm1

; 256  : 	R_ASSERT		( _valid(vSunDir) );

	cmp	BYTE PTR ?ignore_always@?M@??OnFrame@CLensFlare@@QAEXVshared_str@@@Z@4_NA, 0
	jne	SHORT $LN53@OnFrame@10
	call	??$_valid@M@@YAHABU?$_vector3@M@@@Z	; _valid<float>
	test	eax, eax
	jne	SHORT $LN53@OnFrame@10
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?M@??OnFrame@CLensFlare@@QAEXVshared_str@@@Z@4_NA
	push	OFFSET ??_C@_0BE@BKKMFBAJ@CLensFlare?3?3OnFrame?$AA@
	push	256					; 00000100H
	push	OFFSET ??_C@_0DI@CJHPJF@D?3?2CLEARSKY?2sources?2engine?2xrEng@
	push	OFFSET ??_C@_0BA@NBGGFCFO@_valid?$CIvSunDir?$CJ?$AA@
	call	ebx
$LN53@OnFrame@10:

; 257  : 
; 258  : 	// color
; 259  :     float tf		= g_pGamePersistent->Environment().fTimeFactor;

	mov	ecx, DWORD PTR ?g_pGamePersistent@@3PAVIGame_Persistent@@A ; g_pGamePersistent
	mov	eax, DWORD PTR [ecx+1128]
	movss	xmm1, DWORD PTR [eax+244]

; 260  :     Fvector& c		= g_pGamePersistent->Environment().CurrentEnv->sun_color;

	mov	eax, DWORD PTR [eax+120]

; 261  : 	LightColor.set	(c.x,c.y,c.z,1.f); 

	fld	DWORD PTR [eax+140]
	movss	xmm0, DWORD PTR [eax+144]
	movss	xmm2, DWORD PTR [eax+148]
	fstp	DWORD PTR [edi+452]

; 262  : 
; 263  : 	CLensFlareDescriptor* desc = id.size() ? g_pGamePersistent->Environment().add_flare(m_Palette, id) : 0;

	mov	ebx, DWORD PTR _id$[ebp]
	movss	xmm3, DWORD PTR __real@3f800000
	add	ecx, 1128				; 00000468H
	add	eax, 140				; 0000008cH
	test	ebx, ebx
	movss	DWORD PTR _tf$[esp+208], xmm1
	movss	DWORD PTR [edi+456], xmm0
	movss	DWORD PTR [edi+460], xmm2
	movss	DWORD PTR [edi+464], xmm3
	je	SHORT $LN63@OnFrame@10
	cmp	DWORD PTR [ebx+4], 0
	je	SHORT $LN63@OnFrame@10
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR _id$[ebp]
	push	eax
	lea	edx, DWORD PTR [edi+476]
	push	edx
	call	?add_flare@CEnvironment@@QAEPAVCLensFlareDescriptor@@AAV?$xr_vector@PAVCLensFlareDescriptor@@V?$xalloc@PAVCLensFlareDescriptor@@@@@@ABVshared_str@@@Z ; CEnvironment::add_flare
	movss	xmm3, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR _tf$[esp+208]
	jmp	SHORT $LN64@OnFrame@10
$LN63@OnFrame@10:
	xor	eax, eax
$LN64@OnFrame@10:

; 264  : 
; 265  : //	LFState			previous_state = m_State;
; 266  :     switch(m_State){

	mov	ecx, DWORD PTR [edi+492]
	xorps	xmm2, xmm2
	mov	edx, 3
	cmp	ecx, edx
	ja	$LN42@OnFrame@10
	jmp	DWORD PTR $LN321@OnFrame@10[ecx*4]
$LN48@OnFrame@10:

; 267  :     case lfsNone: m_State=lfsShow; m_Current=desc; break;

	mov	DWORD PTR [edi+492], edx
	mov	DWORD PTR [edi+488], eax
	jmp	$LN42@OnFrame@10
$LN47@OnFrame@10:

; 268  :     case lfsIdle: if (desc!=m_Current) m_State=lfsHide; 	break;

	cmp	eax, DWORD PTR [edi+488]
	je	$LN42@OnFrame@10
	mov	DWORD PTR [edi+492], 2
	jmp	$LN42@OnFrame@10
$LN45@OnFrame@10:

; 269  :     case lfsShow: 
; 270  :         m_StateBlend 	= m_Current?(m_StateBlend + m_Current->m_StateBlendUpSpeed * Device.fTimeDelta * tf):1.f+EPS;

	mov	eax, DWORD PTR [edi+488]
	test	eax, eax
	je	SHORT $LN65@OnFrame@10
	movss	xmm0, DWORD PTR [eax+68]
	mulss	xmm0, DWORD PTR ?Device@@3VCRenderDevice@@A+28
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR [edi+496]
	jmp	SHORT $LN66@OnFrame@10
$LN65@OnFrame@10:
	movss	xmm0, DWORD PTR __real@3f800054
$LN66@OnFrame@10:

; 271  :         if (m_StateBlend>=1.f) m_State=lfsIdle;

	comiss	xmm0, xmm3
	movss	DWORD PTR [edi+496], xmm0
	jb	SHORT $LN42@OnFrame@10
	mov	DWORD PTR [edi+492], 1

; 272  :     break;

	jmp	SHORT $LN42@OnFrame@10
$LN43@OnFrame@10:

; 273  :     case lfsHide: 
; 274  :         m_StateBlend 	= m_Current?(m_StateBlend - m_Current->m_StateBlendDnSpeed * Device.fTimeDelta * tf):0.f-EPS;

	mov	ecx, DWORD PTR [edi+488]
	test	ecx, ecx
	je	SHORT $LN67@OnFrame@10
	movss	xmm4, DWORD PTR [ecx+72]
	mulss	xmm4, DWORD PTR ?Device@@3VCRenderDevice@@A+28
	movss	xmm0, DWORD PTR [edi+496]
	mulss	xmm4, xmm1
	subss	xmm0, xmm4
	jmp	SHORT $LN68@OnFrame@10
$LN67@OnFrame@10:
	movss	xmm0, DWORD PTR __real@b727c5ac
$LN68@OnFrame@10:

; 275  :         if (m_StateBlend<=0.f){ 	

	comiss	xmm2, xmm0
	movss	DWORD PTR [edi+496], xmm0
	jb	SHORT $LN42@OnFrame@10

; 276  :             m_State		= lfsShow;
; 277  :             m_Current	= desc;
; 278  : 	        m_StateBlend= m_Current?m_Current->m_StateBlendUpSpeed * Device.fTimeDelta * tf:0;

	test	eax, eax
	mov	DWORD PTR [edi+492], edx
	mov	DWORD PTR [edi+488], eax
	je	SHORT $LN69@OnFrame@10
	movss	xmm0, DWORD PTR [eax+68]
	mulss	xmm0, DWORD PTR ?Device@@3VCRenderDevice@@A+28
	mulss	xmm0, xmm1
	jmp	SHORT $LN70@OnFrame@10
$LN69@OnFrame@10:
	movaps	xmm0, xmm2
$LN70@OnFrame@10:
	movss	DWORD PTR [edi+496], xmm0
$LN42@OnFrame@10:

; 279  :         }
; 280  :     break;
; 281  :     }
; 282  : //	Msg				("%6d : [%s] -> [%s]", Device.dwFrame, state_to_string(previous_state), state_to_string(m_State));
; 283  :     clamp(m_StateBlend,0.f,1.f);

	movss	xmm0, DWORD PTR [edi+496]
	comiss	xmm2, xmm0
	jbe	SHORT $LN103@OnFrame@10
	movss	DWORD PTR [edi+496], xmm2
	jmp	SHORT $LN101@OnFrame@10
$LN103@OnFrame@10:
	comiss	xmm0, xmm3
	jbe	SHORT $LN101@OnFrame@10
	movss	DWORD PTR [edi+496], xmm3
$LN101@OnFrame@10:

; 284  : 
; 285  :     if ((m_Current==0)||(LightColor.magnitude_rgb()==0.f)){bRender=false; return;}

	cmp	DWORD PTR [edi+488], 0
	je	$LN40@OnFrame@10
	movss	xmm2, DWORD PTR [edi+452]
	movss	xmm1, DWORD PTR [edi+456]
	movss	xmm0, DWORD PTR [edi+460]
	movaps	xmm3, xmm2
	mulss	xmm3, xmm2
	movaps	xmm2, xmm1
	mulss	xmm2, xmm1
	movaps	xmm1, xmm0
	addss	xmm3, xmm2
	mulss	xmm1, xmm0
	push	ecx
	addss	xmm3, xmm1
	movss	DWORD PTR [esp], xmm3
	call	_sqrtf
	fldz
	fxch	ST(1)
	add	esp, 4
	fucomip	ST(1)
	fstp	ST(0)
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN40@OnFrame@10

; 286  : 
; 287  : 	//
; 288  : 	// Compute center and axis of flares
; 289  : 	//
; 290  : 	float fDot;
; 291  : 
; 292  : 	Fvector vecPos;
; 293  : 
; 294  : 	Fmatrix	matEffCamPos;
; 295  : 	matEffCamPos.identity();
; 296  : 	// Calculate our position and direction
; 297  : 
; 298  : 	matEffCamPos.i.set(Device.vCameraRight);
; 299  : 	matEffCamPos.j.set(Device.vCameraTop);

	movss	xmm3, DWORD PTR ?Device@@3VCRenderDevice@@A+76
	movss	xmm6, DWORD PTR ?Device@@3VCRenderDevice@@A+84
	movss	xmm1, DWORD PTR ?Device@@3VCRenderDevice@@A+88
	movss	xmm2, DWORD PTR ?Device@@3VCRenderDevice@@A+92
	movss	xmm0, DWORD PTR ?Device@@3VCRenderDevice@@A+72

; 300  : 	matEffCamPos.k.set(Device.vCameraDirection);

	movss	xmm7, DWORD PTR ?Device@@3VCRenderDevice@@A+60
	movss	DWORD PTR _matEffCamPos$[esp+228], xmm3
	movss	xmm3, DWORD PTR ?Device@@3VCRenderDevice@@A+80
	movss	DWORD PTR _matEffCamPos$[esp+232], xmm3
	movss	xmm3, DWORD PTR ?Device@@3VCRenderDevice@@A+64
	movss	DWORD PTR _matEffCamPos$[esp+244], xmm3
	movss	xmm3, DWORD PTR ?Device@@3VCRenderDevice@@A+68
	movss	DWORD PTR _matEffCamPos$[esp+248], xmm3

; 301  : 	vecPos.set(Device.vCameraPosition);

	movss	xmm3, DWORD PTR ?Device@@3VCRenderDevice@@A+48
	movss	DWORD PTR _vecPos$[esp+208], xmm3
	movss	xmm3, DWORD PTR ?Device@@3VCRenderDevice@@A+52
	movss	DWORD PTR _vecPos$[esp+212], xmm3
	movss	xmm3, DWORD PTR ?Device@@3VCRenderDevice@@A+56
	movss	DWORD PTR _vecPos$[esp+216], xmm3

; 302  : 
; 303  : 	vecDir.set(0.0f, 0.0f, 1.0f);

	xorps	xmm3, xmm3
	movss	DWORD PTR [edi+412], xmm3
	movss	DWORD PTR [edi+416], xmm3
	movss	xmm3, DWORD PTR __real@3f800000
	movss	DWORD PTR [edi+420], xmm3

; 304  : 	matEffCamPos.transform_dir(vecDir);

	movss	xmm4, DWORD PTR [edi+416]
	movss	xmm5, DWORD PTR [edi+412]
	movss	DWORD PTR _matEffCamPos$[esp+224], xmm0
	mulss	xmm0, xmm4
	movss	DWORD PTR _matEffCamPos$[esp+240], xmm7
	mulss	xmm7, xmm3
	addss	xmm0, xmm7
	movss	DWORD PTR _matEffCamPos$[esp+216], xmm2
	mulss	xmm2, xmm5
	movss	DWORD PTR _matEffCamPos$[esp+212], xmm1
	mulss	xmm1, xmm5
	movss	DWORD PTR _matEffCamPos$[esp+208], xmm6
	movaps	xmm7, xmm5
	movss	xmm5, DWORD PTR _matEffCamPos$[esp+232]
	mulss	xmm7, xmm6
	movss	xmm6, DWORD PTR _matEffCamPos$[esp+228]
	mulss	xmm6, xmm4
	addss	xmm1, xmm6
	movss	xmm6, DWORD PTR _matEffCamPos$[esp+244]
	mulss	xmm6, xmm3
	addss	xmm1, xmm6
	mulss	xmm5, xmm4
	movss	xmm4, DWORD PTR _matEffCamPos$[esp+248]
	mulss	xmm4, xmm3
	addss	xmm0, xmm7
	addss	xmm2, xmm5
	addss	xmm2, xmm4
	movss	DWORD PTR [edi+412], xmm0

; 305  : 	vecDir.normalize();

	movaps	xmm0, xmm2
	movss	DWORD PTR [edi+416], xmm1
	movss	DWORD PTR [edi+420], xmm2
	movss	xmm2, DWORD PTR [edi+412]
	movaps	xmm3, xmm2
	mulss	xmm3, xmm2
	movss	DWORD PTR tv1345[esp+208], xmm2
	movaps	xmm2, xmm1
	mulss	xmm2, xmm1
	movss	DWORD PTR tv1341[esp+208], xmm1
	movaps	xmm1, xmm0
	mulss	xmm1, xmm0
	movss	DWORD PTR tv1337[esp+208], xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	addss	xmm3, xmm2
	addss	xmm3, xmm1
	push	ecx
	divss	xmm0, xmm3
	movss	DWORD PTR [esp], xmm0
	call	_sqrtf
	fstp	DWORD PTR _mag$544739[esp+212]
	movss	xmm0, DWORD PTR _mag$544739[esp+212]
	movaps	xmm1, xmm0
	mulss	xmm1, DWORD PTR tv1345[esp+212]
	movss	DWORD PTR [edi+412], xmm1
	movaps	xmm1, xmm0
	mulss	xmm1, DWORD PTR tv1341[esp+212]
	mulss	xmm0, DWORD PTR tv1337[esp+212]
	movss	DWORD PTR [edi+416], xmm1
	movss	DWORD PTR [edi+420], xmm0

; 306  : 
; 307  : 	// Figure out of light (or flare) might be visible
; 308  : 	vecLight.set(vSunDir);

	fld	DWORD PTR [esi]
	fstp	DWORD PTR [edi+376]
	fld	DWORD PTR [esi+4]
	fstp	DWORD PTR [edi+380]
	fld	DWORD PTR [esi+8]
	fstp	DWORD PTR [edi+384]

; 309  : 	vecLight.normalize();

	movss	xmm2, DWORD PTR [edi+376]
	movss	xmm1, DWORD PTR [edi+380]
	movss	xmm0, DWORD PTR [edi+384]
	movaps	xmm3, xmm2
	mulss	xmm3, xmm2
	movss	DWORD PTR tv1378[esp+212], xmm2
	movaps	xmm2, xmm1
	mulss	xmm2, xmm1
	movss	DWORD PTR tv1374[esp+212], xmm1
	movaps	xmm1, xmm0
	mulss	xmm1, xmm0
	movss	DWORD PTR tv1370[esp+212], xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	addss	xmm3, xmm2
	addss	xmm3, xmm1
	divss	xmm0, xmm3
	movss	DWORD PTR [esp], xmm0
	call	_sqrtf
	fstp	DWORD PTR _mag$544758[esp+212]
	movss	xmm1, DWORD PTR _mag$544758[esp+212]
	movss	xmm0, DWORD PTR tv1378[esp+212]
	mulss	xmm0, xmm1
	movss	DWORD PTR [edi+376], xmm0
	movss	xmm0, DWORD PTR tv1374[esp+212]
	mulss	xmm0, xmm1
	movss	DWORD PTR [edi+380], xmm0
	movss	xmm0, DWORD PTR tv1370[esp+212]
	mulss	xmm0, xmm1
	movss	DWORD PTR [edi+384], xmm0

; 310  : 
; 311  : 	fDot = vecLight.dotproduct(vecDir);

	movss	xmm1, DWORD PTR [edi+420]
	mulss	xmm1, xmm0
	movss	xmm0, DWORD PTR [edi+416]
	mulss	xmm0, DWORD PTR [edi+380]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [edi+412]
	mulss	xmm0, DWORD PTR [edi+376]
	addss	xmm1, xmm0

; 312  : 
; 313  : 	if(fDot <= 0.01f){	bRender = false; return;} else bRender = true;

	movss	xmm0, DWORD PTR __real@3c23d70a
	add	esp, 4
	comiss	xmm0, xmm1
	jb	SHORT $LN39@OnFrame@10
	lea	ecx, DWORD PTR _id$[ebp]
	mov	DWORD PTR [edi+448], 0
	call	??1shared_str@@QAE@XZ			; shared_str::~shared_str

; 459  : 	}
; 460  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN39@OnFrame@10:

; 312  : 
; 313  : 	if(fDot <= 0.01f){	bRender = false; return;} else bRender = true;

	mov	DWORD PTR [edi+448], 1

; 314  : 
; 315  : 	// Calculate the point directly in front of us, on the far clip plane
; 316  : 	float 	fDistance	= FAR_DIST*0.75f;

	mov	eax, DWORD PTR ?g_pGamePersistent@@3PAVIGame_Persistent@@A ; g_pGamePersistent

; 317  : 	vecCenter.mul(vecDir, fDistance);

	movss	xmm2, DWORD PTR [edi+412]
	mov	ecx, DWORD PTR [eax+1128]
	mov	edx, DWORD PTR [ecx+120]
	movss	xmm0, DWORD PTR [edx+56]
	mulss	xmm0, DWORD PTR __real@3f400000
	mulss	xmm2, xmm0
	movss	DWORD PTR [edi+436], xmm2
	movss	xmm2, DWORD PTR [edi+416]
	mulss	xmm2, xmm0
	movss	DWORD PTR [edi+440], xmm2
	movss	xmm2, DWORD PTR [edi+420]
	mulss	xmm2, xmm0
	movss	DWORD PTR [edi+444], xmm2

; 318  : 	vecCenter.add(vecPos);

	movss	xmm4, DWORD PTR [edi+440]
	movss	xmm5, DWORD PTR [edi+444]
	movss	xmm2, DWORD PTR _vecPos$[esp+208]

; 319  : 	// Calculate position of light on the far clip plane
; 320  : 	vecLight.mul(fDistance / fDot);

	divss	xmm0, xmm1
	movaps	xmm1, xmm0
	movaps	xmm3, xmm2
	addss	xmm3, DWORD PTR [edi+436]
	movss	DWORD PTR [edi+436], xmm3
	movss	xmm3, DWORD PTR _vecPos$[esp+212]
	addss	xmm4, xmm3
	movss	DWORD PTR [edi+440], xmm4
	movss	xmm4, DWORD PTR _vecPos$[esp+216]
	addss	xmm5, xmm4
	movss	DWORD PTR [edi+444], xmm5
	mulss	xmm1, DWORD PTR [edi+376]
	movss	DWORD PTR [edi+376], xmm1
	movaps	xmm1, xmm0
	mulss	xmm0, DWORD PTR [edi+384]
	mulss	xmm1, DWORD PTR [edi+380]
	movss	DWORD PTR [edi+384], xmm0
	movss	DWORD PTR [edi+380], xmm1

; 321  : 	vecLight.add(vecPos);

	movss	xmm0, DWORD PTR [edi+376]

; 322  : 	// Compute axis which goes from light through the center of the screen
; 323  : 	vecAxis.sub(vecLight, vecCenter);
; 324  : 
; 325  : 	//
; 326  : 	// Figure out if light is behind something else
; 327  : 	vecX.set(1.0f, 0.0f, 0.0f);

	movss	xmm5, DWORD PTR __real@3f800000
	addss	xmm0, xmm2
	movss	DWORD PTR [edi+376], xmm0
	movss	xmm0, DWORD PTR [edi+380]
	addss	xmm0, xmm3
	movss	DWORD PTR [edi+380], xmm0
	movss	xmm0, DWORD PTR [edi+384]
	addss	xmm0, xmm4
	movss	DWORD PTR [edi+384], xmm0
	movss	xmm0, DWORD PTR [edi+376]
	subss	xmm0, DWORD PTR [edi+436]
	movss	DWORD PTR [edi+424], xmm0
	movss	xmm0, DWORD PTR [edi+380]
	subss	xmm0, DWORD PTR [edi+440]
	movss	DWORD PTR [edi+428], xmm0
	movss	xmm0, DWORD PTR [edi+384]
	subss	xmm0, DWORD PTR [edi+444]
	movss	DWORD PTR [edi+432], xmm0
	xorps	xmm0, xmm0

; 328  : 	matEffCamPos.transform_dir(vecX);

	movaps	xmm1, xmm0
	movaps	xmm2, xmm5
	movaps	xmm4, xmm0
	mulss	xmm4, DWORD PTR _matEffCamPos$[esp+240]
	movaps	xmm3, xmm2
	mulss	xmm3, DWORD PTR _matEffCamPos$[esp+208]
	addss	xmm3, xmm4
	movaps	xmm4, xmm1
	mulss	xmm4, DWORD PTR _matEffCamPos$[esp+224]
	addss	xmm3, xmm4
	movaps	xmm4, xmm0
	mulss	xmm4, DWORD PTR _matEffCamPos$[esp+244]
	lea	ebx, DWORD PTR [edi+388]
	movaps	xmm6, xmm1
	mulss	xmm6, DWORD PTR _matEffCamPos$[esp+228]
	mulss	xmm1, DWORD PTR _matEffCamPos$[esp+232]
	addss	xmm4, xmm6
	movss	DWORD PTR [ebx+4], xmm0
	movss	DWORD PTR [ebx+8], xmm0
	mulss	xmm0, DWORD PTR _matEffCamPos$[esp+248]
	movaps	xmm6, xmm2
	mulss	xmm6, DWORD PTR _matEffCamPos$[esp+212]
	movss	DWORD PTR [ebx], xmm5
	addss	xmm4, xmm6
	addss	xmm0, xmm1
	mulss	xmm2, DWORD PTR _matEffCamPos$[esp+216]
	addss	xmm0, xmm2

; 329  : 	vecX.normalize();

	movaps	xmm2, xmm3
	movss	DWORD PTR [ebx], xmm3
	movaps	xmm1, xmm4
	mulss	xmm3, xmm2
	movss	DWORD PTR tv1531[esp+208], xmm2
	movaps	xmm2, xmm1
	mulss	xmm2, xmm1
	movss	DWORD PTR tv1527[esp+208], xmm1
	movaps	xmm1, xmm0
	addss	xmm3, xmm2
	mulss	xmm1, xmm0
	addss	xmm3, xmm1
	push	ecx
	divss	xmm5, xmm3
	movss	DWORD PTR [ebx+4], xmm4
	movss	DWORD PTR [ebx+8], xmm0
	movss	DWORD PTR tv1523[esp+212], xmm0
	movss	DWORD PTR [esp], xmm5
	call	_sqrtf
	fstp	DWORD PTR _mag$544827[esp+212]
	movss	xmm0, DWORD PTR _mag$544827[esp+212]
	movss	xmm1, DWORD PTR tv1531[esp+212]
	mulss	xmm1, xmm0
	movss	DWORD PTR [ebx], xmm1
	movss	xmm1, DWORD PTR tv1527[esp+212]
	mulss	xmm1, xmm0
	movss	DWORD PTR [ebx+4], xmm1
	movss	xmm1, DWORD PTR tv1523[esp+212]
	mulss	xmm1, xmm0
	add	esp, 4
	movss	DWORD PTR [ebx+8], xmm1

; 330  : 	R_ASSERT( _valid(vecX) );

	cmp	BYTE PTR ?ignore_always@?CA@??OnFrame@CLensFlare@@QAEXVshared_str@@@Z@4_NA, 0
	jne	SHORT $LN36@OnFrame@10
	mov	esi, ebx
	call	??$_valid@M@@YAHABU?$_vector3@M@@@Z	; _valid<float>
	test	eax, eax
	jne	SHORT $LN36@OnFrame@10
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?CA@??OnFrame@CLensFlare@@QAEXVshared_str@@@Z@4_NA
	push	OFFSET ??_C@_0BE@BKKMFBAJ@CLensFlare?3?3OnFrame?$AA@
	push	330					; 0000014aH
	push	OFFSET ??_C@_0DI@CJHPJF@D?3?2CLEARSKY?2sources?2engine?2xrEng@
	push	OFFSET ??_C@_0N@JEGHJCIB@_valid?$CIvecX?$CJ?$AA@
	call	DWORD PTR __imp_?fail@xrDebug@@QAEXPBD0H0AA_N@Z
$LN36@OnFrame@10:

; 331  : 
; 332  : 	vecY.crossproduct(vecX, vecDir);

	movss	xmm0, DWORD PTR [ebx+4]
	mulss	xmm0, DWORD PTR [edi+420]
	movss	xmm1, DWORD PTR [edi+416]
	mulss	xmm1, DWORD PTR [ebx+8]
	subss	xmm0, xmm1
	movss	DWORD PTR [edi+400], xmm0
	movss	xmm0, DWORD PTR [ebx+8]
	mulss	xmm0, DWORD PTR [edi+412]
	movss	xmm1, DWORD PTR [edi+420]
	mulss	xmm1, DWORD PTR [ebx]
	lea	esi, DWORD PTR [edi+400]
	subss	xmm0, xmm1
	movss	DWORD PTR [esi+4], xmm0
	movss	xmm0, DWORD PTR [edi+416]
	movss	xmm1, DWORD PTR [ebx+4]
	mulss	xmm0, DWORD PTR [ebx]
	mulss	xmm1, DWORD PTR [edi+412]
	subss	xmm0, xmm1
	movss	DWORD PTR [esi+8], xmm0

; 333  : 	R_ASSERT( _valid(vecY) );

	cmp	BYTE PTR ?ignore_always@?CE@??OnFrame@CLensFlare@@QAEXVshared_str@@@Z@4_NA, 0
	jne	SHORT $LN32@OnFrame@10
	call	??$_valid@M@@YAHABU?$_vector3@M@@@Z	; _valid<float>
	test	eax, eax
	jne	SHORT $LN32@OnFrame@10
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?CE@??OnFrame@CLensFlare@@QAEXVshared_str@@@Z@4_NA
	push	OFFSET ??_C@_0BE@BKKMFBAJ@CLensFlare?3?3OnFrame?$AA@
	push	333					; 0000014dH
	push	OFFSET ??_C@_0DI@CJHPJF@D?3?2CLEARSKY?2sources?2engine?2xrEng@
	push	OFFSET ??_C@_0N@JFKFPILG@_valid?$CIvecY?$CJ?$AA@
	call	DWORD PTR __imp_?fail@xrDebug@@QAEXPBD0H0AA_N@Z
$LN32@OnFrame@10:

; 334  : 
; 335  : #ifdef _EDITOR
; 336  : 	float dist = UI->ZFar();
; 337  :     if (Tools->RayPick(Device.m_Camera.GetPosition(),vSunDir,dist))
; 338  : 		fBlend = fBlend - BLEND_DEC_SPEED * Device.fTimeDelta;
; 339  : 	else
; 340  : 		fBlend = fBlend + BLEND_INC_SPEED * Device.fTimeDelta;
; 341  : #else
; 342  : 
; 343  : 	//	Side vectors to bend normal.
; 344  : 	Fvector vecSx;
; 345  : 	Fvector vecSy;
; 346  : 
; 347  : 	//float fScale = m_Current->m_Source.fRadius * vSunDir.magnitude();
; 348  : 	//float fScale = m_Current->m_Source.fRadius;
; 349  : 	//	HACK: it must be read from the weather!
; 350  : 	float fScale = 0.02f;
; 351  : 
; 352  : 	vecSx.mul(vecX, fScale);
; 353  : 	vecSy.mul(vecY, fScale);
; 354  : 
; 355  : 	CObject*	o_main		= g_pGameLevel->CurrentViewEntity();
; 356  : 	R_ASSERT				( _valid(vSunDir) );

	cmp	BYTE PTR ?ignore_always@?CI@??OnFrame@CLensFlare@@QAEXVshared_str@@@Z@4_NA, 0
	movss	xmm0, DWORD PTR __real@3ca3d70a
	movss	xmm1, DWORD PTR [ebx]
	mov	eax, DWORD PTR ?g_pGameLevel@@3PAVIGame_Level@@A ; g_pGameLevel
	mov	ecx, DWORD PTR [eax+36]
	mulss	xmm1, xmm0
	movss	DWORD PTR _vecSx$[esp+208], xmm1
	movss	xmm1, DWORD PTR [ebx+4]
	mulss	xmm1, xmm0
	movss	DWORD PTR _vecSx$[esp+212], xmm1
	movss	xmm1, DWORD PTR [ebx+8]
	mulss	xmm1, xmm0
	movss	DWORD PTR _vecSx$[esp+216], xmm1
	movss	xmm1, DWORD PTR [esi]
	mulss	xmm1, xmm0
	movss	DWORD PTR _vecSy$[esp+208], xmm1
	movss	xmm1, DWORD PTR [esi+4]
	mulss	xmm1, xmm0
	movss	DWORD PTR _vecSy$[esp+212], xmm1
	movss	xmm1, DWORD PTR [esi+8]
	mulss	xmm1, xmm0
	movss	DWORD PTR _vecSy$[esp+216], xmm1
	mov	DWORD PTR _o_main$[esp+208], ecx
	jne	SHORT $LN28@OnFrame@10
	lea	esi, DWORD PTR [edi+364]
	call	??$_valid@M@@YAHABU?$_vector3@M@@@Z	; _valid<float>
	test	eax, eax
	jne	SHORT $LN28@OnFrame@10
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?CI@??OnFrame@CLensFlare@@QAEXVshared_str@@@Z@4_NA
	push	OFFSET ??_C@_0BE@BKKMFBAJ@CLensFlare?3?3OnFrame?$AA@
	push	356					; 00000164H
	push	OFFSET ??_C@_0DI@CJHPJF@D?3?2CLEARSKY?2sources?2engine?2xrEng@
	push	OFFSET ??_C@_0BA@NBGGFCFO@_valid?$CIvSunDir?$CJ?$AA@
	call	DWORD PTR __imp_?fail@xrDebug@@QAEXPBD0H0AA_N@Z
$LN28@OnFrame@10:

; 357  : 	STranspParam TP			(&m_ray_cache[0],Device.vCameraPosition,vSunDir,1000.f,EPS_L);
; 358  : 
; 359  : 	R_ASSERT				( _valid(TP.P) );

	cmp	BYTE PTR ?ignore_always@?CM@??OnFrame@CLensFlare@@QAEXVshared_str@@@Z@4_NA, 0
	mov	edx, DWORD PTR ?Device@@3VCRenderDevice@@A+48
	mov	eax, DWORD PTR ?Device@@3VCRenderDevice@@A+52
	mov	ecx, DWORD PTR ?Device@@3VCRenderDevice@@A+56
	movss	xmm0, DWORD PTR _fuzzy_update_novis
	movss	DWORD PTR _TP$[esp+232], xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	mov	DWORD PTR _TP$[esp+208], edx
	mov	edx, DWORD PTR [edi+364]
	mov	DWORD PTR _TP$[esp+212], eax
	mov	eax, DWORD PTR [edi+368]
	mov	DWORD PTR _TP$[esp+216], ecx
	mov	ecx, DWORD PTR [edi+372]
	lea	ebx, DWORD PTR [edi+16]
	movss	DWORD PTR _TP$[esp+240], xmm0
	movss	xmm0, DWORD PTR _EPS_L
	mov	DWORD PTR _TP$[esp+220], edx
	mov	DWORD PTR _TP$[esp+224], eax
	mov	DWORD PTR _TP$[esp+228], ecx
	mov	DWORD PTR _TP$[esp+236], ebx
	movss	DWORD PTR _TP$[esp+244], xmm0
	jne	SHORT $LN24@OnFrame@10
	lea	esi, DWORD PTR _TP$[esp+208]
	call	??$_valid@M@@YAHABU?$_vector3@M@@@Z	; _valid<float>
	test	eax, eax
	jne	SHORT $LN24@OnFrame@10
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?CM@??OnFrame@CLensFlare@@QAEXVshared_str@@@Z@4_NA
	push	OFFSET ??_C@_0BE@BKKMFBAJ@CLensFlare?3?3OnFrame?$AA@
	push	359					; 00000167H
	push	OFFSET ??_C@_0DI@CJHPJF@D?3?2CLEARSKY?2sources?2engine?2xrEng@
	push	OFFSET ??_C@_0N@NAKPNABC@_valid?$CITP?4P?$CJ?$AA@
	call	DWORD PTR __imp_?fail@xrDebug@@QAEXPBD0H0AA_N@Z
$LN24@OnFrame@10:

; 360  : 	R_ASSERT				( _valid(TP.D) );

	cmp	BYTE PTR ?ignore_always@?DA@??OnFrame@CLensFlare@@QAEXVshared_str@@@Z@4_NA, 0
	jne	SHORT $LN20@OnFrame@10
	lea	esi, DWORD PTR _TP$[esp+220]
	call	??$_valid@M@@YAHABU?$_vector3@M@@@Z	; _valid<float>
	test	eax, eax
	jne	SHORT $LN20@OnFrame@10
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?DA@??OnFrame@CLensFlare@@QAEXVshared_str@@@Z@4_NA
	push	OFFSET ??_C@_0BE@BKKMFBAJ@CLensFlare?3?3OnFrame?$AA@
	push	360					; 00000168H
	push	OFFSET ??_C@_0DI@CJHPJF@D?3?2CLEARSKY?2sources?2engine?2xrEng@
	push	OFFSET ??_C@_0N@MLIANLLO@_valid?$CITP?4D?$CJ?$AA@
	call	DWORD PTR __imp_?fail@xrDebug@@QAEXPBD0H0AA_N@Z
$LN20@OnFrame@10:

; 361  : 	collide::ray_defs RD	(TP.P,TP.D,TP.f,CDB::OPT_CULL,collide::rqtBoth);

	movss	xmm0, DWORD PTR _TP$[esp+232]
	push	3
	lea	ecx, DWORD PTR _TP$[esp+224]
	lea	edx, DWORD PTR _TP$[esp+212]
	lea	eax, DWORD PTR _RD$[esp+212]
	call	??0ray_defs@collide@@QAE@ABU?$_vector3@M@@0MIW4rq_target@1@@Z ; collide::ray_defs::ray_defs

; 362  : 	float	fVisResult = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _fVisResult$[esp+208], xmm0
	mov	DWORD PTR tv2183[esp+208], OFFSET _RayDeltas+4
	mov	DWORD PTR tv2213[esp+208], ebx
$LL17@OnFrame@10:

; 365  : 	{
; 366  : 		TP.D = vSunDir;
; 367  : 		TP.D.add(Fvector().mul( vecSx, RayDeltas[i].x));
; 368  : 		TP.D.add(Fvector().mul( vecSy, RayDeltas[i].y));
; 369  : 		R_ASSERT		( _valid(TP.D) );

	cmp	BYTE PTR ?ignore_always@?DG@??OnFrame@CLensFlare@@QAEXVshared_str@@@Z@4_NA, 0
	mov	eax, DWORD PTR [edi+368]
	mov	ecx, DWORD PTR [edi+372]
	movss	xmm2, DWORD PTR _vecSx$[esp+212]
	movss	xmm3, DWORD PTR _vecSx$[esp+216]
	mov	edx, DWORD PTR [edi+364]
	mov	DWORD PTR _TP$[esp+224], eax
	mov	eax, DWORD PTR tv2183[esp+208]
	movss	xmm1, DWORD PTR [eax-4]
	movss	xmm4, DWORD PTR _TP$[esp+224]
	movss	xmm6, DWORD PTR [eax]
	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
	mov	DWORD PTR _TP$[esp+228], ecx
	movss	xmm5, DWORD PTR _TP$[esp+228]
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR _vecSx$[esp+208]
	addss	xmm4, xmm2
	movss	xmm2, DWORD PTR _vecSy$[esp+212]
	addss	xmm5, xmm3
	movss	xmm3, DWORD PTR _vecSy$[esp+216]
	mov	DWORD PTR _TP$[esp+220], edx
	addss	xmm0, DWORD PTR _TP$[esp+220]
	movaps	xmm1, xmm6
	mulss	xmm1, DWORD PTR _vecSy$[esp+208]
	mulss	xmm2, xmm6
	mulss	xmm3, xmm6
	addss	xmm1, xmm0
	addss	xmm2, xmm4
	addss	xmm3, xmm5
	movss	DWORD PTR _TP$[esp+220], xmm1
	movss	DWORD PTR _TP$[esp+224], xmm2
	movss	DWORD PTR _TP$[esp+228], xmm3
	jne	SHORT $LN13@OnFrame@10
	lea	esi, DWORD PTR _TP$[esp+220]
	call	??$_valid@M@@YAHABU?$_vector3@M@@@Z	; _valid<float>
	test	eax, eax
	jne	SHORT $LN13@OnFrame@10
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?DG@??OnFrame@CLensFlare@@QAEXVshared_str@@@Z@4_NA
	push	OFFSET ??_C@_0BE@BKKMFBAJ@CLensFlare?3?3OnFrame?$AA@
	push	369					; 00000171H
	push	OFFSET ??_C@_0DI@CJHPJF@D?3?2CLEARSKY?2sources?2engine?2xrEng@
	push	OFFSET ??_C@_0N@MLIANLLO@_valid?$CITP?4D?$CJ?$AA@
	call	DWORD PTR __imp_?fail@xrDebug@@QAEXPBD0H0AA_N@Z
$LN13@OnFrame@10:

; 370  : 		TP.pray_cache	= &(m_ray_cache[i]);
; 371  : 		TP.vis			= 1.0f;
; 372  : 		RD.dir			= TP.D;
; 373  : 
; 374  : 		if (m_ray_cache[i].result&&m_ray_cache[i].similar(TP.P,TP.D,TP.f)){

	cmp	DWORD PTR [ebx+28], 0
	mov	edx, DWORD PTR _TP$[esp+220]
	mov	eax, DWORD PTR _TP$[esp+224]
	mov	ecx, DWORD PTR _TP$[esp+228]
	movss	xmm0, DWORD PTR __real@3f800000
	mov	DWORD PTR _TP$[esp+236], ebx
	movss	DWORD PTR _TP$[esp+240], xmm0
	mov	DWORD PTR _RD$[esp+220], edx
	mov	DWORD PTR _RD$[esp+224], eax
	mov	DWORD PTR _RD$[esp+228], ecx
	je	$LN10@OnFrame@10
	movss	xmm0, DWORD PTR _TP$[esp+208]
	subss	xmm0, DWORD PTR [ebx]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_fabsf
	fld	DWORD PTR _EPS_L
	add	esp, 4
	fcomip	ST(1)
	fstp	ST(0)
	jbe	SHORT $LN10@OnFrame@10
	movss	xmm0, DWORD PTR _TP$[esp+212]
	subss	xmm0, DWORD PTR [ebx+4]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_fabsf
	fld	DWORD PTR _EPS_L
	add	esp, 4
	fcomip	ST(1)
	fstp	ST(0)
	jbe	SHORT $LN10@OnFrame@10
	movss	xmm0, DWORD PTR _TP$[esp+216]
	subss	xmm0, DWORD PTR [ebx+8]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_fabsf
	fld	DWORD PTR _EPS_L
	add	esp, 4
	fcomip	ST(1)
	fstp	ST(0)
	jbe	SHORT $LN10@OnFrame@10
	fld	DWORD PTR _TP$[esp+232]
	push	ecx
	lea	eax, DWORD PTR _TP$[esp+224]
	fstp	DWORD PTR [esp]
	mov	esi, ebx
	call	?similar@ray_cache@collide@@QAEHABU?$_vector3@M@@0M@Z ; collide::ray_cache::similar
	test	eax, eax
	je	SHORT $LN10@OnFrame@10

; 375  : 			// similar with previous query == 0
; 376  : 			TP.vis				= 0.f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _TP$[esp+240], xmm0

; 377  : 		}else{

	jmp	$LN6@OnFrame@10
$LN10@OnFrame@10:

; 378  : 			float _u,_v,_range;
; 379  : 			if (CDB::TestRayTri(TP.P,TP.D,m_ray_cache[i].verts,_u,_v,_range,false)&&(_range>0 && _range<TP.f)){

	lea	edx, DWORD PTR __range$133248[esp+208]
	push	edx
	lea	eax, DWORD PTR __v$133247[esp+212]
	push	eax
	lea	ecx, DWORD PTR __u$133246[esp+216]
	push	ecx
	lea	eax, DWORD PTR [ebx+32]
	lea	ecx, DWORD PTR _TP$[esp+232]
	lea	edx, DWORD PTR _TP$[esp+220]
	call	?TestRayTri@CDB@@YA_NABU?$_vector3@M@@0PAU2@AAM22_N@Z ; CDB::TestRayTri
	add	esp, 12					; 0000000cH
	test	al, al
	je	SHORT $LN8@OnFrame@10
	movss	xmm1, DWORD PTR __range$133248[esp+208]
	xorps	xmm0, xmm0
	comiss	xmm1, xmm0
	jbe	SHORT $LN8@OnFrame@10
	movss	xmm2, DWORD PTR _TP$[esp+232]
	comiss	xmm2, xmm1
	jbe	SHORT $LN8@OnFrame@10

; 380  : 				TP.vis			= 0.f;

	movss	DWORD PTR _TP$[esp+240], xmm0

; 381  : 			}else{

	jmp	SHORT $LN6@OnFrame@10
$LN8@OnFrame@10:

; 382  : 				// cache outdated. real query.
; 383  : 				r_dest.r_clear	();

	mov	ecx, DWORD PTR [edi+8]
	mov	eax, DWORD PTR [edi+4]
	cmp	eax, ecx
	lea	esi, DWORD PTR [edi+4]
	je	SHORT $LN255@OnFrame@10
	mov	ebx, ecx
	sub	ebx, ecx
	je	SHORT $LN263@OnFrame@10
	push	ebx
	push	ecx
	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	add	eax, ebx
$LN263@OnFrame@10:
	mov	ebx, DWORD PTR tv2213[esp+208]
	mov	DWORD PTR [esi+4], eax
$LN255@OnFrame@10:

; 384  : 				if (g_pGameLevel->ObjectSpace.RayQuery	(r_dest,RD,material_callback,&TP,NULL,o_main))

	mov	edx, DWORD PTR _o_main$[esp+208]
	push	edx
	push	0
	lea	eax, DWORD PTR _TP$[esp+216]
	push	eax
	push	OFFSET ?material_callback@@YAHAAUrq_result@collide@@PAX@Z ; material_callback
	lea	ecx, DWORD PTR _RD$[esp+224]
	push	ecx
	mov	ecx, DWORD PTR ?g_pGameLevel@@3PAVIGame_Level@@A ; g_pGameLevel
	push	esi
	add	ecx, 262292				; 00040094H
	call	DWORD PTR __imp_?RayQuery@CObjectSpace@@QAEHAAVrq_results@collide@@ABUray_defs@3@P6AHAAUrq_result@3@PAX@Z3P6AH1PAVCObject@@3@Z5@Z
	test	eax, eax

; 385  : 					m_ray_cache[i].result = FALSE			;

	movss	xmm0, DWORD PTR _TP$[esp+240]
	je	SHORT $LN6@OnFrame@10
	mov	DWORD PTR [ebx+28], 0
$LN6@OnFrame@10:

; 363  : 
; 364  : 	for ( int i=0; i<MAX_RAYS; ++i)

	mov	eax, DWORD PTR tv2183[esp+208]

; 386  : 			}
; 387  : 		}
; 388  : 
; 389  : 		fVisResult += TP.vis;

	addss	xmm0, DWORD PTR _fVisResult$[esp+208]
	add	eax, 8
	add	ebx, 68					; 00000044H
	cmp	eax, OFFSET _RayDeltas+44
	movss	DWORD PTR _fVisResult$[esp+208], xmm0
	mov	DWORD PTR tv2183[esp+208], eax
	mov	DWORD PTR tv2213[esp+208], ebx
	jl	$LL17@OnFrame@10

; 390  : 	}
; 391  : 
; 392  : 	fVisResult *= (1.0f/MAX_RAYS);
; 393  : 
; 394  : 	//blend_lerp(fBlend,TP.vis,BLEND_DEC_SPEED,Device.fTimeDelta);
; 395  : 	blend_lerp(fBlend,fVisResult,BLEND_DEC_SPEED,Device.fTimeDelta);

	fld	DWORD PTR ?Device@@3VCRenderDevice@@A+28
	mulss	xmm0, DWORD PTR __real@3e4ccccd
	push	ecx
	lea	esi, DWORD PTR [edi+356]
	fstp	DWORD PTR [esp]
	call	?blend_lerp@@YAXAAMMMM@Z		; blend_lerp

; 396  : 
; 397  : 	/*
; 398  : 	CObject*	o_main		= g_pGameLevel->CurrentViewEntity();
; 399  : 	STranspParam TP			(&m_ray_cache,Device.vCameraPosition,vSunDir,1000.f,EPS_L);
; 400  : 	collide::ray_defs RD	(TP.P,TP.D,TP.f,CDB::OPT_CULL,collide::rqtBoth);
; 401  : 	if (m_ray_cache.result&&m_ray_cache.similar(TP.P,TP.D,TP.f)){
; 402  : 		// similar with previous query == 0
; 403  : 		TP.vis				= 0.f;
; 404  : 	}else{
; 405  : 		float _u,_v,_range;
; 406  : 		if (CDB::TestRayTri(TP.P,TP.D,m_ray_cache.verts,_u,_v,_range,false)&&(_range>0 && _range<TP.f)){
; 407  : 			TP.vis			= 0.f;
; 408  : 		}else{
; 409  : 			// cache outdated. real query.
; 410  : 			r_dest.r_clear	();
; 411  : 			if (g_pGameLevel->ObjectSpace.RayQuery	(r_dest,RD,material_callback,&TP,NULL,o_main))
; 412  : 				m_ray_cache.result = FALSE			;
; 413  : 		}
; 414  : 	}
; 415  : 
; 416  : 	blend_lerp(fBlend,TP.vis,BLEND_DEC_SPEED,Device.fTimeDelta);
; 417  : 	*/
; 418  : /*
; 419  : 	CObject*	o_main		= g_pGameLevel->CurrentViewEntity();
; 420  : 	STranspParam TP			(this,Device.vCameraPosition,vSunDir,1000.f,EPS_L);
; 421  : 	collide::ray_defs RD	(TP.P,TP.D,TP.f,CDB::OPT_CULL,collide::rqtBoth);
; 422  : 	if (m_ray_cache.result&&m_ray_cache.similar(TP.P,TP.D,TP.f)){
; 423  : 		// similar with previous query == 0
; 424  : 		TP.vis				= 0.f;
; 425  : 	}else{
; 426  : 		float _u,_v,_range;
; 427  : 		if (CDB::TestRayTri(TP.P,TP.D,m_ray_cache.verts,_u,_v,_range,false)&&(_range>0 && _range<TP.f)){
; 428  : 			TP.vis			= 0.f;
; 429  : 		}else{
; 430  : 			// cache outdated. real query.
; 431  : 			r_dest.r_clear	();
; 432  : 			if (g_pGameLevel->ObjectSpace.RayQuery	(r_dest,RD,material_callback,&TP,NULL,o_main))
; 433  : 				m_ray_cache.result = FALSE			;
; 434  : 		}
; 435  : 	}
; 436  : 	blend_lerp(fBlend,TP.vis,BLEND_DEC_SPEED,Device.fTimeDelta);
; 437  : */
; 438  : #endif
; 439  : 	clamp( fBlend, 0.0f, 1.0f );

	movss	xmm0, DWORD PTR [esi]
	xorps	xmm1, xmm1
	movss	xmm4, DWORD PTR __real@3f800000
	add	esp, 4
	comiss	xmm1, xmm0
	jbe	SHORT $LN269@OnFrame@10
	movss	DWORD PTR [esi], xmm1
	jmp	SHORT $LN267@OnFrame@10
$LN269@OnFrame@10:
	comiss	xmm0, xmm4
	jbe	SHORT $LN267@OnFrame@10
	movss	DWORD PTR [esi], xmm4
$LN267@OnFrame@10:

; 440  : 
; 441  : 	// gradient
; 442  : 	if (m_Current->m_Flags.is(CLensFlareDescriptor::flGradient))

	mov	ebx, DWORD PTR [edi+488]
	mov	edx, DWORD PTR [ebx+12]
	and	edx, 4
	cmp	dl, 4
	jne	$LN1@OnFrame@10

; 443  :     {
; 444  : 		Fvector				scr_pos;
; 445  : 		Device.mFullTransform.transform	( scr_pos, vecLight );

	movss	xmm2, DWORD PTR [edi+380]
	movss	xmm0, DWORD PTR [edi+376]
	movss	xmm1, DWORD PTR [edi+384]
	movaps	xmm5, xmm0
	mulss	xmm5, DWORD PTR ?Device@@3VCRenderDevice@@A+236
	movaps	xmm3, xmm2
	mulss	xmm3, DWORD PTR ?Device@@3VCRenderDevice@@A+252
	addss	xmm5, xmm3
	movaps	xmm3, xmm1
	mulss	xmm3, DWORD PTR ?Device@@3VCRenderDevice@@A+268
	addss	xmm5, xmm3
	addss	xmm5, DWORD PTR ?Device@@3VCRenderDevice@@A+284
	movaps	xmm3, xmm4
	divss	xmm3, xmm5
	movaps	xmm5, xmm2
	mulss	xmm5, DWORD PTR ?Device@@3VCRenderDevice@@A+240
	mulss	xmm2, DWORD PTR ?Device@@3VCRenderDevice@@A+244
	movaps	xmm6, xmm1
	mulss	xmm6, DWORD PTR ?Device@@3VCRenderDevice@@A+256
	mulss	xmm1, DWORD PTR ?Device@@3VCRenderDevice@@A+260
	addss	xmm5, xmm6
	movaps	xmm6, xmm0
	mulss	xmm0, DWORD PTR ?Device@@3VCRenderDevice@@A+228
	mulss	xmm6, DWORD PTR ?Device@@3VCRenderDevice@@A+224
	addss	xmm5, xmm6
	addss	xmm5, DWORD PTR ?Device@@3VCRenderDevice@@A+272
	addss	xmm0, xmm2

; 446  : 		float kx = 1, ky = 1;
; 447  : 		float sun_blend		= 0.5f;
; 448  : 		float sun_max		= 2.5f;
; 449  : 		scr_pos.y			*= -1;

	addss	xmm0, xmm1
	addss	xmm0, DWORD PTR ?Device@@3VCRenderDevice@@A+276
	mulss	xmm5, xmm3
	movss	DWORD PTR _scr_pos$133255[esp+208], xmm5

; 450  : 
; 451  : 		if (_abs(scr_pos.x) > sun_blend)	kx = ((sun_max - (float)_abs(scr_pos.x))) / (sun_max - sun_blend);

	fld	DWORD PTR _scr_pos$133255[esp+208]
	mulss	xmm0, xmm3
	mulss	xmm0, DWORD PTR __real@bf800000
	push	ecx
	fstp	DWORD PTR [esp]
	movss	DWORD PTR _kx$133256[esp+212], xmm4
	movss	DWORD PTR _ky$133257[esp+212], xmm4
	movss	DWORD PTR _scr_pos$133255[esp+216], xmm0
	call	_fabsf
	fst	DWORD PTR tv1720[esp+212]
	fld	DWORD PTR __real@3f000000
	add	esp, 4
	fxch	ST(1)
	fcomip	ST(1)
	fstp	ST(0)
	jbe	SHORT $LN4@OnFrame@10
	movss	xmm0, DWORD PTR __real@40200000
	subss	xmm0, DWORD PTR tv1720[esp+208]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _kx$133256[esp+208], xmm0
$LN4@OnFrame@10:

; 452  : 		if (_abs(scr_pos.y) > sun_blend)	ky = ((sun_max - (float)_abs(scr_pos.y))) / (sun_max - sun_blend);

	fld	DWORD PTR _scr_pos$133255[esp+212]
	push	ecx
	fstp	DWORD PTR [esp]
	call	_fabsf
	movss	xmm1, DWORD PTR __real@40200000
	fst	DWORD PTR tv1728[esp+212]
	fld	DWORD PTR __real@3f000000
	movss	xmm2, DWORD PTR tv1728[esp+212]
	fxch	ST(1)
	add	esp, 4
	fcomip	ST(1)
	fstp	ST(0)
	jbe	SHORT $LN314@OnFrame@10
	movaps	xmm0, xmm1
	subss	xmm0, xmm2
	mulss	xmm0, DWORD PTR __real@3f000000
	jmp	SHORT $LN3@OnFrame@10
$LN314@OnFrame@10:
	movss	xmm0, DWORD PTR _ky$133257[esp+208]
$LN3@OnFrame@10:

; 453  : 
; 454  : 		if (!((_abs(scr_pos.x) > sun_max) || (_abs(scr_pos.y) > sun_max))){

	movss	xmm3, DWORD PTR tv1720[esp+208]
	comiss	xmm3, xmm1
	ja	SHORT $LN2@OnFrame@10
	comiss	xmm2, xmm1
	ja	SHORT $LN2@OnFrame@10

; 455  :         	float op		= m_StateBlend*m_Current->m_Gradient.fOpacity;

	movss	xmm1, DWORD PTR [ebx+44]
	mulss	xmm1, DWORD PTR [edi+496]
	mulss	xmm1, xmm0

; 456  : 			fGradientValue	= kx * ky *  op * fBlend;

	mulss	xmm1, DWORD PTR _kx$133256[esp+208]
	mulss	xmm1, DWORD PTR [esi]
	movss	DWORD PTR [edi+468], xmm1

; 457  : 		}else

	jmp	SHORT $LN1@OnFrame@10
$LN2@OnFrame@10:

; 458  : 			fGradientValue	= 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR [edi+468], xmm0
$LN1@OnFrame@10:

; 459  : 	}
; 460  : }

	mov	eax, DWORD PTR _id$[ebp]
	test	eax, eax
	je	SHORT $LN116@OnFrame@10
	add	DWORD PTR [eax], -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN40@OnFrame@10:

; 284  : 
; 285  :     if ((m_Current==0)||(LightColor.magnitude_rgb()==0.f)){bRender=false; return;}

	test	ebx, ebx
	mov	DWORD PTR [edi+448], 0
	je	SHORT $LN116@OnFrame@10
	add	DWORD PTR [ebx], -1
$LN116@OnFrame@10:

; 459  : 	}
; 460  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN321@OnFrame@10:
	DD	$LN48@OnFrame@10
	DD	$LN47@OnFrame@10
	DD	$LN43@OnFrame@10
	DD	$LN45@OnFrame@10
?OnFrame@CLensFlare@@QAEXVshared_str@@@Z ENDP		; CLensFlare::OnFrame
END

; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	D:\CLEARSKY\sources\engine\xrEngine\xrImage_Resampler.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??$xr_free@UImage@@@@YAXAAPAUImage@@@Z		; xr_free<Image>
PUBLIC	??$xr_free@I@@YAXAAPAI@Z			; xr_free<unsigned int>
PUBLIC	??$xr_free@UCONTRIB@@@@YAXAAPAUCONTRIB@@@Z	; xr_free<CONTRIB>
PUBLIC	??$xr_free@UCLIST@@@@YAXAAPAUCLIST@@@Z		; xr_free<CLIST>
PUBLIC	??_C@_0M@IMDPDHHN@imf_Process?$AA@		; `string'
PUBLIC	??_C@_0DK@GADPOKAG@D?3?2CLEARSKY?2sources?2engine?2xrEng@ ; `string'
PUBLIC	??_C@_04FOKGOCNN@dstI?$AA@			; `string'
PUBLIC	??_C@_06CCPMIJCE@dstW?$DO1?$AA@			; `string'
PUBLIC	??_C@_06CKIGMOON@dstH?$DO1?$AA@			; `string'
PUBLIC	??_C@_04CNLDHLNP@srcI?$AA@			; `string'
PUBLIC	??_C@_06JJBJLDFD@srcW?$DO1?$AA@			; `string'
PUBLIC	??_C@_06JBGDPEJK@srcH?$DO1?$AA@			; `string'
PUBLIC	??_C@_0P@KHPAJLH@imf_Process?3?31?$AA@		; `string'
PUBLIC	??_C@_0P@CBFCFKHE@imf_Process?3?32?$AA@		; `string'
PUBLIC	??_C@_0BM@BEBDFIJA@imf_Process?3?33?5?$CIxscale?$DM1?40?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BM@FJNLPJJL@imf_Process?3?33?5?$CIxscale?$DO1?40?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0P@HHAIPNPC@imf_Process?3?34?$AA@		; `string'
PUBLIC	??_C@_0P@GOBDMMLD@imf_Process?3?35?$AA@		; `string'
PUBLIC	??_C@_0P@EFDOJPHA@imf_Process?3?36?$AA@		; `string'
PUBLIC	??_C@_0P@FMCFKODB@imf_Process?3?37?$AA@		; `string'
PUBLIC	??_C@_0BM@FBECLCAB@imf_Process?3?38?5?$CIyscale?$DM1?40?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BM@BMIKBDAK@imf_Process?3?38?5?$CIyscale?$DO1?40?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0P@MCKGIDLP@imf_Process?3?39?$AA@		; `string'
PUBLIC	??_C@_0P@CFEAHAEB@imf_Process?3?3A?$AA@		; `string'
PUBLIC	??_C@_0P@OGNCDIC@imf_Process?3?3B?$AA@		; `string'
;	COMDAT ?ignore_always@?3??imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z@4_NA
_BSS	SEGMENT
?ignore_always@?3??imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z@4_NA DB 01H DUP (?) ; `imf_Process'::`4'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?7??imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z@4_NA
_BSS	SEGMENT
?ignore_always@?7??imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z@4_NA DB 01H DUP (?) ; `imf_Process'::`8'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?M@??imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z@4_NA
_BSS	SEGMENT
?ignore_always@?M@??imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z@4_NA DB 01H DUP (?) ; `imf_Process'::`12'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?BA@??imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z@4_NA
_BSS	SEGMENT
?ignore_always@?BA@??imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z@4_NA DB 01H DUP (?) ; `imf_Process'::`16'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?BE@??imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z@4_NA
_BSS	SEGMENT
?ignore_always@?BE@??imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z@4_NA DB 01H DUP (?) ; `imf_Process'::`20'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?BI@??imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z@4_NA
_BSS	SEGMENT
?ignore_always@?BI@??imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z@4_NA DB 01H DUP (?) ; `imf_Process'::`24'::ignore_always
;	COMDAT ??_C@_0P@OGNCDIC@imf_Process?3?3B?$AA@
CONST	SEGMENT
??_C@_0P@OGNCDIC@imf_Process?3?3B?$AA@ DB 'imf_Process::B', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CFEAHAEB@imf_Process?3?3A?$AA@
CONST	SEGMENT
??_C@_0P@CFEAHAEB@imf_Process?3?3A?$AA@ DB 'imf_Process::A', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MCKGIDLP@imf_Process?3?39?$AA@
CONST	SEGMENT
??_C@_0P@MCKGIDLP@imf_Process?3?39?$AA@ DB 'imf_Process::9', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@BMIKBDAK@imf_Process?3?38?5?$CIyscale?$DO1?40?$CJ?$AA@
CONST	SEGMENT
??_C@_0BM@BMIKBDAK@imf_Process?3?38?5?$CIyscale?$DO1?40?$CJ?$AA@ DB 'imf_'
	DB	'Process::8 (yscale>1.0)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FBECLCAB@imf_Process?3?38?5?$CIyscale?$DM1?40?$CJ?$AA@
CONST	SEGMENT
??_C@_0BM@FBECLCAB@imf_Process?3?38?5?$CIyscale?$DM1?40?$CJ?$AA@ DB 'imf_'
	DB	'Process::8 (yscale<1.0)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FMCFKODB@imf_Process?3?37?$AA@
CONST	SEGMENT
??_C@_0P@FMCFKODB@imf_Process?3?37?$AA@ DB 'imf_Process::7', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EFDOJPHA@imf_Process?3?36?$AA@
CONST	SEGMENT
??_C@_0P@EFDOJPHA@imf_Process?3?36?$AA@ DB 'imf_Process::6', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GOBDMMLD@imf_Process?3?35?$AA@
CONST	SEGMENT
??_C@_0P@GOBDMMLD@imf_Process?3?35?$AA@ DB 'imf_Process::5', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HHAIPNPC@imf_Process?3?34?$AA@
CONST	SEGMENT
??_C@_0P@HHAIPNPC@imf_Process?3?34?$AA@ DB 'imf_Process::4', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FJNLPJJL@imf_Process?3?33?5?$CIxscale?$DO1?40?$CJ?$AA@
CONST	SEGMENT
??_C@_0BM@FJNLPJJL@imf_Process?3?33?5?$CIxscale?$DO1?40?$CJ?$AA@ DB 'imf_'
	DB	'Process::3 (xscale>1.0)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@BEBDFIJA@imf_Process?3?33?5?$CIxscale?$DM1?40?$CJ?$AA@
CONST	SEGMENT
??_C@_0BM@BEBDFIJA@imf_Process?3?33?5?$CIxscale?$DM1?40?$CJ?$AA@ DB 'imf_'
	DB	'Process::3 (xscale<1.0)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CBFCFKHE@imf_Process?3?32?$AA@
CONST	SEGMENT
??_C@_0P@CBFCFKHE@imf_Process?3?32?$AA@ DB 'imf_Process::2', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KHPAJLH@imf_Process?3?31?$AA@
CONST	SEGMENT
??_C@_0P@KHPAJLH@imf_Process?3?31?$AA@ DB 'imf_Process::1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06JBGDPEJK@srcH?$DO1?$AA@
CONST	SEGMENT
??_C@_06JBGDPEJK@srcH?$DO1?$AA@ DB 'srcH>1', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06JJBJLDFD@srcW?$DO1?$AA@
CONST	SEGMENT
??_C@_06JJBJLDFD@srcW?$DO1?$AA@ DB 'srcW>1', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04CNLDHLNP@srcI?$AA@
CONST	SEGMENT
??_C@_04CNLDHLNP@srcI?$AA@ DB 'srcI', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CKIGMOON@dstH?$DO1?$AA@
CONST	SEGMENT
??_C@_06CKIGMOON@dstH?$DO1?$AA@ DB 'dstH>1', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06CCPMIJCE@dstW?$DO1?$AA@
CONST	SEGMENT
??_C@_06CCPMIJCE@dstW?$DO1?$AA@ DB 'dstW>1', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04FOKGOCNN@dstI?$AA@
CONST	SEGMENT
??_C@_04FOKGOCNN@dstI?$AA@ DB 'dstI', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@GADPOKAG@D?3?2CLEARSKY?2sources?2engine?2xrEng@
CONST	SEGMENT
??_C@_0DK@GADPOKAG@D?3?2CLEARSKY?2sources?2engine?2xrEng@ DB 'D:\CLEARSKY'
	DB	'\sources\engine\xrEngine\xrImage_Resampler.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IMDPDHHN@imf_Process?$AA@
CONST	SEGMENT
??_C@_0M@IMDPDHHN@imf_Process?$AA@ DB 'imf_Process', 00H ; `string'
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\xrmemory.h
;	COMDAT ??$xr_free@I@@YAXAAPAI@Z
_TEXT	SEGMENT
??$xr_free@I@@YAXAAPAI@Z PROC				; xr_free<unsigned int>, COMDAT
; _P$ = esi

; 111  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN1@xr_free@17
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN1@xr_free@17:
	ret	0
??$xr_free@I@@YAXAAPAI@Z ENDP				; xr_free<unsigned int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$xr_free@UCLIST@@@@YAXAAPAUCLIST@@@Z
_TEXT	SEGMENT
??$xr_free@UCLIST@@@@YAXAAPAUCLIST@@@Z PROC		; xr_free<CLIST>, COMDAT
; _P$ = esi

; 111  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN1@xr_free@18
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN1@xr_free@18:
	ret	0
??$xr_free@UCLIST@@@@YAXAAPAUCLIST@@@Z ENDP		; xr_free<CLIST>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$xr_free@UCONTRIB@@@@YAXAAPAUCONTRIB@@@Z
_TEXT	SEGMENT
??$xr_free@UCONTRIB@@@@YAXAAPAUCONTRIB@@@Z PROC		; xr_free<CONTRIB>, COMDAT
; _P$ = esi

; 111  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN1@xr_free@19
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN1@xr_free@19:
	ret	0
??$xr_free@UCONTRIB@@@@YAXAAPAUCONTRIB@@@Z ENDP		; xr_free<CONTRIB>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$xr_free@UImage@@@@YAXAAPAUImage@@@Z
_TEXT	SEGMENT
??$xr_free@UImage@@@@YAXAAPAUImage@@@Z PROC		; xr_free<Image>, COMDAT
; _P$ = esi

; 111  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN1@xr_free@20
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN1@xr_free@20:
	ret	0
??$xr_free@UImage@@@@YAXAAPAUImage@@@Z ENDP		; xr_free<Image>
_TEXT	ENDS
PUBLIC	__real@412aaaab
PUBLIC	__real@c1a00000
PUBLIC	__real@41400000
PUBLIC	__real@c0155555
PUBLIC	__real@40000000
PUBLIC	__real@3e2aaaab
PUBLIC	__real@40aaaaab
PUBLIC	__real@c1400000
PUBLIC	__real@40e00000
PUBLIC	__real@80000000
PUBLIC	?Mitchell_filter@@YAMM@Z			; Mitchell_filter
;	COMDAT __real@412aaaab
; File d:\clearsky\sources\engine\xrengine\xrimage_resampler.cpp
CONST	SEGMENT
__real@412aaaab DD 0412aaaabr			; 10.6667
CONST	ENDS
;	COMDAT __real@c1a00000
CONST	SEGMENT
__real@c1a00000 DD 0c1a00000r			; -20
CONST	ENDS
;	COMDAT __real@41400000
CONST	SEGMENT
__real@41400000 DD 041400000r			; 12
CONST	ENDS
;	COMDAT __real@c0155555
CONST	SEGMENT
__real@c0155555 DD 0c0155555r			; -2.33333
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3e2aaaab
CONST	SEGMENT
__real@3e2aaaab DD 03e2aaaabr			; 0.166667
CONST	ENDS
;	COMDAT __real@40aaaaab
CONST	SEGMENT
__real@40aaaaab DD 040aaaaabr			; 5.33333
CONST	ENDS
;	COMDAT __real@c1400000
CONST	SEGMENT
__real@c1400000 DD 0c1400000r			; -12
CONST	ENDS
;	COMDAT __real@40e00000
CONST	SEGMENT
__real@40e00000 DD 040e00000r			; 7
CONST	ENDS
;	COMDAT __real@80000000
CONST	SEGMENT
__real@80000000 DD 080000000r			; -0
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?Mitchell_filter@@YAMM@Z
_TEXT	SEGMENT
_tt$ = -4						; size = 4
_t$ = 8							; size = 4
?Mitchell_filter@@YAMM@Z PROC				; Mitchell_filter, COMDAT

; 162  : {

	push	ecx

; 163  : 	float tt;
; 164  : 
; 165  : 	tt = t * t;

	movss	xmm0, DWORD PTR _t$[esp]
	movaps	xmm1, xmm0
	mulss	xmm1, xmm0
	movss	DWORD PTR _tt$[esp+4], xmm1

; 166  : 	if(t < 0) t = -t;

	xorps	xmm1, xmm1
	comiss	xmm1, xmm0
	jbe	SHORT $LN4@Mitchell_f
	movss	xmm1, DWORD PTR __real@80000000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR _t$[esp], xmm0
$LN4@Mitchell_f:

; 167  : 	if(t < 1.0f) {

	movss	xmm1, DWORD PTR __real@3f800000
	comiss	xmm1, xmm0
	jbe	SHORT $LN3@Mitchell_f

; 168  : 		t = (((12.0f - 9.0f * B - 6.0f * C) * (t * tt))
; 169  : 		   + ((-18.0f + 12.0f * B + 6.0f * C) * tt)
; 170  : 		   + (6.0f - 2.0f * B));

	fld	DWORD PTR _tt$[esp+4]
	fld	DWORD PTR _t$[esp]
	fmul	ST(0), ST(1)
	fmul	DWORD PTR __real@40e00000
	fxch	ST(1)
	fmul	DWORD PTR __real@c1400000
	faddp	ST(1), ST(0)

; 171  : 		return(t / 6.0f);

	fadd	DWORD PTR __real@40aaaaab
	fmul	DWORD PTR __real@3e2aaaab

; 180  : }

	pop	ecx
	ret	0
$LN3@Mitchell_f:

; 172  : 	} else if(t < 2.0f) {

	movss	xmm1, DWORD PTR __real@40000000
	comiss	xmm1, xmm0
	jbe	SHORT $LN1@Mitchell_f

; 173  : 		t = (((-1.0f * B - 6.0f * C) * (t * tt))
; 174  : 		   + ((6.0f * B + 30.0f * C) * tt)
; 175  : 		   + ((-12.0f * B - 48.0f * C) * t)
; 176  : 		   + (8.0f * B + 24.f * C));

	fld	DWORD PTR _tt$[esp+4]
	fld	ST(0)
	fld	DWORD PTR _t$[esp]
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fmul	DWORD PTR __real@c0155555
	fxch	ST(2)
	fmul	DWORD PTR __real@41400000
	faddp	ST(2), ST(0)
	fmul	DWORD PTR __real@c1a00000

; 177  : 		return(t / 6.0f);

	faddp	ST(1), ST(0)
	fadd	DWORD PTR __real@412aaaab
	fmul	DWORD PTR __real@3e2aaaab

; 180  : }

	pop	ecx
	ret	0
$LN1@Mitchell_f:

; 178  : 	}
; 179  : 	return(0.0);

	fldz

; 180  : }

	pop	ecx
	ret	0
?Mitchell_filter@@YAMM@Z ENDP				; Mitchell_filter
_TEXT	ENDS
PUBLIC	__real@3f2aaaab
PUBLIC	__real@3f000000
PUBLIC	?B_spline_filter@@YAMM@Z			; B_spline_filter
;	COMDAT __real@3f2aaaab
CONST	SEGMENT
__real@3f2aaaab DD 03f2aaaabr			; 0.666667
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?B_spline_filter@@YAMM@Z
_TEXT	SEGMENT
_t$ = 8							; size = 4
?B_spline_filter@@YAMM@Z PROC				; B_spline_filter, COMDAT

; 128  : 	float tt;
; 129  : 
; 130  : 	if(t < 0) t = -t;

	xorps	xmm1, xmm1
	movss	xmm0, DWORD PTR _t$[esp-4]
	comiss	xmm1, xmm0
	jbe	SHORT $LN4@B_spline_f
	movss	xmm1, DWORD PTR __real@80000000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR _t$[esp-4], xmm0
$LN4@B_spline_f:

; 131  : 	if(t < 1) {

	movss	xmm1, DWORD PTR __real@3f800000
	comiss	xmm1, xmm0
	jbe	SHORT $LN3@B_spline_f

; 132  : 		tt = t * t;

	fld	DWORD PTR _t$[esp-4]
	fld	ST(0)
	fmul	ST(0), ST(1)

; 133  : 		return((.5f * tt * t) - tt + (2.0f / 3.0f));

	fld	ST(0)
	fmulp	ST(2), ST(0)
	fxch	ST(1)
	fmul	DWORD PTR __real@3f000000
	fsubrp	ST(1), ST(0)
	fadd	DWORD PTR __real@3f2aaaab

; 139  : }

	ret	0
$LN3@B_spline_f:

; 134  : 	} else if(t < 2) {

	movss	xmm1, DWORD PTR __real@40000000
	comiss	xmm1, xmm0
	jbe	SHORT $LN1@B_spline_f

; 135  : 		t = 2 - t;

	fld	DWORD PTR __real@40000000
	fsub	DWORD PTR _t$[esp-4]

; 136  : 		return((1.0f / 6.0f) * (t * t * t));

	fld	ST(0)
	fmul	ST(0), ST(1)
	fmulp	ST(1), ST(0)
	fmul	DWORD PTR __real@3e2aaaab

; 139  : }

	ret	0
$LN1@B_spline_f:

; 137  : 	}
; 138  : 	return(0.0f);

	fldz

; 139  : }

	ret	0
?B_spline_filter@@YAMM@Z ENDP				; B_spline_filter
_TEXT	ENDS
PUBLIC	__real@3f400000
PUBLIC	?bell_filter@@YAMM@Z				; bell_filter
;	COMDAT __real@3f400000
CONST	SEGMENT
__real@3f400000 DD 03f400000r			; 0.75
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?bell_filter@@YAMM@Z
_TEXT	SEGMENT
_t$ = 8							; size = 4
?bell_filter@@YAMM@Z PROC				; bell_filter, COMDAT

; 115  : 	if(t < 0) t = -t;

	xorps	xmm1, xmm1
	movss	xmm0, DWORD PTR _t$[esp-4]
	comiss	xmm1, xmm0
	jbe	SHORT $LN3@bell_filte
	movss	xmm1, DWORD PTR __real@80000000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR _t$[esp-4], xmm0
$LN3@bell_filte:

; 116  : 	if(t < .5) return float(.75 - (t * t));

	movss	xmm1, DWORD PTR __real@3f000000
	comiss	xmm1, xmm0
	jbe	SHORT $LN2@bell_filte
	fld	DWORD PTR _t$[esp-4]
	fmul	ST(0), ST(0)
	fsubr	DWORD PTR __real@3f400000

; 122  : }

	ret	0
$LN2@bell_filte:

; 117  : 	if(t < 1.5) {

	movss	xmm1, DWORD PTR _fQuantizerRangeExt
	comiss	xmm1, xmm0
	jbe	SHORT $LN1@bell_filte

; 118  : 		t = (t - 1.5f);

	fld	DWORD PTR _t$[esp-4]
	fsub	DWORD PTR _fQuantizerRangeExt

; 119  : 		return(.5f * (t * t));

	fmul	ST(0), ST(0)
	fmul	DWORD PTR __real@3f000000

; 122  : }

	ret	0
$LN1@bell_filte:

; 120  : 	}
; 121  : 	return(0.0);

	fldz

; 122  : }

	ret	0
?bell_filter@@YAMM@Z ENDP				; bell_filter
_TEXT	ENDS
PUBLIC	?triangle_filter@@YAMM@Z			; triangle_filter
; Function compile flags: /Ogtpy
;	COMDAT ?triangle_filter@@YAMM@Z
_TEXT	SEGMENT
_t$ = 8							; size = 4
?triangle_filter@@YAMM@Z PROC				; triangle_filter, COMDAT

; 106  : 	if(t < 0.0f) t = -t;

	xorps	xmm1, xmm1
	movss	xmm0, DWORD PTR _t$[esp-4]
	comiss	xmm1, xmm0
	jbe	SHORT $LN2@triangle_f
	movss	xmm1, DWORD PTR __real@80000000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR _t$[esp-4], xmm0
$LN2@triangle_f:

; 107  : 	if(t < 1.0f) return(1.0f - t);

	movss	xmm1, DWORD PTR __real@3f800000
	comiss	xmm1, xmm0
	jbe	SHORT $LN1@triangle_f
	fld1
	fsub	DWORD PTR _t$[esp-4]

; 109  : }

	ret	0
$LN1@triangle_f:

; 108  : 	return(0.0f);

	fldz

; 109  : }

	ret	0
?triangle_filter@@YAMM@Z ENDP				; triangle_filter
_TEXT	ENDS
PUBLIC	__real@bf000000
PUBLIC	?box_filter@@YAMM@Z				; box_filter
;	COMDAT __real@bf000000
CONST	SEGMENT
__real@bf000000 DD 0bf000000r			; -0.5
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?box_filter@@YAMM@Z
_TEXT	SEGMENT
_t$ = 8							; size = 4
?box_filter@@YAMM@Z PROC				; box_filter, COMDAT

; 98   : 	if((t > -0.5) && (t <= 0.5)) return(1.0);

	movss	xmm0, DWORD PTR _t$[esp-4]
	comiss	xmm0, DWORD PTR __real@bf000000
	jbe	SHORT $LN1@box_filter
	movss	xmm1, DWORD PTR __real@3f000000
	comiss	xmm1, xmm0
	jb	SHORT $LN1@box_filter
	fld1

; 100  : }

	ret	0
$LN1@box_filter:

; 99   : 	return(0.0);

	fldz

; 100  : }

	ret	0
?box_filter@@YAMM@Z ENDP				; box_filter
_TEXT	ENDS
PUBLIC	__real@3ff0000000000000
PUBLIC	?filter@@YAMM@Z					; filter
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?filter@@YAMM@Z
_TEXT	SEGMENT
_t$ = 8							; size = 4
?filter@@YAMM@Z PROC					; filter, COMDAT

; 88   : 	/* f(t) = 2|t|^3 - 3|t|^2 + 1, -1 <= t <= 1 */
; 89   : 	if(t < 0.0) t = -t;

	xorps	xmm1, xmm1
	movss	xmm0, DWORD PTR _t$[esp-4]
	comiss	xmm1, xmm0
	jbe	SHORT $LN2@filter
	movss	xmm1, DWORD PTR __real@80000000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR _t$[esp-4], xmm0
$LN2@filter:

; 90   : 	if(t < 1.0) return		float((2.0 * t - 3.0) * t * t + 1.0);

	movss	xmm1, DWORD PTR __real@3f800000
	comiss	xmm1, xmm0
	jbe	SHORT $LN1@filter
	fld	DWORD PTR _t$[esp-4]
	fld	ST(0)
	fadd	ST(0), ST(1)
	fsub	DWORD PTR _drop_angle
	fmul	ST(0), ST(1)
	fmulp	ST(1), ST(0)
	fadd	QWORD PTR __real@3ff0000000000000

; 92   : }

	ret	0
$LN1@filter:

; 91   : 	return(0.0);

	fldz

; 92   : }

	ret	0
?filter@@YAMM@Z ENDP					; filter
_TEXT	ENDS
PUBLIC	?put_pixel@@YAIPAUImage@@HHI@Z			; put_pixel
; Function compile flags: /Ogtpy
;	COMDAT ?put_pixel@@YAIPAUImage@@HHI@Z
_TEXT	SEGMENT
?put_pixel@@YAIPAUImage@@HHI@Z PROC			; put_pixel, COMDAT
; _image$ = ecx
; _x$ = edx
; _y$ = esi
; _data$ = eax

; 75   : 	if((x < 0) || (x >= image->xsize) || (y < 0) || (y >= image->ysize)) return 0;

	test	edx, edx
	jl	SHORT $LN1@put_pixel
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN1@put_pixel
	test	esi, esi
	jl	SHORT $LN1@put_pixel
	cmp	esi, DWORD PTR [ecx+4]
	jge	SHORT $LN1@put_pixel
	push	edi

; 76   : 	return	image->data[(y * image->span)+x] = data;

	mov	edi, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+8]
	imul	edi, esi
	add	edi, edx
	mov	DWORD PTR [ecx+edi*4], eax
	pop	edi

; 77   : }

	ret	0
$LN1@put_pixel:

; 75   : 	if((x < 0) || (x >= image->xsize) || (y < 0) || (y >= image->ysize)) return 0;

	xor	eax, eax

; 77   : }

	ret	0
?put_pixel@@YAIPAUImage@@HHI@Z ENDP			; put_pixel
_TEXT	ENDS
PUBLIC	?get_column@@YAXPAIPAUImage@@H@Z		; get_column
; Function compile flags: /Ogtpy
;	COMDAT ?get_column@@YAXPAIPAUImage@@H@Z
_TEXT	SEGMENT
?get_column@@YAXPAIPAUImage@@H@Z PROC			; get_column, COMDAT
; _column$ = edx
; _image$ = ecx
; _x$ = eax

; 61   : {

	push	esi
	mov	esi, eax

; 62   : 	int i, d;
; 63   : 	Pixel *p;
; 64   : 
; 65   : 	if((x < 0) || (x >= image->xsize)) return;

	test	esi, esi
	jl	SHORT $LN4@get_column
	cmp	esi, DWORD PTR [ecx]
	jge	SHORT $LN4@get_column

; 66   : 
; 67   : 	d	= image->span;
; 68   : 	for(i = image->ysize, p = image->data + x; i-- > 0; p += d) {

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	push	edi
	mov	edi, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+8]
	lea	ecx, DWORD PTR [ecx+esi*4]
	jle	SHORT $LN11@get_column
	lea	esi, DWORD PTR [edi*4]
$LL3@get_column:

; 69   : 		*column++ = *p;

	mov	edi, DWORD PTR [ecx]
	sub	eax, 1
	mov	DWORD PTR [edx], edi
	add	edx, 4
	add	ecx, esi
	test	eax, eax
	jg	SHORT $LL3@get_column
$LN11@get_column:
	pop	edi
$LN4@get_column:
	pop	esi

; 70   : 	}
; 71   : }

	ret	0
?get_column@@YAXPAIPAUImage@@H@Z ENDP			; get_column
_TEXT	ENDS
PUBLIC	?get_row@@YAXPAIPAUImage@@H@Z			; get_row
; Function compile flags: /Ogtpy
;	COMDAT ?get_row@@YAXPAIPAUImage@@H@Z
_TEXT	SEGMENT
_row$ = 8						; size = 4
?get_row@@YAXPAIPAUImage@@H@Z PROC			; get_row, COMDAT
; _image$ = eax
; _y$ = ecx

; 56   : 	if((y < 0) || (y >= image->ysize)) return;

	test	ecx, ecx
	jl	SHORT $LN1@get_row
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $LN1@get_row

; 57   : 	CopyMemory(row,	image->data + (y * image->span), (sizeof(Pixel) * image->xsize));

	mov	edx, DWORD PTR [eax]
	add	edx, edx
	add	edx, edx
	push	edx
	mov	edx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR [eax+8]
	imul	edx, ecx
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _row$[esp]
	push	ecx
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN1@get_row:

; 58   : }

	ret	0
?get_row@@YAXPAIPAUImage@@H@Z ENDP			; get_row
_TEXT	ENDS
PUBLIC	?free_image@@YAXPAUImage@@@Z			; free_image
; Function compile flags: /Ogtpy
;	COMDAT ?free_image@@YAXPAUImage@@@Z
_TEXT	SEGMENT
?free_image@@YAXPAUImage@@@Z PROC			; free_image, COMDAT
; _image$ = esi

; 44   : 	xr_free(image->data);

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	push	edi
	mov	edi, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	je	SHORT $LN3@free_image
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
	mov	DWORD PTR [esi+8], 0
$LN3@free_image:

; 45   : 	xr_free(image);

	test	esi, esi
	je	SHORT $LN6@free_image
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	edi
$LN6@free_image:
	pop	edi

; 46   : }

	ret	0
?free_image@@YAXPAUImage@@@Z ENDP			; free_image
PUBLIC	?CC@@YAIM@Z					; CC
; Function compile flags: /Ogtpy
;	COMDAT ?CC@@YAIM@Z
_TEXT	SEGMENT
_a$239483 = -4						; size = 4
?CC@@YAIM@Z PROC					; CC, COMDAT
; _a$ = xmm0s

; 199  : {

	push	ecx

; 200  : 	int	p		= iFloor(float(a)+.5f);

	addss	xmm0, DWORD PTR __real@3f000000
	push	esi
	movss	DWORD PTR _a$239483[esp+8], xmm0
	mov	esi, DWORD PTR _a$239483[esp+8]
	mov	eax, esi
	sar	eax, 23					; 00000017H
	and	eax, 255				; 000000ffH
	mov	edx, esi
	or	edx, -8388608				; ff800000H
	shl	edx, 8
	mov	ecx, 158				; 0000009eH
	sub	ecx, eax
	shr	edx, cl
	sub	ecx, 96					; 00000060H
	mov	eax, 1
	shl	eax, cl
	sub	eax, 1
	sar	eax, 8
	and	eax, esi
	neg	eax
	sbb	eax, eax
	add	eax, 1
	sar	esi, 31					; 0000001fH
	and	eax, esi
	add	ecx, 64					; 00000040H
	sub	edx, eax
	sar	ecx, 31					; 0000001fH
	and	edx, ecx
	xor	edx, esi
	mov	eax, edx
	pop	esi

; 201  : 	if	(p<0)	return 0; else if (p>255) return 255;

	jge	SHORT $LN3@CC
	xor	eax, eax

; 202  : 	return p;
; 203  : }

	pop	ecx
	ret	0
$LN3@CC:

; 201  : 	if	(p<0)	return 0; else if (p>255) return 255;

	cmp	eax, 255				; 000000ffH
	jle	SHORT $LN4@CC
	mov	eax, 255				; 000000ffH
$LN4@CC:

; 202  : 	return p;
; 203  : }

	pop	ecx
	ret	0
?CC@@YAIM@Z ENDP					; CC
_TEXT	ENDS
PUBLIC	__real@40490fda
PUBLIC	?sinc@@YAMM@Z					; sinc
;	COMDAT __real@40490fda
; File j:\msvs8\vc\include\math.h
CONST	SEGMENT
__real@40490fda DD 040490fdar			; 3.14159
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\xrimage_resampler.cpp
CONST	ENDS
;	COMDAT ?sinc@@YAMM@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
?sinc@@YAMM@Z PROC					; sinc, COMDAT

; 145  : 	x *= 3.1415926f;

	movss	xmm0, DWORD PTR _x$[esp-4]
	mulss	xmm0, DWORD PTR __real@40490fda

; 146  : 	if(x != 0) return(_sin(x) / x);

	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	movss	DWORD PTR _x$[esp-4], xmm0
	jnp	SHORT $LN1@sinc
	fld	DWORD PTR _x$[esp-4]
	push	ecx
	fstp	DWORD PTR [esp]
	call	_sinf
	fdiv	DWORD PTR _x$[esp]
	add	esp, 4

; 148  : }

	ret	0
$LN1@sinc:

; 147  : 	return(1.0);

	fld1

; 148  : }

	ret	0
?sinc@@YAMM@Z ENDP					; sinc
_TEXT	ENDS
PUBLIC	?new_image@@YAPAUImage@@HH@Z			; new_image
; Function compile flags: /Ogtpy
;	COMDAT ?new_image@@YAPAUImage@@HH@Z
_TEXT	SEGMENT
_ysize$ = 8						; size = 4
?new_image@@YAPAUImage@@HH@Z PROC			; new_image, COMDAT
; _xsize$ = ebx

; 30   : 	Image *image;
; 31   : 
; 32   : 	if((0!=(image = (Image *)xr_malloc(sizeof(Image)))) && (0!=(image->data = (Pixel *)xr_malloc(ysize*xsize*sizeof(Pixel)))))

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	ebp
	mov	ebp, DWORD PTR _ysize$[esp]
	push	edi
	push	16					; 00000010H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	mov	edi, eax
	test	edi, edi
	je	SHORT $LN1@new_image
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	mov	esi, ebx
	imul	esi, ebp
	add	esi, esi
	add	esi, esi
	push	esi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	test	eax, eax
	mov	DWORD PTR [edi+8], eax
	je	SHORT $LN9@new_image

; 33   : 	{
; 34   : 		ZeroMemory(image->data,ysize*xsize*sizeof(Pixel));

	push	esi
	push	0
	push	eax
	mov	eax, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ecx, DWORD PTR [eax+12]
	call	ecx

; 35   : 		image->xsize	= xsize;

	mov	DWORD PTR [edi], ebx

; 36   : 		image->ysize	= ysize;

	mov	DWORD PTR [edi+4], ebp

; 37   : 		image->span		= xsize;

	mov	DWORD PTR [edi+12], ebx
$LN9@new_image:

; 38   : 	}
; 39   : 	return	(image);

	mov	eax, edi
	pop	esi
$LN1@new_image:
	pop	edi
	pop	ebp

; 40   : }

	ret	0
?new_image@@YAPAUImage@@HH@Z ENDP			; new_image
PUBLIC	__real@3eaaaaab
PUBLIC	?Lanczos3_filter@@YAMM@Z			; Lanczos3_filter
;	COMDAT __real@3eaaaaab
; File j:\msvs8\vc\include\math.h
CONST	SEGMENT
__real@3eaaaaab DD 03eaaaaabr			; 0.333333
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\xrimage_resampler.cpp
CONST	ENDS
;	COMDAT ?Lanczos3_filter@@YAMM@Z
_TEXT	SEGMENT
$T292057 = -4						; size = 4
$T292056 = -4						; size = 4
$T292069 = 8						; size = 4
$T292068 = 8						; size = 4
_t$ = 8							; size = 4
?Lanczos3_filter@@YAMM@Z PROC				; Lanczos3_filter, COMDAT

; 150  : {

	push	ecx

; 151  : 	if(t < 0) t = -t;

	xorps	xmm2, xmm2
	movss	xmm0, DWORD PTR _t$[esp]
	comiss	xmm2, xmm0
	jbe	SHORT $LN2@Lanczos3_f
	movss	xmm1, DWORD PTR __real@80000000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR _t$[esp], xmm0
$LN2@Lanczos3_f:

; 152  : 	if(t < 3.0f) return	float(sinc(t) * sinc(t/3.0f));

	movss	xmm1, DWORD PTR _drop_angle
	comiss	xmm1, xmm0
	jbe	$LN1@Lanczos3_f
	movaps	xmm1, xmm0
	mulss	xmm1, DWORD PTR __real@40490fda
	ucomiss	xmm1, xmm2
	lahf
	test	ah, 68					; 00000044H
	movss	DWORD PTR $T292056[esp+4], xmm1
	jnp	SHORT $LN5@Lanczos3_f
	fld	DWORD PTR $T292056[esp+4]
	push	ecx
	fstp	DWORD PTR [esp]
	call	_sinf
	fdiv	DWORD PTR $T292056[esp+8]
	movss	xmm0, DWORD PTR _t$[esp+4]
	xorps	xmm2, xmm2
	add	esp, 4
	fstp	DWORD PTR $T292057[esp+4]
	jmp	SHORT $LN6@Lanczos3_f
$LN5@Lanczos3_f:
	movss	xmm1, DWORD PTR __real@3f800000
	movss	DWORD PTR $T292057[esp+4], xmm1
$LN6@Lanczos3_f:
	mulss	xmm0, DWORD PTR __real@3eaaaaab
	mulss	xmm0, DWORD PTR __real@40490fda
	ucomiss	xmm0, xmm2
	lahf
	test	ah, 68					; 00000044H
	movss	DWORD PTR $T292068[esp], xmm0
	jnp	SHORT $LN12@Lanczos3_f
	fld	DWORD PTR $T292068[esp]
	push	ecx
	fstp	DWORD PTR [esp]
	call	_sinf
	fdiv	DWORD PTR $T292068[esp+4]
	add	esp, 4
	fmul	DWORD PTR $T292057[esp+4]

; 154  : }

	pop	ecx
	ret	0

; 152  : 	if(t < 3.0f) return	float(sinc(t) * sinc(t/3.0f));

$LN12@Lanczos3_f:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR $T292069[esp], xmm0
	fld	DWORD PTR $T292069[esp]
	fmul	DWORD PTR $T292057[esp+4]

; 154  : }

	pop	ecx
	ret	0
$LN1@Lanczos3_f:

; 153  : 	return(0.0);

	fldz

; 154  : }

	pop	ecx
	ret	0
?Lanczos3_filter@@YAMM@Z ENDP				; Lanczos3_filter
PUBLIC	?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z	; imf_Process
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
; File d:\clearsky\sources\engine\xrcore\xrmemory.h
xdata$x	SEGMENT
__catchsym$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$38 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$24
__catchsym$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$37 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$22
__catchsym$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$36 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$20
__catchsym$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$35 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$18
__catchsym$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$34 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$16
__catchsym$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$33 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$14
__catchsym$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$32 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$12
__catchsym$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$31 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$10
__catchsym$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$30 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$8
__catchsym$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$29 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$6
__catchsym$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$28 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$4
__catchsym$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$27 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$2
__catchsym$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$26 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$0
__ehfuncinfo$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z DD 019930522H
	DD	01aH
	DD	FLAT:__unwindtable$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z
	DD	0dH
	DD	FLAT:__tryblocktable$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$26
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$27
	DD	04H
	DD	04H
	DD	05H
	DD	01H
	DD	FLAT:__catchsym$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$28
	DD	06H
	DD	06H
	DD	07H
	DD	01H
	DD	FLAT:__catchsym$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$29
	DD	08H
	DD	08H
	DD	09H
	DD	01H
	DD	FLAT:__catchsym$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$30
	DD	0aH
	DD	0aH
	DD	0bH
	DD	01H
	DD	FLAT:__catchsym$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$31
	DD	0cH
	DD	0cH
	DD	0dH
	DD	01H
	DD	FLAT:__catchsym$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$32
	DD	0eH
	DD	0eH
	DD	0fH
	DD	01H
	DD	FLAT:__catchsym$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$33
	DD	010H
	DD	010H
	DD	011H
	DD	01H
	DD	FLAT:__catchsym$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$34
	DD	012H
	DD	012H
	DD	013H
	DD	01H
	DD	FLAT:__catchsym$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$35
	DD	014H
	DD	014H
	DD	015H
	DD	01H
	DD	FLAT:__catchsym$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$36
	DD	016H
	DD	016H
	DD	017H
	DD	01H
	DD	FLAT:__catchsym$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$37
	DD	018H
	DD	018H
	DD	019H
	DD	01H
	DD	FLAT:__catchsym$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$38
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\xrimage_resampler.cpp
xdata$x	ENDS
;	COMDAT ?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z
_TEXT	SEGMENT
_dst$ = -140						; size = 16
_src$ = -124						; size = 16
_p$367934 = -108					; size = 4
$T367941 = -104						; size = 4
_i$367932 = -100					; size = 4
_w_r$115215 = -96					; size = 4
_w_g$115216 = -92					; size = 4
_w_b$115217 = -88					; size = 4
_w_a$115218 = -84					; size = 4
tv1369 = -80						; size = 8
tv1287 = -80						; size = 8
tv1056 = -76						; size = 4
_fscale$ = -72						; size = 4
_w_r$115135 = -68					; size = 4
_w_g$115136 = -64					; size = 4
_w_b$115137 = -60					; size = 4
_w_a$115138 = -56					; size = 4
_yscale$ = -52						; size = 4
_xscale$ = -48						; size = 4
tv1398 = -44						; size = 8
tv1316 = -44						; size = 8
tv1040 = -40						; size = 4
$T367887 = -40						; size = 4
_k$ = -36						; size = 4
_j$ = -32						; size = 4
_tmp$ = -28						; size = 4
_i$ = -24						; size = 4
_contrib$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
_filterf$ = 8						; size = 4
_dstI$ = 8						; size = 4
tv1400 = 12						; size = 4
tv1318 = 12						; size = 4
_W$115142 = 12						; size = 4
_right$ = 12						; size = 4
_dstW$ = 12						; size = 4
tv1371 = 16						; size = 4
tv1289 = 16						; size = 4
$T367963 = 16						; size = 4
_width$ = 16						; size = 4
_dstH$ = 16						; size = 4
_fwidth$ = 20						; size = 4
_srcI$ = 20						; size = 4
_W$115222 = 24						; size = 4
_center$ = 24						; size = 4
_srcW$ = 24						; size = 4
tv1341 = 28						; size = 4
tv1340 = 28						; size = 4
tv1339 = 28						; size = 4
tv1338 = 28						; size = 4
tv1257 = 28						; size = 4
tv1256 = 28						; size = 4
tv1255 = 28						; size = 4
tv1254 = 28						; size = 4
$T367962 = 28						; size = 4
_d$367933 = 28						; size = 4
$T367886 = 28						; size = 4
_weight$ = 28						; size = 4
_left$ = 28						; size = 4
_srcH$ = 28						; size = 4
tv1403 = 30						; size = 2
tv1374 = 30						; size = 2
tv1321 = 30						; size = 2
tv1292 = 30						; size = 2
_raster$ = 32						; size = 4
_FILTER$ = 32						; size = 4
?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z PROC		; imf_Process, COMDAT

; 206  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 128				; 00000080H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp

; 207  : 	R_ASSERT		(dstI);	R_ASSERT	(dstW>1);	R_ASSERT	(dstH>1);

	xor	esi, esi
	mov	edi, DWORD PTR __imp_?fail@xrDebug@@QAEXPBD0H0AA_N@Z
	cmp	BYTE PTR ?ignore_always@?3??imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z@4_NA, 0
	jne	SHORT $LN113@imf_Proces
	cmp	DWORD PTR _dstI$[ebp], esi
	jne	SHORT $LN113@imf_Proces
	push	OFFSET ?ignore_always@?3??imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z@4_NA
	push	OFFSET ??_C@_0M@IMDPDHHN@imf_Process?$AA@
	push	207					; 000000cfH
	push	OFFSET ??_C@_0DK@GADPOKAG@D?3?2CLEARSKY?2sources?2engine?2xrEng@
	push	OFFSET ??_C@_04FOKGOCNN@dstI?$AA@
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	call	edi
$LN113@imf_Proces:
	mov	ebx, DWORD PTR _dstW$[ebp]
	cmp	BYTE PTR ?ignore_always@?7??imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z@4_NA, 0
	jne	SHORT $LN109@imf_Proces
	cmp	ebx, 1
	ja	SHORT $LN109@imf_Proces
	push	OFFSET ?ignore_always@?7??imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z@4_NA
	push	OFFSET ??_C@_0M@IMDPDHHN@imf_Process?$AA@
	push	207					; 000000cfH
	push	OFFSET ??_C@_0DK@GADPOKAG@D?3?2CLEARSKY?2sources?2engine?2xrEng@
	push	OFFSET ??_C@_06CCPMIJCE@dstW?$DO1?$AA@
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	call	edi
$LN109@imf_Proces:
	cmp	BYTE PTR ?ignore_always@?M@??imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z@4_NA, 0
	jne	SHORT $LN105@imf_Proces
	cmp	DWORD PTR _dstH$[ebp], 1
	ja	SHORT $LN105@imf_Proces
	push	OFFSET ?ignore_always@?M@??imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z@4_NA
	push	OFFSET ??_C@_0M@IMDPDHHN@imf_Process?$AA@
	push	207					; 000000cfH
	push	OFFSET ??_C@_0DK@GADPOKAG@D?3?2CLEARSKY?2sources?2engine?2xrEng@
	push	OFFSET ??_C@_06CKIGMOON@dstH?$DO1?$AA@
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	call	edi
$LN105@imf_Proces:

; 208  : 	R_ASSERT		(srcI);	R_ASSERT	(srcW>1);	R_ASSERT	(srcH>1);

	cmp	BYTE PTR ?ignore_always@?BA@??imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z@4_NA, 0
	jne	SHORT $LN101@imf_Proces
	cmp	DWORD PTR _srcI$[ebp], esi
	jne	SHORT $LN101@imf_Proces
	push	OFFSET ?ignore_always@?BA@??imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z@4_NA
	push	OFFSET ??_C@_0M@IMDPDHHN@imf_Process?$AA@
	push	208					; 000000d0H
	push	OFFSET ??_C@_0DK@GADPOKAG@D?3?2CLEARSKY?2sources?2engine?2xrEng@
	push	OFFSET ??_C@_04CNLDHLNP@srcI?$AA@
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	call	edi
$LN101@imf_Proces:
	cmp	BYTE PTR ?ignore_always@?BE@??imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z@4_NA, 0
	jne	SHORT $LN97@imf_Proces
	cmp	DWORD PTR _srcW$[ebp], 1
	ja	SHORT $LN97@imf_Proces
	push	OFFSET ?ignore_always@?BE@??imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z@4_NA
	push	OFFSET ??_C@_0M@IMDPDHHN@imf_Process?$AA@
	push	208					; 000000d0H
	push	OFFSET ??_C@_0DK@GADPOKAG@D?3?2CLEARSKY?2sources?2engine?2xrEng@
	push	OFFSET ??_C@_06JJBJLDFD@srcW?$DO1?$AA@
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	call	edi
$LN97@imf_Proces:
	cmp	BYTE PTR ?ignore_always@?BI@??imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z@4_NA, 0
	jne	SHORT $LN93@imf_Proces
	cmp	DWORD PTR _srcH$[ebp], 1
	ja	SHORT $LN93@imf_Proces
	push	OFFSET ?ignore_always@?BI@??imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z@4_NA
	push	OFFSET ??_C@_0M@IMDPDHHN@imf_Process?$AA@
	push	208					; 000000d0H
	push	OFFSET ??_C@_0DK@GADPOKAG@D?3?2CLEARSKY?2sources?2engine?2xrEng@
	push	OFFSET ??_C@_06JBGDPEJK@srcH?$DO1?$AA@
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	call	edi
$LN93@imf_Proces:

; 209  : 
; 210  : 	// SRC & DST images
; 211  : 	Image		src;	src.xsize	= srcW;	src.ysize	= srcH;	src.data	= srcI;	src.span	= srcW;

	mov	eax, DWORD PTR _srcW$[ebp]
	mov	DWORD PTR _src$[ebp], eax
	mov	ecx, DWORD PTR _srcH$[ebp]
	mov	DWORD PTR _src$[ebp+4], ecx
	mov	edx, DWORD PTR _srcI$[ebp]
	mov	DWORD PTR _src$[ebp+8], edx
	mov	DWORD PTR _src$[ebp+12], eax

; 212  : 	Image		dst;	dst.xsize	= dstW;	dst.ysize	= dstH;	dst.data	= dstI;	dst.span	= dstW;

	mov	DWORD PTR _dst$[ebp], ebx
	mov	eax, DWORD PTR _dstH$[ebp]
	mov	DWORD PTR _dst$[ebp+4], eax
	mov	ecx, DWORD PTR _dstI$[ebp]
	mov	DWORD PTR _dst$[ebp+8], ecx
	mov	DWORD PTR _dst$[ebp+12], ebx

; 213  : 
; 214  : 	// Select filter
; 215  : 	float		(*filterf)(float);	filterf		= 0;

	mov	DWORD PTR _filterf$[ebp], esi

; 216  : 	float		fwidth	= 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR _fwidth$[ebp], xmm0

; 217  : 	switch		(FILTER)

	mov	eax, DWORD PTR _FILTER$[ebp]
	cmp	eax, 6
	ja	SHORT $LN89@imf_Proces
	jmp	DWORD PTR $LN401@imf_Proces[eax*4]
$LN88@imf_Proces:

; 218  : 	{
; 219  : 	case imf_filter:	filterf=filter;				fwidth = filter_support;	break;

	mov	DWORD PTR _filterf$[ebp], OFFSET ?filter@@YAMM@Z ; filter
	movss	xmm1, DWORD PTR __real@3f800000
	jmp	SHORT $LN386@imf_Proces
$LN87@imf_Proces:

; 220  : 	case imf_box:		filterf=box_filter;			fwidth = box_support;		break;

	mov	DWORD PTR _filterf$[ebp], OFFSET ?box_filter@@YAMM@Z ; box_filter
	movss	xmm1, DWORD PTR __real@3f000000
	jmp	SHORT $LN386@imf_Proces
$LN86@imf_Proces:

; 221  : 	case imf_triangle:	filterf=triangle_filter;	fwidth = triangle_support;	break;

	mov	DWORD PTR _filterf$[ebp], OFFSET ?triangle_filter@@YAMM@Z ; triangle_filter
	movss	xmm1, DWORD PTR __real@3f800000
	jmp	SHORT $LN386@imf_Proces
$LN85@imf_Proces:

; 222  : 	case imf_bell:		filterf=bell_filter;		fwidth = bell_support;		break;

	mov	DWORD PTR _filterf$[ebp], OFFSET ?bell_filter@@YAMM@Z ; bell_filter
	movss	xmm1, DWORD PTR _fQuantizerRangeExt
	jmp	SHORT $LN386@imf_Proces
$LN84@imf_Proces:

; 223  : 	case imf_b_spline:	filterf=B_spline_filter;	fwidth = B_spline_support;	break;

	mov	DWORD PTR _filterf$[ebp], OFFSET ?B_spline_filter@@YAMM@Z ; B_spline_filter
	jmp	SHORT $LN387@imf_Proces
$LN83@imf_Proces:

; 224  : 	case imf_lanczos3:	filterf=Lanczos3_filter;	fwidth = Lanczos3_support;	break;

	mov	DWORD PTR _filterf$[ebp], OFFSET ?Lanczos3_filter@@YAMM@Z ; Lanczos3_filter
	movss	xmm1, DWORD PTR _drop_angle
	jmp	SHORT $LN386@imf_Proces
$LN82@imf_Proces:

; 225  : 	case imf_mitchell:	filterf=Mitchell_filter;	fwidth = Mitchell_support;	break;

	mov	DWORD PTR _filterf$[ebp], OFFSET ?Mitchell_filter@@YAMM@Z ; Mitchell_filter
$LN387@imf_Proces:
	movss	xmm1, DWORD PTR __real@40000000
$LN386@imf_Proces:
	movss	DWORD PTR _fwidth$[ebp], xmm1
$LN89@imf_Proces:

; 226  : 	}
; 227  : 
; 228  : 
; 229  : 	//
; 230  : 	Image	*tmp	= 0;			/* intermediate image */

	mov	DWORD PTR _tmp$[ebp], esi

; 231  : 	float	xscale	= 0, yscale = 0;/* zoom scale factors */

	movss	DWORD PTR _xscale$[ebp], xmm0
	movss	DWORD PTR _yscale$[ebp], xmm0

; 232  : 	int		i, j, k;				/* loop variables */
; 233  : 	int		n;						/* pixel number */
; 234  : 	float	center, left,	right;	/* filter calculation variables */
; 235  : 	float	width,	fscale, weight;	/* filter calculation variables */
; 236  : 	Pixel	*raster	= 0;			/* a row or column of pixels */

	mov	DWORD PTR _raster$[ebp], esi

; 237  : 	CLIST	*contrib= 0;			/* array of contribution lists */

	mov	DWORD PTR _contrib$[ebp], esi

; 238  : 
; 239  : 	/* create intermediate image to hold horizontal zoom */
; 240  : 	try	{

	mov	DWORD PTR __$EHRec$[ebp+12], esi
	fwait

; 241  : 		tmp		= new_image	(dst.xsize, src.ysize);

	push	16					; 00000010H
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	mov	edi, eax
	cmp	edi, esi
	je	SHORT $LN177@imf_Proces
	mov	esi, ebx
	imul	esi, DWORD PTR _srcH$[ebp]
	add	esi, esi
	add	esi, esi
	push	esi
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	mov	DWORD PTR [edi+8], eax
	test	eax, eax
	je	SHORT $LN177@imf_Proces
	push	esi
	push	0
	push	eax
	mov	edx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR [edi], ebx
	mov	ecx, DWORD PTR _srcH$[ebp]
	mov	DWORD PTR [edi+4], ecx
	mov	DWORD PTR [edi+12], ebx
$LN177@imf_Proces:
	mov	DWORD PTR _tmp$[ebp], edi

; 242  : 		xscale	= float	(dst.xsize) / float(src.xsize);

	cvtsi2ss xmm0, ebx
	cvtsi2ss xmm1, DWORD PTR _srcW$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _xscale$[ebp], xmm0

; 243  : 		yscale	= float	(dst.ysize) / float(src.ysize);

	cvtsi2ss xmm0, DWORD PTR _dstH$[ebp]
	cvtsi2ss xmm1, DWORD PTR _srcH$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _yscale$[ebp], xmm0

; 244  : 	} catch (...) {

	fwait

; 246  : 	};

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN152@imf_Proces
__catch$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$0:

; 245  : 		Msg		("imf_Process::1");

	push	OFFSET ??_C@_0P@KHPAJLH@imf_Process?3?31?$AA@
	call	DWORD PTR __imp_?Msg@@YAXPBDZZ
	add	esp, 4

; 246  : 	};

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN326@imf_Proces
	ret	0
$LN326@imf_Proces:
	mov	ebx, DWORD PTR _dstW$[ebp]
$LN152@imf_Proces:

; 247  : 
; 248  : 	/* pre-calculate filter contributions for a row */
; 249  : 	try	{

	mov	DWORD PTR __$EHRec$[ebp+12], 2
	fwait

; 250  : 		contrib = (CLIST *)	xr_malloc	(dst.xsize*sizeof(CLIST));

	lea	esi, DWORD PTR [ebx*8]
	push	esi
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	mov	DWORD PTR _contrib$[ebp], eax

; 251  : 		ZeroMemory(contrib,dst.xsize*sizeof(CLIST));

	push	esi
	push	0
	push	eax
	mov	edx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 252  : 	} catch (...) {

	fwait

; 254  : 	};

	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN327@imf_Proces:
	mov	ebx, DWORD PTR _contrib$[ebp]

; 255  : 	if(xscale < 1.0) {

	movss	xmm0, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR _xscale$[ebp]
	comiss	xmm0, xmm1
	jbe	$LN79@imf_Proces

; 256  : 		try	{

	mov	DWORD PTR __$EHRec$[ebp+12], 4
	fwait

; 257  : 			width	= fwidth / xscale;

	divss	xmm0, xmm1
	movss	xmm1, DWORD PTR _fwidth$[ebp]
	mulss	xmm1, xmm0
	movss	DWORD PTR _width$[ebp], xmm1

; 258  : 			fscale	= 1.0f / xscale;

	movss	DWORD PTR _fscale$[ebp], xmm0

; 259  : 			for(i = 0; i < dst.xsize; ++i)

	xor	edi, edi
$LN389@imf_Proces:
	mov	DWORD PTR _i$[ebp], edi
	cmp	edi, DWORD PTR _dst$[ebp]
	jge	$LN75@imf_Proces

; 260  : 			{
; 261  : 				contrib[i].n	= 0;

	mov	DWORD PTR [ebx+edi*8], 0

; 262  : 				contrib[i].p	= (CONTRIB *)xr_malloc((int) (width * 2 + 1)*sizeof(CONTRIB));

	fld	DWORD PTR _width$[ebp]
	fadd	ST(0), ST(0)
	fadd	DWORD PTR __real@3f800000
	fnstcw	WORD PTR tv1403[ebp]
	movzx	eax, WORD PTR tv1403[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv1400[ebp], eax
	fldcw	WORD PTR tv1400[ebp]
	fistp	QWORD PTR tv1398[ebp]
	fldcw	WORD PTR tv1403[ebp]
	mov	esi, DWORD PTR tv1398[ebp]
	add	esi, esi
	add	esi, esi
	add	esi, esi
	push	esi
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	lea	ecx, DWORD PTR [ebx+edi*8+4]
	mov	DWORD PTR tv1040[ebp], ecx
	mov	DWORD PTR [ecx], eax

; 263  : 				ZeroMemory(contrib[i].p,(int) (width * 2 + 1)*sizeof(CONTRIB));

	push	esi
	push	0
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	edx, DWORD PTR [ecx+12]
	call	edx

; 264  : 				center			= float(i) / xscale;

	cvtsi2ss xmm0, edi
	divss	xmm0, DWORD PTR _xscale$[ebp]
	movss	DWORD PTR _center$[ebp], xmm0

; 265  : 				left			= ceil	(center - width);

	subss	xmm0, DWORD PTR _width$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_ceilf
	add	esp, 4
	fstp	DWORD PTR _left$[ebp]

; 266  : 				right			= floor	(center + width);

	movss	xmm0, DWORD PTR _center$[ebp]
	addss	xmm0, DWORD PTR _width$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_floorf
	add	esp, 4
	fstp	DWORD PTR _right$[ebp]

; 267  : 				for(j = int(left); j <= int(right); ++j)

	cvttss2si esi, DWORD PTR _left$[ebp]
$LN388@imf_Proces:
	mov	DWORD PTR _j$[ebp], esi
	cvttss2si eax, DWORD PTR _right$[ebp]
	cmp	esi, eax
	jg	$LN72@imf_Proces

; 270  : 					weight	= filterf(weight / fscale) / fscale;

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _fscale$[ebp]
	movss	DWORD PTR tv1056[ebp], xmm0
	cvtsi2ss xmm1, esi

; 268  : 				{
; 269  : 					weight	= center - float(j);

	movss	xmm2, DWORD PTR _center$[ebp]
	subss	xmm2, xmm1

; 270  : 					weight	= filterf(weight / fscale) / fscale;

	mulss	xmm2, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm2
	call	DWORD PTR _filterf$[ebp]
	add	esp, 4
	fmul	DWORD PTR tv1056[ebp]
	fstp	DWORD PTR _weight$[ebp]

; 271  : 					if(j < 0) {

	test	esi, esi
	jge	SHORT $LN71@imf_Proces

; 272  : 						n = -j;

	mov	eax, esi
	neg	eax
	jmp	SHORT $LN68@imf_Proces
__catch$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$2:

; 253  : 		Msg		("imf_Process::2");

	push	OFFSET ??_C@_0P@CBFCFKHE@imf_Process?3?32?$AA@
	call	DWORD PTR __imp_?Msg@@YAXPBDZZ
	add	esp, 4

; 254  : 	};

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN327@imf_Proces
	ret	0
$LN71@imf_Proces:

; 273  : 					} else if(j >= src.xsize) {

	mov	eax, DWORD PTR _src$[ebp]
	cmp	esi, eax
	jl	SHORT $LN69@imf_Proces

; 274  : 						n = (src.xsize - j) + src.xsize - 1;

	add	eax, eax
	sub	eax, esi
	sub	eax, 1

; 275  : 					} else {

	jmp	SHORT $LN68@imf_Proces
$LN69@imf_Proces:

; 276  : 						n = j;

	mov	eax, esi
$LN68@imf_Proces:

; 277  : 					}
; 278  : 					k		= contrib[i].n++;

	mov	ecx, DWORD PTR [ebx+edi*8]
	lea	edx, DWORD PTR [ecx+1]
	mov	DWORD PTR [ebx+edi*8], edx

; 279  : 					contrib[i].p[k].pixel	= (n<src.xsize)?n:(src.xsize-1);

	mov	edx, DWORD PTR _src$[ebp]
	cmp	eax, edx
	jl	SHORT $LN118@imf_Proces
	lea	eax, DWORD PTR [edx-1]
$LN118@imf_Proces:
	mov	edx, DWORD PTR tv1040[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [edx+ecx*8], eax

; 280  : 					contrib[i].p[k].weight	= weight;

	mov	eax, DWORD PTR tv1040[ebp]
	mov	edx, DWORD PTR [eax]
	movss	xmm0, DWORD PTR _weight$[ebp]
	movss	DWORD PTR [edx+ecx*8+4], xmm0

; 267  : 				for(j = int(left); j <= int(right); ++j)

	add	esi, 1
	jmp	$LN388@imf_Proces
$LN72@imf_Proces:

; 259  : 			for(i = 0; i < dst.xsize; ++i)

	add	edi, 1
	jmp	$LN389@imf_Proces
$LN75@imf_Proces:

; 281  : 				}
; 282  : 			}

	fwait

; 285  : 		};

	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN158@imf_Proces:

; 315  : 	}
; 316  : 
; 317  : 	/* apply filter to zoom horizontally from src to tmp */
; 318  : 	try	{

	mov	DWORD PTR __$EHRec$[ebp+12], 8
	fwait

; 319  : 		raster	= (Pixel *)xr_malloc(src.xsize*sizeof(Pixel));

	mov	esi, DWORD PTR _src$[ebp]
	add	esi, esi
	add	esi, esi
	push	esi
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	mov	DWORD PTR _raster$[ebp], eax

; 320  : 		ZeroMemory(raster,src.xsize*sizeof(Pixel));

	push	esi
	push	0
	push	eax
	mov	eax, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ecx, DWORD PTR [eax+12]
	call	ecx

; 321  : 	} catch (...) {	Msg		("imf_Process::4");	};

	fwait
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN330@imf_Proces:
	xorps	xmm1, xmm1
	mov	edi, DWORD PTR _contrib$[ebp]
	mov	esi, DWORD PTR _raster$[ebp]

; 322  : 	try	{

	mov	DWORD PTR __$EHRec$[ebp+12], 10		; 0000000aH
	fwait

; 323  : 		for	(k = 0; k < tmp->ysize; ++k)

	xor	eax, eax
	mov	DWORD PTR _k$[ebp], eax
$LL53@imf_Proces:
	mov	edx, DWORD PTR _tmp$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jge	$LN51@imf_Proces

; 324  : 		{
; 325  : 			get_row	(raster, &src, k);

	test	eax, eax
	jl	SHORT $LN210@imf_Proces
	cmp	eax, DWORD PTR _src$[ebp+4]
	jge	SHORT $LN210@imf_Proces
	mov	ecx, DWORD PTR _src$[ebp]
	lea	edx, DWORD PTR [ecx*4]
	push	edx
	imul	eax, DWORD PTR _src$[ebp+12]
	mov	ecx, DWORD PTR _src$[ebp+8]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	push	esi
	call	_memcpy
	add	esp, 12					; 0000000cH
	xorps	xmm1, xmm1
$LN210@imf_Proces:

; 326  : 			for(i = 0; i < tmp->xsize; ++i)

	xor	ebx, ebx
	mov	DWORD PTR _i$[ebp], ebx
	npad	4
$LL50@imf_Proces:
	mov	eax, DWORD PTR _tmp$[ebp]
	cmp	ebx, DWORD PTR [eax]
	jge	$LN48@imf_Proces

; 327  : 			{
; 328  : 				float	w_r	= 0., w_g = 0., w_b	= 0., w_a = 0.;

	movss	DWORD PTR _w_r$115135[ebp], xmm1
	movss	DWORD PTR _w_g$115136[ebp], xmm1
	movss	DWORD PTR _w_b$115137[ebp], xmm1
	movss	DWORD PTR _w_a$115138[ebp], xmm1

; 329  : 
; 330  : 				for	(j = 0; j < contrib[i].n; ++j)

	xor	ecx, ecx
	mov	DWORD PTR _j$[ebp], ecx
	fld	DWORD PTR _w_r$115135[ebp]
	fld	DWORD PTR _w_g$115136[ebp]
	fld	DWORD PTR _w_b$115137[ebp]
	fld	DWORD PTR _w_a$115138[ebp]
	jmp	$LN47@imf_Proces
__catch$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$4:

; 283  : 		} catch (...) {
; 284  : 			Msg		("imf_Process::3 (xscale<1.0)");

	push	OFFSET ??_C@_0BM@BEBDFIJA@imf_Process?3?33?5?$CIxscale?$DM1?40?$CJ?$AA@
	call	DWORD PTR __imp_?Msg@@YAXPBDZZ
	add	esp, 4

; 285  : 		};

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN158@imf_Proces
	ret	0
$LN79@imf_Proces:

; 286  : 	} else {
; 287  : 		try	{

	mov	DWORD PTR __$EHRec$[ebp+12], 6
	fwait

; 288  : 			for(i = 0; i < dst.xsize; ++i)

	xor	edi, edi
$LN391@imf_Proces:
	mov	DWORD PTR _i$[ebp], edi
	cmp	edi, DWORD PTR _dst$[ebp]
	jge	$LN63@imf_Proces

; 289  : 			{
; 290  : 				contrib[i].n	= 0;

	mov	DWORD PTR [ebx+edi*8], 0

; 291  : 				contrib[i].p	= (CONTRIB *)xr_malloc((int) (fwidth * 2 + 1)*sizeof(CONTRIB));

	fld	DWORD PTR _fwidth$[ebp]
	fadd	ST(0), ST(0)
	fadd	DWORD PTR __real@3f800000
	fnstcw	WORD PTR tv1374[ebp]
	movzx	eax, WORD PTR tv1374[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv1371[ebp], eax
	fldcw	WORD PTR tv1371[ebp]
	fistp	QWORD PTR tv1369[ebp]
	fldcw	WORD PTR tv1374[ebp]
	mov	esi, DWORD PTR tv1369[ebp]
	add	esi, esi
	add	esi, esi
	add	esi, esi
	push	esi
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	lea	ecx, DWORD PTR [ebx+edi*8+4]
	mov	DWORD PTR tv1040[ebp], ecx
	mov	DWORD PTR [ecx], eax

; 292  : 				ZeroMemory(contrib[i].p,(int) (fwidth * 2 + 1)*sizeof(CONTRIB));

	push	esi
	push	0
	push	eax
	mov	eax, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ecx, DWORD PTR [eax+12]
	call	ecx

; 293  : 				center			= float(i) / xscale;

	cvtsi2ss xmm0, edi
	divss	xmm0, DWORD PTR _xscale$[ebp]
	movss	DWORD PTR _center$[ebp], xmm0

; 294  : 				left			= ceil	(center - fwidth);

	subss	xmm0, DWORD PTR _fwidth$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_ceilf
	add	esp, 4
	fstp	DWORD PTR _left$[ebp]

; 295  : 				right			= floor	(center + fwidth);

	movss	xmm0, DWORD PTR _center$[ebp]
	addss	xmm0, DWORD PTR _fwidth$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_floorf
	add	esp, 4
	fstp	DWORD PTR _right$[ebp]

; 296  : 				for(j = int(left); j <= int(right); ++j)

	cvttss2si esi, DWORD PTR _left$[ebp]
$LN390@imf_Proces:
	mov	DWORD PTR _j$[ebp], esi
	cvttss2si edx, DWORD PTR _right$[ebp]
	cmp	esi, edx
	jg	SHORT $LN60@imf_Proces

; 299  : 					weight	= (*filterf)(weight);

	cvtsi2ss xmm0, esi

; 297  : 				{
; 298  : 					weight	= center - (float) j;

	movss	xmm1, DWORD PTR _center$[ebp]
	subss	xmm1, xmm0

; 299  : 					weight	= (*filterf)(weight);

	push	ecx
	movss	DWORD PTR [esp], xmm1
	call	DWORD PTR _filterf$[ebp]
	add	esp, 4
	fstp	DWORD PTR _weight$[ebp]

; 300  : 					if(j < 0) {

	test	esi, esi
	jge	SHORT $LN59@imf_Proces

; 301  : 						n = -j;

	mov	eax, esi
	neg	eax
	jmp	SHORT $LN56@imf_Proces
$LN59@imf_Proces:

; 302  : 					} else if(j >= src.xsize) {

	mov	eax, DWORD PTR _src$[ebp]
	cmp	esi, eax
	jl	SHORT $LN57@imf_Proces

; 303  : 						n = (src.xsize - j) + src.xsize - 1;

	add	eax, eax
	sub	eax, esi
	sub	eax, 1

; 304  : 					} else {

	jmp	SHORT $LN56@imf_Proces
$LN57@imf_Proces:

; 305  : 						n = j;

	mov	eax, esi
$LN56@imf_Proces:

; 306  : 					}
; 307  : 					k		= contrib[i].n++;

	mov	ecx, DWORD PTR [ebx+edi*8]
	lea	edx, DWORD PTR [ecx+1]
	mov	DWORD PTR [ebx+edi*8], edx

; 308  : 					contrib[i].p[k].pixel	= (n<src.xsize)?n:(src.xsize-1);

	mov	edx, DWORD PTR _src$[ebp]
	cmp	eax, edx
	jl	SHORT $LN120@imf_Proces
	lea	eax, DWORD PTR [edx-1]
$LN120@imf_Proces:
	mov	edx, DWORD PTR tv1040[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [edx+ecx*8], eax

; 309  : 					contrib[i].p[k].weight	= weight;

	mov	eax, DWORD PTR tv1040[ebp]
	mov	edx, DWORD PTR [eax]
	movss	xmm0, DWORD PTR _weight$[ebp]
	movss	DWORD PTR [edx+ecx*8+4], xmm0

; 296  : 				for(j = int(left); j <= int(right); ++j)

	add	esi, 1
	jmp	SHORT $LN390@imf_Proces
$LN60@imf_Proces:

; 288  : 			for(i = 0; i < dst.xsize; ++i)

	add	edi, 1
	jmp	$LN391@imf_Proces
$LN63@imf_Proces:

; 310  : 				}
; 311  : 			}

	fwait

; 314  : 		};

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	$LN158@imf_Proces
__catch$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$6:

; 312  : 		} catch (...) {
; 313  : 			Msg		("imf_Process::3 (xscale>1.0)");

	push	OFFSET ??_C@_0BM@FJNLPJJL@imf_Process?3?33?5?$CIxscale?$DO1?40?$CJ?$AA@
	call	DWORD PTR __imp_?Msg@@YAXPBDZZ
	add	esp, 4

; 314  : 		};

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN158@imf_Proces
	ret	0
__catch$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$8:

; 321  : 	} catch (...) {	Msg		("imf_Process::4");	};

	push	OFFSET ??_C@_0P@HHAIPNPC@imf_Process?3?34?$AA@
	call	DWORD PTR __imp_?Msg@@YAXPBDZZ
	add	esp, 4
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN330@imf_Proces
	ret	0
$LN363@imf_Proces:

; 338  : 				}

	fxch	ST(2)
	fxch	ST(3)
	fxch	ST(1)
	fxch	ST(2)
$LN47@imf_Proces:

; 329  : 
; 330  : 				for	(j = 0; j < contrib[i].n; ++j)

	cmp	ecx, DWORD PTR [edi+ebx*8]
	jge	$LN346@imf_Proces

; 331  : 				{
; 332  : 					float	W	=	contrib[i].p[j].weight;

	mov	edx, DWORD PTR [edi+ebx*8+4]
	lea	eax, DWORD PTR [edx+ecx*8]
	movss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR _W$115142[ebp], xmm0

; 333  : 					Pixel	P	=	raster[contrib[i].p[j].pixel];

	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [esi+eax*4]

; 334  : 					w_r			+=	W*float(color_get_R(P));

	mov	edx, eax
	shr	edx, 16					; 00000010H
	and	edx, 255				; 000000ffH
	mov	DWORD PTR tv1341[ebp], edx
	fild	DWORD PTR tv1341[ebp]
	fld	DWORD PTR _W$115142[ebp]
	fmul	ST(1), ST(0)
	fxch	ST(1)
	faddp	ST(5), ST(0)
	fxch	ST(4)
	fst	DWORD PTR _w_r$115135[ebp]

; 335  : 					w_g			+=	W*float(color_get_G(P));

	mov	edx, eax
	shr	edx, 8
	and	edx, 255				; 000000ffH
	mov	DWORD PTR tv1340[ebp], edx
	fild	DWORD PTR tv1340[ebp]
	fmul	ST(0), ST(5)
	faddp	ST(4), ST(0)
	fxch	ST(3)
	fst	DWORD PTR _w_g$115136[ebp]

; 336  : 					w_b			+=	W*float(color_get_B(P));

	movzx	edx, al
	mov	DWORD PTR tv1339[ebp], edx
	fild	DWORD PTR tv1339[ebp]
	fmul	ST(0), ST(5)
	faddp	ST(3), ST(0)
	fxch	ST(2)
	fst	DWORD PTR _w_b$115137[ebp]

; 337  : 					w_a			+=	W*float(color_get_A(P));

	shr	eax, 24					; 00000018H
	mov	DWORD PTR tv1338[ebp], eax
	fild	DWORD PTR tv1338[ebp]
	test	eax, eax
	jge	SHORT $LN384@imf_Proces
	fadd	DWORD PTR __real@4f800000
$LN384@imf_Proces:
	fmulp	ST(5), ST(0)
	fxch	ST(4)
	faddp	ST(1), ST(0)
	fst	DWORD PTR _w_a$115138[ebp]

; 329  : 
; 330  : 				for	(j = 0; j < contrib[i].n; ++j)

	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
	jmp	$LN363@imf_Proces
$LN346@imf_Proces:
	fstp	ST(0)
	fstp	ST(0)
	fstp	ST(0)
	fstp	ST(0)

; 339  : 				put_pixel(tmp, i, k, color_rgba(CC(w_r),CC(w_g),CC(w_b),CC(w_a+0.5f)));

	movss	xmm0, DWORD PTR _w_a$115138[ebp]
	addss	xmm0, DWORD PTR __real@3f000000
	call	?CC@@YAIM@Z				; CC
	mov	edi, eax
	movss	xmm0, DWORD PTR _w_b$115137[ebp]
	call	?CC@@YAIM@Z				; CC
	mov	DWORD PTR $T367887[ebp], eax
	movss	xmm0, DWORD PTR _w_g$115136[ebp]
	call	?CC@@YAIM@Z				; CC
	mov	DWORD PTR $T367886[ebp], eax
	movss	xmm0, DWORD PTR _w_r$115135[ebp]
	call	?CC@@YAIM@Z				; CC
	and	eax, 255				; 000000ffH
	shl	edi, 8
	or	eax, edi
	shl	eax, 8
	movzx	ecx, BYTE PTR $T367886[ebp]
	or	eax, ecx
	shl	eax, 8
	movzx	edx, BYTE PTR $T367887[ebp]
	or	eax, edx
	mov	esi, DWORD PTR _k$[ebp]
	mov	edx, ebx
	mov	ecx, DWORD PTR _tmp$[ebp]
	call	?put_pixel@@YAIPAUImage@@HHI@Z		; put_pixel

; 326  : 			for(i = 0; i < tmp->xsize; ++i)

	add	ebx, 1
	mov	DWORD PTR _i$[ebp], ebx
	mov	edi, DWORD PTR _contrib$[ebp]
	mov	esi, DWORD PTR _raster$[ebp]
	jmp	$LL50@imf_Proces
$LN48@imf_Proces:

; 323  : 		for	(k = 0; k < tmp->ysize; ++k)

	add	DWORD PTR _k$[ebp], 1
	mov	eax, DWORD PTR _k$[ebp]
	jmp	$LL53@imf_Proces
$LN51@imf_Proces:

; 340  : 			}
; 341  : 		}
; 342  : 		xr_free(raster);

	lea	esi, DWORD PTR _raster$[ebp]
	call	??$xr_free@I@@YAXAAPAI@Z		; xr_free<unsigned int>
	fwait

; 343  : 	} catch (...) {	Msg		("imf_Process::5");	};

	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN331@imf_Proces:
	mov	edi, DWORD PTR _contrib$[ebp]

; 344  : 
; 345  : 	/* xr_free the memory allocated for horizontal filter weights */
; 346  : 	try	{

	mov	DWORD PTR __$EHRec$[ebp+12], 12		; 0000000cH
	fwait

; 347  : 		for(i = 0; i < tmp->xsize; ++i) xr_free(contrib[i].p);

	xor	esi, esi
	mov	DWORD PTR _i$[ebp], esi
	mov	ebx, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LL43@imf_Proces:
	mov	eax, DWORD PTR _tmp$[ebp]
	cmp	esi, DWORD PTR [eax]
	jge	SHORT $LN41@imf_Proces
	cmp	DWORD PTR [edi+esi*8+4], 0
	je	SHORT $LN224@imf_Proces
	mov	ecx, DWORD PTR [edi+esi*8+4]
	push	ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	ebx
	mov	DWORD PTR [edi+esi*8+4], 0
$LN224@imf_Proces:
	add	esi, 1
	mov	DWORD PTR _i$[ebp], esi
	jmp	SHORT $LL43@imf_Proces
__catch$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$10:

; 343  : 	} catch (...) {	Msg		("imf_Process::5");	};

	push	OFFSET ??_C@_0P@GOBDMMLD@imf_Process?3?35?$AA@
	call	DWORD PTR __imp_?Msg@@YAXPBDZZ
	add	esp, 4
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN331@imf_Proces
	ret	0
$LN41@imf_Proces:

; 348  : 		xr_free(contrib);

	test	edi, edi
	je	SHORT $LN227@imf_Proces
	push	edi
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	ebx
	mov	DWORD PTR _contrib$[ebp], 0
$LN227@imf_Proces:
	fwait

; 349  : 	} catch (...) {	Msg		("imf_Process::6");	};

	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN164@imf_Proces:

; 350  : 
; 351  : 	/* pre-calculate filter contributions for a column */
; 352  : 	try	{

	mov	DWORD PTR __$EHRec$[ebp+12], 14		; 0000000eH
	fwait

; 353  : 		contrib = (CLIST *)xr_malloc(dst.ysize*sizeof(CLIST));

	mov	esi, DWORD PTR _dst$[ebp+4]
	add	esi, esi
	add	esi, esi
	add	esi, esi
	push	esi
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	mov	ebx, eax
	mov	DWORD PTR _contrib$[ebp], ebx

; 354  : 		ZeroMemory(contrib,dst.ysize*sizeof(CLIST));

	push	esi
	push	0
	push	ebx
	mov	edx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 355  : 	} catch (...) {	Msg		("imf_Process::7");	};

	fwait
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN166@imf_Proces
__catch$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$12:

; 349  : 	} catch (...) {	Msg		("imf_Process::6");	};

	push	OFFSET ??_C@_0P@EFDOJPHA@imf_Process?3?36?$AA@
	call	DWORD PTR __imp_?Msg@@YAXPBDZZ
	add	esp, 4
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN164@imf_Proces
	ret	0
__catch$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$14:

; 355  : 	} catch (...) {	Msg		("imf_Process::7");	};

	push	OFFSET ??_C@_0P@FMCFKODB@imf_Process?3?37?$AA@
	call	DWORD PTR __imp_?Msg@@YAXPBDZZ
	add	esp, 4
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN333@imf_Proces
	ret	0
$LN333@imf_Proces:
	mov	ebx, DWORD PTR _contrib$[ebp]
$LN166@imf_Proces:

; 356  : 	if(yscale < 1.0) {

	movss	xmm0, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR _yscale$[ebp]
	comiss	xmm0, xmm1
	jbe	$LN39@imf_Proces

; 357  : 		try	{

	mov	DWORD PTR __$EHRec$[ebp+12], 16		; 00000010H
	fwait

; 358  : 			width	= fwidth / yscale;

	divss	xmm0, xmm1
	movaps	xmm1, xmm0
	mulss	xmm1, DWORD PTR _fwidth$[ebp]
	movss	DWORD PTR _width$[ebp], xmm1

; 359  : 			fscale	= 1.0f / yscale;

	movss	DWORD PTR _fscale$[ebp], xmm0

; 360  : 			for	(i = 0; i < dst.ysize; ++i)

	xor	edi, edi
$LN393@imf_Proces:
	mov	DWORD PTR _i$[ebp], edi
	cmp	edi, DWORD PTR _dst$[ebp+4]
	jge	$LN23@imf_Proces

; 361  : 			{
; 362  : 				contrib[i].n	= 0;

	mov	DWORD PTR [ebx+edi*8], 0

; 363  : 				contrib[i].p	= (CONTRIB *)xr_malloc((int) (width * 2 + 1)*sizeof(CONTRIB));

	fld	DWORD PTR _width$[ebp]
	fadd	ST(0), ST(0)
	fadd	DWORD PTR __real@3f800000
	fnstcw	WORD PTR tv1321[ebp]
	movzx	eax, WORD PTR tv1321[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv1318[ebp], eax
	fldcw	WORD PTR tv1318[ebp]
	fistp	QWORD PTR tv1316[ebp]
	fldcw	WORD PTR tv1321[ebp]
	mov	esi, DWORD PTR tv1316[ebp]
	add	esi, esi
	add	esi, esi
	add	esi, esi
	push	esi
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	mov	DWORD PTR [ebx+edi*8+4], eax

; 364  : 				ZeroMemory(contrib[i].p,(int) (width * 2 + 1)*sizeof(CONTRIB));

	push	esi
	push	0
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	edx, DWORD PTR [ecx+12]
	call	edx

; 365  : 				center			= (float) i / yscale;

	cvtsi2ss xmm0, edi
	divss	xmm0, DWORD PTR _yscale$[ebp]
	movss	DWORD PTR _center$[ebp], xmm0

; 366  : 				left			= ceil	(center - width);

	subss	xmm0, DWORD PTR _width$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_ceilf
	add	esp, 4
	fstp	DWORD PTR _left$[ebp]

; 367  : 				right			= floor	(center + width);

	movss	xmm0, DWORD PTR _center$[ebp]
	addss	xmm0, DWORD PTR _width$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_floorf
	add	esp, 4
	fstp	DWORD PTR _right$[ebp]

; 368  : 				for(j = int(left); j <= int(right); ++j)

	cvttss2si esi, DWORD PTR _left$[ebp]
$LN392@imf_Proces:
	mov	DWORD PTR _j$[ebp], esi
	cvttss2si eax, DWORD PTR _right$[ebp]
	cmp	esi, eax
	jg	$LN32@imf_Proces

; 371  : 					weight	= filterf(weight / fscale) / fscale;

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _fscale$[ebp]
	movss	DWORD PTR tv1056[ebp], xmm0
	cvtsi2ss xmm1, esi

; 369  : 				{
; 370  : 					weight	= center - (float) j;

	movss	xmm2, DWORD PTR _center$[ebp]
	subss	xmm2, xmm1

; 371  : 					weight	= filterf(weight / fscale) / fscale;

	mulss	xmm2, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm2
	call	DWORD PTR _filterf$[ebp]
	add	esp, 4
	fmul	DWORD PTR tv1056[ebp]
	fstp	DWORD PTR _weight$[ebp]

; 372  : 					if(j < 0) {

	test	esi, esi
	jge	SHORT $LN31@imf_Proces

; 373  : 						n = -j;

	mov	eax, esi
	neg	eax
	jmp	SHORT $LN28@imf_Proces
$LN31@imf_Proces:

; 374  : 					} else if(j >= tmp->ysize) {

	mov	eax, DWORD PTR _tmp$[ebp]
	cmp	esi, DWORD PTR [eax+4]
	jl	SHORT $LN29@imf_Proces

; 375  : 						n = (tmp->ysize - j) + tmp->ysize - 1;

	mov	eax, DWORD PTR [eax+4]
	add	eax, eax
	sub	eax, esi
	sub	eax, 1

; 376  : 					} else {

	jmp	SHORT $LN28@imf_Proces
$LN29@imf_Proces:

; 377  : 						n = j;

	mov	eax, esi
$LN28@imf_Proces:

; 378  : 					}
; 379  : 					k = contrib[i].n++;

	mov	ecx, DWORD PTR [ebx+edi*8]
	lea	edx, DWORD PTR [ecx+1]
	mov	DWORD PTR [ebx+edi*8], edx

; 380  : 					contrib[i].p[k].pixel	= (n<tmp->ysize)?n:(tmp->ysize-1);

	mov	edx, DWORD PTR _tmp$[ebp]
	mov	edx, DWORD PTR [edx+4]
	cmp	eax, edx
	jl	SHORT $LN122@imf_Proces
	lea	eax, DWORD PTR [edx-1]
$LN122@imf_Proces:
	mov	edx, DWORD PTR [ebx+edi*8+4]
	mov	DWORD PTR [edx+ecx*8], eax

; 381  : 					contrib[i].p[k].weight	= weight;

	mov	eax, DWORD PTR [ebx+edi*8+4]
	movss	xmm0, DWORD PTR _weight$[ebp]
	movss	DWORD PTR [eax+ecx*8+4], xmm0

; 368  : 				for(j = int(left); j <= int(right); ++j)

	add	esi, 1
	jmp	$LN392@imf_Proces
$LN32@imf_Proces:

; 360  : 			for	(i = 0; i < dst.ysize; ++i)

	add	edi, 1
	jmp	$LN393@imf_Proces
__catch$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$16:

; 382  : 				}
; 383  : 			}
; 384  : 		} catch (...) {	Msg		("imf_Process::8 (yscale<1.0)");	};

	push	OFFSET ??_C@_0BM@FBECLCAB@imf_Process?3?38?5?$CIyscale?$DM1?40?$CJ?$AA@
	call	DWORD PTR __imp_?Msg@@YAXPBDZZ
	add	esp, 4
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN335@imf_Proces
	ret	0
$LN39@imf_Proces:

; 385  : 	} else {
; 386  : 		try	{

	mov	DWORD PTR __$EHRec$[ebp+12], 18		; 00000012H
	fwait

; 387  : 			for(i = 0; i < dst.ysize; ++i)

	xor	edi, edi
$LN395@imf_Proces:
	mov	DWORD PTR _i$[ebp], edi
	cmp	edi, DWORD PTR _dst$[ebp+4]
	jge	$LN23@imf_Proces

; 388  : 			{
; 389  : 				contrib[i].n	= 0;

	mov	DWORD PTR [ebx+edi*8], 0

; 390  : 				contrib[i].p	= (CONTRIB *)xr_malloc((int) (fwidth * 2 + 1)*sizeof(CONTRIB));

	fld	DWORD PTR _fwidth$[ebp]
	fadd	ST(0), ST(0)
	fadd	DWORD PTR __real@3f800000
	fnstcw	WORD PTR tv1292[ebp]
	movzx	eax, WORD PTR tv1292[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv1289[ebp], eax
	fldcw	WORD PTR tv1289[ebp]
	fistp	QWORD PTR tv1287[ebp]
	fldcw	WORD PTR tv1292[ebp]
	mov	esi, DWORD PTR tv1287[ebp]
	add	esi, esi
	add	esi, esi
	add	esi, esi
	push	esi
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	mov	DWORD PTR [ebx+edi*8+4], eax

; 391  : 				ZeroMemory(contrib[i].p,(int) (fwidth * 2 + 1)*sizeof(CONTRIB));

	push	esi
	push	0
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	edx, DWORD PTR [ecx+12]
	call	edx

; 392  : 				center			= (float) i / yscale;

	cvtsi2ss xmm0, edi
	divss	xmm0, DWORD PTR _yscale$[ebp]
	movss	DWORD PTR _center$[ebp], xmm0

; 393  : 				left			= ceil	(center - fwidth);

	subss	xmm0, DWORD PTR _fwidth$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_ceilf
	add	esp, 4
	fstp	DWORD PTR _left$[ebp]

; 394  : 				right			= floor	(center + fwidth);

	movss	xmm0, DWORD PTR _center$[ebp]
	addss	xmm0, DWORD PTR _fwidth$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_floorf
	add	esp, 4
	fstp	DWORD PTR _right$[ebp]

; 395  : 				for(j = int(left); j <= int(right); ++j) {

	cvttss2si esi, DWORD PTR _left$[ebp]
$LN394@imf_Proces:
	mov	DWORD PTR _j$[ebp], esi
	cvttss2si eax, DWORD PTR _right$[ebp]
	cmp	esi, eax
	jg	SHORT $LN20@imf_Proces

; 397  : 					weight = (*filterf)(weight);

	cvtsi2ss xmm0, esi

; 396  : 					weight = center - (float) j;

	movss	xmm1, DWORD PTR _center$[ebp]
	subss	xmm1, xmm0

; 397  : 					weight = (*filterf)(weight);

	push	ecx
	movss	DWORD PTR [esp], xmm1
	call	DWORD PTR _filterf$[ebp]
	add	esp, 4
	fstp	DWORD PTR _weight$[ebp]

; 398  : 					if(j < 0) {

	test	esi, esi
	jge	SHORT $LN19@imf_Proces

; 399  : 						n = -j;

	mov	eax, esi
	neg	eax
	jmp	SHORT $LN16@imf_Proces
$LN19@imf_Proces:

; 400  : 					} else if(j >= tmp->ysize) {

	mov	eax, DWORD PTR _tmp$[ebp]
	cmp	esi, DWORD PTR [eax+4]
	jl	SHORT $LN17@imf_Proces

; 401  : 						n = (tmp->ysize - j) + tmp->ysize - 1;

	mov	eax, DWORD PTR [eax+4]
	add	eax, eax
	sub	eax, esi
	sub	eax, 1

; 402  : 					} else {

	jmp	SHORT $LN16@imf_Proces
$LN17@imf_Proces:

; 403  : 						n = j;

	mov	eax, esi
$LN16@imf_Proces:

; 404  : 					}
; 405  : 					k = contrib[i].n++;

	mov	ecx, DWORD PTR [ebx+edi*8]
	lea	edx, DWORD PTR [ecx+1]
	mov	DWORD PTR [ebx+edi*8], edx

; 406  : 					contrib[i].p[k].pixel	= (n<tmp->ysize)?n:(tmp->ysize-1);

	mov	edx, DWORD PTR _tmp$[ebp]
	mov	edx, DWORD PTR [edx+4]
	cmp	eax, edx
	jl	SHORT $LN124@imf_Proces
	lea	eax, DWORD PTR [edx-1]
$LN124@imf_Proces:
	mov	edx, DWORD PTR [ebx+edi*8+4]
	mov	DWORD PTR [edx+ecx*8], eax

; 407  : 					contrib[i].p[k].weight	= weight;

	mov	eax, DWORD PTR [ebx+edi*8+4]
	movss	xmm0, DWORD PTR _weight$[ebp]
	movss	DWORD PTR [eax+ecx*8+4], xmm0

; 395  : 				for(j = int(left); j <= int(right); ++j) {

	add	esi, 1
	jmp	SHORT $LN394@imf_Proces
$LN20@imf_Proces:

; 387  : 			for(i = 0; i < dst.ysize; ++i)

	add	edi, 1
	jmp	$LN395@imf_Proces
$LN23@imf_Proces:

; 408  : 				}
; 409  : 			}

	fwait

; 410  : 		} catch (...) {	Msg		("imf_Process::8 (yscale>1.0)");	};

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN170@imf_Proces
__catch$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$18:
	push	OFFSET ??_C@_0BM@BMIKBDAK@imf_Process?3?38?5?$CIyscale?$DO1?40?$CJ?$AA@
	call	DWORD PTR __imp_?Msg@@YAXPBDZZ
	add	esp, 4
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN335@imf_Proces
	ret	0
$LN335@imf_Proces:
	mov	ebx, DWORD PTR _contrib$[ebp]
$LN170@imf_Proces:

; 411  : 	}
; 412  : 
; 413  : 	/* apply filter to zoom vertically from tmp to dst */
; 414  : 	try	{

	mov	DWORD PTR __$EHRec$[ebp+12], 20		; 00000014H
	fwait

; 415  : 		raster = (Pixel *)xr_malloc(tmp->ysize*sizeof(Pixel));

	mov	esi, DWORD PTR _tmp$[ebp]
	mov	eax, DWORD PTR [esi+4]
	add	eax, eax
	add	eax, eax
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	mov	DWORD PTR _raster$[ebp], eax

; 416  : 		ZeroMemory(raster,tmp->ysize*sizeof(Pixel));

	mov	ecx, DWORD PTR [esi+4]
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	0
	push	eax
	mov	edx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 417  : 	} catch (...) {	Msg		("imf_Process::9");	};

	fwait
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN396@imf_Proces
__catch$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$20:
	push	OFFSET ??_C@_0P@MCKGIDLP@imf_Process?3?39?$AA@
	call	DWORD PTR __imp_?Msg@@YAXPBDZZ
	add	esp, 4
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN336@imf_Proces
	ret	0
$LN336@imf_Proces:
	mov	ebx, DWORD PTR _contrib$[ebp]
$LN396@imf_Proces:
	movss	xmm2, DWORD PTR __real@3f000000
	xorps	xmm1, xmm1
	mov	eax, DWORD PTR _tmp$[ebp]

; 418  : 	try	{

	mov	DWORD PTR __$EHRec$[ebp+12], 22		; 00000016H
	fwait

; 419  : 		for(k = 0; k < dst.xsize; ++k)

	xor	edi, edi
	mov	DWORD PTR _k$[ebp], edi
	npad	2
$LL13@imf_Proces:
	cmp	edi, DWORD PTR _dst$[ebp]
	jge	$LN11@imf_Proces

; 420  : 		{
; 421  : 			get_column	(raster, tmp, k);

	mov	ecx, DWORD PTR _raster$[ebp]
	mov	DWORD PTR $T367941[ebp], ecx
	test	edi, edi
	jl	SHORT $LN259@imf_Proces
	cmp	edi, DWORD PTR [eax]
	jge	SHORT $LN259@imf_Proces
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _d$367933[ebp], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _i$367932[ebp], edx
	mov	eax, DWORD PTR [eax+8]
	lea	eax, DWORD PTR [eax+edi*4]
$LN397@imf_Proces:
	mov	DWORD PTR _p$367934[ebp], eax
	mov	esi, edx
	sub	edx, 1
	mov	DWORD PTR _i$367932[ebp], edx
	test	esi, esi
	jle	SHORT $LN259@imf_Proces
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [ecx], esi
	add	ecx, 4
	mov	DWORD PTR $T367941[ebp], ecx
	mov	esi, DWORD PTR _d$367933[ebp]
	lea	eax, DWORD PTR [eax+esi*4]
	jmp	SHORT $LN397@imf_Proces
$LN259@imf_Proces:

; 422  : 			for(i = 0; i < dst.ysize; ++i)

	xor	esi, esi
	mov	DWORD PTR _i$[ebp], esi
$LN398@imf_Proces:
	mov	edx, DWORD PTR _raster$[ebp]
	cmp	esi, DWORD PTR _dst$[ebp+4]
	jge	$LN8@imf_Proces

; 423  : 			{
; 424  : 				float	w_r	= 0., w_g = 0., w_b	= 0., w_a = 0.;

	movss	DWORD PTR _w_r$115215[ebp], xmm1
	movss	DWORD PTR _w_g$115216[ebp], xmm1
	movss	DWORD PTR _w_b$115217[ebp], xmm1
	movss	DWORD PTR _w_a$115218[ebp], xmm1

; 425  : 
; 426  : 				for	(j = 0; j < contrib[i].n; ++j)

	xor	ecx, ecx
	mov	DWORD PTR _j$[ebp], ecx
	fld	DWORD PTR _w_r$115215[ebp]
	fld	DWORD PTR _w_g$115216[ebp]
	fld	DWORD PTR _w_b$115217[ebp]
	fld	DWORD PTR _w_a$115218[ebp]
	jmp	SHORT $LN7@imf_Proces
$LN383@imf_Proces:

; 434  : 				}

	fxch	ST(2)
	fxch	ST(3)
	fxch	ST(1)
	fxch	ST(2)
$LN7@imf_Proces:

; 425  : 
; 426  : 				for	(j = 0; j < contrib[i].n; ++j)

	cmp	ecx, DWORD PTR [ebx+esi*8]
	jge	$LN366@imf_Proces

; 427  : 				{
; 428  : 					float	W	=	contrib[i].p[j].weight;

	mov	eax, DWORD PTR [ebx+esi*8+4]
	lea	eax, DWORD PTR [eax+ecx*8]
	movss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR _W$115222[ebp], xmm0

; 429  : 					Pixel	P	=	raster[contrib[i].p[j].pixel];

	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+eax*4]

; 430  : 					w_r			+=	W*float(color_get_R(P));

	mov	edi, eax
	shr	edi, 16					; 00000010H
	and	edi, 255				; 000000ffH
	mov	DWORD PTR tv1257[ebp], edi
	fild	DWORD PTR tv1257[ebp]
	fld	DWORD PTR _W$115222[ebp]
	fmul	ST(1), ST(0)
	fxch	ST(1)
	faddp	ST(5), ST(0)
	fxch	ST(4)
	fst	DWORD PTR _w_r$115215[ebp]

; 431  : 					w_g			+=	W*float(color_get_G(P));

	mov	edi, eax
	shr	edi, 8
	and	edi, 255				; 000000ffH
	mov	DWORD PTR tv1256[ebp], edi
	fild	DWORD PTR tv1256[ebp]
	fmul	ST(0), ST(5)
	faddp	ST(4), ST(0)
	fxch	ST(3)
	fst	DWORD PTR _w_g$115216[ebp]

; 432  : 					w_b			+=	W*float(color_get_B(P));

	movzx	edi, al
	mov	DWORD PTR tv1255[ebp], edi
	fild	DWORD PTR tv1255[ebp]
	fmul	ST(0), ST(5)
	faddp	ST(3), ST(0)
	fxch	ST(2)
	fst	DWORD PTR _w_b$115217[ebp]

; 433  : 					w_a			+=	W*float(color_get_A(P));

	shr	eax, 24					; 00000018H
	mov	DWORD PTR tv1254[ebp], eax
	fild	DWORD PTR tv1254[ebp]
	test	eax, eax
	jge	SHORT $LN385@imf_Proces
	fadd	DWORD PTR __real@4f800000
$LN385@imf_Proces:
	fmulp	ST(5), ST(0)
	fxch	ST(4)
	faddp	ST(1), ST(0)
	fst	DWORD PTR _w_a$115218[ebp]

; 425  : 
; 426  : 				for	(j = 0; j < contrib[i].n; ++j)

	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
	jmp	$LN383@imf_Proces
$LN366@imf_Proces:
	fstp	ST(0)
	fstp	ST(0)
	fstp	ST(0)
	fstp	ST(0)

; 435  : 				put_pixel(&dst, k, i, color_rgba(CC(w_r),CC(w_g),CC(w_b),CC(w_a+0.5f)));

	movss	xmm0, DWORD PTR _w_a$115218[ebp]
	addss	xmm0, xmm2
	call	?CC@@YAIM@Z				; CC
	mov	edi, eax
	movss	xmm0, DWORD PTR _w_b$115217[ebp]
	call	?CC@@YAIM@Z				; CC
	mov	DWORD PTR $T367963[ebp], eax
	movss	xmm0, DWORD PTR _w_g$115216[ebp]
	call	?CC@@YAIM@Z				; CC
	mov	DWORD PTR $T367962[ebp], eax
	movss	xmm0, DWORD PTR _w_r$115215[ebp]
	call	?CC@@YAIM@Z				; CC
	and	eax, 255				; 000000ffH
	shl	edi, 8
	or	eax, edi
	shl	eax, 8
	movzx	ecx, BYTE PTR $T367962[ebp]
	or	eax, ecx
	shl	eax, 8
	movzx	edx, BYTE PTR $T367963[ebp]
	or	eax, edx
	mov	edx, DWORD PTR _k$[ebp]
	lea	ecx, DWORD PTR _dst$[ebp]
	call	?put_pixel@@YAIPAUImage@@HHI@Z		; put_pixel

; 422  : 			for(i = 0; i < dst.ysize; ++i)

	add	esi, 1
	mov	DWORD PTR _i$[ebp], esi
	mov	edi, edx
	jmp	$LN398@imf_Proces
$LN8@imf_Proces:

; 419  : 		for(k = 0; k < dst.xsize; ++k)

	add	edi, 1
	mov	DWORD PTR _k$[ebp], edi
	mov	eax, DWORD PTR _tmp$[ebp]
	jmp	$LL13@imf_Proces
$LN11@imf_Proces:

; 436  : 			}
; 437  : 
; 438  : 		}
; 439  : 		xr_free(raster);

	lea	esi, DWORD PTR _raster$[ebp]
	call	??$xr_free@I@@YAXAAPAI@Z		; xr_free<unsigned int>
	fwait

; 440  : 	} catch (...) {	Msg		("imf_Process::A");	};

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN399@imf_Proces
__catch$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$22:
	push	OFFSET ??_C@_0P@CFEAHAEB@imf_Process?3?3A?$AA@
	call	DWORD PTR __imp_?Msg@@YAXPBDZZ
	add	esp, 4
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN337@imf_Proces
	ret	0
$LN337@imf_Proces:
	mov	ebx, DWORD PTR _contrib$[ebp]
$LN399@imf_Proces:
	mov	edi, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 441  : 
; 442  : 	/* xr_free the memory allocated for vertical filter weights */
; 443  : 	try	{

	mov	DWORD PTR __$EHRec$[ebp+12], 24		; 00000018H
	fwait

; 444  : 		for	(i = 0; i < dst.ysize; ++i) xr_free(contrib[i].p);

	xor	esi, esi
$LN400@imf_Proces:
	mov	DWORD PTR _i$[ebp], esi
	cmp	esi, DWORD PTR _dst$[ebp+4]
	jge	SHORT $LN1@imf_Proces
	cmp	DWORD PTR [ebx+esi*8+4], 0
	je	SHORT $LN273@imf_Proces
	mov	eax, DWORD PTR [ebx+esi*8+4]
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	edi
	mov	DWORD PTR [ebx+esi*8+4], 0
$LN273@imf_Proces:
	add	esi, 1
	jmp	SHORT $LN400@imf_Proces
$LN1@imf_Proces:

; 445  : 		xr_free(contrib);

	test	ebx, ebx
	je	SHORT $LN276@imf_Proces
	push	ebx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	edi
	mov	DWORD PTR _contrib$[ebp], 0
$LN276@imf_Proces:
	fwait

; 446  : 	} catch (...) {	Msg		("imf_Process::B");	};

	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN338@imf_Proces:
	mov	esi, DWORD PTR _tmp$[ebp]

; 447  : 
; 448  : 	free_image(tmp);

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN281@imf_Proces
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi+8], 0
$LN281@imf_Proces:
	test	esi, esi
	je	SHORT $LN284@imf_Proces
	push	esi
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN284@imf_Proces:

; 449  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
__catch$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z$24:

; 446  : 	} catch (...) {	Msg		("imf_Process::B");	};

	push	OFFSET ??_C@_0P@OGNCDIC@imf_Process?3?3B?$AA@
	call	DWORD PTR __imp_?Msg@@YAXPBDZZ
	add	esp, 4
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN338@imf_Proces
	ret	0
	npad	3
$LN401@imf_Proces:

; 449  : }

	DD	$LN88@imf_Proces
	DD	$LN87@imf_Proces
	DD	$LN86@imf_Proces
	DD	$LN85@imf_Proces
	DD	$LN84@imf_Proces
	DD	$LN83@imf_Proces
	DD	$LN82@imf_Proces
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z ENDP		; imf_Process
END

; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	D:\CLEARSKY\sources\engine\xrEngine\stdafx.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_R4CLoadScreenRenderer@@6B@			; CLoadScreenRenderer::`RTTI Complete Object Locator'
PUBLIC	??_R3CLoadScreenRenderer@@8			; CLoadScreenRenderer::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CLoadScreenRenderer@@8			; CLoadScreenRenderer::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CLoadScreenRenderer@@8		; CLoadScreenRenderer::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCLoadScreenRenderer@@@8			; CLoadScreenRenderer `RTTI Type Descriptor'
PUBLIC	?StatPhysics@CRenderDevice@@EAGPAVCStatsPhysics@@XZ ; CRenderDevice::StatPhysics
PUBLIC	??_R4CRenderDevice@@6B@				; CRenderDevice::`RTTI Complete Object Locator'
PUBLIC	??_R3CRenderDevice@@8				; CRenderDevice::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CRenderDevice@@8				; CRenderDevice::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CRenderDevice@@8			; CRenderDevice::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCRenderDevice@@@8			; CRenderDevice `RTTI Type Descriptor'
PUBLIC	??_R4CRenderDeviceBase@@6B@			; CRenderDeviceBase::`RTTI Complete Object Locator'
PUBLIC	??_R3CRenderDeviceBase@@8			; CRenderDeviceBase::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CRenderDeviceBase@@8			; CRenderDeviceBase::`RTTI Base Class Array'
PUBLIC	??_R13?0A@EA@CRenderDeviceData@@8		; CRenderDeviceData::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R3CRenderDeviceData@@8			; CRenderDeviceData::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CRenderDeviceData@@8			; CRenderDeviceData::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CRenderDeviceData@@8		; CRenderDeviceData::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCRenderDeviceData@@@8			; CRenderDeviceData `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@CRenderDeviceBase@@8		; CRenderDeviceBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCRenderDeviceBase@@@8			; CRenderDeviceBase `RTTI Type Descriptor'
PUBLIC	??_R4IRenderDevice@@6B@				; IRenderDevice::`RTTI Complete Object Locator'
PUBLIC	??_R3IRenderDevice@@8				; IRenderDevice::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IRenderDevice@@8				; IRenderDevice::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@IRenderDevice@@8			; IRenderDevice::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVIRenderDevice@@@8			; IRenderDevice `RTTI Type Descriptor'
PUBLIC	??_R4CStats@@6B@				; CStats::`RTTI Complete Object Locator'
PUBLIC	??_R3CStats@@8					; CStats::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CStats@@8					; CStats::`RTTI Base Class Array'
PUBLIC	??_R17?0A@EA@CStatsPhysics@@8			; CStatsPhysics::`RTTI Base Class Descriptor at (8,-1,0,64)'
PUBLIC	??_R3CStatsPhysics@@8				; CStatsPhysics::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CStatsPhysics@@8				; CStatsPhysics::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CStatsPhysics@@8			; CStatsPhysics::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCStatsPhysics@@@8			; CStatsPhysics `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@CStats@@8				; CStats::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCStats@@@8				; CStats `RTTI Type Descriptor'
PUBLIC	??_R4pureStats@@6B@				; pureStats::`RTTI Complete Object Locator'
PUBLIC	??_R3pureStats@@8				; pureStats::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2pureStats@@8				; pureStats::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@pureStats@@8			; pureStats::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVpureStats@@@8				; pureStats `RTTI Type Descriptor'
PUBLIC	??_R4pureScreenResolutionChanged@@6B@		; pureScreenResolutionChanged::`RTTI Complete Object Locator'
PUBLIC	??_R3pureScreenResolutionChanged@@8		; pureScreenResolutionChanged::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2pureScreenResolutionChanged@@8		; pureScreenResolutionChanged::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@pureScreenResolutionChanged@@8	; pureScreenResolutionChanged::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVpureScreenResolutionChanged@@@8		; pureScreenResolutionChanged `RTTI Type Descriptor'
PUBLIC	??_R4pureDeviceReset@@6B@			; pureDeviceReset::`RTTI Complete Object Locator'
PUBLIC	??_R3pureDeviceReset@@8				; pureDeviceReset::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2pureDeviceReset@@8				; pureDeviceReset::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@pureDeviceReset@@8		; pureDeviceReset::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVpureDeviceReset@@@8			; pureDeviceReset `RTTI Type Descriptor'
PUBLIC	??_R4pureAppEnd@@6B@				; pureAppEnd::`RTTI Complete Object Locator'
PUBLIC	??_R3pureAppEnd@@8				; pureAppEnd::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2pureAppEnd@@8				; pureAppEnd::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@pureAppEnd@@8			; pureAppEnd::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVpureAppEnd@@@8				; pureAppEnd `RTTI Type Descriptor'
PUBLIC	??_R4pureAppStart@@6B@				; pureAppStart::`RTTI Complete Object Locator'
PUBLIC	??_R3pureAppStart@@8				; pureAppStart::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2pureAppStart@@8				; pureAppStart::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@pureAppStart@@8			; pureAppStart::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVpureAppStart@@@8			; pureAppStart `RTTI Type Descriptor'
PUBLIC	??_R4pureAppDeactivate@@6B@			; pureAppDeactivate::`RTTI Complete Object Locator'
PUBLIC	??_R3pureAppDeactivate@@8			; pureAppDeactivate::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2pureAppDeactivate@@8			; pureAppDeactivate::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@pureAppDeactivate@@8		; pureAppDeactivate::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVpureAppDeactivate@@@8			; pureAppDeactivate `RTTI Type Descriptor'
PUBLIC	??_R4pureAppActivate@@6B@			; pureAppActivate::`RTTI Complete Object Locator'
PUBLIC	??_R3pureAppActivate@@8				; pureAppActivate::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2pureAppActivate@@8				; pureAppActivate::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@pureAppActivate@@8		; pureAppActivate::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVpureAppActivate@@@8			; pureAppActivate `RTTI Type Descriptor'
PUBLIC	??_R4pureRender@@6B@				; pureRender::`RTTI Complete Object Locator'
PUBLIC	??_R3pureRender@@8				; pureRender::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2pureRender@@8				; pureRender::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@pureRender@@8			; pureRender::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVpureRender@@@8				; pureRender `RTTI Type Descriptor'
PUBLIC	??_R4pureFrame@@6B@				; pureFrame::`RTTI Complete Object Locator'
PUBLIC	??_R3pureFrame@@8				; pureFrame::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2pureFrame@@8				; pureFrame::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@pureFrame@@8			; pureFrame::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVpureFrame@@@8				; pureFrame `RTTI Type Descriptor'
PUBLIC	?shedule_Name@ISheduled@@UBE?AVshared_str@@XZ	; ISheduled::shedule_Name
PUBLIC	??_EISheduled@@UAEPAXI@Z			; ISheduled::`vector deleting destructor'
PUBLIC	??_R4ISheduled@@6B@				; ISheduled::`RTTI Complete Object Locator'
PUBLIC	??_R3ISheduled@@8				; ISheduled::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ISheduled@@8				; ISheduled::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ISheduled@@8			; ISheduled::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVISheduled@@@8				; ISheduled `RTTI Type Descriptor'
PUBLIC	??_R4IEventReceiver@@6B@			; IEventReceiver::`RTTI Complete Object Locator'
PUBLIC	??_R3IEventReceiver@@8				; IEventReceiver::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IEventReceiver@@8				; IEventReceiver::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@IEventReceiver@@8			; IEventReceiver::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVIEventReceiver@@@8			; IEventReceiver `RTTI Type Descriptor'
PUBLIC	??_EDLL_Pure@@UAEPAXI@Z				; DLL_Pure::`vector deleting destructor'
PUBLIC	?_construct@DLL_Pure@@UAEPAV1@XZ		; DLL_Pure::_construct
PUBLIC	??_R4DLL_Pure@@6B@				; DLL_Pure::`RTTI Complete Object Locator'
PUBLIC	??_R3DLL_Pure@@8				; DLL_Pure::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2DLL_Pure@@8				; DLL_Pure::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@DLL_Pure@@8			; DLL_Pure::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVDLL_Pure@@@8				; DLL_Pure `RTTI Type Descriptor'
PUBLIC	??_C@_0P@GHFPNOJB@bad?5allocation?$AA@		; `string'
PUBLIC	?begin@?$vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@stlp_std@@QAEPAV?$FastDelegate0@X@fastdelegate@@XZ ; stlp_std::vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::begin
PUBLIC	?end@?$vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@stlp_std@@QAEPAV?$FastDelegate0@X@fastdelegate@@XZ ; stlp_std::vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::end
PUBLIC	??$__copy@PAV?$FastDelegate0@X@fastdelegate@@PAV12@H@priv@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PAV23@00ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__copy<fastdelegate::FastDelegate0<void> *,fastdelegate::FastDelegate0<void> *,int>
PUBLIC	??$__copy_ptrs@PAV?$FastDelegate0@X@fastdelegate@@PAV12@@priv@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PAV23@00ABU__false_type@1@@Z ; stlp_std::priv::__copy_ptrs<fastdelegate::FastDelegate0<void> *,fastdelegate::FastDelegate0<void> *>
PUBLIC	??$__destroy_aux@V?$FastDelegate0@X@fastdelegate@@@stlp_std@@YAXPAV?$FastDelegate0@X@fastdelegate@@ABU__true_type@0@@Z ; stlp_std::__destroy_aux<fastdelegate::FastDelegate0<void> >
PUBLIC	??$_Destroy@V?$FastDelegate0@X@fastdelegate@@@stlp_std@@YAXPAV?$FastDelegate0@X@fastdelegate@@@Z ; stlp_std::_Destroy<fastdelegate::FastDelegate0<void> >
PUBLIC	?_M_erase@?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@AAEPAV?$FastDelegate0@X@fastdelegate@@PAV45@ABU__false_type@3@@Z ; stlp_std::priv::_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::_M_erase
PUBLIC	?erase@?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAEPAV?$FastDelegate0@X@fastdelegate@@PAV45@@Z ; stlp_std::priv::_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::erase
PUBLIC	?to_value_type_ptr@?$_CastTraits@V?$FastDelegate0@X@fastdelegate@@V12@@priv@stlp_std@@SAPAV?$FastDelegate0@X@fastdelegate@@PAV45@@Z ; stlp_std::priv::_CastTraits<fastdelegate::FastDelegate0<void>,fastdelegate::FastDelegate0<void> >::to_value_type_ptr
PUBLIC	?to_storage_type_ptr@?$_CastTraits@V?$FastDelegate0@X@fastdelegate@@V12@@priv@stlp_std@@SAPAV?$FastDelegate0@X@fastdelegate@@PAV45@@Z ; stlp_std::priv::_CastTraits<fastdelegate::FastDelegate0<void>,fastdelegate::FastDelegate0<void> >::to_storage_type_ptr
PUBLIC	?erase@?$vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@stlp_std@@QAEPAV?$FastDelegate0@X@fastdelegate@@PAV34@@Z ; stlp_std::vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::erase
PUBLIC	?IsEqual@DelegateMemento@fastdelegate@@QBE_NABV12@@Z ; fastdelegate::DelegateMemento::IsEqual
PUBLIC	??8?$FastDelegate0@X@fastdelegate@@QBE_NABV01@@Z ; fastdelegate::FastDelegate0<void>::operator==
PUBLIC	??$__find@PAV?$FastDelegate0@X@fastdelegate@@V12@@priv@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PAV23@0ABV23@ABUrandom_access_iterator_tag@1@@Z ; stlp_std::priv::__find<fastdelegate::FastDelegate0<void> *,fastdelegate::FastDelegate0<void> >
PUBLIC	??$find@PAV?$FastDelegate0@X@fastdelegate@@V12@@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PAV12@0ABV12@@Z ; stlp_std::find<fastdelegate::FastDelegate0<void> *,fastdelegate::FastDelegate0<void> >
PUBLIC	??1?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@QAE@XZ ; xr_vector<shared_str,xalloc<shared_str> >::~xr_vector<shared_str,xalloc<shared_str> >
PUBLIC	??0?$_STLP_alloc_proxy@PAVshared_str@@V1@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAE@ABV?$xalloc@Vshared_str@@@@PAVshared_str@@@Z ; stlp_std::priv::_STLP_alloc_proxy<shared_str *,shared_str,xalloc<shared_str> >::_STLP_alloc_proxy<shared_str *,shared_str,xalloc<shared_str> >
PUBLIC	??0?$_Vector_base@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAE@IABV?$xalloc@Vshared_str@@@@@Z ; stlp_std::priv::_Vector_base<shared_str,xalloc<shared_str> >::_Vector_base<shared_str,xalloc<shared_str> >
PUBLIC	??0?$xalloc@Vshared_str@@@@QAE@ABV0@@Z		; xalloc<shared_str>::xalloc<shared_str>
PUBLIC	?get_allocator@?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QBE?AV?$xalloc@Vshared_str@@@@XZ ; stlp_std::priv::_Impl_vector<shared_str,xalloc<shared_str> >::get_allocator
PUBLIC	?begin@?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QBEPBVshared_str@@XZ ; stlp_std::priv::_Impl_vector<shared_str,xalloc<shared_str> >::begin
PUBLIC	?end@?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QBEPBVshared_str@@XZ ; stlp_std::priv::_Impl_vector<shared_str,xalloc<shared_str> >::end
PUBLIC	??0?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAE@ABV012@@Z ; stlp_std::priv::_Impl_vector<shared_str,xalloc<shared_str> >::_Impl_vector<shared_str,xalloc<shared_str> >
PUBLIC	??0?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@stlp_std@@QAE@ABV01@@Z ; stlp_std::vector<shared_str,xalloc<shared_str> >::vector<shared_str,xalloc<shared_str> >
PUBLIC	??1?$_Vector_base@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAE@XZ ; stlp_std::priv::_Vector_base<shared_str,xalloc<shared_str> >::~_Vector_base<shared_str,xalloc<shared_str> >
PUBLIC	??1?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAE@XZ ; stlp_std::priv::_Impl_vector<shared_str,xalloc<shared_str> >::~_Impl_vector<shared_str,xalloc<shared_str> >
PUBLIC	??1?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@stlp_std@@QAE@XZ ; stlp_std::vector<shared_str,xalloc<shared_str> >::~vector<shared_str,xalloc<shared_str> >
PUBLIC	??0?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@QAE@ABV0@@Z ; xr_vector<shared_str,xalloc<shared_str> >::xr_vector<shared_str,xalloc<shared_str> >
PUBLIC	?DestroyObject@?$FactoryPtr@VIStatsRender@@@@AAEXXZ ; FactoryPtr<IStatsRender>::DestroyObject
PUBLIC	??1?$FactoryPtr@VIStatsRender@@@@QAE@XZ		; FactoryPtr<IStatsRender>::~FactoryPtr<IStatsRender>
PUBLIC	?CreateObject@?$FactoryPtr@VIStatsRender@@@@AAEXXZ ; FactoryPtr<IStatsRender>::CreateObject
PUBLIC	??0?$FactoryPtr@VIStatsRender@@@@QAE@ABV0@@Z	; FactoryPtr<IStatsRender>::FactoryPtr<IStatsRender>
PUBLIC	??1?$CRegistrator@VpureStats@@@@QAE@XZ		; CRegistrator<pureStats>::~CRegistrator<pureStats>
PUBLIC	??0?$CRegistrator@VpureStats@@@@QAE@ABV0@@Z	; CRegistrator<pureStats>::CRegistrator<pureStats>
PUBLIC	??4?$CRegistrator@VpureDeviceReset@@@@QAEAAV0@ABV0@@Z ; CRegistrator<pureDeviceReset>::operator=
PUBLIC	?size@?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QBEIXZ ; stlp_std::priv::_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::size
PUBLIC	?capacity@?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QBEIXZ ; stlp_std::priv::_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::capacity
PUBLIC	?_M_clear@?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@AAEXXZ ; stlp_std::priv::_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::_M_clear
PUBLIC	??$xr_alloc@V?$FastDelegate0@X@fastdelegate@@@@YAPAV?$FastDelegate0@X@fastdelegate@@I@Z ; xr_alloc<fastdelegate::FastDelegate0<void> >
PUBLIC	?allocate@?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@QBEPAV?$FastDelegate0@X@fastdelegate@@IPBX@Z ; xalloc<fastdelegate::FastDelegate0<void> >::allocate
PUBLIC	?allocate@?$_STLP_alloc_proxy@PAV?$FastDelegate0@X@fastdelegate@@V12@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAEPAV?$FastDelegate0@X@fastdelegate@@I@Z ; stlp_std::priv::_STLP_alloc_proxy<fastdelegate::FastDelegate0<void> *,fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::allocate
PUBLIC	?allocate@?$_STLP_alloc_proxy@PAV?$FastDelegate0@X@fastdelegate@@V12@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@AAEPAV?$FastDelegate0@X@fastdelegate@@IAAIABU__false_type@3@@Z ; stlp_std::priv::_STLP_alloc_proxy<fastdelegate::FastDelegate0<void> *,fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::allocate
PUBLIC	?allocate@?$_STLP_alloc_proxy@PAV?$FastDelegate0@X@fastdelegate@@V12@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAEPAV?$FastDelegate0@X@fastdelegate@@IAAI@Z ; stlp_std::priv::_STLP_alloc_proxy<fastdelegate::FastDelegate0<void> *,fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::allocate
PUBLIC	?_Answer@?$_BothPtrType@PBV?$FastDelegate0@X@fastdelegate@@PAV12@@stlp_std@@SA?AU__true_type@2@XZ ; stlp_std::_BothPtrType<fastdelegate::FastDelegate0<void> const *,fastdelegate::FastDelegate0<void> *>::_Answer
PUBLIC	??$_UseTrivialUCopy@V?$FastDelegate0@X@fastdelegate@@V12@@stlp_std@@YA?AU?$_TrivialUCopy@V?$FastDelegate0@X@fastdelegate@@V12@@0@PAV?$FastDelegate0@X@fastdelegate@@0@Z ; stlp_std::_UseTrivialUCopy<fastdelegate::FastDelegate0<void>,fastdelegate::FastDelegate0<void> >
PUBLIC	?_Answer@?$_TrivialUCopy@V?$FastDelegate0@X@fastdelegate@@V12@@stlp_std@@SA?AU__false_type@2@XZ ; stlp_std::_TrivialUCopy<fastdelegate::FastDelegate0<void>,fastdelegate::FastDelegate0<void> >::_Answer
PUBLIC	??$__ucopy_aux@PBV?$FastDelegate0@X@fastdelegate@@PAV12@@priv@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PBV23@0PAV23@ABU__true_type@1@@Z ; stlp_std::priv::__ucopy_aux<fastdelegate::FastDelegate0<void> const *,fastdelegate::FastDelegate0<void> *>
PUBLIC	??$uninitialized_copy@PBV?$FastDelegate0@X@fastdelegate@@PAV12@@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PBV12@0PAV12@@Z ; stlp_std::uninitialized_copy<fastdelegate::FastDelegate0<void> const *,fastdelegate::FastDelegate0<void> *>
PUBLIC	??$_M_allocate_and_copy@PBV?$FastDelegate0@X@fastdelegate@@@?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@AAEPAV?$FastDelegate0@X@fastdelegate@@AAIPBV34@1@Z ; stlp_std::priv::_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::_M_allocate_and_copy<fastdelegate::FastDelegate0<void> const *>
PUBLIC	??4?$FastDelegate0@X@fastdelegate@@QAEXABV01@@Z	; fastdelegate::FastDelegate0<void>::operator=
PUBLIC	??$__copy@PBV?$FastDelegate0@X@fastdelegate@@PAV12@H@priv@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PBV23@0PAV23@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__copy<fastdelegate::FastDelegate0<void> const *,fastdelegate::FastDelegate0<void> *,int>
PUBLIC	??$__copy_ptrs@PBV?$FastDelegate0@X@fastdelegate@@PAV12@@priv@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PBV23@0PAV23@ABU__false_type@1@@Z ; stlp_std::priv::__copy_ptrs<fastdelegate::FastDelegate0<void> const *,fastdelegate::FastDelegate0<void> *>
PUBLIC	??$__destroy_range_aux@PAV?$FastDelegate0@X@fastdelegate@@V12@@stlp_std@@YAXPAV?$FastDelegate0@X@fastdelegate@@00ABU__true_type@0@@Z ; stlp_std::__destroy_range_aux<fastdelegate::FastDelegate0<void> *,fastdelegate::FastDelegate0<void> >
PUBLIC	??$__destroy_range@PAV?$FastDelegate0@X@fastdelegate@@V12@@stlp_std@@YAXPAV?$FastDelegate0@X@fastdelegate@@00@Z ; stlp_std::__destroy_range<fastdelegate::FastDelegate0<void> *,fastdelegate::FastDelegate0<void> >
PUBLIC	??$_Destroy_Range@PAV?$FastDelegate0@X@fastdelegate@@@stlp_std@@YAXPAV?$FastDelegate0@X@fastdelegate@@0@Z ; stlp_std::_Destroy_Range<fastdelegate::FastDelegate0<void> *>
PUBLIC	??0DelegateMemento@fastdelegate@@QAE@XZ		; fastdelegate::DelegateMemento::DelegateMemento
PUBLIC	??0?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AGXXZP6GXXZP6GXXZ@detail@fastdelegate@@QAE@XZ ; fastdelegate::detail::ClosurePtr<void (__stdcall fastdelegate::detail::GenericClass::*)(void),void (__stdcall*)(void),void (__stdcall*)(void)>::ClosurePtr<void (__stdcall fastdelegate::detail::GenericClass::*)(void),void (__stdcall*)(void),void (__stdcall*)(void)>
PUBLIC	?SetMementoFrom@DelegateMemento@fastdelegate@@IAEXABV12@@Z ; fastdelegate::DelegateMemento::SetMementoFrom
PUBLIC	??$CopyFrom@V?$FastDelegate0@X@fastdelegate@@@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AGXXZP6GXXZP6GXXZ@detail@fastdelegate@@QAEXPAV?$FastDelegate0@X@2@ABVDelegateMemento@2@@Z ; fastdelegate::detail::ClosurePtr<void (__stdcall fastdelegate::detail::GenericClass::*)(void),void (__stdcall*)(void),void (__stdcall*)(void)>::CopyFrom<fastdelegate::FastDelegate0<void> >
PUBLIC	??0?$FastDelegate0@X@fastdelegate@@QAE@ABV01@@Z	; fastdelegate::FastDelegate0<void>::FastDelegate0<void>
PUBLIC	??$_Param_Construct@V?$FastDelegate0@X@fastdelegate@@V12@@stlp_std@@YAXPAV?$FastDelegate0@X@fastdelegate@@ABV12@@Z ; stlp_std::_Param_Construct<fastdelegate::FastDelegate0<void>,fastdelegate::FastDelegate0<void> >
PUBLIC	??$__ucopy@PBV?$FastDelegate0@X@fastdelegate@@PAV12@H@priv@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PBV23@0PAV23@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<fastdelegate::FastDelegate0<void> const *,fastdelegate::FastDelegate0<void> *,int>
PUBLIC	??$__ucopy_ptrs@PBV?$FastDelegate0@X@fastdelegate@@PAV12@@priv@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PBV23@0PAV23@ABU__false_type@1@@Z ; stlp_std::priv::__ucopy_ptrs<fastdelegate::FastDelegate0<void> const *,fastdelegate::FastDelegate0<void> *>
PUBLIC	??4?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::operator=
PUBLIC	??4?$vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@stlp_std@@QAEAAV01@ABV01@@Z ; stlp_std::vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::operator=
PUBLIC	??4?$xr_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@@QAEAAV0@ABV0@@Z ; xr_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::operator=
PUBLIC	?size@?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QBEIXZ ; stlp_std::priv::_Impl_vector<shared_str,xalloc<shared_str> >::size
PUBLIC	?capacity@?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QBEIXZ ; stlp_std::priv::_Impl_vector<shared_str,xalloc<shared_str> >::capacity
PUBLIC	??$xr_free@Vshared_str@@@@YAXAAPAVshared_str@@@Z ; xr_free<shared_str>
PUBLIC	?deallocate@?$xalloc@Vshared_str@@@@QBEXPAVshared_str@@I@Z ; xalloc<shared_str>::deallocate
PUBLIC	?end@?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAEPAVshared_str@@XZ ; stlp_std::priv::_Impl_vector<shared_str,xalloc<shared_str> >::end
PUBLIC	?rbegin@?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAVshared_str@@@3@XZ ; stlp_std::priv::_Impl_vector<shared_str,xalloc<shared_str> >::rbegin
PUBLIC	?begin@?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAEPAVshared_str@@XZ ; stlp_std::priv::_Impl_vector<shared_str,xalloc<shared_str> >::begin
PUBLIC	??0?$reverse_iterator@PAVshared_str@@@stlp_std@@QAE@PAVshared_str@@@Z ; stlp_std::reverse_iterator<shared_str *>::reverse_iterator<shared_str *>
PUBLIC	?rend@?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAVshared_str@@@3@XZ ; stlp_std::priv::_Impl_vector<shared_str,xalloc<shared_str> >::rend
PUBLIC	??0?$reverse_iterator@PAVshared_str@@@stlp_std@@QAE@ABV01@@Z ; stlp_std::reverse_iterator<shared_str *>::reverse_iterator<shared_str *>
PUBLIC	??D?$reverse_iterator@PAVshared_str@@@stlp_std@@QBEAAVshared_str@@XZ ; stlp_std::reverse_iterator<shared_str *>::operator*
PUBLIC	??E?$reverse_iterator@PAVshared_str@@@stlp_std@@QAEAAV01@XZ ; stlp_std::reverse_iterator<shared_str *>::operator++
PUBLIC	?base@?$reverse_iterator@PAVshared_str@@@stlp_std@@QBEPAVshared_str@@XZ ; stlp_std::reverse_iterator<shared_str *>::base
PUBLIC	??$?8PAVshared_str@@@stlp_std@@YA_NABV?$reverse_iterator@PAVshared_str@@@0@0@Z ; stlp_std::operator==<shared_str *>
PUBLIC	??$?9PAVshared_str@@@stlp_std@@YA_NABV?$reverse_iterator@PAVshared_str@@@0@0@Z ; stlp_std::operator!=<shared_str *>
PUBLIC	??$__destroy_range_aux@V?$reverse_iterator@PAVshared_str@@@stlp_std@@Vshared_str@@@stlp_std@@YAXV?$reverse_iterator@PAVshared_str@@@0@0PAVshared_str@@ABU__false_type@0@@Z ; stlp_std::__destroy_range_aux<stlp_std::reverse_iterator<shared_str *>,shared_str>
PUBLIC	??$__destroy_range@V?$reverse_iterator@PAVshared_str@@@stlp_std@@Vshared_str@@@stlp_std@@YAXV?$reverse_iterator@PAVshared_str@@@0@0PAVshared_str@@@Z ; stlp_std::__destroy_range<stlp_std::reverse_iterator<shared_str *>,shared_str>
PUBLIC	??$_Destroy_Range@V?$reverse_iterator@PAVshared_str@@@stlp_std@@@stlp_std@@YAXV?$reverse_iterator@PAVshared_str@@@0@0@Z ; stlp_std::_Destroy_Range<stlp_std::reverse_iterator<shared_str *> >
PUBLIC	?_M_clear@?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@AAEXXZ ; stlp_std::priv::_Impl_vector<shared_str,xalloc<shared_str> >::_M_clear
PUBLIC	??$xr_alloc@Vshared_str@@@@YAPAVshared_str@@I@Z	; xr_alloc<shared_str>
PUBLIC	?allocate@?$xalloc@Vshared_str@@@@QBEPAVshared_str@@IPBX@Z ; xalloc<shared_str>::allocate
PUBLIC	?allocate@?$_STLP_alloc_proxy@PAVshared_str@@V1@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAEPAVshared_str@@I@Z ; stlp_std::priv::_STLP_alloc_proxy<shared_str *,shared_str,xalloc<shared_str> >::allocate
PUBLIC	?allocate@?$_STLP_alloc_proxy@PAVshared_str@@V1@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@AAEPAVshared_str@@IAAIABU__false_type@3@@Z ; stlp_std::priv::_STLP_alloc_proxy<shared_str *,shared_str,xalloc<shared_str> >::allocate
PUBLIC	?allocate@?$_STLP_alloc_proxy@PAVshared_str@@V1@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAEPAVshared_str@@IAAI@Z ; stlp_std::priv::_STLP_alloc_proxy<shared_str *,shared_str,xalloc<shared_str> >::allocate
PUBLIC	?_Answer@?$_BothPtrType@PBVshared_str@@PAV1@@stlp_std@@SA?AU__true_type@2@XZ ; stlp_std::_BothPtrType<shared_str const *,shared_str *>::_Answer
PUBLIC	??$_Param_Construct@Vshared_str@@V1@@stlp_std@@YAXPAVshared_str@@ABV1@@Z ; stlp_std::_Param_Construct<shared_str,shared_str>
PUBLIC	??$__ucopy@PBVshared_str@@PAV1@H@priv@stlp_std@@YAPAVshared_str@@PBV2@0PAV2@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<shared_str const *,shared_str *,int>
PUBLIC	??$__ucopy_ptrs@PBVshared_str@@PAV1@@priv@stlp_std@@YAPAVshared_str@@PBV2@0PAV2@ABU__false_type@1@@Z ; stlp_std::priv::__ucopy_ptrs<shared_str const *,shared_str *>
PUBLIC	??$_UseTrivialUCopy@Vshared_str@@V1@@stlp_std@@YA?AU?$_TrivialUCopy@Vshared_str@@V1@@0@PAVshared_str@@0@Z ; stlp_std::_UseTrivialUCopy<shared_str,shared_str>
PUBLIC	?_Answer@?$_TrivialUCopy@Vshared_str@@V1@@stlp_std@@SA?AU__false_type@2@XZ ; stlp_std::_TrivialUCopy<shared_str,shared_str>::_Answer
PUBLIC	??$__ucopy_aux@PBVshared_str@@PAV1@@priv@stlp_std@@YAPAVshared_str@@PBV2@0PAV2@ABU__true_type@1@@Z ; stlp_std::priv::__ucopy_aux<shared_str const *,shared_str *>
PUBLIC	??$uninitialized_copy@PBVshared_str@@PAV1@@stlp_std@@YAPAVshared_str@@PBV1@0PAV1@@Z ; stlp_std::uninitialized_copy<shared_str const *,shared_str *>
PUBLIC	??$_M_allocate_and_copy@PBVshared_str@@@?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@AAEPAVshared_str@@AAIPBV3@1@Z ; stlp_std::priv::_Impl_vector<shared_str,xalloc<shared_str> >::_M_allocate_and_copy<shared_str const *>
PUBLIC	??$__copy@PBVshared_str@@PAV1@H@priv@stlp_std@@YAPAVshared_str@@PBV2@0PAV2@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__copy<shared_str const *,shared_str *,int>
PUBLIC	??$__copy_ptrs@PBVshared_str@@PAV1@@priv@stlp_std@@YAPAVshared_str@@PBV2@0PAV2@ABU__false_type@1@@Z ; stlp_std::priv::__copy_ptrs<shared_str const *,shared_str *>
PUBLIC	??_Gshared_str@@QAEPAXI@Z			; shared_str::`scalar deleting destructor'
PUBLIC	??$__destroy_aux@Vshared_str@@@stlp_std@@YAXPAVshared_str@@ABU__false_type@0@@Z ; stlp_std::__destroy_aux<shared_str>
PUBLIC	??$__destroy_range_aux@PAVshared_str@@V1@@stlp_std@@YAXPAVshared_str@@00ABU__false_type@0@@Z ; stlp_std::__destroy_range_aux<shared_str *,shared_str>
PUBLIC	??$__destroy_range@PAVshared_str@@V1@@stlp_std@@YAXPAVshared_str@@00@Z ; stlp_std::__destroy_range<shared_str *,shared_str>
PUBLIC	??$_Destroy_Range@PAVshared_str@@@stlp_std@@YAXPAVshared_str@@0@Z ; stlp_std::_Destroy_Range<shared_str *>
PUBLIC	??4?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<shared_str,xalloc<shared_str> >::operator=
PUBLIC	??4?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@stlp_std@@QAEAAV01@ABV01@@Z ; stlp_std::vector<shared_str,xalloc<shared_str> >::operator=
PUBLIC	??4?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@QAEAAV0@ABV0@@Z ; xr_vector<shared_str,xalloc<shared_str> >::operator=
PUBLIC	??4?$FactoryPtr@VIStatsRender@@@@QAEAAV0@ABV0@@Z ; FactoryPtr<IStatsRender>::operator=
PUBLIC	??4?$CRegistrator@VpureStats@@@@QAEAAV0@ABV0@@Z	; CRegistrator<pureStats>::operator=
PUBLIC	??0?$xalloc@PAVCEvent@@@@QAE@XZ			; xalloc<CEvent *>::xalloc<CEvent *>
PUBLIC	??0?$xalloc@PAX@@QAE@ABV0@@Z			; xalloc<void *>::xalloc<void *>
PUBLIC	??0?$_STLP_alloc_proxy@PAPAXPAXV?$xalloc@PAX@@@priv@stlp_std@@QAE@ABV?$xalloc@PAX@@PAPAX@Z ; stlp_std::priv::_STLP_alloc_proxy<void * *,void *,xalloc<void *> >::_STLP_alloc_proxy<void * *,void *,xalloc<void *> >
PUBLIC	??0?$_Vector_base@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAE@ABV?$xalloc@PAX@@@Z ; stlp_std::priv::_Vector_base<void *,xalloc<void *> >::_Vector_base<void *,xalloc<void *> >
PUBLIC	??0?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAE@ABV?$xalloc@PAX@@@Z ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::_Impl_vector<void *,xalloc<void *> >
PUBLIC	??$?0PAVCEvent@@@?$xalloc@PAX@@QAE@ABV?$xalloc@PAVCEvent@@@@@Z ; xalloc<void *>::xalloc<void *><CEvent *>
PUBLIC	??0?$vector@PAVCEvent@@V?$xalloc@PAVCEvent@@@@@stlp_std@@QAE@ABV?$xalloc@PAVCEvent@@@@@Z ; stlp_std::vector<CEvent *,xalloc<CEvent *> >::vector<CEvent *,xalloc<CEvent *> >
PUBLIC	??0?$xr_vector@PAVCEvent@@V?$xalloc@PAVCEvent@@@@@@QAE@XZ ; xr_vector<CEvent *,xalloc<CEvent *> >::xr_vector<CEvent *,xalloc<CEvent *> >
PUBLIC	??0?$xalloc@UDeferred@CEventAPI@@@@QAE@XZ	; xalloc<CEventAPI::Deferred>::xalloc<CEventAPI::Deferred>
PUBLIC	??0?$xalloc@UDeferred@CEventAPI@@@@QAE@ABV0@@Z	; xalloc<CEventAPI::Deferred>::xalloc<CEventAPI::Deferred>
PUBLIC	??0?$_STLP_alloc_proxy@PAUDeferred@CEventAPI@@U12@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UDeferred@CEventAPI@@@@PAUDeferred@CEventAPI@@@Z ; stlp_std::priv::_STLP_alloc_proxy<CEventAPI::Deferred *,CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::_STLP_alloc_proxy<CEventAPI::Deferred *,CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >
PUBLIC	??0?$_Vector_base@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UDeferred@CEventAPI@@@@@Z ; stlp_std::priv::_Vector_base<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::_Vector_base<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >
PUBLIC	??0?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UDeferred@CEventAPI@@@@@Z ; stlp_std::priv::_Impl_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::_Impl_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >
PUBLIC	??0?$vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@stlp_std@@QAE@ABV?$xalloc@UDeferred@CEventAPI@@@@@Z ; stlp_std::vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >
PUBLIC	??0?$xr_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@@QAE@XZ ; xr_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::xr_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >
PUBLIC	??1?$_Vector_base@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAE@XZ ; stlp_std::priv::_Vector_base<void *,xalloc<void *> >::~_Vector_base<void *,xalloc<void *> >
PUBLIC	??1?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAE@XZ ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::~_Impl_vector<void *,xalloc<void *> >
PUBLIC	??1?$vector@PAVCEvent@@V?$xalloc@PAVCEvent@@@@@stlp_std@@QAE@XZ ; stlp_std::vector<CEvent *,xalloc<CEvent *> >::~vector<CEvent *,xalloc<CEvent *> >
PUBLIC	??1?$xr_vector@PAVCEvent@@V?$xalloc@PAVCEvent@@@@@@QAE@XZ ; xr_vector<CEvent *,xalloc<CEvent *> >::~xr_vector<CEvent *,xalloc<CEvent *> >
PUBLIC	??1?$_Vector_base@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAE@XZ ; stlp_std::priv::_Vector_base<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::~_Vector_base<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >
PUBLIC	??1?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAE@XZ ; stlp_std::priv::_Impl_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::~_Impl_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >
PUBLIC	??1?$vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@stlp_std@@QAE@XZ ; stlp_std::vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::~vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >
PUBLIC	??1?$xr_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@@QAE@XZ ; xr_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::~xr_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >
PUBLIC	?size@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QBEIXZ ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::size
PUBLIC	?capacity@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QBEIXZ ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::capacity
PUBLIC	??$xr_free@PAX@@YAXAAPAPAX@Z			; xr_free<void *>
PUBLIC	?deallocate@?$xalloc@PAX@@QBEXPAPAXI@Z		; xalloc<void *>::deallocate
PUBLIC	?end@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEPAPAXXZ ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::end
PUBLIC	?rbegin@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAPAX@3@XZ ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::rbegin
PUBLIC	?begin@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEPAPAXXZ ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::begin
PUBLIC	??0?$reverse_iterator@PAPAX@stlp_std@@QAE@PAPAX@Z ; stlp_std::reverse_iterator<void * *>::reverse_iterator<void * *>
PUBLIC	?rend@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAPAX@3@XZ ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::rend
PUBLIC	??0?$reverse_iterator@PAPAX@stlp_std@@QAE@ABV01@@Z ; stlp_std::reverse_iterator<void * *>::reverse_iterator<void * *>
PUBLIC	??$__destroy_range_aux@V?$reverse_iterator@PAPAX@stlp_std@@PAX@stlp_std@@YAXV?$reverse_iterator@PAPAX@0@0PAPAXABU__true_type@0@@Z ; stlp_std::__destroy_range_aux<stlp_std::reverse_iterator<void * *>,void *>
PUBLIC	??$__destroy_range@V?$reverse_iterator@PAPAX@stlp_std@@PAX@stlp_std@@YAXV?$reverse_iterator@PAPAX@0@0PAPAX@Z ; stlp_std::__destroy_range<stlp_std::reverse_iterator<void * *>,void *>
PUBLIC	??$_Destroy_Range@V?$reverse_iterator@PAPAX@stlp_std@@@stlp_std@@YAXV?$reverse_iterator@PAPAX@0@0@Z ; stlp_std::_Destroy_Range<stlp_std::reverse_iterator<void * *> >
PUBLIC	?_M_clear@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@AAEXXZ ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::_M_clear
PUBLIC	??$xr_alloc@PAX@@YAPAPAXI@Z			; xr_alloc<void *>
PUBLIC	?allocate@?$xalloc@PAX@@QBEPAPAXIPBX@Z		; xalloc<void *>::allocate
PUBLIC	?allocate@?$_STLP_alloc_proxy@PAPAXPAXV?$xalloc@PAX@@@priv@stlp_std@@QAEPAPAXI@Z ; stlp_std::priv::_STLP_alloc_proxy<void * *,void *,xalloc<void *> >::allocate
PUBLIC	?allocate@?$_STLP_alloc_proxy@PAPAXPAXV?$xalloc@PAX@@@priv@stlp_std@@AAEPAPAXIAAIABU__false_type@3@@Z ; stlp_std::priv::_STLP_alloc_proxy<void * *,void *,xalloc<void *> >::allocate
PUBLIC	?allocate@?$_STLP_alloc_proxy@PAPAXPAXV?$xalloc@PAX@@@priv@stlp_std@@QAEPAPAXIAAI@Z ; stlp_std::priv::_STLP_alloc_proxy<void * *,void *,xalloc<void *> >::allocate
PUBLIC	?_Answer@?$_BothPtrType@PBQAXPAPAX@stlp_std@@SA?AU__true_type@2@XZ ; stlp_std::_BothPtrType<void * const *,void * *>::_Answer
PUBLIC	??$_UseTrivialUCopy@PAXPAX@stlp_std@@YA?AU?$_TrivialUCopy@PAXPAX@0@PAPAX0@Z ; stlp_std::_UseTrivialUCopy<void *,void *>
PUBLIC	?_Answer@?$_TrivialUCopy@PAXPAX@stlp_std@@SA?AU__true_type@2@XZ ; stlp_std::_TrivialUCopy<void *,void *>::_Answer
PUBLIC	??$__ucopy_aux@PBQAXPAPAX@priv@stlp_std@@YAPAPAXPBQAX0PAPAXABU__true_type@1@@Z ; stlp_std::priv::__ucopy_aux<void * const *,void * *>
PUBLIC	??$uninitialized_copy@PBQAXPAPAX@stlp_std@@YAPAPAXPBQAX0PAPAX@Z ; stlp_std::uninitialized_copy<void * const *,void * *>
PUBLIC	??$_M_allocate_and_copy@PBQAX@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@AAEPAPAXAAIPBQAX1@Z ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::_M_allocate_and_copy<void * const *>
PUBLIC	??$__copy_ptrs@PBQAXPAPAX@priv@stlp_std@@YAPAPAXPBQAX0PAPAXABU__true_type@1@@Z ; stlp_std::priv::__copy_ptrs<void * const *,void * *>
PUBLIC	??$__destroy_range_aux@PAPAXPAX@stlp_std@@YAXPAPAX00ABU__true_type@0@@Z ; stlp_std::__destroy_range_aux<void * *,void *>
PUBLIC	??$__destroy_range@PAPAXPAX@stlp_std@@YAXPAPAX00@Z ; stlp_std::__destroy_range<void * *,void *>
PUBLIC	??$_Destroy_Range@PAPAX@stlp_std@@YAXPAPAX0@Z	; stlp_std::_Destroy_Range<void * *>
PUBLIC	??$__ucopy_ptrs@PBQAXPAPAX@priv@stlp_std@@YAPAPAXPBQAX0PAPAXABU__true_type@1@@Z ; stlp_std::priv::__ucopy_ptrs<void * const *,void * *>
PUBLIC	??4?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::operator=
PUBLIC	??4?$vector@PAVCEvent@@V?$xalloc@PAVCEvent@@@@@stlp_std@@QAEAAV01@ABV01@@Z ; stlp_std::vector<CEvent *,xalloc<CEvent *> >::operator=
PUBLIC	??4?$xr_vector@PAVCEvent@@V?$xalloc@PAVCEvent@@@@@@QAEAAV0@ABV0@@Z ; xr_vector<CEvent *,xalloc<CEvent *> >::operator=
PUBLIC	?size@?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QBEIXZ ; stlp_std::priv::_Impl_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::size
PUBLIC	?capacity@?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QBEIXZ ; stlp_std::priv::_Impl_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::capacity
PUBLIC	??$xr_free@UDeferred@CEventAPI@@@@YAXAAPAUDeferred@CEventAPI@@@Z ; xr_free<CEventAPI::Deferred>
PUBLIC	?deallocate@?$xalloc@UDeferred@CEventAPI@@@@QBEXPAUDeferred@CEventAPI@@I@Z ; xalloc<CEventAPI::Deferred>::deallocate
PUBLIC	?end@?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAEPAUDeferred@CEventAPI@@XZ ; stlp_std::priv::_Impl_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::end
PUBLIC	?rbegin@?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAUDeferred@CEventAPI@@@3@XZ ; stlp_std::priv::_Impl_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::rbegin
PUBLIC	?begin@?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAEPAUDeferred@CEventAPI@@XZ ; stlp_std::priv::_Impl_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::begin
PUBLIC	??0?$reverse_iterator@PAUDeferred@CEventAPI@@@stlp_std@@QAE@PAUDeferred@CEventAPI@@@Z ; stlp_std::reverse_iterator<CEventAPI::Deferred *>::reverse_iterator<CEventAPI::Deferred *>
PUBLIC	?rend@?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAUDeferred@CEventAPI@@@3@XZ ; stlp_std::priv::_Impl_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::rend
PUBLIC	??0?$reverse_iterator@PAUDeferred@CEventAPI@@@stlp_std@@QAE@ABV01@@Z ; stlp_std::reverse_iterator<CEventAPI::Deferred *>::reverse_iterator<CEventAPI::Deferred *>
PUBLIC	??$__destroy_range_aux@V?$reverse_iterator@PAUDeferred@CEventAPI@@@stlp_std@@UDeferred@CEventAPI@@@stlp_std@@YAXV?$reverse_iterator@PAUDeferred@CEventAPI@@@0@0PAUDeferred@CEventAPI@@ABU__true_type@0@@Z ; stlp_std::__destroy_range_aux<stlp_std::reverse_iterator<CEventAPI::Deferred *>,CEventAPI::Deferred>
PUBLIC	??$__destroy_range@V?$reverse_iterator@PAUDeferred@CEventAPI@@@stlp_std@@UDeferred@CEventAPI@@@stlp_std@@YAXV?$reverse_iterator@PAUDeferred@CEventAPI@@@0@0PAUDeferred@CEventAPI@@@Z ; stlp_std::__destroy_range<stlp_std::reverse_iterator<CEventAPI::Deferred *>,CEventAPI::Deferred>
PUBLIC	??$_Destroy_Range@V?$reverse_iterator@PAUDeferred@CEventAPI@@@stlp_std@@@stlp_std@@YAXV?$reverse_iterator@PAUDeferred@CEventAPI@@@0@0@Z ; stlp_std::_Destroy_Range<stlp_std::reverse_iterator<CEventAPI::Deferred *> >
PUBLIC	?_M_clear@?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@AAEXXZ ; stlp_std::priv::_Impl_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::_M_clear
PUBLIC	??$xr_alloc@UDeferred@CEventAPI@@@@YAPAUDeferred@CEventAPI@@I@Z ; xr_alloc<CEventAPI::Deferred>
PUBLIC	?allocate@?$xalloc@UDeferred@CEventAPI@@@@QBEPAUDeferred@CEventAPI@@IPBX@Z ; xalloc<CEventAPI::Deferred>::allocate
PUBLIC	?allocate@?$_STLP_alloc_proxy@PAUDeferred@CEventAPI@@U12@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAEPAUDeferred@CEventAPI@@I@Z ; stlp_std::priv::_STLP_alloc_proxy<CEventAPI::Deferred *,CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::allocate
PUBLIC	?allocate@?$_STLP_alloc_proxy@PAUDeferred@CEventAPI@@U12@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@AAEPAUDeferred@CEventAPI@@IAAIABU__false_type@3@@Z ; stlp_std::priv::_STLP_alloc_proxy<CEventAPI::Deferred *,CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::allocate
PUBLIC	?allocate@?$_STLP_alloc_proxy@PAUDeferred@CEventAPI@@U12@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAEPAUDeferred@CEventAPI@@IAAI@Z ; stlp_std::priv::_STLP_alloc_proxy<CEventAPI::Deferred *,CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::allocate
PUBLIC	?_Answer@?$_BothPtrType@PBUDeferred@CEventAPI@@PAU12@@stlp_std@@SA?AU__true_type@2@XZ ; stlp_std::_BothPtrType<CEventAPI::Deferred const *,CEventAPI::Deferred *>::_Answer
PUBLIC	??$_UseTrivialUCopy@UDeferred@CEventAPI@@U12@@stlp_std@@YA?AU?$_TrivialUCopy@UDeferred@CEventAPI@@U12@@0@PAUDeferred@CEventAPI@@0@Z ; stlp_std::_UseTrivialUCopy<CEventAPI::Deferred,CEventAPI::Deferred>
PUBLIC	?_Answer@?$_TrivialUCopy@UDeferred@CEventAPI@@U12@@stlp_std@@SA?AU__true_type@2@XZ ; stlp_std::_TrivialUCopy<CEventAPI::Deferred,CEventAPI::Deferred>::_Answer
PUBLIC	??$__ucopy_aux@PBUDeferred@CEventAPI@@PAU12@@priv@stlp_std@@YAPAUDeferred@CEventAPI@@PBU23@0PAU23@ABU__true_type@1@@Z ; stlp_std::priv::__ucopy_aux<CEventAPI::Deferred const *,CEventAPI::Deferred *>
PUBLIC	??$uninitialized_copy@PBUDeferred@CEventAPI@@PAU12@@stlp_std@@YAPAUDeferred@CEventAPI@@PBU12@0PAU12@@Z ; stlp_std::uninitialized_copy<CEventAPI::Deferred const *,CEventAPI::Deferred *>
PUBLIC	??$_M_allocate_and_copy@PBUDeferred@CEventAPI@@@?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@AAEPAUDeferred@CEventAPI@@AAIPBU34@1@Z ; stlp_std::priv::_Impl_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::_M_allocate_and_copy<CEventAPI::Deferred const *>
PUBLIC	??$__copy_ptrs@PBUDeferred@CEventAPI@@PAU12@@priv@stlp_std@@YAPAUDeferred@CEventAPI@@PBU23@0PAU23@ABU__true_type@1@@Z ; stlp_std::priv::__copy_ptrs<CEventAPI::Deferred const *,CEventAPI::Deferred *>
PUBLIC	??$__destroy_range_aux@PAUDeferred@CEventAPI@@U12@@stlp_std@@YAXPAUDeferred@CEventAPI@@00ABU__true_type@0@@Z ; stlp_std::__destroy_range_aux<CEventAPI::Deferred *,CEventAPI::Deferred>
PUBLIC	??$__destroy_range@PAUDeferred@CEventAPI@@U12@@stlp_std@@YAXPAUDeferred@CEventAPI@@00@Z ; stlp_std::__destroy_range<CEventAPI::Deferred *,CEventAPI::Deferred>
PUBLIC	??$_Destroy_Range@PAUDeferred@CEventAPI@@@stlp_std@@YAXPAUDeferred@CEventAPI@@0@Z ; stlp_std::_Destroy_Range<CEventAPI::Deferred *>
PUBLIC	??$__ucopy_ptrs@PBUDeferred@CEventAPI@@PAU12@@priv@stlp_std@@YAPAUDeferred@CEventAPI@@PBU23@0PAU23@ABU__true_type@1@@Z ; stlp_std::priv::__ucopy_ptrs<CEventAPI::Deferred const *,CEventAPI::Deferred *>
PUBLIC	??4?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::operator=
PUBLIC	??4?$vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@stlp_std@@QAEAAV01@ABV01@@Z ; stlp_std::vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::operator=
PUBLIC	??4?$xr_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@@QAEAAV0@ABV0@@Z ; xr_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::operator=
PUBLIC	?_set@shared_str@@QAEXPBD@Z			; shared_str::_set
PUBLIC	??0shared_str@@QAE@PBD@Z			; shared_str::shared_str
PUBLIC	??0IRenderDevice@@QAE@XZ			; IRenderDevice::IRenderDevice
PUBLIC	??_V@YAXPAX@Z					; operator delete[]
PUBLIC	??0?$CRegistrator@VpureRender@@@@QAE@XZ		; CRegistrator<pureRender>::CRegistrator<pureRender>
PUBLIC	??0?$CRegistrator@VpureAppActivate@@@@QAE@XZ	; CRegistrator<pureAppActivate>::CRegistrator<pureAppActivate>
PUBLIC	??0?$CRegistrator@VpureAppDeactivate@@@@QAE@XZ	; CRegistrator<pureAppDeactivate>::CRegistrator<pureAppDeactivate>
PUBLIC	??0?$CRegistrator@VpureAppStart@@@@QAE@XZ	; CRegistrator<pureAppStart>::CRegistrator<pureAppStart>
PUBLIC	??0?$CRegistrator@VpureAppEnd@@@@QAE@XZ		; CRegistrator<pureAppEnd>::CRegistrator<pureAppEnd>
PUBLIC	??0?$CRegistrator@VpureScreenResolutionChanged@@@@QAE@XZ ; CRegistrator<pureScreenResolutionChanged>::CRegistrator<pureScreenResolutionChanged>
PUBLIC	?front@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEAAUItem@CSheduler@@XZ ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::front
PUBLIC	?to_value_type_ref@?$_CastTraits@UItem@CSheduler@@U12@@priv@stlp_std@@SAAAUItem@CSheduler@@AAU45@@Z ; stlp_std::priv::_CastTraits<CSheduler::Item,CSheduler::Item>::to_value_type_ref
PUBLIC	?front@?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAEAAUItem@CSheduler@@XZ ; stlp_std::vector<CSheduler::Item,xalloc<CSheduler::Item> >::front
PUBLIC	??0IRenderDevice@@QAE@ABV0@@Z			; IRenderDevice::IRenderDevice
PUBLIC	??0?$xalloc@UItem@CSheduler@@@@QAE@XZ		; xalloc<CSheduler::Item>::xalloc<CSheduler::Item>
PUBLIC	??0?$_Vector_base@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UItem@CSheduler@@@@@Z ; stlp_std::priv::_Vector_base<CSheduler::Item,xalloc<CSheduler::Item> >::_Vector_base<CSheduler::Item,xalloc<CSheduler::Item> >
PUBLIC	??0?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UItem@CSheduler@@@@@Z ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >
PUBLIC	??0?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAE@ABV?$xalloc@UItem@CSheduler@@@@@Z ; stlp_std::vector<CSheduler::Item,xalloc<CSheduler::Item> >::vector<CSheduler::Item,xalloc<CSheduler::Item> >
PUBLIC	??0?$xr_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@@QAE@XZ ; xr_vector<CSheduler::Item,xalloc<CSheduler::Item> >::xr_vector<CSheduler::Item,xalloc<CSheduler::Item> >
PUBLIC	??0?$xalloc@UItemReg@CSheduler@@@@QAE@XZ	; xalloc<CSheduler::ItemReg>::xalloc<CSheduler::ItemReg>
PUBLIC	??0?$_Vector_base@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UItemReg@CSheduler@@@@@Z ; stlp_std::priv::_Vector_base<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::_Vector_base<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >
PUBLIC	??0?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UItemReg@CSheduler@@@@@Z ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >
PUBLIC	??0?$vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@stlp_std@@QAE@ABV?$xalloc@UItemReg@CSheduler@@@@@Z ; stlp_std::vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >
PUBLIC	??0?$xr_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@@QAE@XZ ; xr_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::xr_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >
PUBLIC	??1?$CRegistrator@VpureRender@@@@QAE@XZ		; CRegistrator<pureRender>::~CRegistrator<pureRender>
PUBLIC	??0?$CRegistrator@VpureRender@@@@QAE@ABV0@@Z	; CRegistrator<pureRender>::CRegistrator<pureRender>
PUBLIC	??1?$CRegistrator@VpureAppActivate@@@@QAE@XZ	; CRegistrator<pureAppActivate>::~CRegistrator<pureAppActivate>
PUBLIC	??0?$CRegistrator@VpureAppActivate@@@@QAE@ABV0@@Z ; CRegistrator<pureAppActivate>::CRegistrator<pureAppActivate>
PUBLIC	??1?$CRegistrator@VpureAppDeactivate@@@@QAE@XZ	; CRegistrator<pureAppDeactivate>::~CRegistrator<pureAppDeactivate>
PUBLIC	??0?$CRegistrator@VpureAppDeactivate@@@@QAE@ABV0@@Z ; CRegistrator<pureAppDeactivate>::CRegistrator<pureAppDeactivate>
PUBLIC	??1?$CRegistrator@VpureAppStart@@@@QAE@XZ	; CRegistrator<pureAppStart>::~CRegistrator<pureAppStart>
PUBLIC	??0?$CRegistrator@VpureAppStart@@@@QAE@ABV0@@Z	; CRegistrator<pureAppStart>::CRegistrator<pureAppStart>
PUBLIC	??1?$CRegistrator@VpureAppEnd@@@@QAE@XZ		; CRegistrator<pureAppEnd>::~CRegistrator<pureAppEnd>
PUBLIC	??0?$CRegistrator@VpureAppEnd@@@@QAE@ABV0@@Z	; CRegistrator<pureAppEnd>::CRegistrator<pureAppEnd>
PUBLIC	??0?$CRegistrator@VpureFrame@@@@QAE@ABV0@@Z	; CRegistrator<pureFrame>::CRegistrator<pureFrame>
PUBLIC	??1?$CRegistrator@VpureScreenResolutionChanged@@@@QAE@XZ ; CRegistrator<pureScreenResolutionChanged>::~CRegistrator<pureScreenResolutionChanged>
PUBLIC	??0?$_Vector_base@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE@IABV?$xalloc@U_REG_INFO@@@@@Z ; stlp_std::priv::_Vector_base<_REG_INFO,xalloc<_REG_INFO> >::_Vector_base<_REG_INFO,xalloc<_REG_INFO> >
PUBLIC	?get_allocator@?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QBE?AV?$xalloc@U_REG_INFO@@@@XZ ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::get_allocator
PUBLIC	?begin@?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QBEPBU_REG_INFO@@XZ ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::begin
PUBLIC	?end@?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QBEPBU_REG_INFO@@XZ ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::end
PUBLIC	??0?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE@ABV012@@Z ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >
PUBLIC	??0?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@stlp_std@@QAE@ABV01@@Z ; stlp_std::vector<_REG_INFO,xalloc<_REG_INFO> >::vector<_REG_INFO,xalloc<_REG_INFO> >
PUBLIC	??0?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QAE@ABV0@@Z ; xr_vector<_REG_INFO,xalloc<_REG_INFO> >::xr_vector<_REG_INFO,xalloc<_REG_INFO> >
PUBLIC	??0?$CRegistrator@VpureScreenResolutionChanged@@@@QAE@ABV0@@Z ; CRegistrator<pureScreenResolutionChanged>::CRegistrator<pureScreenResolutionChanged>
PUBLIC	??4IRenderDevice@@QAEAAV0@ABV0@@Z		; IRenderDevice::operator=
PUBLIC	??4?$CRegistrator@VpureRender@@@@QAEAAV0@ABV0@@Z ; CRegistrator<pureRender>::operator=
PUBLIC	??4?$CRegistrator@VpureAppActivate@@@@QAEAAV0@ABV0@@Z ; CRegistrator<pureAppActivate>::operator=
PUBLIC	??4?$CRegistrator@VpureAppDeactivate@@@@QAEAAV0@ABV0@@Z ; CRegistrator<pureAppDeactivate>::operator=
PUBLIC	??4?$CRegistrator@VpureAppStart@@@@QAEAAV0@ABV0@@Z ; CRegistrator<pureAppStart>::operator=
PUBLIC	??4?$CRegistrator@VpureAppEnd@@@@QAEAAV0@ABV0@@Z ; CRegistrator<pureAppEnd>::operator=
PUBLIC	??4?$CRegistrator@VpureFrame@@@@QAEAAV0@ABV0@@Z	; CRegistrator<pureFrame>::operator=
PUBLIC	?size@?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QBEIXZ ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::size
PUBLIC	?capacity@?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QBEIXZ ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::capacity
PUBLIC	?_M_clear@?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@AAEXXZ ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::_M_clear
PUBLIC	??$xr_alloc@U_REG_INFO@@@@YAPAU_REG_INFO@@I@Z	; xr_alloc<_REG_INFO>
PUBLIC	?allocate@?$xalloc@U_REG_INFO@@@@QBEPAU_REG_INFO@@IPBX@Z ; xalloc<_REG_INFO>::allocate
PUBLIC	?allocate@?$_STLP_alloc_proxy@PAU_REG_INFO@@U1@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAEPAU_REG_INFO@@I@Z ; stlp_std::priv::_STLP_alloc_proxy<_REG_INFO *,_REG_INFO,xalloc<_REG_INFO> >::allocate
PUBLIC	?allocate@?$_STLP_alloc_proxy@PAU_REG_INFO@@U1@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@AAEPAU_REG_INFO@@IAAIABU__false_type@3@@Z ; stlp_std::priv::_STLP_alloc_proxy<_REG_INFO *,_REG_INFO,xalloc<_REG_INFO> >::allocate
PUBLIC	?allocate@?$_STLP_alloc_proxy@PAU_REG_INFO@@U1@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAEPAU_REG_INFO@@IAAI@Z ; stlp_std::priv::_STLP_alloc_proxy<_REG_INFO *,_REG_INFO,xalloc<_REG_INFO> >::allocate
PUBLIC	?_Answer@?$_BothPtrType@PBU_REG_INFO@@PAU1@@stlp_std@@SA?AU__true_type@2@XZ ; stlp_std::_BothPtrType<_REG_INFO const *,_REG_INFO *>::_Answer
PUBLIC	??$__ucopy_ptrs@PBU_REG_INFO@@PAU1@@priv@stlp_std@@YAPAU_REG_INFO@@PBU2@0PAU2@ABU__true_type@1@@Z ; stlp_std::priv::__ucopy_ptrs<_REG_INFO const *,_REG_INFO *>
PUBLIC	??$_UseTrivialUCopy@U_REG_INFO@@U1@@stlp_std@@YA?AU?$_TrivialUCopy@U_REG_INFO@@U1@@0@PAU_REG_INFO@@0@Z ; stlp_std::_UseTrivialUCopy<_REG_INFO,_REG_INFO>
PUBLIC	?_Answer@?$_TrivialUCopy@U_REG_INFO@@U1@@stlp_std@@SA?AU__true_type@2@XZ ; stlp_std::_TrivialUCopy<_REG_INFO,_REG_INFO>::_Answer
PUBLIC	??$__ucopy_aux@PBU_REG_INFO@@PAU1@@priv@stlp_std@@YAPAU_REG_INFO@@PBU2@0PAU2@ABU__true_type@1@@Z ; stlp_std::priv::__ucopy_aux<_REG_INFO const *,_REG_INFO *>
PUBLIC	??$uninitialized_copy@PBU_REG_INFO@@PAU1@@stlp_std@@YAPAU_REG_INFO@@PBU1@0PAU1@@Z ; stlp_std::uninitialized_copy<_REG_INFO const *,_REG_INFO *>
PUBLIC	??$_M_allocate_and_copy@PBU_REG_INFO@@@?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@AAEPAU_REG_INFO@@AAIPBU3@1@Z ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::_M_allocate_and_copy<_REG_INFO const *>
PUBLIC	??$__copy_ptrs@PBU_REG_INFO@@PAU1@@priv@stlp_std@@YAPAU_REG_INFO@@PBU2@0PAU2@ABU__true_type@1@@Z ; stlp_std::priv::__copy_ptrs<_REG_INFO const *,_REG_INFO *>
PUBLIC	??$__destroy_range_aux@PAU_REG_INFO@@U1@@stlp_std@@YAXPAU_REG_INFO@@00ABU__true_type@0@@Z ; stlp_std::__destroy_range_aux<_REG_INFO *,_REG_INFO>
PUBLIC	??$__destroy_range@PAU_REG_INFO@@U1@@stlp_std@@YAXPAU_REG_INFO@@00@Z ; stlp_std::__destroy_range<_REG_INFO *,_REG_INFO>
PUBLIC	??$_Destroy_Range@PAU_REG_INFO@@@stlp_std@@YAXPAU_REG_INFO@@0@Z ; stlp_std::_Destroy_Range<_REG_INFO *>
PUBLIC	??4?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::operator=
PUBLIC	??4?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@stlp_std@@QAEAAV01@ABV01@@Z ; stlp_std::vector<_REG_INFO,xalloc<_REG_INFO> >::operator=
PUBLIC	??4?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QAEAAV0@ABV0@@Z ; xr_vector<_REG_INFO,xalloc<_REG_INFO> >::operator=
PUBLIC	??4?$CRegistrator@VpureScreenResolutionChanged@@@@QAEAAV0@ABV0@@Z ; CRegistrator<pureScreenResolutionChanged>::operator=
PUBLIC	??1?$xr_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@@QAE@XZ ; xr_vector<CSheduler::Item,xalloc<CSheduler::Item> >::~xr_vector<CSheduler::Item,xalloc<CSheduler::Item> >
PUBLIC	??0?$_STLP_alloc_proxy@PAUItem@CSheduler@@U12@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UItem@CSheduler@@@@PAUItem@CSheduler@@@Z ; stlp_std::priv::_STLP_alloc_proxy<CSheduler::Item *,CSheduler::Item,xalloc<CSheduler::Item> >::_STLP_alloc_proxy<CSheduler::Item *,CSheduler::Item,xalloc<CSheduler::Item> >
PUBLIC	??0?$_Vector_base@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAE@IABV?$xalloc@UItem@CSheduler@@@@@Z ; stlp_std::priv::_Vector_base<CSheduler::Item,xalloc<CSheduler::Item> >::_Vector_base<CSheduler::Item,xalloc<CSheduler::Item> >
PUBLIC	??0?$xalloc@UItem@CSheduler@@@@QAE@ABV0@@Z	; xalloc<CSheduler::Item>::xalloc<CSheduler::Item>
PUBLIC	?get_allocator@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QBE?AV?$xalloc@UItem@CSheduler@@@@XZ ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::get_allocator
PUBLIC	?begin@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QBEPBUItem@CSheduler@@XZ ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::begin
PUBLIC	?end@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QBEPBUItem@CSheduler@@XZ ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::end
PUBLIC	??0?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAE@ABV012@@Z ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >
PUBLIC	??0?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAE@ABV01@@Z ; stlp_std::vector<CSheduler::Item,xalloc<CSheduler::Item> >::vector<CSheduler::Item,xalloc<CSheduler::Item> >
PUBLIC	??1?$_Vector_base@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAE@XZ ; stlp_std::priv::_Vector_base<CSheduler::Item,xalloc<CSheduler::Item> >::~_Vector_base<CSheduler::Item,xalloc<CSheduler::Item> >
PUBLIC	??1?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAE@XZ ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::~_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >
PUBLIC	??1?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAE@XZ ; stlp_std::vector<CSheduler::Item,xalloc<CSheduler::Item> >::~vector<CSheduler::Item,xalloc<CSheduler::Item> >
PUBLIC	??0?$xr_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@@QAE@ABV0@@Z ; xr_vector<CSheduler::Item,xalloc<CSheduler::Item> >::xr_vector<CSheduler::Item,xalloc<CSheduler::Item> >
PUBLIC	??1?$xr_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@@QAE@XZ ; xr_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::~xr_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >
PUBLIC	??0?$_STLP_alloc_proxy@PAUItemReg@CSheduler@@U12@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UItemReg@CSheduler@@@@PAUItemReg@CSheduler@@@Z ; stlp_std::priv::_STLP_alloc_proxy<CSheduler::ItemReg *,CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::_STLP_alloc_proxy<CSheduler::ItemReg *,CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >
PUBLIC	??0?$_Vector_base@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAE@IABV?$xalloc@UItemReg@CSheduler@@@@@Z ; stlp_std::priv::_Vector_base<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::_Vector_base<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >
PUBLIC	??0?$xalloc@UItemReg@CSheduler@@@@QAE@ABV0@@Z	; xalloc<CSheduler::ItemReg>::xalloc<CSheduler::ItemReg>
PUBLIC	?get_allocator@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QBE?AV?$xalloc@UItemReg@CSheduler@@@@XZ ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::get_allocator
PUBLIC	?begin@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QBEPBUItemReg@CSheduler@@XZ ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::begin
PUBLIC	?end@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QBEPBUItemReg@CSheduler@@XZ ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::end
PUBLIC	??0?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAE@ABV012@@Z ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >
PUBLIC	??0?$vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@stlp_std@@QAE@ABV01@@Z ; stlp_std::vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >
PUBLIC	??1?$_Vector_base@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAE@XZ ; stlp_std::priv::_Vector_base<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::~_Vector_base<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >
PUBLIC	??1?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAE@XZ ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::~_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >
PUBLIC	??1?$vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@stlp_std@@QAE@XZ ; stlp_std::vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::~vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >
PUBLIC	??0?$xr_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@@QAE@ABV0@@Z ; xr_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::xr_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >
PUBLIC	?size@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QBEIXZ ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::size
PUBLIC	?capacity@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QBEIXZ ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::capacity
PUBLIC	??$xr_free@UItem@CSheduler@@@@YAXAAPAUItem@CSheduler@@@Z ; xr_free<CSheduler::Item>
PUBLIC	?deallocate@?$xalloc@UItem@CSheduler@@@@QBEXPAUItem@CSheduler@@I@Z ; xalloc<CSheduler::Item>::deallocate
PUBLIC	?end@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEPAUItem@CSheduler@@XZ ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::end
PUBLIC	?rbegin@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAUItem@CSheduler@@@3@XZ ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::rbegin
PUBLIC	?begin@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEPAUItem@CSheduler@@XZ ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::begin
PUBLIC	??0?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@QAE@PAUItem@CSheduler@@@Z ; stlp_std::reverse_iterator<CSheduler::Item *>::reverse_iterator<CSheduler::Item *>
PUBLIC	?rend@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAUItem@CSheduler@@@3@XZ ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::rend
PUBLIC	??0?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@QAE@ABV01@@Z ; stlp_std::reverse_iterator<CSheduler::Item *>::reverse_iterator<CSheduler::Item *>
PUBLIC	??D?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@QBEAAUItem@CSheduler@@XZ ; stlp_std::reverse_iterator<CSheduler::Item *>::operator*
PUBLIC	??E?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@QAEAAV01@XZ ; stlp_std::reverse_iterator<CSheduler::Item *>::operator++
PUBLIC	?base@?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@QBEPAUItem@CSheduler@@XZ ; stlp_std::reverse_iterator<CSheduler::Item *>::base
PUBLIC	??$?8PAUItem@CSheduler@@@stlp_std@@YA_NABV?$reverse_iterator@PAUItem@CSheduler@@@0@0@Z ; stlp_std::operator==<CSheduler::Item *>
PUBLIC	??$?9PAUItem@CSheduler@@@stlp_std@@YA_NABV?$reverse_iterator@PAUItem@CSheduler@@@0@0@Z ; stlp_std::operator!=<CSheduler::Item *>
PUBLIC	??$__destroy_range_aux@V?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@UItem@CSheduler@@@stlp_std@@YAXV?$reverse_iterator@PAUItem@CSheduler@@@0@0PAUItem@CSheduler@@ABU__false_type@0@@Z ; stlp_std::__destroy_range_aux<stlp_std::reverse_iterator<CSheduler::Item *>,CSheduler::Item>
PUBLIC	??$__destroy_range@V?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@UItem@CSheduler@@@stlp_std@@YAXV?$reverse_iterator@PAUItem@CSheduler@@@0@0PAUItem@CSheduler@@@Z ; stlp_std::__destroy_range<stlp_std::reverse_iterator<CSheduler::Item *>,CSheduler::Item>
PUBLIC	??$_Destroy_Range@V?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@@stlp_std@@YAXV?$reverse_iterator@PAUItem@CSheduler@@@0@0@Z ; stlp_std::_Destroy_Range<stlp_std::reverse_iterator<CSheduler::Item *> >
PUBLIC	?_M_clear@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@AAEXXZ ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::_M_clear
PUBLIC	??$xr_alloc@UItem@CSheduler@@@@YAPAUItem@CSheduler@@I@Z ; xr_alloc<CSheduler::Item>
PUBLIC	?allocate@?$xalloc@UItem@CSheduler@@@@QBEPAUItem@CSheduler@@IPBX@Z ; xalloc<CSheduler::Item>::allocate
PUBLIC	?allocate@?$_STLP_alloc_proxy@PAUItem@CSheduler@@U12@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEPAUItem@CSheduler@@I@Z ; stlp_std::priv::_STLP_alloc_proxy<CSheduler::Item *,CSheduler::Item,xalloc<CSheduler::Item> >::allocate
PUBLIC	?allocate@?$_STLP_alloc_proxy@PAUItem@CSheduler@@U12@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@AAEPAUItem@CSheduler@@IAAIABU__false_type@3@@Z ; stlp_std::priv::_STLP_alloc_proxy<CSheduler::Item *,CSheduler::Item,xalloc<CSheduler::Item> >::allocate
PUBLIC	?allocate@?$_STLP_alloc_proxy@PAUItem@CSheduler@@U12@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEPAUItem@CSheduler@@IAAI@Z ; stlp_std::priv::_STLP_alloc_proxy<CSheduler::Item *,CSheduler::Item,xalloc<CSheduler::Item> >::allocate
PUBLIC	?_Answer@?$_BothPtrType@PBUItem@CSheduler@@PAU12@@stlp_std@@SA?AU__true_type@2@XZ ; stlp_std::_BothPtrType<CSheduler::Item const *,CSheduler::Item *>::_Answer
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??0shared_str@@QAE@ABV0@@Z			; shared_str::shared_str
PUBLIC	??0Item@CSheduler@@QAE@ABU01@@Z			; CSheduler::Item::Item
PUBLIC	??$_Param_Construct@UItem@CSheduler@@U12@@stlp_std@@YAXPAUItem@CSheduler@@ABU12@@Z ; stlp_std::_Param_Construct<CSheduler::Item,CSheduler::Item>
PUBLIC	??$__ucopy@PBUItem@CSheduler@@PAU12@H@priv@stlp_std@@YAPAUItem@CSheduler@@PBU23@0PAU23@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<CSheduler::Item const *,CSheduler::Item *,int>
PUBLIC	??$__ucopy_ptrs@PBUItem@CSheduler@@PAU12@@priv@stlp_std@@YAPAUItem@CSheduler@@PBU23@0PAU23@ABU__false_type@1@@Z ; stlp_std::priv::__ucopy_ptrs<CSheduler::Item const *,CSheduler::Item *>
PUBLIC	??$_UseTrivialUCopy@UItem@CSheduler@@U12@@stlp_std@@YA?AU?$_TrivialUCopy@UItem@CSheduler@@U12@@0@PAUItem@CSheduler@@0@Z ; stlp_std::_UseTrivialUCopy<CSheduler::Item,CSheduler::Item>
PUBLIC	?_Answer@?$_TrivialUCopy@UItem@CSheduler@@U12@@stlp_std@@SA?AU__false_type@2@XZ ; stlp_std::_TrivialUCopy<CSheduler::Item,CSheduler::Item>::_Answer
PUBLIC	??$__ucopy_aux@PBUItem@CSheduler@@PAU12@@priv@stlp_std@@YAPAUItem@CSheduler@@PBU23@0PAU23@ABU__true_type@1@@Z ; stlp_std::priv::__ucopy_aux<CSheduler::Item const *,CSheduler::Item *>
PUBLIC	??$uninitialized_copy@PBUItem@CSheduler@@PAU12@@stlp_std@@YAPAUItem@CSheduler@@PBU12@0PAU12@@Z ; stlp_std::uninitialized_copy<CSheduler::Item const *,CSheduler::Item *>
PUBLIC	??$_M_allocate_and_copy@PBUItem@CSheduler@@@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@AAEPAUItem@CSheduler@@AAIPBU34@1@Z ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::_M_allocate_and_copy<CSheduler::Item const *>
PUBLIC	?_set@shared_str@@QAEXABV1@@Z			; shared_str::_set
PUBLIC	??4shared_str@@QAEAAV0@ABV0@@Z			; shared_str::operator=
PUBLIC	??4Item@CSheduler@@QAEAAU01@ABU01@@Z		; CSheduler::Item::operator=
PUBLIC	??$__copy@PBUItem@CSheduler@@PAU12@H@priv@stlp_std@@YAPAUItem@CSheduler@@PBU23@0PAU23@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__copy<CSheduler::Item const *,CSheduler::Item *,int>
PUBLIC	??$__copy_ptrs@PBUItem@CSheduler@@PAU12@@priv@stlp_std@@YAPAUItem@CSheduler@@PBU23@0PAU23@ABU__false_type@1@@Z ; stlp_std::priv::__copy_ptrs<CSheduler::Item const *,CSheduler::Item *>
PUBLIC	?_dec@shared_str@@IAEXXZ			; shared_str::_dec
PUBLIC	??1shared_str@@QAE@XZ				; shared_str::~shared_str
PUBLIC	??1Item@CSheduler@@QAE@XZ			; CSheduler::Item::~Item
PUBLIC	??_GItem@CSheduler@@QAEPAXI@Z			; CSheduler::Item::`scalar deleting destructor'
PUBLIC	??$__destroy_aux@UItem@CSheduler@@@stlp_std@@YAXPAUItem@CSheduler@@ABU__false_type@0@@Z ; stlp_std::__destroy_aux<CSheduler::Item>
PUBLIC	??$__destroy_range_aux@PAUItem@CSheduler@@U12@@stlp_std@@YAXPAUItem@CSheduler@@00ABU__false_type@0@@Z ; stlp_std::__destroy_range_aux<CSheduler::Item *,CSheduler::Item>
PUBLIC	??$__destroy_range@PAUItem@CSheduler@@U12@@stlp_std@@YAXPAUItem@CSheduler@@00@Z ; stlp_std::__destroy_range<CSheduler::Item *,CSheduler::Item>
PUBLIC	??$_Destroy_Range@PAUItem@CSheduler@@@stlp_std@@YAXPAUItem@CSheduler@@0@Z ; stlp_std::_Destroy_Range<CSheduler::Item *>
PUBLIC	??4?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::operator=
PUBLIC	??4?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAEAAV01@ABV01@@Z ; stlp_std::vector<CSheduler::Item,xalloc<CSheduler::Item> >::operator=
PUBLIC	??4?$xr_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@@QAEAAV0@ABV0@@Z ; xr_vector<CSheduler::Item,xalloc<CSheduler::Item> >::operator=
PUBLIC	?size@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QBEIXZ ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::size
PUBLIC	?capacity@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QBEIXZ ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::capacity
PUBLIC	??$xr_free@UItemReg@CSheduler@@@@YAXAAPAUItemReg@CSheduler@@@Z ; xr_free<CSheduler::ItemReg>
PUBLIC	?deallocate@?$xalloc@UItemReg@CSheduler@@@@QBEXPAUItemReg@CSheduler@@I@Z ; xalloc<CSheduler::ItemReg>::deallocate
PUBLIC	?end@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAEPAUItemReg@CSheduler@@XZ ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::end
PUBLIC	?rbegin@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAUItemReg@CSheduler@@@3@XZ ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::rbegin
PUBLIC	?begin@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAEPAUItemReg@CSheduler@@XZ ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::begin
PUBLIC	??0?$reverse_iterator@PAUItemReg@CSheduler@@@stlp_std@@QAE@PAUItemReg@CSheduler@@@Z ; stlp_std::reverse_iterator<CSheduler::ItemReg *>::reverse_iterator<CSheduler::ItemReg *>
PUBLIC	?rend@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAUItemReg@CSheduler@@@3@XZ ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::rend
PUBLIC	??0?$reverse_iterator@PAUItemReg@CSheduler@@@stlp_std@@QAE@ABV01@@Z ; stlp_std::reverse_iterator<CSheduler::ItemReg *>::reverse_iterator<CSheduler::ItemReg *>
PUBLIC	??$__destroy_range_aux@V?$reverse_iterator@PAUItemReg@CSheduler@@@stlp_std@@UItemReg@CSheduler@@@stlp_std@@YAXV?$reverse_iterator@PAUItemReg@CSheduler@@@0@0PAUItemReg@CSheduler@@ABU__true_type@0@@Z ; stlp_std::__destroy_range_aux<stlp_std::reverse_iterator<CSheduler::ItemReg *>,CSheduler::ItemReg>
PUBLIC	??$__destroy_range@V?$reverse_iterator@PAUItemReg@CSheduler@@@stlp_std@@UItemReg@CSheduler@@@stlp_std@@YAXV?$reverse_iterator@PAUItemReg@CSheduler@@@0@0PAUItemReg@CSheduler@@@Z ; stlp_std::__destroy_range<stlp_std::reverse_iterator<CSheduler::ItemReg *>,CSheduler::ItemReg>
PUBLIC	??$_Destroy_Range@V?$reverse_iterator@PAUItemReg@CSheduler@@@stlp_std@@@stlp_std@@YAXV?$reverse_iterator@PAUItemReg@CSheduler@@@0@0@Z ; stlp_std::_Destroy_Range<stlp_std::reverse_iterator<CSheduler::ItemReg *> >
PUBLIC	?_M_clear@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@AAEXXZ ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::_M_clear
PUBLIC	??$xr_alloc@UItemReg@CSheduler@@@@YAPAUItemReg@CSheduler@@I@Z ; xr_alloc<CSheduler::ItemReg>
PUBLIC	?allocate@?$xalloc@UItemReg@CSheduler@@@@QBEPAUItemReg@CSheduler@@IPBX@Z ; xalloc<CSheduler::ItemReg>::allocate
PUBLIC	?allocate@?$_STLP_alloc_proxy@PAUItemReg@CSheduler@@U12@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAEPAUItemReg@CSheduler@@I@Z ; stlp_std::priv::_STLP_alloc_proxy<CSheduler::ItemReg *,CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::allocate
PUBLIC	?allocate@?$_STLP_alloc_proxy@PAUItemReg@CSheduler@@U12@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@AAEPAUItemReg@CSheduler@@IAAIABU__false_type@3@@Z ; stlp_std::priv::_STLP_alloc_proxy<CSheduler::ItemReg *,CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::allocate
PUBLIC	?allocate@?$_STLP_alloc_proxy@PAUItemReg@CSheduler@@U12@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAEPAUItemReg@CSheduler@@IAAI@Z ; stlp_std::priv::_STLP_alloc_proxy<CSheduler::ItemReg *,CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::allocate
PUBLIC	?_Answer@?$_BothPtrType@PBUItemReg@CSheduler@@PAU12@@stlp_std@@SA?AU__true_type@2@XZ ; stlp_std::_BothPtrType<CSheduler::ItemReg const *,CSheduler::ItemReg *>::_Answer
PUBLIC	?__ucopy_trivial@priv@stlp_std@@YAPAXPBX0PAX@Z	; stlp_std::priv::__ucopy_trivial
PUBLIC	??$__ucopy_ptrs@PBUItemReg@CSheduler@@PAU12@@priv@stlp_std@@YAPAUItemReg@CSheduler@@PBU23@0PAU23@ABU__true_type@1@@Z ; stlp_std::priv::__ucopy_ptrs<CSheduler::ItemReg const *,CSheduler::ItemReg *>
PUBLIC	??$_UseTrivialUCopy@UItemReg@CSheduler@@U12@@stlp_std@@YA?AU?$_TrivialUCopy@UItemReg@CSheduler@@U12@@0@PAUItemReg@CSheduler@@0@Z ; stlp_std::_UseTrivialUCopy<CSheduler::ItemReg,CSheduler::ItemReg>
PUBLIC	?_Answer@?$_TrivialUCopy@UItemReg@CSheduler@@U12@@stlp_std@@SA?AU__true_type@2@XZ ; stlp_std::_TrivialUCopy<CSheduler::ItemReg,CSheduler::ItemReg>::_Answer
PUBLIC	??$__ucopy_aux@PBUItemReg@CSheduler@@PAU12@@priv@stlp_std@@YAPAUItemReg@CSheduler@@PBU23@0PAU23@ABU__true_type@1@@Z ; stlp_std::priv::__ucopy_aux<CSheduler::ItemReg const *,CSheduler::ItemReg *>
PUBLIC	??$uninitialized_copy@PBUItemReg@CSheduler@@PAU12@@stlp_std@@YAPAUItemReg@CSheduler@@PBU12@0PAU12@@Z ; stlp_std::uninitialized_copy<CSheduler::ItemReg const *,CSheduler::ItemReg *>
PUBLIC	??$_M_allocate_and_copy@PBUItemReg@CSheduler@@@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@AAEPAUItemReg@CSheduler@@AAIPBU34@1@Z ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::_M_allocate_and_copy<CSheduler::ItemReg const *>
PUBLIC	?__copy_trivial@priv@stlp_std@@YAPAXPBX0PAX@Z	; stlp_std::priv::__copy_trivial
PUBLIC	??$__copy_ptrs@PBUItemReg@CSheduler@@PAU12@@priv@stlp_std@@YAPAUItemReg@CSheduler@@PBU23@0PAU23@ABU__true_type@1@@Z ; stlp_std::priv::__copy_ptrs<CSheduler::ItemReg const *,CSheduler::ItemReg *>
PUBLIC	??$__destroy_range_aux@PAUItemReg@CSheduler@@U12@@stlp_std@@YAXPAUItemReg@CSheduler@@00ABU__true_type@0@@Z ; stlp_std::__destroy_range_aux<CSheduler::ItemReg *,CSheduler::ItemReg>
PUBLIC	??$__destroy_range@PAUItemReg@CSheduler@@U12@@stlp_std@@YAXPAUItemReg@CSheduler@@00@Z ; stlp_std::__destroy_range<CSheduler::ItemReg *,CSheduler::ItemReg>
PUBLIC	??$_Destroy_Range@PAUItemReg@CSheduler@@@stlp_std@@YAXPAUItemReg@CSheduler@@0@Z ; stlp_std::_Destroy_Range<CSheduler::ItemReg *>
PUBLIC	??4?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::operator=
PUBLIC	??4?$vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@stlp_std@@QAEAAV01@ABV01@@Z ; stlp_std::vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::operator=
PUBLIC	??4?$xr_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@@QAEAAV0@ABV0@@Z ; xr_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::operator=
PUBLIC	??0?$CRegistrator@VpureFrame@@@@QAE@XZ		; CRegistrator<pureFrame>::CRegistrator<pureFrame>
PUBLIC	??1?$CRegistrator@VpureFrame@@@@QAE@XZ		; CRegistrator<pureFrame>::~CRegistrator<pureFrame>
PUBLIC	??0?$xalloc@U_REG_INFO@@@@QAE@XZ		; xalloc<_REG_INFO>::xalloc<_REG_INFO>
PUBLIC	??0?$xalloc@U_REG_INFO@@@@QAE@ABV0@@Z		; xalloc<_REG_INFO>::xalloc<_REG_INFO>
PUBLIC	??0?$_STLP_alloc_proxy@PAU_REG_INFO@@U1@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE@ABV?$xalloc@U_REG_INFO@@@@PAU_REG_INFO@@@Z ; stlp_std::priv::_STLP_alloc_proxy<_REG_INFO *,_REG_INFO,xalloc<_REG_INFO> >::_STLP_alloc_proxy<_REG_INFO *,_REG_INFO,xalloc<_REG_INFO> >
PUBLIC	??0?$_Vector_base@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE@ABV?$xalloc@U_REG_INFO@@@@@Z ; stlp_std::priv::_Vector_base<_REG_INFO,xalloc<_REG_INFO> >::_Vector_base<_REG_INFO,xalloc<_REG_INFO> >
PUBLIC	??0?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE@ABV?$xalloc@U_REG_INFO@@@@@Z ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >
PUBLIC	??0?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@stlp_std@@QAE@ABV?$xalloc@U_REG_INFO@@@@@Z ; stlp_std::vector<_REG_INFO,xalloc<_REG_INFO> >::vector<_REG_INFO,xalloc<_REG_INFO> >
PUBLIC	??0?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QAE@XZ ; xr_vector<_REG_INFO,xalloc<_REG_INFO> >::xr_vector<_REG_INFO,xalloc<_REG_INFO> >
PUBLIC	??0?$CRegistrator@VpureDeviceReset@@@@QAE@XZ	; CRegistrator<pureDeviceReset>::CRegistrator<pureDeviceReset>
PUBLIC	??$xr_free@U_REG_INFO@@@@YAXAAPAU_REG_INFO@@@Z	; xr_free<_REG_INFO>
PUBLIC	?deallocate@?$xalloc@U_REG_INFO@@@@QBEXPAU_REG_INFO@@I@Z ; xalloc<_REG_INFO>::deallocate
PUBLIC	??1?$_Vector_base@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE@XZ ; stlp_std::priv::_Vector_base<_REG_INFO,xalloc<_REG_INFO> >::~_Vector_base<_REG_INFO,xalloc<_REG_INFO> >
PUBLIC	?end@?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAEPAU_REG_INFO@@XZ ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::end
PUBLIC	?rbegin@?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAU_REG_INFO@@@3@XZ ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::rbegin
PUBLIC	?begin@?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAEPAU_REG_INFO@@XZ ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::begin
PUBLIC	??0?$reverse_iterator@PAU_REG_INFO@@@stlp_std@@QAE@PAU_REG_INFO@@@Z ; stlp_std::reverse_iterator<_REG_INFO *>::reverse_iterator<_REG_INFO *>
PUBLIC	?rend@?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAU_REG_INFO@@@3@XZ ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::rend
PUBLIC	??0?$reverse_iterator@PAU_REG_INFO@@@stlp_std@@QAE@ABV01@@Z ; stlp_std::reverse_iterator<_REG_INFO *>::reverse_iterator<_REG_INFO *>
PUBLIC	??$__destroy_range_aux@V?$reverse_iterator@PAU_REG_INFO@@@stlp_std@@U_REG_INFO@@@stlp_std@@YAXV?$reverse_iterator@PAU_REG_INFO@@@0@0PAU_REG_INFO@@ABU__true_type@0@@Z ; stlp_std::__destroy_range_aux<stlp_std::reverse_iterator<_REG_INFO *>,_REG_INFO>
PUBLIC	??$__destroy_range@V?$reverse_iterator@PAU_REG_INFO@@@stlp_std@@U_REG_INFO@@@stlp_std@@YAXV?$reverse_iterator@PAU_REG_INFO@@@0@0PAU_REG_INFO@@@Z ; stlp_std::__destroy_range<stlp_std::reverse_iterator<_REG_INFO *>,_REG_INFO>
PUBLIC	??$_Destroy_Range@V?$reverse_iterator@PAU_REG_INFO@@@stlp_std@@@stlp_std@@YAXV?$reverse_iterator@PAU_REG_INFO@@@0@0@Z ; stlp_std::_Destroy_Range<stlp_std::reverse_iterator<_REG_INFO *> >
PUBLIC	??1?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE@XZ ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::~_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >
PUBLIC	??1?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@stlp_std@@QAE@XZ ; stlp_std::vector<_REG_INFO,xalloc<_REG_INFO> >::~vector<_REG_INFO,xalloc<_REG_INFO> >
PUBLIC	??1?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QAE@XZ ; xr_vector<_REG_INFO,xalloc<_REG_INFO> >::~xr_vector<_REG_INFO,xalloc<_REG_INFO> >
PUBLIC	??1?$CRegistrator@VpureDeviceReset@@@@QAE@XZ	; CRegistrator<pureDeviceReset>::~CRegistrator<pureDeviceReset>
PUBLIC	??0?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@QAE@XZ ; xalloc<fastdelegate::FastDelegate0<void> >::xalloc<fastdelegate::FastDelegate0<void> >
PUBLIC	??0?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@QAE@ABV0@@Z ; xalloc<fastdelegate::FastDelegate0<void> >::xalloc<fastdelegate::FastDelegate0<void> >
PUBLIC	??0?$_STLP_alloc_proxy@PAV?$FastDelegate0@X@fastdelegate@@V12@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAE@ABV?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@PAV?$FastDelegate0@X@fastdelegate@@@Z ; stlp_std::priv::_STLP_alloc_proxy<fastdelegate::FastDelegate0<void> *,fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::_STLP_alloc_proxy<fastdelegate::FastDelegate0<void> *,fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >
PUBLIC	??0?$_Vector_base@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAE@ABV?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@Z ; stlp_std::priv::_Vector_base<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::_Vector_base<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >
PUBLIC	??0?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAE@ABV?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@Z ; stlp_std::priv::_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >
PUBLIC	??0?$vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@stlp_std@@QAE@ABV?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@Z ; stlp_std::vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >
PUBLIC	??0?$xr_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@@QAE@XZ ; xr_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::xr_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >
PUBLIC	??$xr_free@V?$FastDelegate0@X@fastdelegate@@@@YAXAAPAV?$FastDelegate0@X@fastdelegate@@@Z ; xr_free<fastdelegate::FastDelegate0<void> >
PUBLIC	?deallocate@?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@QBEXPAV?$FastDelegate0@X@fastdelegate@@I@Z ; xalloc<fastdelegate::FastDelegate0<void> >::deallocate
PUBLIC	??1?$_Vector_base@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAE@XZ ; stlp_std::priv::_Vector_base<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::~_Vector_base<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >
PUBLIC	?end@?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAEPAV?$FastDelegate0@X@fastdelegate@@XZ ; stlp_std::priv::_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::end
PUBLIC	?rbegin@?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAV?$FastDelegate0@X@fastdelegate@@@3@XZ ; stlp_std::priv::_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::rbegin
PUBLIC	?begin@?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAEPAV?$FastDelegate0@X@fastdelegate@@XZ ; stlp_std::priv::_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::begin
PUBLIC	??0?$reverse_iterator@PAV?$FastDelegate0@X@fastdelegate@@@stlp_std@@QAE@PAV?$FastDelegate0@X@fastdelegate@@@Z ; stlp_std::reverse_iterator<fastdelegate::FastDelegate0<void> *>::reverse_iterator<fastdelegate::FastDelegate0<void> *>
PUBLIC	?rend@?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAV?$FastDelegate0@X@fastdelegate@@@3@XZ ; stlp_std::priv::_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::rend
PUBLIC	??0?$reverse_iterator@PAV?$FastDelegate0@X@fastdelegate@@@stlp_std@@QAE@ABV01@@Z ; stlp_std::reverse_iterator<fastdelegate::FastDelegate0<void> *>::reverse_iterator<fastdelegate::FastDelegate0<void> *>
PUBLIC	??$__destroy_range_aux@V?$reverse_iterator@PAV?$FastDelegate0@X@fastdelegate@@@stlp_std@@V?$FastDelegate0@X@fastdelegate@@@stlp_std@@YAXV?$reverse_iterator@PAV?$FastDelegate0@X@fastdelegate@@@0@0PAV?$FastDelegate0@X@fastdelegate@@ABU__true_type@0@@Z ; stlp_std::__destroy_range_aux<stlp_std::reverse_iterator<fastdelegate::FastDelegate0<void> *>,fastdelegate::FastDelegate0<void> >
PUBLIC	??$__destroy_range@V?$reverse_iterator@PAV?$FastDelegate0@X@fastdelegate@@@stlp_std@@V?$FastDelegate0@X@fastdelegate@@@stlp_std@@YAXV?$reverse_iterator@PAV?$FastDelegate0@X@fastdelegate@@@0@0PAV?$FastDelegate0@X@fastdelegate@@@Z ; stlp_std::__destroy_range<stlp_std::reverse_iterator<fastdelegate::FastDelegate0<void> *>,fastdelegate::FastDelegate0<void> >
PUBLIC	??$_Destroy_Range@V?$reverse_iterator@PAV?$FastDelegate0@X@fastdelegate@@@stlp_std@@@stlp_std@@YAXV?$reverse_iterator@PAV?$FastDelegate0@X@fastdelegate@@@0@0@Z ; stlp_std::_Destroy_Range<stlp_std::reverse_iterator<fastdelegate::FastDelegate0<void> *> >
PUBLIC	??1?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAE@XZ ; stlp_std::priv::_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::~_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >
PUBLIC	??1?$vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@stlp_std@@QAE@XZ ; stlp_std::vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::~vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >
PUBLIC	??1?$xr_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@@QAE@XZ ; xr_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::~xr_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >
PUBLIC	___@@_PchSym_@00@UxovzihpbUhlfixvhUvmtrmvUcivmtrmvUivovzhvPhvxfilnUhgwzucOlyq@
PUBLIC	??_C@_07CIFAGBMG@unknown?$AA@			; `string'
PUBLIC	??_7DLL_Pure@@6B@				; DLL_Pure::`vftable'
PUBLIC	??_7IEventReceiver@@6B@				; IEventReceiver::`vftable'
PUBLIC	??_7ISheduled@@6B@				; ISheduled::`vftable'
PUBLIC	??_7pureFrame@@6B@				; pureFrame::`vftable'
PUBLIC	??_7pureRender@@6B@				; pureRender::`vftable'
PUBLIC	??_7pureAppActivate@@6B@			; pureAppActivate::`vftable'
PUBLIC	??_7pureAppDeactivate@@6B@			; pureAppDeactivate::`vftable'
PUBLIC	??_7pureAppStart@@6B@				; pureAppStart::`vftable'
PUBLIC	??_7pureAppEnd@@6B@				; pureAppEnd::`vftable'
PUBLIC	??_7pureDeviceReset@@6B@			; pureDeviceReset::`vftable'
PUBLIC	??_7pureScreenResolutionChanged@@6B@		; pureScreenResolutionChanged::`vftable'
PUBLIC	??_7pureStats@@6B@				; pureStats::`vftable'
PUBLIC	??_7CStats@@6B@					; CStats::`vftable'
PUBLIC	??_7IRenderDevice@@6B@				; IRenderDevice::`vftable'
PUBLIC	??_7CRenderDeviceBase@@6B@			; CRenderDeviceBase::`vftable'
PUBLIC	??_7CRenderDevice@@6B@				; CRenderDevice::`vftable'
PUBLIC	??_7CLoadScreenRenderer@@6B@			; CLoadScreenRenderer::`vftable'
EXTRN	__imp_?qpc_overhead@CPU@@3_KA:QWORD
EXTRN	__imp_?GetElapsed_ticks@CTimerBase@@QBE_KXZ:PROC
EXTRN	__imp_?GetElapsed_ticks@CTimer@@ABE_KAB_K@Z:PROC
EXTRN	__imp_?time_factor@CTimer@@QAEXABM@Z:PROC
EXTRN	__imp_?time_factor@CTimer@@QBEABMXZ:PROC
EXTRN	__imp_??0CStatTimer@@QAE@XZ:PROC
EXTRN	__imp_?RenderFactory@@3PAVIRenderFactory@@A:DWORD
EXTRN	__imp_?dock@str_container@@QAEPAUstr_value@@PBD@Z:PROC
EXTRN	__imp_?g_pStringContainer@@3PAVstr_container@@A:DWORD
EXTRN	__imp_??0CTimer_paused@@QAE@XZ:PROC
EXTRN	__imp_??1CTimer_paused@@UAE@XZ:PROC
EXTRN	__imp_??1CTimer_paused_ex@@UAE@XZ:PROC
EXTRN	__imp_??_7CTimer_paused_ex@@6B@:QWORD
EXTRN	__imp_??0CTimer_paused_ex@@QAE@ABV0@@Z:PROC
EXTRN	__imp_??_7CTimer_paused@@6B@:QWORD
EXTRN	__imp_??0CTimer_paused@@QAE@ABV0@@Z:PROC
EXTRN	__imp_??4CTimer_paused_ex@@QAEAAV0@ABV0@@Z:PROC
EXTRN	__imp_??4CTimer_paused@@QAEAAV0@ABV0@@Z:PROC
EXTRN	__imp__memmove:PROC
EXTRN	__imp_??0xrCriticalSection@@QAE@XZ:PROC
EXTRN	__imp_??1xrCriticalSection@@QAE@XZ:PROC
EXTRN	__imp_??0CTimerBase@@QAE@XZ:PROC
EXTRN	__imp_??0CTimer@@QAE@XZ:PROC
EXTRN	__imp_?QPC@CPU@@YA_KXZ:PROC
EXTRN	__imp_?Start@CTimerBase@@QAEXXZ:PROC
EXTRN	__imp_?Start@CTimer@@QAEXXZ:PROC
EXTRN	__purecall:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	__imp_?GetElapsed_ms@CTimer@@QBEIXZ:PROC
___@@_PchSym_@00@UxovzihpbUhlfixvhUvmtrmvUcivmtrmvUivovzhvPhvxfilnUhgwzucOlyq@ DD 01H DUP (?)
;	COMDAT ??_7CLoadScreenRenderer@@6B@
CONST	SEGMENT
??_7CLoadScreenRenderer@@6B@ DD FLAT:??_R4CLoadScreenRenderer@@6B@ ; CLoadScreenRenderer::`vftable'
	DD	FLAT:?OnRender@CLoadScreenRenderer@@UAEXXZ
CONST	ENDS
;	COMDAT ??_R4CLoadScreenRenderer@@6B@
rdata$r	SEGMENT
??_R4CLoadScreenRenderer@@6B@ DD 00H			; CLoadScreenRenderer::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCLoadScreenRenderer@@@8
	DD	FLAT:??_R3CLoadScreenRenderer@@8
rdata$r	ENDS
;	COMDAT ??_R3CLoadScreenRenderer@@8
rdata$r	SEGMENT
??_R3CLoadScreenRenderer@@8 DD 00H			; CLoadScreenRenderer::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CLoadScreenRenderer@@8
rdata$r	ENDS
;	COMDAT ??_R2CLoadScreenRenderer@@8
rdata$r	SEGMENT
??_R2CLoadScreenRenderer@@8 DD FLAT:??_R1A@?0A@EA@CLoadScreenRenderer@@8 ; CLoadScreenRenderer::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@pureRender@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CLoadScreenRenderer@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CLoadScreenRenderer@@8 DD FLAT:??_R0?AVCLoadScreenRenderer@@@8 ; CLoadScreenRenderer::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CLoadScreenRenderer@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCLoadScreenRenderer@@@8
_DATA	SEGMENT
??_R0?AVCLoadScreenRenderer@@@8 DD FLAT:??_7type_info@@6B@ ; CLoadScreenRenderer `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCLoadScreenRenderer@@', 00H
_DATA	ENDS
;	COMDAT ??_7CRenderDevice@@6B@
CONST	SEGMENT
??_7CRenderDevice@@6B@ DD FLAT:??_R4CRenderDevice@@6B@	; CRenderDevice::`vftable'
	DD	FLAT:?StatPhysics@CRenderDevice@@EAGPAVCStatsPhysics@@XZ
	DD	FLAT:?AddSeqFrame@CRenderDevice@@EAGXPAVpureFrame@@_N@Z
	DD	FLAT:?RemoveSeqFrame@CRenderDevice@@EAGXPAVpureFrame@@@Z
CONST	ENDS
;	COMDAT ??_R4CRenderDevice@@6B@
rdata$r	SEGMENT
??_R4CRenderDevice@@6B@ DD 00H				; CRenderDevice::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCRenderDevice@@@8
	DD	FLAT:??_R3CRenderDevice@@8
rdata$r	ENDS
;	COMDAT ??_R3CRenderDevice@@8
rdata$r	SEGMENT
??_R3CRenderDevice@@8 DD 00H				; CRenderDevice::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2CRenderDevice@@8
rdata$r	ENDS
;	COMDAT ??_R2CRenderDevice@@8
rdata$r	SEGMENT
??_R2CRenderDevice@@8 DD FLAT:??_R1A@?0A@EA@CRenderDevice@@8 ; CRenderDevice::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CRenderDeviceBase@@8
	DD	FLAT:??_R1A@?0A@EA@IRenderDevice@@8
	DD	FLAT:??_R13?0A@EA@CRenderDeviceData@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CRenderDevice@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CRenderDevice@@8 DD FLAT:??_R0?AVCRenderDevice@@@8 ; CRenderDevice::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CRenderDevice@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCRenderDevice@@@8
_DATA	SEGMENT
??_R0?AVCRenderDevice@@@8 DD FLAT:??_7type_info@@6B@	; CRenderDevice `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCRenderDevice@@', 00H
_DATA	ENDS
;	COMDAT ??_7CRenderDeviceBase@@6B@
CONST	SEGMENT
??_7CRenderDeviceBase@@6B@ DD FLAT:??_R4CRenderDeviceBase@@6B@ ; CRenderDeviceBase::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_R4CRenderDeviceBase@@6B@
rdata$r	SEGMENT
??_R4CRenderDeviceBase@@6B@ DD 00H			; CRenderDeviceBase::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCRenderDeviceBase@@@8
	DD	FLAT:??_R3CRenderDeviceBase@@8
rdata$r	ENDS
;	COMDAT ??_R3CRenderDeviceBase@@8
rdata$r	SEGMENT
??_R3CRenderDeviceBase@@8 DD 00H			; CRenderDeviceBase::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	03H
	DD	FLAT:??_R2CRenderDeviceBase@@8
rdata$r	ENDS
;	COMDAT ??_R2CRenderDeviceBase@@8
rdata$r	SEGMENT
??_R2CRenderDeviceBase@@8 DD FLAT:??_R1A@?0A@EA@CRenderDeviceBase@@8 ; CRenderDeviceBase::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IRenderDevice@@8
	DD	FLAT:??_R13?0A@EA@CRenderDeviceData@@8
rdata$r	ENDS
;	COMDAT ??_R13?0A@EA@CRenderDeviceData@@8
rdata$r	SEGMENT
??_R13?0A@EA@CRenderDeviceData@@8 DD FLAT:??_R0?AVCRenderDeviceData@@@8 ; CRenderDeviceData::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CRenderDeviceData@@8
rdata$r	ENDS
;	COMDAT ??_R3CRenderDeviceData@@8
rdata$r	SEGMENT
??_R3CRenderDeviceData@@8 DD 00H			; CRenderDeviceData::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CRenderDeviceData@@8
rdata$r	ENDS
;	COMDAT ??_R2CRenderDeviceData@@8
rdata$r	SEGMENT
??_R2CRenderDeviceData@@8 DD FLAT:??_R1A@?0A@EA@CRenderDeviceData@@8 ; CRenderDeviceData::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CRenderDeviceData@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CRenderDeviceData@@8 DD FLAT:??_R0?AVCRenderDeviceData@@@8 ; CRenderDeviceData::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CRenderDeviceData@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCRenderDeviceData@@@8
_DATA	SEGMENT
??_R0?AVCRenderDeviceData@@@8 DD FLAT:??_7type_info@@6B@ ; CRenderDeviceData `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCRenderDeviceData@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@CRenderDeviceBase@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CRenderDeviceBase@@8 DD FLAT:??_R0?AVCRenderDeviceBase@@@8 ; CRenderDeviceBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CRenderDeviceBase@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCRenderDeviceBase@@@8
_DATA	SEGMENT
??_R0?AVCRenderDeviceBase@@@8 DD FLAT:??_7type_info@@6B@ ; CRenderDeviceBase `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCRenderDeviceBase@@', 00H
_DATA	ENDS
;	COMDAT ??_7IRenderDevice@@6B@
CONST	SEGMENT
??_7IRenderDevice@@6B@ DD FLAT:??_R4IRenderDevice@@6B@	; IRenderDevice::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_R4IRenderDevice@@6B@
rdata$r	SEGMENT
??_R4IRenderDevice@@6B@ DD 00H				; IRenderDevice::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVIRenderDevice@@@8
	DD	FLAT:??_R3IRenderDevice@@8
rdata$r	ENDS
;	COMDAT ??_R3IRenderDevice@@8
rdata$r	SEGMENT
??_R3IRenderDevice@@8 DD 00H				; IRenderDevice::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2IRenderDevice@@8
rdata$r	ENDS
;	COMDAT ??_R2IRenderDevice@@8
rdata$r	SEGMENT
??_R2IRenderDevice@@8 DD FLAT:??_R1A@?0A@EA@IRenderDevice@@8 ; IRenderDevice::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@IRenderDevice@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IRenderDevice@@8 DD FLAT:??_R0?AVIRenderDevice@@@8 ; IRenderDevice::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IRenderDevice@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVIRenderDevice@@@8
_DATA	SEGMENT
??_R0?AVIRenderDevice@@@8 DD FLAT:??_7type_info@@6B@	; IRenderDevice `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVIRenderDevice@@', 00H
_DATA	ENDS
;	COMDAT ??_7CStats@@6B@
CONST	SEGMENT
??_7CStats@@6B@ DD FLAT:??_R4CStats@@6B@		; CStats::`vftable'
	DD	FLAT:?OnRender@CStats@@UAEXXZ
CONST	ENDS
;	COMDAT ??_R4CStats@@6B@
rdata$r	SEGMENT
??_R4CStats@@6B@ DD 00H					; CStats::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCStats@@@8
	DD	FLAT:??_R3CStats@@8
rdata$r	ENDS
;	COMDAT ??_R3CStats@@8
rdata$r	SEGMENT
??_R3CStats@@8 DD 00H					; CStats::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	03H
	DD	FLAT:??_R2CStats@@8
rdata$r	ENDS
;	COMDAT ??_R2CStats@@8
rdata$r	SEGMENT
??_R2CStats@@8 DD FLAT:??_R1A@?0A@EA@CStats@@8		; CStats::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@pureRender@@8
	DD	FLAT:??_R17?0A@EA@CStatsPhysics@@8
rdata$r	ENDS
;	COMDAT ??_R17?0A@EA@CStatsPhysics@@8
rdata$r	SEGMENT
??_R17?0A@EA@CStatsPhysics@@8 DD FLAT:??_R0?AVCStatsPhysics@@@8 ; CStatsPhysics::`RTTI Base Class Descriptor at (8,-1,0,64)'
	DD	00H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CStatsPhysics@@8
rdata$r	ENDS
;	COMDAT ??_R3CStatsPhysics@@8
rdata$r	SEGMENT
??_R3CStatsPhysics@@8 DD 00H				; CStatsPhysics::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CStatsPhysics@@8
rdata$r	ENDS
;	COMDAT ??_R2CStatsPhysics@@8
rdata$r	SEGMENT
??_R2CStatsPhysics@@8 DD FLAT:??_R1A@?0A@EA@CStatsPhysics@@8 ; CStatsPhysics::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CStatsPhysics@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CStatsPhysics@@8 DD FLAT:??_R0?AVCStatsPhysics@@@8 ; CStatsPhysics::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CStatsPhysics@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCStatsPhysics@@@8
_DATA	SEGMENT
??_R0?AVCStatsPhysics@@@8 DD FLAT:??_7type_info@@6B@	; CStatsPhysics `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCStatsPhysics@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@CStats@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CStats@@8 DD FLAT:??_R0?AVCStats@@@8	; CStats::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CStats@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCStats@@@8
_DATA	SEGMENT
??_R0?AVCStats@@@8 DD FLAT:??_7type_info@@6B@		; CStats `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCStats@@', 00H
_DATA	ENDS
;	COMDAT ??_7pureStats@@6B@
CONST	SEGMENT
??_7pureStats@@6B@ DD FLAT:??_R4pureStats@@6B@		; pureStats::`vftable'
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_R4pureStats@@6B@
rdata$r	SEGMENT
??_R4pureStats@@6B@ DD 00H				; pureStats::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVpureStats@@@8
	DD	FLAT:??_R3pureStats@@8
rdata$r	ENDS
;	COMDAT ??_R3pureStats@@8
rdata$r	SEGMENT
??_R3pureStats@@8 DD 00H				; pureStats::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2pureStats@@8
rdata$r	ENDS
;	COMDAT ??_R2pureStats@@8
rdata$r	SEGMENT
??_R2pureStats@@8 DD FLAT:??_R1A@?0A@EA@pureStats@@8	; pureStats::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@pureStats@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@pureStats@@8 DD FLAT:??_R0?AVpureStats@@@8 ; pureStats::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3pureStats@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVpureStats@@@8
_DATA	SEGMENT
??_R0?AVpureStats@@@8 DD FLAT:??_7type_info@@6B@	; pureStats `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVpureStats@@', 00H
_DATA	ENDS
;	COMDAT ??_7pureScreenResolutionChanged@@6B@
CONST	SEGMENT
??_7pureScreenResolutionChanged@@6B@ DD FLAT:??_R4pureScreenResolutionChanged@@6B@ ; pureScreenResolutionChanged::`vftable'
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_R4pureScreenResolutionChanged@@6B@
rdata$r	SEGMENT
??_R4pureScreenResolutionChanged@@6B@ DD 00H		; pureScreenResolutionChanged::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVpureScreenResolutionChanged@@@8
	DD	FLAT:??_R3pureScreenResolutionChanged@@8
rdata$r	ENDS
;	COMDAT ??_R3pureScreenResolutionChanged@@8
rdata$r	SEGMENT
??_R3pureScreenResolutionChanged@@8 DD 00H		; pureScreenResolutionChanged::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2pureScreenResolutionChanged@@8
rdata$r	ENDS
;	COMDAT ??_R2pureScreenResolutionChanged@@8
rdata$r	SEGMENT
??_R2pureScreenResolutionChanged@@8 DD FLAT:??_R1A@?0A@EA@pureScreenResolutionChanged@@8 ; pureScreenResolutionChanged::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@pureScreenResolutionChanged@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@pureScreenResolutionChanged@@8 DD FLAT:??_R0?AVpureScreenResolutionChanged@@@8 ; pureScreenResolutionChanged::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3pureScreenResolutionChanged@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVpureScreenResolutionChanged@@@8
_DATA	SEGMENT
??_R0?AVpureScreenResolutionChanged@@@8 DD FLAT:??_7type_info@@6B@ ; pureScreenResolutionChanged `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVpureScreenResolutionChanged@@', 00H
_DATA	ENDS
;	COMDAT ??_7pureDeviceReset@@6B@
CONST	SEGMENT
??_7pureDeviceReset@@6B@ DD FLAT:??_R4pureDeviceReset@@6B@ ; pureDeviceReset::`vftable'
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_R4pureDeviceReset@@6B@
rdata$r	SEGMENT
??_R4pureDeviceReset@@6B@ DD 00H			; pureDeviceReset::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVpureDeviceReset@@@8
	DD	FLAT:??_R3pureDeviceReset@@8
rdata$r	ENDS
;	COMDAT ??_R3pureDeviceReset@@8
rdata$r	SEGMENT
??_R3pureDeviceReset@@8 DD 00H				; pureDeviceReset::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2pureDeviceReset@@8
rdata$r	ENDS
;	COMDAT ??_R2pureDeviceReset@@8
rdata$r	SEGMENT
??_R2pureDeviceReset@@8 DD FLAT:??_R1A@?0A@EA@pureDeviceReset@@8 ; pureDeviceReset::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@pureDeviceReset@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@pureDeviceReset@@8 DD FLAT:??_R0?AVpureDeviceReset@@@8 ; pureDeviceReset::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3pureDeviceReset@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVpureDeviceReset@@@8
_DATA	SEGMENT
??_R0?AVpureDeviceReset@@@8 DD FLAT:??_7type_info@@6B@	; pureDeviceReset `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVpureDeviceReset@@', 00H
_DATA	ENDS
;	COMDAT ??_7pureAppEnd@@6B@
CONST	SEGMENT
??_7pureAppEnd@@6B@ DD FLAT:??_R4pureAppEnd@@6B@	; pureAppEnd::`vftable'
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_R4pureAppEnd@@6B@
rdata$r	SEGMENT
??_R4pureAppEnd@@6B@ DD 00H				; pureAppEnd::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVpureAppEnd@@@8
	DD	FLAT:??_R3pureAppEnd@@8
rdata$r	ENDS
;	COMDAT ??_R3pureAppEnd@@8
rdata$r	SEGMENT
??_R3pureAppEnd@@8 DD 00H				; pureAppEnd::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2pureAppEnd@@8
rdata$r	ENDS
;	COMDAT ??_R2pureAppEnd@@8
rdata$r	SEGMENT
??_R2pureAppEnd@@8 DD FLAT:??_R1A@?0A@EA@pureAppEnd@@8	; pureAppEnd::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@pureAppEnd@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@pureAppEnd@@8 DD FLAT:??_R0?AVpureAppEnd@@@8 ; pureAppEnd::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3pureAppEnd@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVpureAppEnd@@@8
_DATA	SEGMENT
??_R0?AVpureAppEnd@@@8 DD FLAT:??_7type_info@@6B@	; pureAppEnd `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVpureAppEnd@@', 00H
_DATA	ENDS
;	COMDAT ??_7pureAppStart@@6B@
CONST	SEGMENT
??_7pureAppStart@@6B@ DD FLAT:??_R4pureAppStart@@6B@	; pureAppStart::`vftable'
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_R4pureAppStart@@6B@
rdata$r	SEGMENT
??_R4pureAppStart@@6B@ DD 00H				; pureAppStart::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVpureAppStart@@@8
	DD	FLAT:??_R3pureAppStart@@8
rdata$r	ENDS
;	COMDAT ??_R3pureAppStart@@8
rdata$r	SEGMENT
??_R3pureAppStart@@8 DD 00H				; pureAppStart::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2pureAppStart@@8
rdata$r	ENDS
;	COMDAT ??_R2pureAppStart@@8
rdata$r	SEGMENT
??_R2pureAppStart@@8 DD FLAT:??_R1A@?0A@EA@pureAppStart@@8 ; pureAppStart::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@pureAppStart@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@pureAppStart@@8 DD FLAT:??_R0?AVpureAppStart@@@8 ; pureAppStart::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3pureAppStart@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVpureAppStart@@@8
_DATA	SEGMENT
??_R0?AVpureAppStart@@@8 DD FLAT:??_7type_info@@6B@	; pureAppStart `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVpureAppStart@@', 00H
_DATA	ENDS
;	COMDAT ??_7pureAppDeactivate@@6B@
CONST	SEGMENT
??_7pureAppDeactivate@@6B@ DD FLAT:??_R4pureAppDeactivate@@6B@ ; pureAppDeactivate::`vftable'
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_R4pureAppDeactivate@@6B@
rdata$r	SEGMENT
??_R4pureAppDeactivate@@6B@ DD 00H			; pureAppDeactivate::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVpureAppDeactivate@@@8
	DD	FLAT:??_R3pureAppDeactivate@@8
rdata$r	ENDS
;	COMDAT ??_R3pureAppDeactivate@@8
rdata$r	SEGMENT
??_R3pureAppDeactivate@@8 DD 00H			; pureAppDeactivate::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2pureAppDeactivate@@8
rdata$r	ENDS
;	COMDAT ??_R2pureAppDeactivate@@8
rdata$r	SEGMENT
??_R2pureAppDeactivate@@8 DD FLAT:??_R1A@?0A@EA@pureAppDeactivate@@8 ; pureAppDeactivate::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@pureAppDeactivate@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@pureAppDeactivate@@8 DD FLAT:??_R0?AVpureAppDeactivate@@@8 ; pureAppDeactivate::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3pureAppDeactivate@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVpureAppDeactivate@@@8
_DATA	SEGMENT
??_R0?AVpureAppDeactivate@@@8 DD FLAT:??_7type_info@@6B@ ; pureAppDeactivate `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVpureAppDeactivate@@', 00H
_DATA	ENDS
;	COMDAT ??_7pureAppActivate@@6B@
CONST	SEGMENT
??_7pureAppActivate@@6B@ DD FLAT:??_R4pureAppActivate@@6B@ ; pureAppActivate::`vftable'
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_R4pureAppActivate@@6B@
rdata$r	SEGMENT
??_R4pureAppActivate@@6B@ DD 00H			; pureAppActivate::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVpureAppActivate@@@8
	DD	FLAT:??_R3pureAppActivate@@8
rdata$r	ENDS
;	COMDAT ??_R3pureAppActivate@@8
rdata$r	SEGMENT
??_R3pureAppActivate@@8 DD 00H				; pureAppActivate::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2pureAppActivate@@8
rdata$r	ENDS
;	COMDAT ??_R2pureAppActivate@@8
rdata$r	SEGMENT
??_R2pureAppActivate@@8 DD FLAT:??_R1A@?0A@EA@pureAppActivate@@8 ; pureAppActivate::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@pureAppActivate@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@pureAppActivate@@8 DD FLAT:??_R0?AVpureAppActivate@@@8 ; pureAppActivate::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3pureAppActivate@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVpureAppActivate@@@8
_DATA	SEGMENT
??_R0?AVpureAppActivate@@@8 DD FLAT:??_7type_info@@6B@	; pureAppActivate `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVpureAppActivate@@', 00H
_DATA	ENDS
;	COMDAT ??_7pureRender@@6B@
CONST	SEGMENT
??_7pureRender@@6B@ DD FLAT:??_R4pureRender@@6B@	; pureRender::`vftable'
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_R4pureRender@@6B@
rdata$r	SEGMENT
??_R4pureRender@@6B@ DD 00H				; pureRender::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVpureRender@@@8
	DD	FLAT:??_R3pureRender@@8
rdata$r	ENDS
;	COMDAT ??_R3pureRender@@8
rdata$r	SEGMENT
??_R3pureRender@@8 DD 00H				; pureRender::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2pureRender@@8
rdata$r	ENDS
;	COMDAT ??_R2pureRender@@8
rdata$r	SEGMENT
??_R2pureRender@@8 DD FLAT:??_R1A@?0A@EA@pureRender@@8	; pureRender::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@pureRender@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@pureRender@@8 DD FLAT:??_R0?AVpureRender@@@8 ; pureRender::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3pureRender@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVpureRender@@@8
_DATA	SEGMENT
??_R0?AVpureRender@@@8 DD FLAT:??_7type_info@@6B@	; pureRender `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVpureRender@@', 00H
_DATA	ENDS
;	COMDAT ??_7pureFrame@@6B@
CONST	SEGMENT
??_7pureFrame@@6B@ DD FLAT:??_R4pureFrame@@6B@		; pureFrame::`vftable'
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_R4pureFrame@@6B@
rdata$r	SEGMENT
??_R4pureFrame@@6B@ DD 00H				; pureFrame::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVpureFrame@@@8
	DD	FLAT:??_R3pureFrame@@8
rdata$r	ENDS
;	COMDAT ??_R3pureFrame@@8
rdata$r	SEGMENT
??_R3pureFrame@@8 DD 00H				; pureFrame::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2pureFrame@@8
rdata$r	ENDS
;	COMDAT ??_R2pureFrame@@8
rdata$r	SEGMENT
??_R2pureFrame@@8 DD FLAT:??_R1A@?0A@EA@pureFrame@@8	; pureFrame::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@pureFrame@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@pureFrame@@8 DD FLAT:??_R0?AVpureFrame@@@8 ; pureFrame::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3pureFrame@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVpureFrame@@@8
_DATA	SEGMENT
??_R0?AVpureFrame@@@8 DD FLAT:??_7type_info@@6B@	; pureFrame `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVpureFrame@@', 00H
_DATA	ENDS
;	COMDAT ??_7ISheduled@@6B@
CONST	SEGMENT
??_7ISheduled@@6B@ DD FLAT:??_R4ISheduled@@6B@		; ISheduled::`vftable'
	DD	FLAT:??_EISheduled@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:?shedule_Update@ISheduled@@UAEXI@Z
	DD	FLAT:?shedule_Name@ISheduled@@UBE?AVshared_str@@XZ
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_R4ISheduled@@6B@
rdata$r	SEGMENT
??_R4ISheduled@@6B@ DD 00H				; ISheduled::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVISheduled@@@8
	DD	FLAT:??_R3ISheduled@@8
rdata$r	ENDS
;	COMDAT ??_R3ISheduled@@8
rdata$r	SEGMENT
??_R3ISheduled@@8 DD 00H				; ISheduled::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2ISheduled@@8
rdata$r	ENDS
;	COMDAT ??_R2ISheduled@@8
rdata$r	SEGMENT
??_R2ISheduled@@8 DD FLAT:??_R1A@?0A@EA@ISheduled@@8	; ISheduled::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ISheduled@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ISheduled@@8 DD FLAT:??_R0?AVISheduled@@@8 ; ISheduled::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ISheduled@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVISheduled@@@8
_DATA	SEGMENT
??_R0?AVISheduled@@@8 DD FLAT:??_7type_info@@6B@	; ISheduled `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVISheduled@@', 00H
_DATA	ENDS
;	COMDAT ??_7IEventReceiver@@6B@
CONST	SEGMENT
??_7IEventReceiver@@6B@ DD FLAT:??_R4IEventReceiver@@6B@ ; IEventReceiver::`vftable'
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_R4IEventReceiver@@6B@
rdata$r	SEGMENT
??_R4IEventReceiver@@6B@ DD 00H				; IEventReceiver::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVIEventReceiver@@@8
	DD	FLAT:??_R3IEventReceiver@@8
rdata$r	ENDS
;	COMDAT ??_R3IEventReceiver@@8
rdata$r	SEGMENT
??_R3IEventReceiver@@8 DD 00H				; IEventReceiver::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2IEventReceiver@@8
rdata$r	ENDS
;	COMDAT ??_R2IEventReceiver@@8
rdata$r	SEGMENT
??_R2IEventReceiver@@8 DD FLAT:??_R1A@?0A@EA@IEventReceiver@@8 ; IEventReceiver::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@IEventReceiver@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IEventReceiver@@8 DD FLAT:??_R0?AVIEventReceiver@@@8 ; IEventReceiver::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IEventReceiver@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVIEventReceiver@@@8
_DATA	SEGMENT
??_R0?AVIEventReceiver@@@8 DD FLAT:??_7type_info@@6B@	; IEventReceiver `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVIEventReceiver@@', 00H
_DATA	ENDS
;	COMDAT ??_7DLL_Pure@@6B@
CONST	SEGMENT
??_7DLL_Pure@@6B@ DD FLAT:??_R4DLL_Pure@@6B@		; DLL_Pure::`vftable'
	DD	FLAT:?_construct@DLL_Pure@@UAEPAV1@XZ
	DD	FLAT:??_EDLL_Pure@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4DLL_Pure@@6B@
rdata$r	SEGMENT
??_R4DLL_Pure@@6B@ DD 00H				; DLL_Pure::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVDLL_Pure@@@8
	DD	FLAT:??_R3DLL_Pure@@8
rdata$r	ENDS
;	COMDAT ??_R3DLL_Pure@@8
rdata$r	SEGMENT
??_R3DLL_Pure@@8 DD 00H					; DLL_Pure::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2DLL_Pure@@8
rdata$r	ENDS
;	COMDAT ??_R2DLL_Pure@@8
rdata$r	SEGMENT
??_R2DLL_Pure@@8 DD FLAT:??_R1A@?0A@EA@DLL_Pure@@8	; DLL_Pure::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@DLL_Pure@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@DLL_Pure@@8 DD FLAT:??_R0?AVDLL_Pure@@@8	; DLL_Pure::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3DLL_Pure@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVDLL_Pure@@@8
_DATA	SEGMENT
??_R0?AVDLL_Pure@@@8 DD FLAT:??_7type_info@@6B@		; DLL_Pure `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVDLL_Pure@@', 00H
_DATA	ENDS
;	COMDAT ??_C@_07CIFAGBMG@unknown?$AA@
CONST	SEGMENT
??_C@_07CIFAGBMG@unknown?$AA@ DB 'unknown', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
CONST	SEGMENT
??_C@_0P@GHFPNOJB@bad?5allocation?$AA@ DB 'bad allocation', 00H ; `string'
	ORG $+3
__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
_EPS_L	DD	03a83126fr			; 0.001
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_iterator.h
;	COMDAT ?base@?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@QBEPAUItem@CSheduler@@XZ
_TEXT	SEGMENT
?base@?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@QBEPAUItem@CSheduler@@XZ PROC ; stlp_std::reverse_iterator<CSheduler::Item *>::base, COMDAT
; _this$ = eax

; 75   :   iterator_type base() const { return current; }

	mov	eax, DWORD PTR [eax]
	ret	0
?base@?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@QBEPAUItem@CSheduler@@XZ ENDP ; stlp_std::reverse_iterator<CSheduler::Item *>::base
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?base@?$reverse_iterator@PAVshared_str@@@stlp_std@@QBEPAVshared_str@@XZ
_TEXT	SEGMENT
?base@?$reverse_iterator@PAVshared_str@@@stlp_std@@QBEPAVshared_str@@XZ PROC ; stlp_std::reverse_iterator<shared_str *>::base, COMDAT
; _this$ = eax

; 75   :   iterator_type base() const { return current; }

	mov	eax, DWORD PTR [eax]
	ret	0
?base@?$reverse_iterator@PAVshared_str@@@stlp_std@@QBEPAVshared_str@@XZ ENDP ; stlp_std::reverse_iterator<shared_str *>::base
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?8PAUItem@CSheduler@@@stlp_std@@YA_NABV?$reverse_iterator@PAUItem@CSheduler@@@0@0@Z
_TEXT	SEGMENT
??$?8PAUItem@CSheduler@@@stlp_std@@YA_NABV?$reverse_iterator@PAUItem@CSheduler@@@0@0@Z PROC ; stlp_std::operator==<CSheduler::Item *>, COMDAT
; ___x$ = eax
; ___y$ = edx

; 116  : { return __x.base() == __y.base(); }

	mov	ecx, DWORD PTR [eax]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx]
	sete	al
	ret	0
??$?8PAUItem@CSheduler@@@stlp_std@@YA_NABV?$reverse_iterator@PAUItem@CSheduler@@@0@0@Z ENDP ; stlp_std::operator==<CSheduler::Item *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?8PAVshared_str@@@stlp_std@@YA_NABV?$reverse_iterator@PAVshared_str@@@0@0@Z
_TEXT	SEGMENT
??$?8PAVshared_str@@@stlp_std@@YA_NABV?$reverse_iterator@PAVshared_str@@@0@0@Z PROC ; stlp_std::operator==<shared_str *>, COMDAT
; ___x$ = eax
; ___y$ = edx

; 116  : { return __x.base() == __y.base(); }

	mov	ecx, DWORD PTR [eax]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx]
	sete	al
	ret	0
??$?8PAVshared_str@@@stlp_std@@YA_NABV?$reverse_iterator@PAVshared_str@@@0@0@Z ENDP ; stlp_std::operator==<shared_str *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\type_traits.h
_TEXT	ENDS
;	COMDAT ??$_UseTrivialUCopy@V?$FastDelegate0@X@fastdelegate@@V12@@stlp_std@@YA?AU?$_TrivialUCopy@V?$FastDelegate0@X@fastdelegate@@V12@@0@PAV?$FastDelegate0@X@fastdelegate@@0@Z
_TEXT	SEGMENT
??$_UseTrivialUCopy@V?$FastDelegate0@X@fastdelegate@@V12@@stlp_std@@YA?AU?$_TrivialUCopy@V?$FastDelegate0@X@fastdelegate@@V12@@0@PAV?$FastDelegate0@X@fastdelegate@@0@Z PROC ; stlp_std::_UseTrivialUCopy<fastdelegate::FastDelegate0<void>,fastdelegate::FastDelegate0<void> >, COMDAT

; 489  : { return _TrivialUCopy<_Src, _Dst>(); }

	xor	al, al
	ret	0
??$_UseTrivialUCopy@V?$FastDelegate0@X@fastdelegate@@V12@@stlp_std@@YA?AU?$_TrivialUCopy@V?$FastDelegate0@X@fastdelegate@@V12@@0@PAV?$FastDelegate0@X@fastdelegate@@0@Z ENDP ; stlp_std::_UseTrivialUCopy<fastdelegate::FastDelegate0<void>,fastdelegate::FastDelegate0<void> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_UseTrivialUCopy@U_REG_INFO@@U1@@stlp_std@@YA?AU?$_TrivialUCopy@U_REG_INFO@@U1@@0@PAU_REG_INFO@@0@Z
_TEXT	SEGMENT
??$_UseTrivialUCopy@U_REG_INFO@@U1@@stlp_std@@YA?AU?$_TrivialUCopy@U_REG_INFO@@U1@@0@PAU_REG_INFO@@0@Z PROC ; stlp_std::_UseTrivialUCopy<_REG_INFO,_REG_INFO>, COMDAT

; 489  : { return _TrivialUCopy<_Src, _Dst>(); }

	xor	al, al
	ret	0
??$_UseTrivialUCopy@U_REG_INFO@@U1@@stlp_std@@YA?AU?$_TrivialUCopy@U_REG_INFO@@U1@@0@PAU_REG_INFO@@0@Z ENDP ; stlp_std::_UseTrivialUCopy<_REG_INFO,_REG_INFO>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_UseTrivialUCopy@UItemReg@CSheduler@@U12@@stlp_std@@YA?AU?$_TrivialUCopy@UItemReg@CSheduler@@U12@@0@PAUItemReg@CSheduler@@0@Z
_TEXT	SEGMENT
??$_UseTrivialUCopy@UItemReg@CSheduler@@U12@@stlp_std@@YA?AU?$_TrivialUCopy@UItemReg@CSheduler@@U12@@0@PAUItemReg@CSheduler@@0@Z PROC ; stlp_std::_UseTrivialUCopy<CSheduler::ItemReg,CSheduler::ItemReg>, COMDAT

; 489  : { return _TrivialUCopy<_Src, _Dst>(); }

	xor	al, al
	ret	0
??$_UseTrivialUCopy@UItemReg@CSheduler@@U12@@stlp_std@@YA?AU?$_TrivialUCopy@UItemReg@CSheduler@@U12@@0@PAUItemReg@CSheduler@@0@Z ENDP ; stlp_std::_UseTrivialUCopy<CSheduler::ItemReg,CSheduler::ItemReg>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_UseTrivialUCopy@UItem@CSheduler@@U12@@stlp_std@@YA?AU?$_TrivialUCopy@UItem@CSheduler@@U12@@0@PAUItem@CSheduler@@0@Z
_TEXT	SEGMENT
??$_UseTrivialUCopy@UItem@CSheduler@@U12@@stlp_std@@YA?AU?$_TrivialUCopy@UItem@CSheduler@@U12@@0@PAUItem@CSheduler@@0@Z PROC ; stlp_std::_UseTrivialUCopy<CSheduler::Item,CSheduler::Item>, COMDAT

; 489  : { return _TrivialUCopy<_Src, _Dst>(); }

	xor	al, al
	ret	0
??$_UseTrivialUCopy@UItem@CSheduler@@U12@@stlp_std@@YA?AU?$_TrivialUCopy@UItem@CSheduler@@U12@@0@PAUItem@CSheduler@@0@Z ENDP ; stlp_std::_UseTrivialUCopy<CSheduler::Item,CSheduler::Item>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_UseTrivialUCopy@UDeferred@CEventAPI@@U12@@stlp_std@@YA?AU?$_TrivialUCopy@UDeferred@CEventAPI@@U12@@0@PAUDeferred@CEventAPI@@0@Z
_TEXT	SEGMENT
??$_UseTrivialUCopy@UDeferred@CEventAPI@@U12@@stlp_std@@YA?AU?$_TrivialUCopy@UDeferred@CEventAPI@@U12@@0@PAUDeferred@CEventAPI@@0@Z PROC ; stlp_std::_UseTrivialUCopy<CEventAPI::Deferred,CEventAPI::Deferred>, COMDAT

; 489  : { return _TrivialUCopy<_Src, _Dst>(); }

	xor	al, al
	ret	0
??$_UseTrivialUCopy@UDeferred@CEventAPI@@U12@@stlp_std@@YA?AU?$_TrivialUCopy@UDeferred@CEventAPI@@U12@@0@PAUDeferred@CEventAPI@@0@Z ENDP ; stlp_std::_UseTrivialUCopy<CEventAPI::Deferred,CEventAPI::Deferred>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_UseTrivialUCopy@Vshared_str@@V1@@stlp_std@@YA?AU?$_TrivialUCopy@Vshared_str@@V1@@0@PAVshared_str@@0@Z
_TEXT	SEGMENT
??$_UseTrivialUCopy@Vshared_str@@V1@@stlp_std@@YA?AU?$_TrivialUCopy@Vshared_str@@V1@@0@PAVshared_str@@0@Z PROC ; stlp_std::_UseTrivialUCopy<shared_str,shared_str>, COMDAT

; 489  : { return _TrivialUCopy<_Src, _Dst>(); }

	xor	al, al
	ret	0
??$_UseTrivialUCopy@Vshared_str@@V1@@stlp_std@@YA?AU?$_TrivialUCopy@Vshared_str@@V1@@0@PAVshared_str@@0@Z ENDP ; stlp_std::_UseTrivialUCopy<shared_str,shared_str>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_UseTrivialUCopy@PAXPAX@stlp_std@@YA?AU?$_TrivialUCopy@PAXPAX@0@PAPAX0@Z
_TEXT	SEGMENT
??$_UseTrivialUCopy@PAXPAX@stlp_std@@YA?AU?$_TrivialUCopy@PAXPAX@0@PAPAX0@Z PROC ; stlp_std::_UseTrivialUCopy<void *,void *>, COMDAT

; 489  : { return _TrivialUCopy<_Src, _Dst>(); }

	xor	al, al
	ret	0
??$_UseTrivialUCopy@PAXPAX@stlp_std@@YA?AU?$_TrivialUCopy@PAXPAX@0@PAPAX0@Z ENDP ; stlp_std::_UseTrivialUCopy<void *,void *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Answer@?$_TrivialUCopy@V?$FastDelegate0@X@fastdelegate@@V12@@stlp_std@@SA?AU__false_type@2@XZ
_TEXT	SEGMENT
?_Answer@?$_TrivialUCopy@V?$FastDelegate0@X@fastdelegate@@V12@@stlp_std@@SA?AU__false_type@2@XZ PROC ; stlp_std::_TrivialUCopy<fastdelegate::FastDelegate0<void>,fastdelegate::FastDelegate0<void> >::_Answer, COMDAT

; 407  :   static _Ret _Answer() { return _Ret(); }

	xor	al, al
	ret	0
?_Answer@?$_TrivialUCopy@V?$FastDelegate0@X@fastdelegate@@V12@@stlp_std@@SA?AU__false_type@2@XZ ENDP ; stlp_std::_TrivialUCopy<fastdelegate::FastDelegate0<void>,fastdelegate::FastDelegate0<void> >::_Answer
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Answer@?$_TrivialUCopy@U_REG_INFO@@U1@@stlp_std@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT
?_Answer@?$_TrivialUCopy@U_REG_INFO@@U1@@stlp_std@@SA?AU__true_type@2@XZ PROC ; stlp_std::_TrivialUCopy<_REG_INFO,_REG_INFO>::_Answer, COMDAT

; 407  :   static _Ret _Answer() { return _Ret(); }

	xor	al, al
	ret	0
?_Answer@?$_TrivialUCopy@U_REG_INFO@@U1@@stlp_std@@SA?AU__true_type@2@XZ ENDP ; stlp_std::_TrivialUCopy<_REG_INFO,_REG_INFO>::_Answer
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Answer@?$_TrivialUCopy@UItemReg@CSheduler@@U12@@stlp_std@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT
?_Answer@?$_TrivialUCopy@UItemReg@CSheduler@@U12@@stlp_std@@SA?AU__true_type@2@XZ PROC ; stlp_std::_TrivialUCopy<CSheduler::ItemReg,CSheduler::ItemReg>::_Answer, COMDAT

; 407  :   static _Ret _Answer() { return _Ret(); }

	xor	al, al
	ret	0
?_Answer@?$_TrivialUCopy@UItemReg@CSheduler@@U12@@stlp_std@@SA?AU__true_type@2@XZ ENDP ; stlp_std::_TrivialUCopy<CSheduler::ItemReg,CSheduler::ItemReg>::_Answer
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Answer@?$_TrivialUCopy@UItem@CSheduler@@U12@@stlp_std@@SA?AU__false_type@2@XZ
_TEXT	SEGMENT
?_Answer@?$_TrivialUCopy@UItem@CSheduler@@U12@@stlp_std@@SA?AU__false_type@2@XZ PROC ; stlp_std::_TrivialUCopy<CSheduler::Item,CSheduler::Item>::_Answer, COMDAT

; 407  :   static _Ret _Answer() { return _Ret(); }

	xor	al, al
	ret	0
?_Answer@?$_TrivialUCopy@UItem@CSheduler@@U12@@stlp_std@@SA?AU__false_type@2@XZ ENDP ; stlp_std::_TrivialUCopy<CSheduler::Item,CSheduler::Item>::_Answer
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Answer@?$_TrivialUCopy@UDeferred@CEventAPI@@U12@@stlp_std@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT
?_Answer@?$_TrivialUCopy@UDeferred@CEventAPI@@U12@@stlp_std@@SA?AU__true_type@2@XZ PROC ; stlp_std::_TrivialUCopy<CEventAPI::Deferred,CEventAPI::Deferred>::_Answer, COMDAT

; 407  :   static _Ret _Answer() { return _Ret(); }

	xor	al, al
	ret	0
?_Answer@?$_TrivialUCopy@UDeferred@CEventAPI@@U12@@stlp_std@@SA?AU__true_type@2@XZ ENDP ; stlp_std::_TrivialUCopy<CEventAPI::Deferred,CEventAPI::Deferred>::_Answer
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Answer@?$_TrivialUCopy@Vshared_str@@V1@@stlp_std@@SA?AU__false_type@2@XZ
_TEXT	SEGMENT
?_Answer@?$_TrivialUCopy@Vshared_str@@V1@@stlp_std@@SA?AU__false_type@2@XZ PROC ; stlp_std::_TrivialUCopy<shared_str,shared_str>::_Answer, COMDAT

; 407  :   static _Ret _Answer() { return _Ret(); }

	xor	al, al
	ret	0
?_Answer@?$_TrivialUCopy@Vshared_str@@V1@@stlp_std@@SA?AU__false_type@2@XZ ENDP ; stlp_std::_TrivialUCopy<shared_str,shared_str>::_Answer
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Answer@?$_TrivialUCopy@PAXPAX@stlp_std@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT
?_Answer@?$_TrivialUCopy@PAXPAX@stlp_std@@SA?AU__true_type@2@XZ PROC ; stlp_std::_TrivialUCopy<void *,void *>::_Answer, COMDAT

; 407  :   static _Ret _Answer() { return _Ret(); }

	xor	al, al
	ret	0
?_Answer@?$_TrivialUCopy@PAXPAX@stlp_std@@SA?AU__true_type@2@XZ ENDP ; stlp_std::_TrivialUCopy<void *,void *>::_Answer
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_iterator.h
_TEXT	ENDS
;	COMDAT ??$?9PAUItem@CSheduler@@@stlp_std@@YA_NABV?$reverse_iterator@PAUItem@CSheduler@@@0@0@Z
_TEXT	SEGMENT
??$?9PAUItem@CSheduler@@@stlp_std@@YA_NABV?$reverse_iterator@PAUItem@CSheduler@@@0@0@Z PROC ; stlp_std::operator!=<CSheduler::Item *>, COMDAT
; ___x$ = eax
; ___y$ = edx

; 127  : { return !(__x == __y); }

	mov	ecx, DWORD PTR [eax]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx]
	setne	al
	ret	0
??$?9PAUItem@CSheduler@@@stlp_std@@YA_NABV?$reverse_iterator@PAUItem@CSheduler@@@0@0@Z ENDP ; stlp_std::operator!=<CSheduler::Item *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?9PAVshared_str@@@stlp_std@@YA_NABV?$reverse_iterator@PAVshared_str@@@0@0@Z
_TEXT	SEGMENT
??$?9PAVshared_str@@@stlp_std@@YA_NABV?$reverse_iterator@PAVshared_str@@@0@0@Z PROC ; stlp_std::operator!=<shared_str *>, COMDAT
; ___x$ = eax
; ___y$ = edx

; 127  : { return !(__x == __y); }

	mov	ecx, DWORD PTR [eax]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx]
	setne	al
	ret	0
??$?9PAVshared_str@@@stlp_std@@YA_NABV?$reverse_iterator@PAVshared_str@@@0@0@Z ENDP ; stlp_std::operator!=<shared_str *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_construct.h
_TEXT	ENDS
;	COMDAT ??$__destroy_range_aux@PAV?$FastDelegate0@X@fastdelegate@@V12@@stlp_std@@YAXPAV?$FastDelegate0@X@fastdelegate@@00ABU__true_type@0@@Z
_TEXT	SEGMENT
??$__destroy_range_aux@PAV?$FastDelegate0@X@fastdelegate@@V12@@stlp_std@@YAXPAV?$FastDelegate0@X@fastdelegate@@00ABU__true_type@0@@Z PROC ; stlp_std::__destroy_range_aux<fastdelegate::FastDelegate0<void> *,fastdelegate::FastDelegate0<void> >, COMDAT

; 169  : __destroy_range_aux(_ForwardIterator, _ForwardIterator, _Tp*, const __true_type& /*_Trivial_destructor*/) {}

	ret	0
??$__destroy_range_aux@PAV?$FastDelegate0@X@fastdelegate@@V12@@stlp_std@@YAXPAV?$FastDelegate0@X@fastdelegate@@00ABU__true_type@0@@Z ENDP ; stlp_std::__destroy_range_aux<fastdelegate::FastDelegate0<void> *,fastdelegate::FastDelegate0<void> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$__destroy_range_aux@PAU_REG_INFO@@U1@@stlp_std@@YAXPAU_REG_INFO@@00ABU__true_type@0@@Z
_TEXT	SEGMENT
??$__destroy_range_aux@PAU_REG_INFO@@U1@@stlp_std@@YAXPAU_REG_INFO@@00ABU__true_type@0@@Z PROC ; stlp_std::__destroy_range_aux<_REG_INFO *,_REG_INFO>, COMDAT

; 169  : __destroy_range_aux(_ForwardIterator, _ForwardIterator, _Tp*, const __true_type& /*_Trivial_destructor*/) {}

	ret	0
??$__destroy_range_aux@PAU_REG_INFO@@U1@@stlp_std@@YAXPAU_REG_INFO@@00ABU__true_type@0@@Z ENDP ; stlp_std::__destroy_range_aux<_REG_INFO *,_REG_INFO>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$__destroy_range_aux@PAUItemReg@CSheduler@@U12@@stlp_std@@YAXPAUItemReg@CSheduler@@00ABU__true_type@0@@Z
_TEXT	SEGMENT
??$__destroy_range_aux@PAUItemReg@CSheduler@@U12@@stlp_std@@YAXPAUItemReg@CSheduler@@00ABU__true_type@0@@Z PROC ; stlp_std::__destroy_range_aux<CSheduler::ItemReg *,CSheduler::ItemReg>, COMDAT

; 169  : __destroy_range_aux(_ForwardIterator, _ForwardIterator, _Tp*, const __true_type& /*_Trivial_destructor*/) {}

	ret	0
??$__destroy_range_aux@PAUItemReg@CSheduler@@U12@@stlp_std@@YAXPAUItemReg@CSheduler@@00ABU__true_type@0@@Z ENDP ; stlp_std::__destroy_range_aux<CSheduler::ItemReg *,CSheduler::ItemReg>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$__destroy_range_aux@PAUDeferred@CEventAPI@@U12@@stlp_std@@YAXPAUDeferred@CEventAPI@@00ABU__true_type@0@@Z
_TEXT	SEGMENT
??$__destroy_range_aux@PAUDeferred@CEventAPI@@U12@@stlp_std@@YAXPAUDeferred@CEventAPI@@00ABU__true_type@0@@Z PROC ; stlp_std::__destroy_range_aux<CEventAPI::Deferred *,CEventAPI::Deferred>, COMDAT

; 169  : __destroy_range_aux(_ForwardIterator, _ForwardIterator, _Tp*, const __true_type& /*_Trivial_destructor*/) {}

	ret	0
??$__destroy_range_aux@PAUDeferred@CEventAPI@@U12@@stlp_std@@YAXPAUDeferred@CEventAPI@@00ABU__true_type@0@@Z ENDP ; stlp_std::__destroy_range_aux<CEventAPI::Deferred *,CEventAPI::Deferred>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$__destroy_range_aux@PAPAXPAX@stlp_std@@YAXPAPAX00ABU__true_type@0@@Z
_TEXT	SEGMENT
??$__destroy_range_aux@PAPAXPAX@stlp_std@@YAXPAPAX00ABU__true_type@0@@Z PROC ; stlp_std::__destroy_range_aux<void * *,void *>, COMDAT

; 169  : __destroy_range_aux(_ForwardIterator, _ForwardIterator, _Tp*, const __true_type& /*_Trivial_destructor*/) {}

	ret	0
??$__destroy_range_aux@PAPAXPAX@stlp_std@@YAXPAPAX00ABU__true_type@0@@Z ENDP ; stlp_std::__destroy_range_aux<void * *,void *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\type_traits.h
_TEXT	ENDS
;	COMDAT ?_Answer@?$_BothPtrType@PBV?$FastDelegate0@X@fastdelegate@@PAV12@@stlp_std@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT
?_Answer@?$_BothPtrType@PBV?$FastDelegate0@X@fastdelegate@@PAV12@@stlp_std@@SA?AU__true_type@2@XZ PROC ; stlp_std::_BothPtrType<fastdelegate::FastDelegate0<void> const *,fastdelegate::FastDelegate0<void> *>::_Answer, COMDAT

; 468  :   static _Ret _Answer() { return _Ret(); }

	xor	al, al
	ret	0
?_Answer@?$_BothPtrType@PBV?$FastDelegate0@X@fastdelegate@@PAV12@@stlp_std@@SA?AU__true_type@2@XZ ENDP ; stlp_std::_BothPtrType<fastdelegate::FastDelegate0<void> const *,fastdelegate::FastDelegate0<void> *>::_Answer
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Answer@?$_BothPtrType@PBU_REG_INFO@@PAU1@@stlp_std@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT
?_Answer@?$_BothPtrType@PBU_REG_INFO@@PAU1@@stlp_std@@SA?AU__true_type@2@XZ PROC ; stlp_std::_BothPtrType<_REG_INFO const *,_REG_INFO *>::_Answer, COMDAT

; 468  :   static _Ret _Answer() { return _Ret(); }

	xor	al, al
	ret	0
?_Answer@?$_BothPtrType@PBU_REG_INFO@@PAU1@@stlp_std@@SA?AU__true_type@2@XZ ENDP ; stlp_std::_BothPtrType<_REG_INFO const *,_REG_INFO *>::_Answer
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Answer@?$_BothPtrType@PBUItemReg@CSheduler@@PAU12@@stlp_std@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT
?_Answer@?$_BothPtrType@PBUItemReg@CSheduler@@PAU12@@stlp_std@@SA?AU__true_type@2@XZ PROC ; stlp_std::_BothPtrType<CSheduler::ItemReg const *,CSheduler::ItemReg *>::_Answer, COMDAT

; 468  :   static _Ret _Answer() { return _Ret(); }

	xor	al, al
	ret	0
?_Answer@?$_BothPtrType@PBUItemReg@CSheduler@@PAU12@@stlp_std@@SA?AU__true_type@2@XZ ENDP ; stlp_std::_BothPtrType<CSheduler::ItemReg const *,CSheduler::ItemReg *>::_Answer
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Answer@?$_BothPtrType@PBUItem@CSheduler@@PAU12@@stlp_std@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT
?_Answer@?$_BothPtrType@PBUItem@CSheduler@@PAU12@@stlp_std@@SA?AU__true_type@2@XZ PROC ; stlp_std::_BothPtrType<CSheduler::Item const *,CSheduler::Item *>::_Answer, COMDAT

; 468  :   static _Ret _Answer() { return _Ret(); }

	xor	al, al
	ret	0
?_Answer@?$_BothPtrType@PBUItem@CSheduler@@PAU12@@stlp_std@@SA?AU__true_type@2@XZ ENDP ; stlp_std::_BothPtrType<CSheduler::Item const *,CSheduler::Item *>::_Answer
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Answer@?$_BothPtrType@PBUDeferred@CEventAPI@@PAU12@@stlp_std@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT
?_Answer@?$_BothPtrType@PBUDeferred@CEventAPI@@PAU12@@stlp_std@@SA?AU__true_type@2@XZ PROC ; stlp_std::_BothPtrType<CEventAPI::Deferred const *,CEventAPI::Deferred *>::_Answer, COMDAT

; 468  :   static _Ret _Answer() { return _Ret(); }

	xor	al, al
	ret	0
?_Answer@?$_BothPtrType@PBUDeferred@CEventAPI@@PAU12@@stlp_std@@SA?AU__true_type@2@XZ ENDP ; stlp_std::_BothPtrType<CEventAPI::Deferred const *,CEventAPI::Deferred *>::_Answer
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Answer@?$_BothPtrType@PBVshared_str@@PAV1@@stlp_std@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT
?_Answer@?$_BothPtrType@PBVshared_str@@PAV1@@stlp_std@@SA?AU__true_type@2@XZ PROC ; stlp_std::_BothPtrType<shared_str const *,shared_str *>::_Answer, COMDAT

; 468  :   static _Ret _Answer() { return _Ret(); }

	xor	al, al
	ret	0
?_Answer@?$_BothPtrType@PBVshared_str@@PAV1@@stlp_std@@SA?AU__true_type@2@XZ ENDP ; stlp_std::_BothPtrType<shared_str const *,shared_str *>::_Answer
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Answer@?$_BothPtrType@PBQAXPAPAX@stlp_std@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT
?_Answer@?$_BothPtrType@PBQAXPAPAX@stlp_std@@SA?AU__true_type@2@XZ PROC ; stlp_std::_BothPtrType<void * const *,void * *>::_Answer, COMDAT

; 468  :   static _Ret _Answer() { return _Ret(); }

	xor	al, al
	ret	0
?_Answer@?$_BothPtrType@PBQAXPAPAX@stlp_std@@SA?AU__true_type@2@XZ ENDP ; stlp_std::_BothPtrType<void * const *,void * *>::_Answer
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_iterator.h
_TEXT	ENDS
;	COMDAT ??E?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@QAEAAV01@XZ PROC ; stlp_std::reverse_iterator<CSheduler::Item *>::operator++, COMDAT
; _this$ = eax

; 82   :     --current;

	add	DWORD PTR [eax], -20			; ffffffecH

; 83   :     return *this;
; 84   :   }

	ret	0
??E?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@QAEAAV01@XZ ENDP ; stlp_std::reverse_iterator<CSheduler::Item *>::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??D?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@QBEAAUItem@CSheduler@@XZ
_TEXT	SEGMENT
??D?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@QBEAAUItem@CSheduler@@XZ PROC ; stlp_std::reverse_iterator<CSheduler::Item *>::operator*, COMDAT
; _this$ = eax

; 77   :     _Iterator __tmp = current;
; 78   :     return *--__tmp;

	mov	eax, DWORD PTR [eax]
	sub	eax, 20					; 00000014H

; 79   :   }

	ret	0
??D?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@QBEAAUItem@CSheduler@@XZ ENDP ; stlp_std::reverse_iterator<CSheduler::Item *>::operator*
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$reverse_iterator@PAVshared_str@@@stlp_std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$reverse_iterator@PAVshared_str@@@stlp_std@@QAEAAV01@XZ PROC ; stlp_std::reverse_iterator<shared_str *>::operator++, COMDAT
; _this$ = eax

; 82   :     --current;

	add	DWORD PTR [eax], -4			; fffffffcH

; 83   :     return *this;
; 84   :   }

	ret	0
??E?$reverse_iterator@PAVshared_str@@@stlp_std@@QAEAAV01@XZ ENDP ; stlp_std::reverse_iterator<shared_str *>::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??D?$reverse_iterator@PAVshared_str@@@stlp_std@@QBEAAVshared_str@@XZ
_TEXT	SEGMENT
??D?$reverse_iterator@PAVshared_str@@@stlp_std@@QBEAAVshared_str@@XZ PROC ; stlp_std::reverse_iterator<shared_str *>::operator*, COMDAT
; _this$ = eax

; 77   :     _Iterator __tmp = current;
; 78   :     return *--__tmp;

	mov	eax, DWORD PTR [eax]
	sub	eax, 4

; 79   :   }

	ret	0
??D?$reverse_iterator@PAVshared_str@@@stlp_std@@QBEAAVshared_str@@XZ ENDP ; stlp_std::reverse_iterator<shared_str *>::operator*
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\xrmemory.h
_TEXT	ENDS
;	COMDAT ??$xr_alloc@V?$FastDelegate0@X@fastdelegate@@@@YAPAV?$FastDelegate0@X@fastdelegate@@I@Z
_TEXT	SEGMENT
??$xr_alloc@V?$FastDelegate0@X@fastdelegate@@@@YAPAV?$FastDelegate0@X@fastdelegate@@I@Z PROC ; xr_alloc<fastdelegate::FastDelegate0<void> >, COMDAT
; _count$ = eax

; 109  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	ecx, DWORD PTR [eax*8]
	push	ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@V?$FastDelegate0@X@fastdelegate@@@@YAPAV?$FastDelegate0@X@fastdelegate@@I@Z ENDP ; xr_alloc<fastdelegate::FastDelegate0<void> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$xr_alloc@UDeferred@CEventAPI@@@@YAPAUDeferred@CEventAPI@@I@Z
_TEXT	SEGMENT
??$xr_alloc@UDeferred@CEventAPI@@@@YAPAUDeferred@CEventAPI@@I@Z PROC ; xr_alloc<CEventAPI::Deferred>, COMDAT
; _count$ = eax

; 109  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	eax, DWORD PTR [eax+eax*2]
	add	eax, eax
	add	eax, eax
	add	eax, eax
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@UDeferred@CEventAPI@@@@YAPAUDeferred@CEventAPI@@I@Z ENDP ; xr_alloc<CEventAPI::Deferred>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$xr_alloc@PAX@@YAPAPAXI@Z
_TEXT	SEGMENT
??$xr_alloc@PAX@@YAPAPAXI@Z PROC			; xr_alloc<void *>, COMDAT
; _count$ = eax

; 109  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	ecx, DWORD PTR [eax*4]
	push	ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@PAX@@YAPAPAXI@Z ENDP			; xr_alloc<void *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_construct.h
_TEXT	ENDS
;	COMDAT ??$__destroy_range_aux@V?$reverse_iterator@PAV?$FastDelegate0@X@fastdelegate@@@stlp_std@@V?$FastDelegate0@X@fastdelegate@@@stlp_std@@YAXV?$reverse_iterator@PAV?$FastDelegate0@X@fastdelegate@@@0@0PAV?$FastDelegate0@X@fastdelegate@@ABU__true_type@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$__destroy_range_aux@V?$reverse_iterator@PAV?$FastDelegate0@X@fastdelegate@@@stlp_std@@V?$FastDelegate0@X@fastdelegate@@@stlp_std@@YAXV?$reverse_iterator@PAV?$FastDelegate0@X@fastdelegate@@@0@0PAV?$FastDelegate0@X@fastdelegate@@ABU__true_type@0@@Z PROC ; stlp_std::__destroy_range_aux<stlp_std::reverse_iterator<fastdelegate::FastDelegate0<void> *>,fastdelegate::FastDelegate0<void> >, COMDAT

; 169  : __destroy_range_aux(_ForwardIterator, _ForwardIterator, _Tp*, const __true_type& /*_Trivial_destructor*/) {}

	ret	0
??$__destroy_range_aux@V?$reverse_iterator@PAV?$FastDelegate0@X@fastdelegate@@@stlp_std@@V?$FastDelegate0@X@fastdelegate@@@stlp_std@@YAXV?$reverse_iterator@PAV?$FastDelegate0@X@fastdelegate@@@0@0PAV?$FastDelegate0@X@fastdelegate@@ABU__true_type@0@@Z ENDP ; stlp_std::__destroy_range_aux<stlp_std::reverse_iterator<fastdelegate::FastDelegate0<void> *>,fastdelegate::FastDelegate0<void> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$__destroy_range_aux@V?$reverse_iterator@PAU_REG_INFO@@@stlp_std@@U_REG_INFO@@@stlp_std@@YAXV?$reverse_iterator@PAU_REG_INFO@@@0@0PAU_REG_INFO@@ABU__true_type@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$__destroy_range_aux@V?$reverse_iterator@PAU_REG_INFO@@@stlp_std@@U_REG_INFO@@@stlp_std@@YAXV?$reverse_iterator@PAU_REG_INFO@@@0@0PAU_REG_INFO@@ABU__true_type@0@@Z PROC ; stlp_std::__destroy_range_aux<stlp_std::reverse_iterator<_REG_INFO *>,_REG_INFO>, COMDAT

; 169  : __destroy_range_aux(_ForwardIterator, _ForwardIterator, _Tp*, const __true_type& /*_Trivial_destructor*/) {}

	ret	0
??$__destroy_range_aux@V?$reverse_iterator@PAU_REG_INFO@@@stlp_std@@U_REG_INFO@@@stlp_std@@YAXV?$reverse_iterator@PAU_REG_INFO@@@0@0PAU_REG_INFO@@ABU__true_type@0@@Z ENDP ; stlp_std::__destroy_range_aux<stlp_std::reverse_iterator<_REG_INFO *>,_REG_INFO>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$__destroy_range_aux@V?$reverse_iterator@PAUItemReg@CSheduler@@@stlp_std@@UItemReg@CSheduler@@@stlp_std@@YAXV?$reverse_iterator@PAUItemReg@CSheduler@@@0@0PAUItemReg@CSheduler@@ABU__true_type@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$__destroy_range_aux@V?$reverse_iterator@PAUItemReg@CSheduler@@@stlp_std@@UItemReg@CSheduler@@@stlp_std@@YAXV?$reverse_iterator@PAUItemReg@CSheduler@@@0@0PAUItemReg@CSheduler@@ABU__true_type@0@@Z PROC ; stlp_std::__destroy_range_aux<stlp_std::reverse_iterator<CSheduler::ItemReg *>,CSheduler::ItemReg>, COMDAT

; 169  : __destroy_range_aux(_ForwardIterator, _ForwardIterator, _Tp*, const __true_type& /*_Trivial_destructor*/) {}

	ret	0
??$__destroy_range_aux@V?$reverse_iterator@PAUItemReg@CSheduler@@@stlp_std@@UItemReg@CSheduler@@@stlp_std@@YAXV?$reverse_iterator@PAUItemReg@CSheduler@@@0@0PAUItemReg@CSheduler@@ABU__true_type@0@@Z ENDP ; stlp_std::__destroy_range_aux<stlp_std::reverse_iterator<CSheduler::ItemReg *>,CSheduler::ItemReg>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$__destroy_range_aux@V?$reverse_iterator@PAUDeferred@CEventAPI@@@stlp_std@@UDeferred@CEventAPI@@@stlp_std@@YAXV?$reverse_iterator@PAUDeferred@CEventAPI@@@0@0PAUDeferred@CEventAPI@@ABU__true_type@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$__destroy_range_aux@V?$reverse_iterator@PAUDeferred@CEventAPI@@@stlp_std@@UDeferred@CEventAPI@@@stlp_std@@YAXV?$reverse_iterator@PAUDeferred@CEventAPI@@@0@0PAUDeferred@CEventAPI@@ABU__true_type@0@@Z PROC ; stlp_std::__destroy_range_aux<stlp_std::reverse_iterator<CEventAPI::Deferred *>,CEventAPI::Deferred>, COMDAT

; 169  : __destroy_range_aux(_ForwardIterator, _ForwardIterator, _Tp*, const __true_type& /*_Trivial_destructor*/) {}

	ret	0
??$__destroy_range_aux@V?$reverse_iterator@PAUDeferred@CEventAPI@@@stlp_std@@UDeferred@CEventAPI@@@stlp_std@@YAXV?$reverse_iterator@PAUDeferred@CEventAPI@@@0@0PAUDeferred@CEventAPI@@ABU__true_type@0@@Z ENDP ; stlp_std::__destroy_range_aux<stlp_std::reverse_iterator<CEventAPI::Deferred *>,CEventAPI::Deferred>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$__destroy_range_aux@V?$reverse_iterator@PAPAX@stlp_std@@PAX@stlp_std@@YAXV?$reverse_iterator@PAPAX@0@0PAPAXABU__true_type@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$__destroy_range_aux@V?$reverse_iterator@PAPAX@stlp_std@@PAX@stlp_std@@YAXV?$reverse_iterator@PAPAX@0@0PAPAXABU__true_type@0@@Z PROC ; stlp_std::__destroy_range_aux<stlp_std::reverse_iterator<void * *>,void *>, COMDAT

; 169  : __destroy_range_aux(_ForwardIterator, _ForwardIterator, _Tp*, const __true_type& /*_Trivial_destructor*/) {}

	ret	0
??$__destroy_range_aux@V?$reverse_iterator@PAPAX@stlp_std@@PAX@stlp_std@@YAXV?$reverse_iterator@PAPAX@0@0PAPAXABU__true_type@0@@Z ENDP ; stlp_std::__destroy_range_aux<stlp_std::reverse_iterator<void * *>,void *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$__destroy_range@PAV?$FastDelegate0@X@fastdelegate@@V12@@stlp_std@@YAXPAV?$FastDelegate0@X@fastdelegate@@00@Z
_TEXT	SEGMENT
??$__destroy_range@PAV?$FastDelegate0@X@fastdelegate@@V12@@stlp_std@@YAXPAV?$FastDelegate0@X@fastdelegate@@00@Z PROC ; stlp_std::__destroy_range<fastdelegate::FastDelegate0<void> *,fastdelegate::FastDelegate0<void> >, COMDAT

; 175  :   typedef typename __type_traits<_Tp>::has_trivial_destructor _Trivial_destructor;
; 176  :   __destroy_range_aux(__first, __last, __ptr, _Trivial_destructor());
; 177  : }

	ret	0
??$__destroy_range@PAV?$FastDelegate0@X@fastdelegate@@V12@@stlp_std@@YAXPAV?$FastDelegate0@X@fastdelegate@@00@Z ENDP ; stlp_std::__destroy_range<fastdelegate::FastDelegate0<void> *,fastdelegate::FastDelegate0<void> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$__destroy_range@PAU_REG_INFO@@U1@@stlp_std@@YAXPAU_REG_INFO@@00@Z
_TEXT	SEGMENT
??$__destroy_range@PAU_REG_INFO@@U1@@stlp_std@@YAXPAU_REG_INFO@@00@Z PROC ; stlp_std::__destroy_range<_REG_INFO *,_REG_INFO>, COMDAT

; 175  :   typedef typename __type_traits<_Tp>::has_trivial_destructor _Trivial_destructor;
; 176  :   __destroy_range_aux(__first, __last, __ptr, _Trivial_destructor());
; 177  : }

	ret	0
??$__destroy_range@PAU_REG_INFO@@U1@@stlp_std@@YAXPAU_REG_INFO@@00@Z ENDP ; stlp_std::__destroy_range<_REG_INFO *,_REG_INFO>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$__destroy_range@PAUItemReg@CSheduler@@U12@@stlp_std@@YAXPAUItemReg@CSheduler@@00@Z
_TEXT	SEGMENT
??$__destroy_range@PAUItemReg@CSheduler@@U12@@stlp_std@@YAXPAUItemReg@CSheduler@@00@Z PROC ; stlp_std::__destroy_range<CSheduler::ItemReg *,CSheduler::ItemReg>, COMDAT

; 175  :   typedef typename __type_traits<_Tp>::has_trivial_destructor _Trivial_destructor;
; 176  :   __destroy_range_aux(__first, __last, __ptr, _Trivial_destructor());
; 177  : }

	ret	0
??$__destroy_range@PAUItemReg@CSheduler@@U12@@stlp_std@@YAXPAUItemReg@CSheduler@@00@Z ENDP ; stlp_std::__destroy_range<CSheduler::ItemReg *,CSheduler::ItemReg>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$__destroy_range@PAUDeferred@CEventAPI@@U12@@stlp_std@@YAXPAUDeferred@CEventAPI@@00@Z
_TEXT	SEGMENT
??$__destroy_range@PAUDeferred@CEventAPI@@U12@@stlp_std@@YAXPAUDeferred@CEventAPI@@00@Z PROC ; stlp_std::__destroy_range<CEventAPI::Deferred *,CEventAPI::Deferred>, COMDAT

; 175  :   typedef typename __type_traits<_Tp>::has_trivial_destructor _Trivial_destructor;
; 176  :   __destroy_range_aux(__first, __last, __ptr, _Trivial_destructor());
; 177  : }

	ret	0
??$__destroy_range@PAUDeferred@CEventAPI@@U12@@stlp_std@@YAXPAUDeferred@CEventAPI@@00@Z ENDP ; stlp_std::__destroy_range<CEventAPI::Deferred *,CEventAPI::Deferred>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$__destroy_range@PAPAXPAX@stlp_std@@YAXPAPAX00@Z
_TEXT	SEGMENT
??$__destroy_range@PAPAXPAX@stlp_std@@YAXPAPAX00@Z PROC	; stlp_std::__destroy_range<void * *,void *>, COMDAT

; 175  :   typedef typename __type_traits<_Tp>::has_trivial_destructor _Trivial_destructor;
; 176  :   __destroy_range_aux(__first, __last, __ptr, _Trivial_destructor());
; 177  : }

	ret	0
??$__destroy_range@PAPAXPAX@stlp_std@@YAXPAPAX00@Z ENDP	; stlp_std::__destroy_range<void * *,void *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ?allocate@?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@QBEPAV?$FastDelegate0@X@fastdelegate@@IPBX@Z
_TEXT	SEGMENT
?allocate@?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@QBEPAV?$FastDelegate0@X@fastdelegate@@IPBX@Z PROC ; xalloc<fastdelegate::FastDelegate0<void> >::allocate, COMDAT
; _n$ = eax

; 81   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	lea	ecx, DWORD PTR [eax*8]
	push	ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
?allocate@?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@QBEPAV?$FastDelegate0@X@fastdelegate@@IPBX@Z ENDP ; xalloc<fastdelegate::FastDelegate0<void> >::allocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$xalloc@UDeferred@CEventAPI@@@@QBEPAUDeferred@CEventAPI@@IPBX@Z
_TEXT	SEGMENT
?allocate@?$xalloc@UDeferred@CEventAPI@@@@QBEPAUDeferred@CEventAPI@@IPBX@Z PROC ; xalloc<CEventAPI::Deferred>::allocate, COMDAT
; _n$ = eax

; 81   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	eax, DWORD PTR [eax+eax*2]
	add	eax, eax
	add	eax, eax
	add	eax, eax
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
?allocate@?$xalloc@UDeferred@CEventAPI@@@@QBEPAUDeferred@CEventAPI@@IPBX@Z ENDP ; xalloc<CEventAPI::Deferred>::allocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$xalloc@PAX@@QBEPAPAXIPBX@Z
_TEXT	SEGMENT
?allocate@?$xalloc@PAX@@QBEPAPAXIPBX@Z PROC		; xalloc<void *>::allocate, COMDAT
; _n$ = eax

; 81   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	lea	ecx, DWORD PTR [eax*4]
	push	ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
?allocate@?$xalloc@PAX@@QBEPAPAXIPBX@Z ENDP		; xalloc<void *>::allocate
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_alloc.h
_TEXT	ENDS
;	COMDAT ?allocate@?$_STLP_alloc_proxy@PAV?$FastDelegate0@X@fastdelegate@@V12@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAEPAV?$FastDelegate0@X@fastdelegate@@I@Z
_TEXT	SEGMENT
?allocate@?$_STLP_alloc_proxy@PAV?$FastDelegate0@X@fastdelegate@@V12@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAEPAV?$FastDelegate0@X@fastdelegate@@I@Z PROC ; stlp_std::priv::_STLP_alloc_proxy<fastdelegate::FastDelegate0<void> *,fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::allocate, COMDAT
; ___n$ = eax

; 633  :   { return _Base::allocate(__n); }

	lea	ecx, DWORD PTR [eax*8]
	push	ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
?allocate@?$_STLP_alloc_proxy@PAV?$FastDelegate0@X@fastdelegate@@V12@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAEPAV?$FastDelegate0@X@fastdelegate@@I@Z ENDP ; stlp_std::priv::_STLP_alloc_proxy<fastdelegate::FastDelegate0<void> *,fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::allocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$_STLP_alloc_proxy@PAUDeferred@CEventAPI@@U12@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAEPAUDeferred@CEventAPI@@I@Z
_TEXT	SEGMENT
?allocate@?$_STLP_alloc_proxy@PAUDeferred@CEventAPI@@U12@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAEPAUDeferred@CEventAPI@@I@Z PROC ; stlp_std::priv::_STLP_alloc_proxy<CEventAPI::Deferred *,CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::allocate, COMDAT
; ___n$ = eax

; 633  :   { return _Base::allocate(__n); }

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	eax, DWORD PTR [eax+eax*2]
	add	eax, eax
	add	eax, eax
	add	eax, eax
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
?allocate@?$_STLP_alloc_proxy@PAUDeferred@CEventAPI@@U12@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAEPAUDeferred@CEventAPI@@I@Z ENDP ; stlp_std::priv::_STLP_alloc_proxy<CEventAPI::Deferred *,CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::allocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$_STLP_alloc_proxy@PAPAXPAXV?$xalloc@PAX@@@priv@stlp_std@@QAEPAPAXI@Z
_TEXT	SEGMENT
?allocate@?$_STLP_alloc_proxy@PAPAXPAXV?$xalloc@PAX@@@priv@stlp_std@@QAEPAPAXI@Z PROC ; stlp_std::priv::_STLP_alloc_proxy<void * *,void *,xalloc<void *> >::allocate, COMDAT
; ___n$ = eax

; 633  :   { return _Base::allocate(__n); }

	lea	ecx, DWORD PTR [eax*4]
	push	ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
?allocate@?$_STLP_alloc_proxy@PAPAXPAXV?$xalloc@PAX@@@priv@stlp_std@@QAEPAPAXI@Z ENDP ; stlp_std::priv::_STLP_alloc_proxy<void * *,void *,xalloc<void *> >::allocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$_STLP_alloc_proxy@PAV?$FastDelegate0@X@fastdelegate@@V12@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@AAEPAV?$FastDelegate0@X@fastdelegate@@IAAIABU__false_type@3@@Z
_TEXT	SEGMENT
?allocate@?$_STLP_alloc_proxy@PAV?$FastDelegate0@X@fastdelegate@@V12@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@AAEPAV?$FastDelegate0@X@fastdelegate@@IAAIABU__false_type@3@@Z PROC ; stlp_std::priv::_STLP_alloc_proxy<fastdelegate::FastDelegate0<void> *,fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::allocate, COMDAT
; ___n$ = eax
; ___allocated_n$ = ecx

; 640  :   { __allocated_n = __n; return allocate(__n); }

	lea	edx, DWORD PTR [eax*8]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edx
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
?allocate@?$_STLP_alloc_proxy@PAV?$FastDelegate0@X@fastdelegate@@V12@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@AAEPAV?$FastDelegate0@X@fastdelegate@@IAAIABU__false_type@3@@Z ENDP ; stlp_std::priv::_STLP_alloc_proxy<fastdelegate::FastDelegate0<void> *,fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::allocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$_STLP_alloc_proxy@PAUDeferred@CEventAPI@@U12@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@AAEPAUDeferred@CEventAPI@@IAAIABU__false_type@3@@Z
_TEXT	SEGMENT
?allocate@?$_STLP_alloc_proxy@PAUDeferred@CEventAPI@@U12@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@AAEPAUDeferred@CEventAPI@@IAAIABU__false_type@3@@Z PROC ; stlp_std::priv::_STLP_alloc_proxy<CEventAPI::Deferred *,CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::allocate, COMDAT
; ___n$ = eax
; ___allocated_n$ = ecx

; 640  :   { __allocated_n = __n; return allocate(__n); }

	lea	edx, DWORD PTR [eax+eax*2]
	add	edx, edx
	add	edx, edx
	add	edx, edx
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edx
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
?allocate@?$_STLP_alloc_proxy@PAUDeferred@CEventAPI@@U12@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@AAEPAUDeferred@CEventAPI@@IAAIABU__false_type@3@@Z ENDP ; stlp_std::priv::_STLP_alloc_proxy<CEventAPI::Deferred *,CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::allocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$_STLP_alloc_proxy@PAPAXPAXV?$xalloc@PAX@@@priv@stlp_std@@AAEPAPAXIAAIABU__false_type@3@@Z
_TEXT	SEGMENT
?allocate@?$_STLP_alloc_proxy@PAPAXPAXV?$xalloc@PAX@@@priv@stlp_std@@AAEPAPAXIAAIABU__false_type@3@@Z PROC ; stlp_std::priv::_STLP_alloc_proxy<void * *,void *,xalloc<void *> >::allocate, COMDAT
; ___n$ = eax
; ___allocated_n$ = ecx

; 640  :   { __allocated_n = __n; return allocate(__n); }

	lea	edx, DWORD PTR [eax*4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edx
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
?allocate@?$_STLP_alloc_proxy@PAPAXPAXV?$xalloc@PAX@@@priv@stlp_std@@AAEPAPAXIAAIABU__false_type@3@@Z ENDP ; stlp_std::priv::_STLP_alloc_proxy<void * *,void *,xalloc<void *> >::allocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$_STLP_alloc_proxy@PAV?$FastDelegate0@X@fastdelegate@@V12@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAEPAV?$FastDelegate0@X@fastdelegate@@IAAI@Z
_TEXT	SEGMENT
?allocate@?$_STLP_alloc_proxy@PAV?$FastDelegate0@X@fastdelegate@@V12@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAEPAV?$FastDelegate0@X@fastdelegate@@IAAI@Z PROC ; stlp_std::priv::_STLP_alloc_proxy<fastdelegate::FastDelegate0<void> *,fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::allocate, COMDAT
; ___n$ = eax
; ___allocated_n$ = ecx

; 611  : #if !defined (__BORLANDC__)
; 612  :     typedef typename _IsSTLportClass<_MaybeReboundAlloc>::_Ret _STLportAlloc;
; 613  : #else
; 614  :     typedef typename __bool2type<_IsSTLportClass<_MaybeReboundAlloc>::_Is>::_Ret _STLportAlloc;
; 615  : #endif
; 616  :     return allocate(__n, __allocated_n, _STLportAlloc());

	lea	edx, DWORD PTR [eax*8]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edx
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 617  :   }

	ret	0
?allocate@?$_STLP_alloc_proxy@PAV?$FastDelegate0@X@fastdelegate@@V12@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAEPAV?$FastDelegate0@X@fastdelegate@@IAAI@Z ENDP ; stlp_std::priv::_STLP_alloc_proxy<fastdelegate::FastDelegate0<void> *,fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::allocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$_STLP_alloc_proxy@PAUDeferred@CEventAPI@@U12@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAEPAUDeferred@CEventAPI@@IAAI@Z
_TEXT	SEGMENT
?allocate@?$_STLP_alloc_proxy@PAUDeferred@CEventAPI@@U12@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAEPAUDeferred@CEventAPI@@IAAI@Z PROC ; stlp_std::priv::_STLP_alloc_proxy<CEventAPI::Deferred *,CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::allocate, COMDAT
; ___n$ = eax
; ___allocated_n$ = ecx

; 611  : #if !defined (__BORLANDC__)
; 612  :     typedef typename _IsSTLportClass<_MaybeReboundAlloc>::_Ret _STLportAlloc;
; 613  : #else
; 614  :     typedef typename __bool2type<_IsSTLportClass<_MaybeReboundAlloc>::_Is>::_Ret _STLportAlloc;
; 615  : #endif
; 616  :     return allocate(__n, __allocated_n, _STLportAlloc());

	lea	edx, DWORD PTR [eax+eax*2]
	add	edx, edx
	add	edx, edx
	add	edx, edx
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edx
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 617  :   }

	ret	0
?allocate@?$_STLP_alloc_proxy@PAUDeferred@CEventAPI@@U12@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAEPAUDeferred@CEventAPI@@IAAI@Z ENDP ; stlp_std::priv::_STLP_alloc_proxy<CEventAPI::Deferred *,CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::allocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$_STLP_alloc_proxy@PAPAXPAXV?$xalloc@PAX@@@priv@stlp_std@@QAEPAPAXIAAI@Z
_TEXT	SEGMENT
?allocate@?$_STLP_alloc_proxy@PAPAXPAXV?$xalloc@PAX@@@priv@stlp_std@@QAEPAPAXIAAI@Z PROC ; stlp_std::priv::_STLP_alloc_proxy<void * *,void *,xalloc<void *> >::allocate, COMDAT
; ___n$ = eax
; ___allocated_n$ = ecx

; 611  : #if !defined (__BORLANDC__)
; 612  :     typedef typename _IsSTLportClass<_MaybeReboundAlloc>::_Ret _STLportAlloc;
; 613  : #else
; 614  :     typedef typename __bool2type<_IsSTLportClass<_MaybeReboundAlloc>::_Is>::_Ret _STLportAlloc;
; 615  : #endif
; 616  :     return allocate(__n, __allocated_n, _STLportAlloc());

	lea	edx, DWORD PTR [eax*4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edx
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 617  :   }

	ret	0
?allocate@?$_STLP_alloc_proxy@PAPAXPAXV?$xalloc@PAX@@@priv@stlp_std@@QAEPAPAXIAAI@Z ENDP ; stlp_std::priv::_STLP_alloc_proxy<void * *,void *,xalloc<void *> >::allocate
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_construct.h
_TEXT	ENDS
;	COMDAT ??$__destroy_aux@V?$FastDelegate0@X@fastdelegate@@@stlp_std@@YAXPAV?$FastDelegate0@X@fastdelegate@@ABU__true_type@0@@Z
_TEXT	SEGMENT
??$__destroy_aux@V?$FastDelegate0@X@fastdelegate@@@stlp_std@@YAXPAV?$FastDelegate0@X@fastdelegate@@ABU__true_type@0@@Z PROC ; stlp_std::__destroy_aux<fastdelegate::FastDelegate0<void> >, COMDAT

; 56   : inline void __destroy_aux(_Tp*, const __true_type& /*_Trivial_destructor*/) {}

	ret	0
??$__destroy_aux@V?$FastDelegate0@X@fastdelegate@@@stlp_std@@YAXPAV?$FastDelegate0@X@fastdelegate@@ABU__true_type@0@@Z ENDP ; stlp_std::__destroy_aux<fastdelegate::FastDelegate0<void> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_Range@PAV?$FastDelegate0@X@fastdelegate@@@stlp_std@@YAXPAV?$FastDelegate0@X@fastdelegate@@0@Z
_TEXT	SEGMENT
??$_Destroy_Range@PAV?$FastDelegate0@X@fastdelegate@@@stlp_std@@YAXPAV?$FastDelegate0@X@fastdelegate@@0@Z PROC ; stlp_std::_Destroy_Range<fastdelegate::FastDelegate0<void> *>, COMDAT

; 181  :   __destroy_range(__first, __last, _STLP_VALUE_TYPE(__first, _ForwardIterator));
; 182  : }

	ret	0
??$_Destroy_Range@PAV?$FastDelegate0@X@fastdelegate@@@stlp_std@@YAXPAV?$FastDelegate0@X@fastdelegate@@0@Z ENDP ; stlp_std::_Destroy_Range<fastdelegate::FastDelegate0<void> *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_Range@PAU_REG_INFO@@@stlp_std@@YAXPAU_REG_INFO@@0@Z
_TEXT	SEGMENT
??$_Destroy_Range@PAU_REG_INFO@@@stlp_std@@YAXPAU_REG_INFO@@0@Z PROC ; stlp_std::_Destroy_Range<_REG_INFO *>, COMDAT

; 181  :   __destroy_range(__first, __last, _STLP_VALUE_TYPE(__first, _ForwardIterator));
; 182  : }

	ret	0
??$_Destroy_Range@PAU_REG_INFO@@@stlp_std@@YAXPAU_REG_INFO@@0@Z ENDP ; stlp_std::_Destroy_Range<_REG_INFO *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_Range@PAUItemReg@CSheduler@@@stlp_std@@YAXPAUItemReg@CSheduler@@0@Z
_TEXT	SEGMENT
??$_Destroy_Range@PAUItemReg@CSheduler@@@stlp_std@@YAXPAUItemReg@CSheduler@@0@Z PROC ; stlp_std::_Destroy_Range<CSheduler::ItemReg *>, COMDAT

; 181  :   __destroy_range(__first, __last, _STLP_VALUE_TYPE(__first, _ForwardIterator));
; 182  : }

	ret	0
??$_Destroy_Range@PAUItemReg@CSheduler@@@stlp_std@@YAXPAUItemReg@CSheduler@@0@Z ENDP ; stlp_std::_Destroy_Range<CSheduler::ItemReg *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_Range@PAUDeferred@CEventAPI@@@stlp_std@@YAXPAUDeferred@CEventAPI@@0@Z
_TEXT	SEGMENT
??$_Destroy_Range@PAUDeferred@CEventAPI@@@stlp_std@@YAXPAUDeferred@CEventAPI@@0@Z PROC ; stlp_std::_Destroy_Range<CEventAPI::Deferred *>, COMDAT

; 181  :   __destroy_range(__first, __last, _STLP_VALUE_TYPE(__first, _ForwardIterator));
; 182  : }

	ret	0
??$_Destroy_Range@PAUDeferred@CEventAPI@@@stlp_std@@YAXPAUDeferred@CEventAPI@@0@Z ENDP ; stlp_std::_Destroy_Range<CEventAPI::Deferred *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_Range@PAPAX@stlp_std@@YAXPAPAX0@Z
_TEXT	SEGMENT
??$_Destroy_Range@PAPAX@stlp_std@@YAXPAPAX0@Z PROC	; stlp_std::_Destroy_Range<void * *>, COMDAT

; 181  :   __destroy_range(__first, __last, _STLP_VALUE_TYPE(__first, _ForwardIterator));
; 182  : }

	ret	0
??$_Destroy_Range@PAPAX@stlp_std@@YAXPAPAX0@Z ENDP	; stlp_std::_Destroy_Range<void * *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_iterator.h
_TEXT	ENDS
;	COMDAT ??0?$reverse_iterator@PAV?$FastDelegate0@X@fastdelegate@@@stlp_std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$reverse_iterator@PAV?$FastDelegate0@X@fastdelegate@@@stlp_std@@QAE@ABV01@@Z PROC ; stlp_std::reverse_iterator<fastdelegate::FastDelegate0<void> *>::reverse_iterator<fastdelegate::FastDelegate0<void> *>, COMDAT
; _this$ = eax
; ___x$ = ecx

; 66   :   reverse_iterator(const _Self& __x) : current(__x.current) {}

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	ret	0
??0?$reverse_iterator@PAV?$FastDelegate0@X@fastdelegate@@@stlp_std@@QAE@ABV01@@Z ENDP ; stlp_std::reverse_iterator<fastdelegate::FastDelegate0<void> *>::reverse_iterator<fastdelegate::FastDelegate0<void> *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$reverse_iterator@PAU_REG_INFO@@@stlp_std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$reverse_iterator@PAU_REG_INFO@@@stlp_std@@QAE@ABV01@@Z PROC ; stlp_std::reverse_iterator<_REG_INFO *>::reverse_iterator<_REG_INFO *>, COMDAT
; _this$ = eax
; ___x$ = ecx

; 66   :   reverse_iterator(const _Self& __x) : current(__x.current) {}

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	ret	0
??0?$reverse_iterator@PAU_REG_INFO@@@stlp_std@@QAE@ABV01@@Z ENDP ; stlp_std::reverse_iterator<_REG_INFO *>::reverse_iterator<_REG_INFO *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$reverse_iterator@PAUItemReg@CSheduler@@@stlp_std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$reverse_iterator@PAUItemReg@CSheduler@@@stlp_std@@QAE@ABV01@@Z PROC ; stlp_std::reverse_iterator<CSheduler::ItemReg *>::reverse_iterator<CSheduler::ItemReg *>, COMDAT
; _this$ = eax
; ___x$ = ecx

; 66   :   reverse_iterator(const _Self& __x) : current(__x.current) {}

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	ret	0
??0?$reverse_iterator@PAUItemReg@CSheduler@@@stlp_std@@QAE@ABV01@@Z ENDP ; stlp_std::reverse_iterator<CSheduler::ItemReg *>::reverse_iterator<CSheduler::ItemReg *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@QAE@ABV01@@Z PROC ; stlp_std::reverse_iterator<CSheduler::Item *>::reverse_iterator<CSheduler::Item *>, COMDAT
; _this$ = eax
; ___x$ = ecx

; 66   :   reverse_iterator(const _Self& __x) : current(__x.current) {}

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	ret	0
??0?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@QAE@ABV01@@Z ENDP ; stlp_std::reverse_iterator<CSheduler::Item *>::reverse_iterator<CSheduler::Item *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$reverse_iterator@PAUDeferred@CEventAPI@@@stlp_std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$reverse_iterator@PAUDeferred@CEventAPI@@@stlp_std@@QAE@ABV01@@Z PROC ; stlp_std::reverse_iterator<CEventAPI::Deferred *>::reverse_iterator<CEventAPI::Deferred *>, COMDAT
; _this$ = eax
; ___x$ = ecx

; 66   :   reverse_iterator(const _Self& __x) : current(__x.current) {}

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	ret	0
??0?$reverse_iterator@PAUDeferred@CEventAPI@@@stlp_std@@QAE@ABV01@@Z ENDP ; stlp_std::reverse_iterator<CEventAPI::Deferred *>::reverse_iterator<CEventAPI::Deferred *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$reverse_iterator@PAVshared_str@@@stlp_std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$reverse_iterator@PAVshared_str@@@stlp_std@@QAE@ABV01@@Z PROC ; stlp_std::reverse_iterator<shared_str *>::reverse_iterator<shared_str *>, COMDAT
; _this$ = eax
; ___x$ = ecx

; 66   :   reverse_iterator(const _Self& __x) : current(__x.current) {}

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	ret	0
??0?$reverse_iterator@PAVshared_str@@@stlp_std@@QAE@ABV01@@Z ENDP ; stlp_std::reverse_iterator<shared_str *>::reverse_iterator<shared_str *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$reverse_iterator@PAPAX@stlp_std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$reverse_iterator@PAPAX@stlp_std@@QAE@ABV01@@Z PROC	; stlp_std::reverse_iterator<void * *>::reverse_iterator<void * *>, COMDAT
; _this$ = eax
; ___x$ = ecx

; 66   :   reverse_iterator(const _Self& __x) : current(__x.current) {}

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	ret	0
??0?$reverse_iterator@PAPAX@stlp_std@@QAE@ABV01@@Z ENDP	; stlp_std::reverse_iterator<void * *>::reverse_iterator<void * *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ?capacity@?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QBEIXZ PROC ; stlp_std::priv::_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::capacity, COMDAT
; _this$ = ecx

; 187  :   size_type capacity() const    { return size_type(this->_M_end_of_storage._M_data - this->_M_start); }

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 3
	ret	0
?capacity@?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QBEIXZ ENDP ; stlp_std::priv::_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::capacity
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QBEIXZ PROC ; stlp_std::priv::_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::size, COMDAT
; _this$ = ecx

; 180  :   size_type size() const        { return size_type(this->_M_finish - this->_M_start); }

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 3
	ret	0
?size@?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QBEIXZ ENDP ; stlp_std::priv::_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?capacity@?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QBEIXZ PROC ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::capacity, COMDAT
; _this$ = eax

; 187  :   size_type capacity() const    { return size_type(this->_M_end_of_storage._M_data - this->_M_start); }

	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR [eax]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	ret	0
?capacity@?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QBEIXZ ENDP ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::capacity
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?capacity@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QBEIXZ PROC ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::capacity, COMDAT
; _this$ = eax

; 187  :   size_type capacity() const    { return size_type(this->_M_end_of_storage._M_data - this->_M_start); }

	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR [eax]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	ret	0
?capacity@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QBEIXZ ENDP ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::capacity
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?capacity@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QBEIXZ PROC ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::capacity, COMDAT
; _this$ = eax

; 187  :   size_type capacity() const    { return size_type(this->_M_end_of_storage._M_data - this->_M_start); }

	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR [eax]
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	ret	0
?capacity@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QBEIXZ ENDP ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::capacity
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?capacity@?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QBEIXZ PROC ; stlp_std::priv::_Impl_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::capacity, COMDAT
; _this$ = eax

; 187  :   size_type capacity() const    { return size_type(this->_M_end_of_storage._M_data - this->_M_start); }

	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR [eax]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	ret	0
?capacity@?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QBEIXZ ENDP ; stlp_std::priv::_Impl_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::capacity
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QBEIXZ PROC ; stlp_std::priv::_Impl_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::size, COMDAT
; _this$ = eax

; 180  :   size_type size() const        { return size_type(this->_M_finish - this->_M_start); }

	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR [eax]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	ret	0
?size@?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QBEIXZ ENDP ; stlp_std::priv::_Impl_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?capacity@?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QBEIXZ PROC ; stlp_std::priv::_Impl_vector<shared_str,xalloc<shared_str> >::capacity, COMDAT
; _this$ = ecx

; 187  :   size_type capacity() const    { return size_type(this->_M_end_of_storage._M_data - this->_M_start); }

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	ret	0
?capacity@?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QBEIXZ ENDP ; stlp_std::priv::_Impl_vector<shared_str,xalloc<shared_str> >::capacity
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?capacity@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QBEIXZ PROC ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::capacity, COMDAT
; _this$ = ecx

; 187  :   size_type capacity() const    { return size_type(this->_M_end_of_storage._M_data - this->_M_start); }

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	ret	0
?capacity@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QBEIXZ ENDP ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::capacity
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QBEIXZ PROC ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::size, COMDAT
; _this$ = ecx

; 180  :   size_type size() const        { return size_type(this->_M_finish - this->_M_start); }

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	ret	0
?size@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QBEIXZ ENDP ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::size
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\xrmemory.h
_TEXT	ENDS
;	COMDAT ??$xr_alloc@U_REG_INFO@@@@YAPAU_REG_INFO@@I@Z
_TEXT	SEGMENT
??$xr_alloc@U_REG_INFO@@@@YAPAU_REG_INFO@@I@Z PROC	; xr_alloc<_REG_INFO>, COMDAT
; _count$ = eax

; 109  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	eax, DWORD PTR [eax+eax*2]
	add	eax, eax
	add	eax, eax
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@U_REG_INFO@@@@YAPAU_REG_INFO@@I@Z ENDP	; xr_alloc<_REG_INFO>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$xr_alloc@UItemReg@CSheduler@@@@YAPAUItemReg@CSheduler@@I@Z
_TEXT	SEGMENT
??$xr_alloc@UItemReg@CSheduler@@@@YAPAUItemReg@CSheduler@@I@Z PROC ; xr_alloc<CSheduler::ItemReg>, COMDAT
; _count$ = eax

; 109  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	eax, DWORD PTR [eax+eax*2]
	add	eax, eax
	add	eax, eax
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@UItemReg@CSheduler@@@@YAPAUItemReg@CSheduler@@I@Z ENDP ; xr_alloc<CSheduler::ItemReg>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$xr_alloc@UItem@CSheduler@@@@YAPAUItem@CSheduler@@I@Z
_TEXT	SEGMENT
??$xr_alloc@UItem@CSheduler@@@@YAPAUItem@CSheduler@@I@Z PROC ; xr_alloc<CSheduler::Item>, COMDAT
; _count$ = eax

; 109  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	eax, DWORD PTR [eax+eax*4]
	add	eax, eax
	add	eax, eax
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@UItem@CSheduler@@@@YAPAUItem@CSheduler@@I@Z ENDP ; xr_alloc<CSheduler::Item>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$xr_alloc@Vshared_str@@@@YAPAVshared_str@@I@Z
_TEXT	SEGMENT
??$xr_alloc@Vshared_str@@@@YAPAVshared_str@@I@Z PROC	; xr_alloc<shared_str>, COMDAT
; _count$ = eax

; 109  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	ecx, DWORD PTR [eax*4]
	push	ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@Vshared_str@@@@YAPAVshared_str@@I@Z ENDP	; xr_alloc<shared_str>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_construct.h
_TEXT	ENDS
;	COMDAT ??$_Destroy@V?$FastDelegate0@X@fastdelegate@@@stlp_std@@YAXPAV?$FastDelegate0@X@fastdelegate@@@Z
_TEXT	SEGMENT
??$_Destroy@V?$FastDelegate0@X@fastdelegate@@@stlp_std@@YAXPAV?$FastDelegate0@X@fastdelegate@@@Z PROC ; stlp_std::_Destroy<fastdelegate::FastDelegate0<void> >, COMDAT

; 60   : #if defined (_STLP_MSVC) && (_STLP_MSVC <= 1010)
; 61   :   __pointer;
; 62   : #endif
; 63   :   typedef typename __type_traits<_Tp>::has_trivial_destructor _Trivial_destructor;
; 64   :   __destroy_aux(__pointer, _Trivial_destructor());
; 65   : #if defined (_STLP_DEBUG_UNINITIALIZED)
; 66   :   memset(__REINTERPRET_CAST(char*, __pointer), _STLP_SHRED_BYTE, sizeof(_Tp));
; 67   : #endif
; 68   : }

	ret	0
??$_Destroy@V?$FastDelegate0@X@fastdelegate@@@stlp_std@@YAXPAV?$FastDelegate0@X@fastdelegate@@@Z ENDP ; stlp_std::_Destroy<fastdelegate::FastDelegate0<void> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\xrmemory.h
_TEXT	ENDS
;	COMDAT ??$xr_free@V?$FastDelegate0@X@fastdelegate@@@@YAXAAPAV?$FastDelegate0@X@fastdelegate@@@Z
_TEXT	SEGMENT
??$xr_free@V?$FastDelegate0@X@fastdelegate@@@@YAXAAPAV?$FastDelegate0@X@fastdelegate@@@Z PROC ; xr_free<fastdelegate::FastDelegate0<void> >, COMDAT
; _P$ = esi

; 111  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN1@xr_free@49
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN1@xr_free@49:
	ret	0
??$xr_free@V?$FastDelegate0@X@fastdelegate@@@@YAXAAPAV?$FastDelegate0@X@fastdelegate@@@Z ENDP ; xr_free<fastdelegate::FastDelegate0<void> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$xr_free@U_REG_INFO@@@@YAXAAPAU_REG_INFO@@@Z
_TEXT	SEGMENT
??$xr_free@U_REG_INFO@@@@YAXAAPAU_REG_INFO@@@Z PROC	; xr_free<_REG_INFO>, COMDAT
; _P$ = esi

; 111  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN1@xr_free@50
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN1@xr_free@50:
	ret	0
??$xr_free@U_REG_INFO@@@@YAXAAPAU_REG_INFO@@@Z ENDP	; xr_free<_REG_INFO>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$xr_free@UItemReg@CSheduler@@@@YAXAAPAUItemReg@CSheduler@@@Z
_TEXT	SEGMENT
??$xr_free@UItemReg@CSheduler@@@@YAXAAPAUItemReg@CSheduler@@@Z PROC ; xr_free<CSheduler::ItemReg>, COMDAT
; _P$ = esi

; 111  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN1@xr_free@51
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN1@xr_free@51:
	ret	0
??$xr_free@UItemReg@CSheduler@@@@YAXAAPAUItemReg@CSheduler@@@Z ENDP ; xr_free<CSheduler::ItemReg>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$xr_free@UItem@CSheduler@@@@YAXAAPAUItem@CSheduler@@@Z
_TEXT	SEGMENT
??$xr_free@UItem@CSheduler@@@@YAXAAPAUItem@CSheduler@@@Z PROC ; xr_free<CSheduler::Item>, COMDAT
; _P$ = esi

; 111  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN1@xr_free@52
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN1@xr_free@52:
	ret	0
??$xr_free@UItem@CSheduler@@@@YAXAAPAUItem@CSheduler@@@Z ENDP ; xr_free<CSheduler::Item>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$xr_free@UDeferred@CEventAPI@@@@YAXAAPAUDeferred@CEventAPI@@@Z
_TEXT	SEGMENT
??$xr_free@UDeferred@CEventAPI@@@@YAXAAPAUDeferred@CEventAPI@@@Z PROC ; xr_free<CEventAPI::Deferred>, COMDAT
; _P$ = esi

; 111  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN1@xr_free@53
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN1@xr_free@53:
	ret	0
??$xr_free@UDeferred@CEventAPI@@@@YAXAAPAUDeferred@CEventAPI@@@Z ENDP ; xr_free<CEventAPI::Deferred>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$xr_free@Vshared_str@@@@YAXAAPAVshared_str@@@Z
_TEXT	SEGMENT
??$xr_free@Vshared_str@@@@YAXAAPAVshared_str@@@Z PROC	; xr_free<shared_str>, COMDAT
; _P$ = esi

; 111  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN1@xr_free@54
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN1@xr_free@54:
	ret	0
??$xr_free@Vshared_str@@@@YAXAAPAVshared_str@@@Z ENDP	; xr_free<shared_str>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$xr_free@PAX@@YAXAAPAPAX@Z
_TEXT	SEGMENT
??$xr_free@PAX@@YAXAAPAPAX@Z PROC			; xr_free<void *>, COMDAT
; _P$ = esi

; 111  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN1@xr_free@55
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN1@xr_free@55:
	ret	0
??$xr_free@PAX@@YAXAAPAPAX@Z ENDP			; xr_free<void *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ??$?0PAVCEvent@@@?$xalloc@PAX@@QAE@ABV?$xalloc@PAVCEvent@@@@@Z
_TEXT	SEGMENT
??$?0PAVCEvent@@@?$xalloc@PAX@@QAE@ABV?$xalloc@PAVCEvent@@@@@Z PROC ; xalloc<void *>::xalloc<void *><CEvent *>, COMDAT
; _this$ = eax

; 79   : 	template<class _Other>							xalloc			(const xalloc<_Other>&)					{	}

	ret	0
??$?0PAVCEvent@@@?$xalloc@PAX@@QAE@ABV?$xalloc@PAVCEvent@@@@@Z ENDP ; xalloc<void *>::xalloc<void *><CEvent *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$xalloc@U_REG_INFO@@@@QBEPAU_REG_INFO@@IPBX@Z
_TEXT	SEGMENT
?allocate@?$xalloc@U_REG_INFO@@@@QBEPAU_REG_INFO@@IPBX@Z PROC ; xalloc<_REG_INFO>::allocate, COMDAT
; _n$ = eax

; 81   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	eax, DWORD PTR [eax+eax*2]
	add	eax, eax
	add	eax, eax
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
?allocate@?$xalloc@U_REG_INFO@@@@QBEPAU_REG_INFO@@IPBX@Z ENDP ; xalloc<_REG_INFO>::allocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$xalloc@UItemReg@CSheduler@@@@QBEPAUItemReg@CSheduler@@IPBX@Z
_TEXT	SEGMENT
?allocate@?$xalloc@UItemReg@CSheduler@@@@QBEPAUItemReg@CSheduler@@IPBX@Z PROC ; xalloc<CSheduler::ItemReg>::allocate, COMDAT
; _n$ = eax

; 81   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	eax, DWORD PTR [eax+eax*2]
	add	eax, eax
	add	eax, eax
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
?allocate@?$xalloc@UItemReg@CSheduler@@@@QBEPAUItemReg@CSheduler@@IPBX@Z ENDP ; xalloc<CSheduler::ItemReg>::allocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$xalloc@UItem@CSheduler@@@@QBEPAUItem@CSheduler@@IPBX@Z
_TEXT	SEGMENT
?allocate@?$xalloc@UItem@CSheduler@@@@QBEPAUItem@CSheduler@@IPBX@Z PROC ; xalloc<CSheduler::Item>::allocate, COMDAT
; _n$ = eax

; 81   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	eax, DWORD PTR [eax+eax*4]
	add	eax, eax
	add	eax, eax
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
?allocate@?$xalloc@UItem@CSheduler@@@@QBEPAUItem@CSheduler@@IPBX@Z ENDP ; xalloc<CSheduler::Item>::allocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$xalloc@Vshared_str@@@@QBEPAVshared_str@@IPBX@Z
_TEXT	SEGMENT
?allocate@?$xalloc@Vshared_str@@@@QBEPAVshared_str@@IPBX@Z PROC ; xalloc<shared_str>::allocate, COMDAT
; _n$ = eax

; 81   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	lea	ecx, DWORD PTR [eax*4]
	push	ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
?allocate@?$xalloc@Vshared_str@@@@QBEPAVshared_str@@IPBX@Z ENDP ; xalloc<shared_str>::allocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
??0?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@QAE@ABV0@@Z PROC ; xalloc<fastdelegate::FastDelegate0<void> >::xalloc<fastdelegate::FastDelegate0<void> >, COMDAT
; _this$ = eax

; 78   : 													xalloc			(const xalloc<T>&)						{	}

	ret	0
??0?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@QAE@ABV0@@Z ENDP ; xalloc<fastdelegate::FastDelegate0<void> >::xalloc<fastdelegate::FastDelegate0<void> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_alloc.h
_TEXT	ENDS
;	COMDAT ?allocate@?$_STLP_alloc_proxy@PAU_REG_INFO@@U1@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAEPAU_REG_INFO@@I@Z
_TEXT	SEGMENT
?allocate@?$_STLP_alloc_proxy@PAU_REG_INFO@@U1@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAEPAU_REG_INFO@@I@Z PROC ; stlp_std::priv::_STLP_alloc_proxy<_REG_INFO *,_REG_INFO,xalloc<_REG_INFO> >::allocate, COMDAT
; ___n$ = eax

; 633  :   { return _Base::allocate(__n); }

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	eax, DWORD PTR [eax+eax*2]
	add	eax, eax
	add	eax, eax
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
?allocate@?$_STLP_alloc_proxy@PAU_REG_INFO@@U1@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAEPAU_REG_INFO@@I@Z ENDP ; stlp_std::priv::_STLP_alloc_proxy<_REG_INFO *,_REG_INFO,xalloc<_REG_INFO> >::allocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$_STLP_alloc_proxy@PAUItemReg@CSheduler@@U12@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAEPAUItemReg@CSheduler@@I@Z
_TEXT	SEGMENT
?allocate@?$_STLP_alloc_proxy@PAUItemReg@CSheduler@@U12@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAEPAUItemReg@CSheduler@@I@Z PROC ; stlp_std::priv::_STLP_alloc_proxy<CSheduler::ItemReg *,CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::allocate, COMDAT
; ___n$ = eax

; 633  :   { return _Base::allocate(__n); }

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	eax, DWORD PTR [eax+eax*2]
	add	eax, eax
	add	eax, eax
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
?allocate@?$_STLP_alloc_proxy@PAUItemReg@CSheduler@@U12@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAEPAUItemReg@CSheduler@@I@Z ENDP ; stlp_std::priv::_STLP_alloc_proxy<CSheduler::ItemReg *,CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::allocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$_STLP_alloc_proxy@PAUItem@CSheduler@@U12@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEPAUItem@CSheduler@@I@Z
_TEXT	SEGMENT
?allocate@?$_STLP_alloc_proxy@PAUItem@CSheduler@@U12@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEPAUItem@CSheduler@@I@Z PROC ; stlp_std::priv::_STLP_alloc_proxy<CSheduler::Item *,CSheduler::Item,xalloc<CSheduler::Item> >::allocate, COMDAT
; ___n$ = eax

; 633  :   { return _Base::allocate(__n); }

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	eax, DWORD PTR [eax+eax*4]
	add	eax, eax
	add	eax, eax
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
?allocate@?$_STLP_alloc_proxy@PAUItem@CSheduler@@U12@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEPAUItem@CSheduler@@I@Z ENDP ; stlp_std::priv::_STLP_alloc_proxy<CSheduler::Item *,CSheduler::Item,xalloc<CSheduler::Item> >::allocate
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ??0?$xalloc@UDeferred@CEventAPI@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
??0?$xalloc@UDeferred@CEventAPI@@@@QAE@ABV0@@Z PROC	; xalloc<CEventAPI::Deferred>::xalloc<CEventAPI::Deferred>, COMDAT
; _this$ = eax

; 78   : 													xalloc			(const xalloc<T>&)						{	}

	ret	0
??0?$xalloc@UDeferred@CEventAPI@@@@QAE@ABV0@@Z ENDP	; xalloc<CEventAPI::Deferred>::xalloc<CEventAPI::Deferred>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_alloc.h
_TEXT	ENDS
;	COMDAT ?allocate@?$_STLP_alloc_proxy@PAVshared_str@@V1@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAEPAVshared_str@@I@Z
_TEXT	SEGMENT
?allocate@?$_STLP_alloc_proxy@PAVshared_str@@V1@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAEPAVshared_str@@I@Z PROC ; stlp_std::priv::_STLP_alloc_proxy<shared_str *,shared_str,xalloc<shared_str> >::allocate, COMDAT
; ___n$ = eax

; 633  :   { return _Base::allocate(__n); }

	lea	ecx, DWORD PTR [eax*4]
	push	ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
?allocate@?$_STLP_alloc_proxy@PAVshared_str@@V1@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAEPAVshared_str@@I@Z ENDP ; stlp_std::priv::_STLP_alloc_proxy<shared_str *,shared_str,xalloc<shared_str> >::allocate
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ??0?$xalloc@PAX@@QAE@ABV0@@Z
_TEXT	SEGMENT
??0?$xalloc@PAX@@QAE@ABV0@@Z PROC			; xalloc<void *>::xalloc<void *>, COMDAT
; _this$ = eax

; 78   : 													xalloc			(const xalloc<T>&)						{	}

	ret	0
??0?$xalloc@PAX@@QAE@ABV0@@Z ENDP			; xalloc<void *>::xalloc<void *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_alloc.h
_TEXT	ENDS
;	COMDAT ??0?$_STLP_alloc_proxy@PAV?$FastDelegate0@X@fastdelegate@@V12@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAE@ABV?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@PAV?$FastDelegate0@X@fastdelegate@@@Z
_TEXT	SEGMENT
??0?$_STLP_alloc_proxy@PAV?$FastDelegate0@X@fastdelegate@@V12@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAE@ABV?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@PAV?$FastDelegate0@X@fastdelegate@@@Z PROC ; stlp_std::priv::_STLP_alloc_proxy<fastdelegate::FastDelegate0<void> *,fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::_STLP_alloc_proxy<fastdelegate::FastDelegate0<void> *,fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >, COMDAT
; _this$ = eax

; 571  :     _MaybeReboundAlloc(__a), _M_data(__p) {}

	mov	DWORD PTR [eax], 0
	ret	0
??0?$_STLP_alloc_proxy@PAV?$FastDelegate0@X@fastdelegate@@V12@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAE@ABV?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@PAV?$FastDelegate0@X@fastdelegate@@@Z ENDP ; stlp_std::priv::_STLP_alloc_proxy<fastdelegate::FastDelegate0<void> *,fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::_STLP_alloc_proxy<fastdelegate::FastDelegate0<void> *,fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$_STLP_alloc_proxy@PAU_REG_INFO@@U1@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@AAEPAU_REG_INFO@@IAAIABU__false_type@3@@Z
_TEXT	SEGMENT
?allocate@?$_STLP_alloc_proxy@PAU_REG_INFO@@U1@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@AAEPAU_REG_INFO@@IAAIABU__false_type@3@@Z PROC ; stlp_std::priv::_STLP_alloc_proxy<_REG_INFO *,_REG_INFO,xalloc<_REG_INFO> >::allocate, COMDAT
; ___n$ = eax
; ___allocated_n$ = ecx

; 640  :   { __allocated_n = __n; return allocate(__n); }

	lea	edx, DWORD PTR [eax+eax*2]
	add	edx, edx
	add	edx, edx
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edx
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
?allocate@?$_STLP_alloc_proxy@PAU_REG_INFO@@U1@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@AAEPAU_REG_INFO@@IAAIABU__false_type@3@@Z ENDP ; stlp_std::priv::_STLP_alloc_proxy<_REG_INFO *,_REG_INFO,xalloc<_REG_INFO> >::allocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$_STLP_alloc_proxy@PAUItemReg@CSheduler@@U12@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@AAEPAUItemReg@CSheduler@@IAAIABU__false_type@3@@Z
_TEXT	SEGMENT
?allocate@?$_STLP_alloc_proxy@PAUItemReg@CSheduler@@U12@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@AAEPAUItemReg@CSheduler@@IAAIABU__false_type@3@@Z PROC ; stlp_std::priv::_STLP_alloc_proxy<CSheduler::ItemReg *,CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::allocate, COMDAT
; ___n$ = eax
; ___allocated_n$ = ecx

; 640  :   { __allocated_n = __n; return allocate(__n); }

	lea	edx, DWORD PTR [eax+eax*2]
	add	edx, edx
	add	edx, edx
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edx
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
?allocate@?$_STLP_alloc_proxy@PAUItemReg@CSheduler@@U12@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@AAEPAUItemReg@CSheduler@@IAAIABU__false_type@3@@Z ENDP ; stlp_std::priv::_STLP_alloc_proxy<CSheduler::ItemReg *,CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::allocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$_STLP_alloc_proxy@PAUItem@CSheduler@@U12@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@AAEPAUItem@CSheduler@@IAAIABU__false_type@3@@Z
_TEXT	SEGMENT
?allocate@?$_STLP_alloc_proxy@PAUItem@CSheduler@@U12@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@AAEPAUItem@CSheduler@@IAAIABU__false_type@3@@Z PROC ; stlp_std::priv::_STLP_alloc_proxy<CSheduler::Item *,CSheduler::Item,xalloc<CSheduler::Item> >::allocate, COMDAT
; ___n$ = eax
; ___allocated_n$ = ecx

; 640  :   { __allocated_n = __n; return allocate(__n); }

	lea	edx, DWORD PTR [eax+eax*4]
	add	edx, edx
	add	edx, edx
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edx
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
?allocate@?$_STLP_alloc_proxy@PAUItem@CSheduler@@U12@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@AAEPAUItem@CSheduler@@IAAIABU__false_type@3@@Z ENDP ; stlp_std::priv::_STLP_alloc_proxy<CSheduler::Item *,CSheduler::Item,xalloc<CSheduler::Item> >::allocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_STLP_alloc_proxy@PAUDeferred@CEventAPI@@U12@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UDeferred@CEventAPI@@@@PAUDeferred@CEventAPI@@@Z
_TEXT	SEGMENT
??0?$_STLP_alloc_proxy@PAUDeferred@CEventAPI@@U12@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UDeferred@CEventAPI@@@@PAUDeferred@CEventAPI@@@Z PROC ; stlp_std::priv::_STLP_alloc_proxy<CEventAPI::Deferred *,CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::_STLP_alloc_proxy<CEventAPI::Deferred *,CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >, COMDAT
; _this$ = eax

; 571  :     _MaybeReboundAlloc(__a), _M_data(__p) {}

	mov	DWORD PTR [eax], 0
	ret	0
??0?$_STLP_alloc_proxy@PAUDeferred@CEventAPI@@U12@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UDeferred@CEventAPI@@@@PAUDeferred@CEventAPI@@@Z ENDP ; stlp_std::priv::_STLP_alloc_proxy<CEventAPI::Deferred *,CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::_STLP_alloc_proxy<CEventAPI::Deferred *,CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$_STLP_alloc_proxy@PAVshared_str@@V1@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@AAEPAVshared_str@@IAAIABU__false_type@3@@Z
_TEXT	SEGMENT
?allocate@?$_STLP_alloc_proxy@PAVshared_str@@V1@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@AAEPAVshared_str@@IAAIABU__false_type@3@@Z PROC ; stlp_std::priv::_STLP_alloc_proxy<shared_str *,shared_str,xalloc<shared_str> >::allocate, COMDAT
; ___n$ = eax
; ___allocated_n$ = ecx

; 640  :   { __allocated_n = __n; return allocate(__n); }

	lea	edx, DWORD PTR [eax*4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edx
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
?allocate@?$_STLP_alloc_proxy@PAVshared_str@@V1@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@AAEPAVshared_str@@IAAIABU__false_type@3@@Z ENDP ; stlp_std::priv::_STLP_alloc_proxy<shared_str *,shared_str,xalloc<shared_str> >::allocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_STLP_alloc_proxy@PAPAXPAXV?$xalloc@PAX@@@priv@stlp_std@@QAE@ABV?$xalloc@PAX@@PAPAX@Z
_TEXT	SEGMENT
??0?$_STLP_alloc_proxy@PAPAXPAXV?$xalloc@PAX@@@priv@stlp_std@@QAE@ABV?$xalloc@PAX@@PAPAX@Z PROC ; stlp_std::priv::_STLP_alloc_proxy<void * *,void *,xalloc<void *> >::_STLP_alloc_proxy<void * *,void *,xalloc<void *> >, COMDAT
; _this$ = eax
; ___p$ = ecx

; 571  :     _MaybeReboundAlloc(__a), _M_data(__p) {}

	mov	DWORD PTR [eax], ecx
	ret	0
??0?$_STLP_alloc_proxy@PAPAXPAXV?$xalloc@PAX@@@priv@stlp_std@@QAE@ABV?$xalloc@PAX@@PAPAX@Z ENDP ; stlp_std::priv::_STLP_alloc_proxy<void * *,void *,xalloc<void *> >::_STLP_alloc_proxy<void * *,void *,xalloc<void *> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ??0?$_Vector_base@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAE@ABV?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@Z
_TEXT	SEGMENT
??0?$_Vector_base@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAE@ABV?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@Z PROC ; stlp_std::priv::_Vector_base<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::_Vector_base<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >, COMDAT
; _this$ = eax

; 67   :     : _M_start(0), _M_finish(0), _M_end_of_storage(__a, 0) {}

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$_Vector_base@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAE@ABV?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@Z ENDP ; stlp_std::priv::_Vector_base<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::_Vector_base<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_alloc.h
_TEXT	ENDS
;	COMDAT ?allocate@?$_STLP_alloc_proxy@PAU_REG_INFO@@U1@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAEPAU_REG_INFO@@IAAI@Z
_TEXT	SEGMENT
?allocate@?$_STLP_alloc_proxy@PAU_REG_INFO@@U1@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAEPAU_REG_INFO@@IAAI@Z PROC ; stlp_std::priv::_STLP_alloc_proxy<_REG_INFO *,_REG_INFO,xalloc<_REG_INFO> >::allocate, COMDAT
; ___n$ = eax
; ___allocated_n$ = ecx

; 611  : #if !defined (__BORLANDC__)
; 612  :     typedef typename _IsSTLportClass<_MaybeReboundAlloc>::_Ret _STLportAlloc;
; 613  : #else
; 614  :     typedef typename __bool2type<_IsSTLportClass<_MaybeReboundAlloc>::_Is>::_Ret _STLportAlloc;
; 615  : #endif
; 616  :     return allocate(__n, __allocated_n, _STLportAlloc());

	lea	edx, DWORD PTR [eax+eax*2]
	add	edx, edx
	add	edx, edx
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edx
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 617  :   }

	ret	0
?allocate@?$_STLP_alloc_proxy@PAU_REG_INFO@@U1@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAEPAU_REG_INFO@@IAAI@Z ENDP ; stlp_std::priv::_STLP_alloc_proxy<_REG_INFO *,_REG_INFO,xalloc<_REG_INFO> >::allocate
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ??0?$xalloc@U_REG_INFO@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
??0?$xalloc@U_REG_INFO@@@@QAE@ABV0@@Z PROC		; xalloc<_REG_INFO>::xalloc<_REG_INFO>, COMDAT
; _this$ = eax

; 78   : 													xalloc			(const xalloc<T>&)						{	}

	ret	0
??0?$xalloc@U_REG_INFO@@@@QAE@ABV0@@Z ENDP		; xalloc<_REG_INFO>::xalloc<_REG_INFO>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_alloc.h
_TEXT	ENDS
;	COMDAT ?allocate@?$_STLP_alloc_proxy@PAUItemReg@CSheduler@@U12@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAEPAUItemReg@CSheduler@@IAAI@Z
_TEXT	SEGMENT
?allocate@?$_STLP_alloc_proxy@PAUItemReg@CSheduler@@U12@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAEPAUItemReg@CSheduler@@IAAI@Z PROC ; stlp_std::priv::_STLP_alloc_proxy<CSheduler::ItemReg *,CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::allocate, COMDAT
; ___n$ = eax
; ___allocated_n$ = ecx

; 611  : #if !defined (__BORLANDC__)
; 612  :     typedef typename _IsSTLportClass<_MaybeReboundAlloc>::_Ret _STLportAlloc;
; 613  : #else
; 614  :     typedef typename __bool2type<_IsSTLportClass<_MaybeReboundAlloc>::_Is>::_Ret _STLportAlloc;
; 615  : #endif
; 616  :     return allocate(__n, __allocated_n, _STLportAlloc());

	lea	edx, DWORD PTR [eax+eax*2]
	add	edx, edx
	add	edx, edx
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edx
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 617  :   }

	ret	0
?allocate@?$_STLP_alloc_proxy@PAUItemReg@CSheduler@@U12@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAEPAUItemReg@CSheduler@@IAAI@Z ENDP ; stlp_std::priv::_STLP_alloc_proxy<CSheduler::ItemReg *,CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::allocate
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ??0?$xalloc@UItemReg@CSheduler@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
??0?$xalloc@UItemReg@CSheduler@@@@QAE@ABV0@@Z PROC	; xalloc<CSheduler::ItemReg>::xalloc<CSheduler::ItemReg>, COMDAT
; _this$ = eax

; 78   : 													xalloc			(const xalloc<T>&)						{	}

	ret	0
??0?$xalloc@UItemReg@CSheduler@@@@QAE@ABV0@@Z ENDP	; xalloc<CSheduler::ItemReg>::xalloc<CSheduler::ItemReg>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_alloc.h
_TEXT	ENDS
;	COMDAT ?allocate@?$_STLP_alloc_proxy@PAUItem@CSheduler@@U12@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEPAUItem@CSheduler@@IAAI@Z
_TEXT	SEGMENT
?allocate@?$_STLP_alloc_proxy@PAUItem@CSheduler@@U12@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEPAUItem@CSheduler@@IAAI@Z PROC ; stlp_std::priv::_STLP_alloc_proxy<CSheduler::Item *,CSheduler::Item,xalloc<CSheduler::Item> >::allocate, COMDAT
; ___n$ = eax
; ___allocated_n$ = ecx

; 611  : #if !defined (__BORLANDC__)
; 612  :     typedef typename _IsSTLportClass<_MaybeReboundAlloc>::_Ret _STLportAlloc;
; 613  : #else
; 614  :     typedef typename __bool2type<_IsSTLportClass<_MaybeReboundAlloc>::_Is>::_Ret _STLportAlloc;
; 615  : #endif
; 616  :     return allocate(__n, __allocated_n, _STLportAlloc());

	lea	edx, DWORD PTR [eax+eax*4]
	add	edx, edx
	add	edx, edx
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edx
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 617  :   }

	ret	0
?allocate@?$_STLP_alloc_proxy@PAUItem@CSheduler@@U12@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEPAUItem@CSheduler@@IAAI@Z ENDP ; stlp_std::priv::_STLP_alloc_proxy<CSheduler::Item *,CSheduler::Item,xalloc<CSheduler::Item> >::allocate
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ??0?$xalloc@UItem@CSheduler@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
??0?$xalloc@UItem@CSheduler@@@@QAE@ABV0@@Z PROC		; xalloc<CSheduler::Item>::xalloc<CSheduler::Item>, COMDAT
; _this$ = eax

; 78   : 													xalloc			(const xalloc<T>&)						{	}

	ret	0
??0?$xalloc@UItem@CSheduler@@@@QAE@ABV0@@Z ENDP		; xalloc<CSheduler::Item>::xalloc<CSheduler::Item>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ??0?$_Vector_base@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UDeferred@CEventAPI@@@@@Z
_TEXT	SEGMENT
??0?$_Vector_base@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UDeferred@CEventAPI@@@@@Z PROC ; stlp_std::priv::_Vector_base<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::_Vector_base<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >, COMDAT
; _this$ = eax

; 67   :     : _M_start(0), _M_finish(0), _M_end_of_storage(__a, 0) {}

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$_Vector_base@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UDeferred@CEventAPI@@@@@Z ENDP ; stlp_std::priv::_Vector_base<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::_Vector_base<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_alloc.h
_TEXT	ENDS
;	COMDAT ?allocate@?$_STLP_alloc_proxy@PAVshared_str@@V1@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAEPAVshared_str@@IAAI@Z
_TEXT	SEGMENT
?allocate@?$_STLP_alloc_proxy@PAVshared_str@@V1@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAEPAVshared_str@@IAAI@Z PROC ; stlp_std::priv::_STLP_alloc_proxy<shared_str *,shared_str,xalloc<shared_str> >::allocate, COMDAT
; ___n$ = eax
; ___allocated_n$ = ecx

; 611  : #if !defined (__BORLANDC__)
; 612  :     typedef typename _IsSTLportClass<_MaybeReboundAlloc>::_Ret _STLportAlloc;
; 613  : #else
; 614  :     typedef typename __bool2type<_IsSTLportClass<_MaybeReboundAlloc>::_Is>::_Ret _STLportAlloc;
; 615  : #endif
; 616  :     return allocate(__n, __allocated_n, _STLportAlloc());

	lea	edx, DWORD PTR [eax*4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edx
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 617  :   }

	ret	0
?allocate@?$_STLP_alloc_proxy@PAVshared_str@@V1@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAEPAVshared_str@@IAAI@Z ENDP ; stlp_std::priv::_STLP_alloc_proxy<shared_str *,shared_str,xalloc<shared_str> >::allocate
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ??0?$xalloc@Vshared_str@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
??0?$xalloc@Vshared_str@@@@QAE@ABV0@@Z PROC		; xalloc<shared_str>::xalloc<shared_str>, COMDAT
; _this$ = eax

; 78   : 													xalloc			(const xalloc<T>&)						{	}

	ret	0
??0?$xalloc@Vshared_str@@@@QAE@ABV0@@Z ENDP		; xalloc<shared_str>::xalloc<shared_str>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ??0?$_Vector_base@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAE@ABV?$xalloc@PAX@@@Z
_TEXT	SEGMENT
??0?$_Vector_base@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAE@ABV?$xalloc@PAX@@@Z PROC ; stlp_std::priv::_Vector_base<void *,xalloc<void *> >::_Vector_base<void *,xalloc<void *> >, COMDAT
; _this$ = eax

; 67   :     : _M_start(0), _M_finish(0), _M_end_of_storage(__a, 0) {}

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$_Vector_base@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAE@ABV?$xalloc@PAX@@@Z ENDP ; stlp_std::priv::_Vector_base<void *,xalloc<void *> >::_Vector_base<void *,xalloc<void *> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_iterator.h
_TEXT	ENDS
;	COMDAT ??0?$reverse_iterator@PAV?$FastDelegate0@X@fastdelegate@@@stlp_std@@QAE@PAV?$FastDelegate0@X@fastdelegate@@@Z
_TEXT	SEGMENT
??0?$reverse_iterator@PAV?$FastDelegate0@X@fastdelegate@@@stlp_std@@QAE@PAV?$FastDelegate0@X@fastdelegate@@@Z PROC ; stlp_std::reverse_iterator<fastdelegate::FastDelegate0<void> *>::reverse_iterator<fastdelegate::FastDelegate0<void> *>, COMDAT
; _this$ = eax
; ___x$ = ecx

; 65   :   explicit reverse_iterator(iterator_type __x) : current(__x) {}

	mov	DWORD PTR [eax], ecx
	ret	0
??0?$reverse_iterator@PAV?$FastDelegate0@X@fastdelegate@@@stlp_std@@QAE@PAV?$FastDelegate0@X@fastdelegate@@@Z ENDP ; stlp_std::reverse_iterator<fastdelegate::FastDelegate0<void> *>::reverse_iterator<fastdelegate::FastDelegate0<void> *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$reverse_iterator@PAU_REG_INFO@@@stlp_std@@QAE@PAU_REG_INFO@@@Z
_TEXT	SEGMENT
??0?$reverse_iterator@PAU_REG_INFO@@@stlp_std@@QAE@PAU_REG_INFO@@@Z PROC ; stlp_std::reverse_iterator<_REG_INFO *>::reverse_iterator<_REG_INFO *>, COMDAT
; _this$ = eax
; ___x$ = ecx

; 65   :   explicit reverse_iterator(iterator_type __x) : current(__x) {}

	mov	DWORD PTR [eax], ecx
	ret	0
??0?$reverse_iterator@PAU_REG_INFO@@@stlp_std@@QAE@PAU_REG_INFO@@@Z ENDP ; stlp_std::reverse_iterator<_REG_INFO *>::reverse_iterator<_REG_INFO *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$reverse_iterator@PAUItemReg@CSheduler@@@stlp_std@@QAE@PAUItemReg@CSheduler@@@Z
_TEXT	SEGMENT
??0?$reverse_iterator@PAUItemReg@CSheduler@@@stlp_std@@QAE@PAUItemReg@CSheduler@@@Z PROC ; stlp_std::reverse_iterator<CSheduler::ItemReg *>::reverse_iterator<CSheduler::ItemReg *>, COMDAT
; _this$ = eax
; ___x$ = ecx

; 65   :   explicit reverse_iterator(iterator_type __x) : current(__x) {}

	mov	DWORD PTR [eax], ecx
	ret	0
??0?$reverse_iterator@PAUItemReg@CSheduler@@@stlp_std@@QAE@PAUItemReg@CSheduler@@@Z ENDP ; stlp_std::reverse_iterator<CSheduler::ItemReg *>::reverse_iterator<CSheduler::ItemReg *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@QAE@PAUItem@CSheduler@@@Z
_TEXT	SEGMENT
??0?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@QAE@PAUItem@CSheduler@@@Z PROC ; stlp_std::reverse_iterator<CSheduler::Item *>::reverse_iterator<CSheduler::Item *>, COMDAT
; _this$ = eax
; ___x$ = ecx

; 65   :   explicit reverse_iterator(iterator_type __x) : current(__x) {}

	mov	DWORD PTR [eax], ecx
	ret	0
??0?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@QAE@PAUItem@CSheduler@@@Z ENDP ; stlp_std::reverse_iterator<CSheduler::Item *>::reverse_iterator<CSheduler::Item *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$reverse_iterator@PAUDeferred@CEventAPI@@@stlp_std@@QAE@PAUDeferred@CEventAPI@@@Z
_TEXT	SEGMENT
??0?$reverse_iterator@PAUDeferred@CEventAPI@@@stlp_std@@QAE@PAUDeferred@CEventAPI@@@Z PROC ; stlp_std::reverse_iterator<CEventAPI::Deferred *>::reverse_iterator<CEventAPI::Deferred *>, COMDAT
; _this$ = eax
; ___x$ = ecx

; 65   :   explicit reverse_iterator(iterator_type __x) : current(__x) {}

	mov	DWORD PTR [eax], ecx
	ret	0
??0?$reverse_iterator@PAUDeferred@CEventAPI@@@stlp_std@@QAE@PAUDeferred@CEventAPI@@@Z ENDP ; stlp_std::reverse_iterator<CEventAPI::Deferred *>::reverse_iterator<CEventAPI::Deferred *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$reverse_iterator@PAVshared_str@@@stlp_std@@QAE@PAVshared_str@@@Z
_TEXT	SEGMENT
??0?$reverse_iterator@PAVshared_str@@@stlp_std@@QAE@PAVshared_str@@@Z PROC ; stlp_std::reverse_iterator<shared_str *>::reverse_iterator<shared_str *>, COMDAT
; _this$ = eax
; ___x$ = ecx

; 65   :   explicit reverse_iterator(iterator_type __x) : current(__x) {}

	mov	DWORD PTR [eax], ecx
	ret	0
??0?$reverse_iterator@PAVshared_str@@@stlp_std@@QAE@PAVshared_str@@@Z ENDP ; stlp_std::reverse_iterator<shared_str *>::reverse_iterator<shared_str *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$reverse_iterator@PAPAX@stlp_std@@QAE@PAPAX@Z
_TEXT	SEGMENT
??0?$reverse_iterator@PAPAX@stlp_std@@QAE@PAPAX@Z PROC	; stlp_std::reverse_iterator<void * *>::reverse_iterator<void * *>, COMDAT
; _this$ = eax
; ___x$ = ecx

; 65   :   explicit reverse_iterator(iterator_type __x) : current(__x) {}

	mov	DWORD PTR [eax], ecx
	ret	0
??0?$reverse_iterator@PAPAX@stlp_std@@QAE@PAPAX@Z ENDP	; stlp_std::reverse_iterator<void * *>::reverse_iterator<void * *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ?deallocate@?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@QBEXPAV?$FastDelegate0@X@fastdelegate@@I@Z
_TEXT	SEGMENT
?deallocate@?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@QBEXPAV?$FastDelegate0@X@fastdelegate@@I@Z PROC ; xalloc<fastdelegate::FastDelegate0<void> >::deallocate, COMDAT
; _p$ = eax

; 83   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	test	eax, eax
	je	SHORT $LN3@deallocate@40
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN3@deallocate@40:
	ret	0
?deallocate@?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@QBEXPAV?$FastDelegate0@X@fastdelegate@@I@Z ENDP ; xalloc<fastdelegate::FastDelegate0<void> >::deallocate
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ?size@?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QBEIXZ PROC ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::size, COMDAT
; _this$ = eax

; 180  :   size_type size() const        { return size_type(this->_M_finish - this->_M_start); }

	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR [eax]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	ret	0
?size@?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QBEIXZ ENDP ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QBEPBU_REG_INFO@@XZ
_TEXT	SEGMENT
?end@?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QBEPBU_REG_INFO@@XZ PROC ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::end, COMDAT
; _this$ = eax

; 173  :   const_iterator end() const   { return this->_M_finish; }

	mov	eax, DWORD PTR [eax+4]
	ret	0
?end@?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QBEPBU_REG_INFO@@XZ ENDP ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAEPAU_REG_INFO@@XZ
_TEXT	SEGMENT
?end@?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAEPAU_REG_INFO@@XZ PROC ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::end, COMDAT
; _this$ = eax

; 172  :   iterator end()               { return this->_M_finish; }

	mov	eax, DWORD PTR [eax+4]
	ret	0
?end@?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAEPAU_REG_INFO@@XZ ENDP ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QBEPBU_REG_INFO@@XZ
_TEXT	SEGMENT
?begin@?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QBEPBU_REG_INFO@@XZ PROC ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::begin, COMDAT
; _this$ = eax

; 171  :   const_iterator begin() const { return this->_M_start; }

	mov	eax, DWORD PTR [eax]
	ret	0
?begin@?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QBEPBU_REG_INFO@@XZ ENDP ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::begin
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAEPAU_REG_INFO@@XZ
_TEXT	SEGMENT
?begin@?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAEPAU_REG_INFO@@XZ PROC ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::begin, COMDAT
; _this$ = eax

; 170  :   iterator begin()             { return this->_M_start; }

	mov	eax, DWORD PTR [eax]
	ret	0
?begin@?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAEPAU_REG_INFO@@XZ ENDP ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::begin
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?get_allocator@?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QBE?AV?$xalloc@U_REG_INFO@@@@XZ
_TEXT	SEGMENT
?get_allocator@?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QBE?AV?$xalloc@U_REG_INFO@@@@XZ PROC ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::get_allocator, COMDAT
; ___$ReturnUdt$ = eax

; 134  :   { return _STLP_CONVERT_ALLOCATOR((const allocator_type&)this->_M_end_of_storage, _Tp); }

	ret	0
?get_allocator@?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QBE?AV?$xalloc@U_REG_INFO@@@@XZ ENDP ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::get_allocator
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ?deallocate@?$xalloc@U_REG_INFO@@@@QBEXPAU_REG_INFO@@I@Z
_TEXT	SEGMENT
?deallocate@?$xalloc@U_REG_INFO@@@@QBEXPAU_REG_INFO@@I@Z PROC ; xalloc<_REG_INFO>::deallocate, COMDAT
; _p$ = eax

; 83   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	test	eax, eax
	je	SHORT $LN3@deallocate@41
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN3@deallocate@41:
	ret	0
?deallocate@?$xalloc@U_REG_INFO@@@@QBEXPAU_REG_INFO@@I@Z ENDP ; xalloc<_REG_INFO>::deallocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$xalloc@U_REG_INFO@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@U_REG_INFO@@@@QAE@XZ PROC			; xalloc<_REG_INFO>::xalloc<_REG_INFO>, COMDAT
; _this$ = eax

; 77   : 													xalloc			()										{	}

	ret	0
??0?$xalloc@U_REG_INFO@@@@QAE@XZ ENDP			; xalloc<_REG_INFO>::xalloc<_REG_INFO>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ?size@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QBEIXZ PROC ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::size, COMDAT
; _this$ = eax

; 180  :   size_type size() const        { return size_type(this->_M_finish - this->_M_start); }

	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR [eax]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	ret	0
?size@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QBEIXZ ENDP ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QBEPBUItemReg@CSheduler@@XZ
_TEXT	SEGMENT
?end@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QBEPBUItemReg@CSheduler@@XZ PROC ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::end, COMDAT
; _this$ = eax

; 173  :   const_iterator end() const   { return this->_M_finish; }

	mov	eax, DWORD PTR [eax+4]
	ret	0
?end@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QBEPBUItemReg@CSheduler@@XZ ENDP ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAEPAUItemReg@CSheduler@@XZ
_TEXT	SEGMENT
?end@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAEPAUItemReg@CSheduler@@XZ PROC ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::end, COMDAT
; _this$ = eax

; 172  :   iterator end()               { return this->_M_finish; }

	mov	eax, DWORD PTR [eax+4]
	ret	0
?end@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAEPAUItemReg@CSheduler@@XZ ENDP ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QBEPBUItemReg@CSheduler@@XZ
_TEXT	SEGMENT
?begin@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QBEPBUItemReg@CSheduler@@XZ PROC ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::begin, COMDAT
; _this$ = eax

; 171  :   const_iterator begin() const { return this->_M_start; }

	mov	eax, DWORD PTR [eax]
	ret	0
?begin@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QBEPBUItemReg@CSheduler@@XZ ENDP ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::begin
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAEPAUItemReg@CSheduler@@XZ
_TEXT	SEGMENT
?begin@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAEPAUItemReg@CSheduler@@XZ PROC ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::begin, COMDAT
; _this$ = eax

; 170  :   iterator begin()             { return this->_M_start; }

	mov	eax, DWORD PTR [eax]
	ret	0
?begin@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAEPAUItemReg@CSheduler@@XZ ENDP ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::begin
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?get_allocator@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QBE?AV?$xalloc@UItemReg@CSheduler@@@@XZ
_TEXT	SEGMENT
?get_allocator@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QBE?AV?$xalloc@UItemReg@CSheduler@@@@XZ PROC ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::get_allocator, COMDAT
; ___$ReturnUdt$ = eax

; 134  :   { return _STLP_CONVERT_ALLOCATOR((const allocator_type&)this->_M_end_of_storage, _Tp); }

	ret	0
?get_allocator@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QBE?AV?$xalloc@UItemReg@CSheduler@@@@XZ ENDP ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::get_allocator
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ?deallocate@?$xalloc@UItemReg@CSheduler@@@@QBEXPAUItemReg@CSheduler@@I@Z
_TEXT	SEGMENT
?deallocate@?$xalloc@UItemReg@CSheduler@@@@QBEXPAUItemReg@CSheduler@@I@Z PROC ; xalloc<CSheduler::ItemReg>::deallocate, COMDAT
; _p$ = eax

; 83   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	test	eax, eax
	je	SHORT $LN3@deallocate@42
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN3@deallocate@42:
	ret	0
?deallocate@?$xalloc@UItemReg@CSheduler@@@@QBEXPAUItemReg@CSheduler@@I@Z ENDP ; xalloc<CSheduler::ItemReg>::deallocate
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ?size@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QBEIXZ PROC ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::size, COMDAT
; _this$ = eax

; 180  :   size_type size() const        { return size_type(this->_M_finish - this->_M_start); }

	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR [eax]
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	ret	0
?size@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QBEIXZ ENDP ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QBEPBUItem@CSheduler@@XZ
_TEXT	SEGMENT
?end@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QBEPBUItem@CSheduler@@XZ PROC ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::end, COMDAT
; _this$ = eax

; 173  :   const_iterator end() const   { return this->_M_finish; }

	mov	eax, DWORD PTR [eax+4]
	ret	0
?end@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QBEPBUItem@CSheduler@@XZ ENDP ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEPAUItem@CSheduler@@XZ
_TEXT	SEGMENT
?end@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEPAUItem@CSheduler@@XZ PROC ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::end, COMDAT
; _this$ = eax

; 172  :   iterator end()               { return this->_M_finish; }

	mov	eax, DWORD PTR [eax+4]
	ret	0
?end@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEPAUItem@CSheduler@@XZ ENDP ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QBEPBUItem@CSheduler@@XZ
_TEXT	SEGMENT
?begin@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QBEPBUItem@CSheduler@@XZ PROC ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::begin, COMDAT
; _this$ = eax

; 171  :   const_iterator begin() const { return this->_M_start; }

	mov	eax, DWORD PTR [eax]
	ret	0
?begin@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QBEPBUItem@CSheduler@@XZ ENDP ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::begin
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEPAUItem@CSheduler@@XZ
_TEXT	SEGMENT
?begin@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEPAUItem@CSheduler@@XZ PROC ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::begin, COMDAT
; _this$ = eax

; 170  :   iterator begin()             { return this->_M_start; }

	mov	eax, DWORD PTR [eax]
	ret	0
?begin@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEPAUItem@CSheduler@@XZ ENDP ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::begin
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?get_allocator@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QBE?AV?$xalloc@UItem@CSheduler@@@@XZ
_TEXT	SEGMENT
?get_allocator@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QBE?AV?$xalloc@UItem@CSheduler@@@@XZ PROC ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::get_allocator, COMDAT
; ___$ReturnUdt$ = eax

; 134  :   { return _STLP_CONVERT_ALLOCATOR((const allocator_type&)this->_M_end_of_storage, _Tp); }

	ret	0
?get_allocator@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QBE?AV?$xalloc@UItem@CSheduler@@@@XZ ENDP ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::get_allocator
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ?deallocate@?$xalloc@UItem@CSheduler@@@@QBEXPAUItem@CSheduler@@I@Z
_TEXT	SEGMENT
?deallocate@?$xalloc@UItem@CSheduler@@@@QBEXPAUItem@CSheduler@@I@Z PROC ; xalloc<CSheduler::Item>::deallocate, COMDAT
; _p$ = eax

; 83   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	test	eax, eax
	je	SHORT $LN3@deallocate@43
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN3@deallocate@43:
	ret	0
?deallocate@?$xalloc@UItem@CSheduler@@@@QBEXPAUItem@CSheduler@@I@Z ENDP ; xalloc<CSheduler::Item>::deallocate
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ?end@?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAEPAUDeferred@CEventAPI@@XZ
_TEXT	SEGMENT
?end@?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAEPAUDeferred@CEventAPI@@XZ PROC ; stlp_std::priv::_Impl_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::end, COMDAT
; _this$ = eax

; 172  :   iterator end()               { return this->_M_finish; }

	mov	eax, DWORD PTR [eax+4]
	ret	0
?end@?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAEPAUDeferred@CEventAPI@@XZ ENDP ; stlp_std::priv::_Impl_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAEPAUDeferred@CEventAPI@@XZ
_TEXT	SEGMENT
?begin@?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAEPAUDeferred@CEventAPI@@XZ PROC ; stlp_std::priv::_Impl_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::begin, COMDAT
; _this$ = eax

; 170  :   iterator begin()             { return this->_M_start; }

	mov	eax, DWORD PTR [eax]
	ret	0
?begin@?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAEPAUDeferred@CEventAPI@@XZ ENDP ; stlp_std::priv::_Impl_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::begin
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ?deallocate@?$xalloc@UDeferred@CEventAPI@@@@QBEXPAUDeferred@CEventAPI@@I@Z
_TEXT	SEGMENT
?deallocate@?$xalloc@UDeferred@CEventAPI@@@@QBEXPAUDeferred@CEventAPI@@I@Z PROC ; xalloc<CEventAPI::Deferred>::deallocate, COMDAT
; _p$ = eax

; 83   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	test	eax, eax
	je	SHORT $LN3@deallocate@44
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN3@deallocate@44:
	ret	0
?deallocate@?$xalloc@UDeferred@CEventAPI@@@@QBEXPAUDeferred@CEventAPI@@I@Z ENDP ; xalloc<CEventAPI::Deferred>::deallocate
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ?size@?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QBEIXZ PROC ; stlp_std::priv::_Impl_vector<shared_str,xalloc<shared_str> >::size, COMDAT
; _this$ = ecx

; 180  :   size_type size() const        { return size_type(this->_M_finish - this->_M_start); }

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	ret	0
?size@?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QBEIXZ ENDP ; stlp_std::priv::_Impl_vector<shared_str,xalloc<shared_str> >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QBEPBVshared_str@@XZ
_TEXT	SEGMENT
?end@?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QBEPBVshared_str@@XZ PROC ; stlp_std::priv::_Impl_vector<shared_str,xalloc<shared_str> >::end, COMDAT
; _this$ = eax

; 173  :   const_iterator end() const   { return this->_M_finish; }

	mov	eax, DWORD PTR [eax+4]
	ret	0
?end@?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QBEPBVshared_str@@XZ ENDP ; stlp_std::priv::_Impl_vector<shared_str,xalloc<shared_str> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAEPAVshared_str@@XZ
_TEXT	SEGMENT
?end@?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAEPAVshared_str@@XZ PROC ; stlp_std::priv::_Impl_vector<shared_str,xalloc<shared_str> >::end, COMDAT
; _this$ = eax

; 172  :   iterator end()               { return this->_M_finish; }

	mov	eax, DWORD PTR [eax+4]
	ret	0
?end@?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAEPAVshared_str@@XZ ENDP ; stlp_std::priv::_Impl_vector<shared_str,xalloc<shared_str> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QBEPBVshared_str@@XZ
_TEXT	SEGMENT
?begin@?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QBEPBVshared_str@@XZ PROC ; stlp_std::priv::_Impl_vector<shared_str,xalloc<shared_str> >::begin, COMDAT
; _this$ = eax

; 171  :   const_iterator begin() const { return this->_M_start; }

	mov	eax, DWORD PTR [eax]
	ret	0
?begin@?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QBEPBVshared_str@@XZ ENDP ; stlp_std::priv::_Impl_vector<shared_str,xalloc<shared_str> >::begin
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAEPAVshared_str@@XZ
_TEXT	SEGMENT
?begin@?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAEPAVshared_str@@XZ PROC ; stlp_std::priv::_Impl_vector<shared_str,xalloc<shared_str> >::begin, COMDAT
; _this$ = eax

; 170  :   iterator begin()             { return this->_M_start; }

	mov	eax, DWORD PTR [eax]
	ret	0
?begin@?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAEPAVshared_str@@XZ ENDP ; stlp_std::priv::_Impl_vector<shared_str,xalloc<shared_str> >::begin
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?get_allocator@?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QBE?AV?$xalloc@Vshared_str@@@@XZ
_TEXT	SEGMENT
?get_allocator@?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QBE?AV?$xalloc@Vshared_str@@@@XZ PROC ; stlp_std::priv::_Impl_vector<shared_str,xalloc<shared_str> >::get_allocator, COMDAT
; ___$ReturnUdt$ = eax

; 134  :   { return _STLP_CONVERT_ALLOCATOR((const allocator_type&)this->_M_end_of_storage, _Tp); }

	ret	0
?get_allocator@?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QBE?AV?$xalloc@Vshared_str@@@@XZ ENDP ; stlp_std::priv::_Impl_vector<shared_str,xalloc<shared_str> >::get_allocator
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ?deallocate@?$xalloc@Vshared_str@@@@QBEXPAVshared_str@@I@Z
_TEXT	SEGMENT
?deallocate@?$xalloc@Vshared_str@@@@QBEXPAVshared_str@@I@Z PROC ; xalloc<shared_str>::deallocate, COMDAT
; _p$ = eax

; 83   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	test	eax, eax
	je	SHORT $LN3@deallocate@45
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN3@deallocate@45:
	ret	0
?deallocate@?$xalloc@Vshared_str@@@@QBEXPAVshared_str@@I@Z ENDP ; xalloc<shared_str>::deallocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?deallocate@?$xalloc@PAX@@QBEXPAPAXI@Z
_TEXT	SEGMENT
?deallocate@?$xalloc@PAX@@QBEXPAPAXI@Z PROC		; xalloc<void *>::deallocate, COMDAT
; _p$ = eax

; 83   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	test	eax, eax
	je	SHORT $LN3@deallocate@46
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN3@deallocate@46:
	ret	0
?deallocate@?$xalloc@PAX@@QBEXPAPAXI@Z ENDP		; xalloc<void *>::deallocate
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ?end@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEPAPAXXZ
_TEXT	SEGMENT
?end@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEPAPAXXZ PROC ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::end, COMDAT
; _this$ = eax

; 172  :   iterator end()               { return this->_M_finish; }

	mov	eax, DWORD PTR [eax+4]
	ret	0
?end@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEPAPAXXZ ENDP ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEPAPAXXZ
_TEXT	SEGMENT
?begin@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEPAPAXXZ PROC ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::begin, COMDAT
; _this$ = eax

; 170  :   iterator begin()             { return this->_M_start; }

	mov	eax, DWORD PTR [eax]
	ret	0
?begin@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEPAPAXXZ ENDP ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::begin
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_tools.h
_TEXT	ENDS
;	COMDAT ?to_storage_type_ptr@?$_CastTraits@V?$FastDelegate0@X@fastdelegate@@V12@@priv@stlp_std@@SAPAV?$FastDelegate0@X@fastdelegate@@PAV45@@Z
_TEXT	SEGMENT
?to_storage_type_ptr@?$_CastTraits@V?$FastDelegate0@X@fastdelegate@@V12@@priv@stlp_std@@SAPAV?$FastDelegate0@X@fastdelegate@@PAV45@@Z PROC ; stlp_std::priv::_CastTraits<fastdelegate::FastDelegate0<void>,fastdelegate::FastDelegate0<void> >::to_storage_type_ptr, COMDAT
; ___ptr$ = eax

; 248  :   { return __ptr; }

	ret	0
?to_storage_type_ptr@?$_CastTraits@V?$FastDelegate0@X@fastdelegate@@V12@@priv@stlp_std@@SAPAV?$FastDelegate0@X@fastdelegate@@PAV45@@Z ENDP ; stlp_std::priv::_CastTraits<fastdelegate::FastDelegate0<void>,fastdelegate::FastDelegate0<void> >::to_storage_type_ptr
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?to_value_type_ptr@?$_CastTraits@V?$FastDelegate0@X@fastdelegate@@V12@@priv@stlp_std@@SAPAV?$FastDelegate0@X@fastdelegate@@PAV45@@Z
_TEXT	SEGMENT
?to_value_type_ptr@?$_CastTraits@V?$FastDelegate0@X@fastdelegate@@V12@@priv@stlp_std@@SAPAV?$FastDelegate0@X@fastdelegate@@PAV45@@Z PROC ; stlp_std::priv::_CastTraits<fastdelegate::FastDelegate0<void>,fastdelegate::FastDelegate0<void> >::to_value_type_ptr, COMDAT
; ___ptr$ = eax

; 237  :   { return __ptr; }

	ret	0
?to_value_type_ptr@?$_CastTraits@V?$FastDelegate0@X@fastdelegate@@V12@@priv@stlp_std@@SAPAV?$FastDelegate0@X@fastdelegate@@PAV45@@Z ENDP ; stlp_std::priv::_CastTraits<fastdelegate::FastDelegate0<void>,fastdelegate::FastDelegate0<void> >::to_value_type_ptr
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?to_value_type_ref@?$_CastTraits@UItem@CSheduler@@U12@@priv@stlp_std@@SAAAUItem@CSheduler@@AAU45@@Z
_TEXT	SEGMENT
?to_value_type_ref@?$_CastTraits@UItem@CSheduler@@U12@@priv@stlp_std@@SAAAUItem@CSheduler@@AAU45@@Z PROC ; stlp_std::priv::_CastTraits<CSheduler::Item,CSheduler::Item>::to_value_type_ref, COMDAT
; ___ref$ = eax

; 243  :   { return __ref; }

	ret	0
?to_value_type_ref@?$_CastTraits@UItem@CSheduler@@U12@@priv@stlp_std@@SAAAUItem@CSheduler@@AAU45@@Z ENDP ; stlp_std::priv::_CastTraits<CSheduler::Item,CSheduler::Item>::to_value_type_ref
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ??1?$_Vector_base@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_base@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAE@XZ PROC ; stlp_std::priv::_Vector_base<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::~_Vector_base<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >, COMDAT
; _this$ = eax

; 85   :     if (_M_start != _STLP_DEFAULT_CONSTRUCTED(pointer))

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN6@Vector_bas@25

; 86   :       _M_end_of_storage.deallocate(_M_start, _M_end_of_storage._M_data - _M_start);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN6@Vector_bas@25:

; 87   :   }

	ret	0
??1?$_Vector_base@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAE@XZ ENDP ; stlp_std::priv::_Vector_base<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::~_Vector_base<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAEPAV?$FastDelegate0@X@fastdelegate@@XZ
_TEXT	SEGMENT
?end@?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAEPAV?$FastDelegate0@X@fastdelegate@@XZ PROC ; stlp_std::priv::_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::end, COMDAT
; _this$ = eax

; 172  :   iterator end()               { return this->_M_finish; }

	mov	eax, DWORD PTR [eax+4]
	ret	0
?end@?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAEPAV?$FastDelegate0@X@fastdelegate@@XZ ENDP ; stlp_std::priv::_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAEPAV?$FastDelegate0@X@fastdelegate@@XZ
_TEXT	SEGMENT
?begin@?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAEPAV?$FastDelegate0@X@fastdelegate@@XZ PROC ; stlp_std::priv::_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::begin, COMDAT
; _this$ = eax

; 170  :   iterator begin()             { return this->_M_start; }

	mov	eax, DWORD PTR [eax]
	ret	0
?begin@?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAEPAV?$FastDelegate0@X@fastdelegate@@XZ ENDP ; stlp_std::priv::_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::begin
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ??0?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@QAE@XZ PROC ; xalloc<fastdelegate::FastDelegate0<void> >::xalloc<fastdelegate::FastDelegate0<void> >, COMDAT
; _this$ = eax

; 77   : 													xalloc			()										{	}

	ret	0
??0?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@QAE@XZ ENDP ; xalloc<fastdelegate::FastDelegate0<void> >::xalloc<fastdelegate::FastDelegate0<void> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ??1?$_Vector_base@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_base@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE@XZ PROC ; stlp_std::priv::_Vector_base<_REG_INFO,xalloc<_REG_INFO> >::~_Vector_base<_REG_INFO,xalloc<_REG_INFO> >, COMDAT
; _this$ = eax

; 85   :     if (_M_start != _STLP_DEFAULT_CONSTRUCTED(pointer))

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN6@Vector_bas@26

; 86   :       _M_end_of_storage.deallocate(_M_start, _M_end_of_storage._M_data - _M_start);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN6@Vector_bas@26:

; 87   :   }

	ret	0
??1?$_Vector_base@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE@XZ ENDP ; stlp_std::priv::_Vector_base<_REG_INFO,xalloc<_REG_INFO> >::~_Vector_base<_REG_INFO,xalloc<_REG_INFO> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?rend@?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAU_REG_INFO@@@3@XZ
_TEXT	SEGMENT
?rend@?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAU_REG_INFO@@@3@XZ PROC ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::rend, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 177  :   reverse_iterator rend()                { return reverse_iterator(begin()); }

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	ret	0
?rend@?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAU_REG_INFO@@@3@XZ ENDP ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::rend
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?rbegin@?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAU_REG_INFO@@@3@XZ
_TEXT	SEGMENT
?rbegin@?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAU_REG_INFO@@@3@XZ PROC ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::rbegin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 175  :   reverse_iterator rbegin()              { return reverse_iterator(end()); }

	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	ret	0
?rbegin@?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAU_REG_INFO@@@3@XZ ENDP ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::rbegin
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Vector_base@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_base@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAE@XZ PROC ; stlp_std::priv::_Vector_base<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::~_Vector_base<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >, COMDAT
; _this$ = eax

; 85   :     if (_M_start != _STLP_DEFAULT_CONSTRUCTED(pointer))

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN6@Vector_bas@27

; 86   :       _M_end_of_storage.deallocate(_M_start, _M_end_of_storage._M_data - _M_start);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN6@Vector_bas@27:

; 87   :   }

	ret	0
??1?$_Vector_base@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAE@XZ ENDP ; stlp_std::priv::_Vector_base<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::~_Vector_base<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?rend@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAUItemReg@CSheduler@@@3@XZ
_TEXT	SEGMENT
?rend@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAUItemReg@CSheduler@@@3@XZ PROC ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::rend, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 177  :   reverse_iterator rend()                { return reverse_iterator(begin()); }

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	ret	0
?rend@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAUItemReg@CSheduler@@@3@XZ ENDP ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::rend
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?rbegin@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAUItemReg@CSheduler@@@3@XZ
_TEXT	SEGMENT
?rbegin@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAUItemReg@CSheduler@@@3@XZ PROC ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::rbegin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 175  :   reverse_iterator rbegin()              { return reverse_iterator(end()); }

	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	ret	0
?rbegin@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAUItemReg@CSheduler@@@3@XZ ENDP ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::rbegin
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ??0?$xalloc@UItemReg@CSheduler@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@UItemReg@CSheduler@@@@QAE@XZ PROC		; xalloc<CSheduler::ItemReg>::xalloc<CSheduler::ItemReg>, COMDAT
; _this$ = eax

; 77   : 													xalloc			()										{	}

	ret	0
??0?$xalloc@UItemReg@CSheduler@@@@QAE@XZ ENDP		; xalloc<CSheduler::ItemReg>::xalloc<CSheduler::ItemReg>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ??1?$_Vector_base@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_base@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAE@XZ PROC ; stlp_std::priv::_Vector_base<CSheduler::Item,xalloc<CSheduler::Item> >::~_Vector_base<CSheduler::Item,xalloc<CSheduler::Item> >, COMDAT
; _this$ = eax

; 85   :     if (_M_start != _STLP_DEFAULT_CONSTRUCTED(pointer))

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN6@Vector_bas@28

; 86   :       _M_end_of_storage.deallocate(_M_start, _M_end_of_storage._M_data - _M_start);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN6@Vector_bas@28:

; 87   :   }

	ret	0
??1?$_Vector_base@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAE@XZ ENDP ; stlp_std::priv::_Vector_base<CSheduler::Item,xalloc<CSheduler::Item> >::~_Vector_base<CSheduler::Item,xalloc<CSheduler::Item> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?front@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEAAUItem@CSheduler@@XZ
_TEXT	SEGMENT
?front@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEAAUItem@CSheduler@@XZ PROC ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::front, COMDAT
; _this$ = eax

; 193  :   reference front()             { return *begin(); }

	mov	eax, DWORD PTR [eax]
	ret	0
?front@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEAAUItem@CSheduler@@XZ ENDP ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::front
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?rend@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAUItem@CSheduler@@@3@XZ
_TEXT	SEGMENT
?rend@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAUItem@CSheduler@@@3@XZ PROC ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::rend, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 177  :   reverse_iterator rend()                { return reverse_iterator(begin()); }

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	ret	0
?rend@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAUItem@CSheduler@@@3@XZ ENDP ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::rend
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?rbegin@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAUItem@CSheduler@@@3@XZ
_TEXT	SEGMENT
?rbegin@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAUItem@CSheduler@@@3@XZ PROC ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::rbegin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 175  :   reverse_iterator rbegin()              { return reverse_iterator(end()); }

	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	ret	0
?rbegin@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAUItem@CSheduler@@@3@XZ ENDP ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::rbegin
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ??0?$xalloc@UItem@CSheduler@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@UItem@CSheduler@@@@QAE@XZ PROC		; xalloc<CSheduler::Item>::xalloc<CSheduler::Item>, COMDAT
; _this$ = eax

; 77   : 													xalloc			()										{	}

	ret	0
??0?$xalloc@UItem@CSheduler@@@@QAE@XZ ENDP		; xalloc<CSheduler::Item>::xalloc<CSheduler::Item>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ??1?$_Vector_base@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_base@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAE@XZ PROC ; stlp_std::priv::_Vector_base<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::~_Vector_base<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >, COMDAT
; _this$ = eax

; 85   :     if (_M_start != _STLP_DEFAULT_CONSTRUCTED(pointer))

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN6@Vector_bas@29

; 86   :       _M_end_of_storage.deallocate(_M_start, _M_end_of_storage._M_data - _M_start);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN6@Vector_bas@29:

; 87   :   }

	ret	0
??1?$_Vector_base@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAE@XZ ENDP ; stlp_std::priv::_Vector_base<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::~_Vector_base<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?rend@?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAUDeferred@CEventAPI@@@3@XZ
_TEXT	SEGMENT
?rend@?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAUDeferred@CEventAPI@@@3@XZ PROC ; stlp_std::priv::_Impl_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::rend, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 177  :   reverse_iterator rend()                { return reverse_iterator(begin()); }

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	ret	0
?rend@?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAUDeferred@CEventAPI@@@3@XZ ENDP ; stlp_std::priv::_Impl_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::rend
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?rbegin@?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAUDeferred@CEventAPI@@@3@XZ
_TEXT	SEGMENT
?rbegin@?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAUDeferred@CEventAPI@@@3@XZ PROC ; stlp_std::priv::_Impl_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::rbegin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 175  :   reverse_iterator rbegin()              { return reverse_iterator(end()); }

	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	ret	0
?rbegin@?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAUDeferred@CEventAPI@@@3@XZ ENDP ; stlp_std::priv::_Impl_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::rbegin
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ??0?$xalloc@UDeferred@CEventAPI@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@UDeferred@CEventAPI@@@@QAE@XZ PROC		; xalloc<CEventAPI::Deferred>::xalloc<CEventAPI::Deferred>, COMDAT
; _this$ = eax

; 77   : 													xalloc			()										{	}

	ret	0
??0?$xalloc@UDeferred@CEventAPI@@@@QAE@XZ ENDP		; xalloc<CEventAPI::Deferred>::xalloc<CEventAPI::Deferred>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$xalloc@PAVCEvent@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@PAVCEvent@@@@QAE@XZ PROC			; xalloc<CEvent *>::xalloc<CEvent *>, COMDAT
; _this$ = eax

; 77   : 													xalloc			()										{	}

	ret	0
??0?$xalloc@PAVCEvent@@@@QAE@XZ ENDP			; xalloc<CEvent *>::xalloc<CEvent *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ??1?$_Vector_base@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_base@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAE@XZ PROC ; stlp_std::priv::_Vector_base<shared_str,xalloc<shared_str> >::~_Vector_base<shared_str,xalloc<shared_str> >, COMDAT
; _this$ = eax

; 85   :     if (_M_start != _STLP_DEFAULT_CONSTRUCTED(pointer))

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN6@Vector_bas@30

; 86   :       _M_end_of_storage.deallocate(_M_start, _M_end_of_storage._M_data - _M_start);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN6@Vector_bas@30:

; 87   :   }

	ret	0
??1?$_Vector_base@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAE@XZ ENDP ; stlp_std::priv::_Vector_base<shared_str,xalloc<shared_str> >::~_Vector_base<shared_str,xalloc<shared_str> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?rend@?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAVshared_str@@@3@XZ
_TEXT	SEGMENT
?rend@?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAVshared_str@@@3@XZ PROC ; stlp_std::priv::_Impl_vector<shared_str,xalloc<shared_str> >::rend, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 177  :   reverse_iterator rend()                { return reverse_iterator(begin()); }

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	ret	0
?rend@?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAVshared_str@@@3@XZ ENDP ; stlp_std::priv::_Impl_vector<shared_str,xalloc<shared_str> >::rend
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?rbegin@?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAVshared_str@@@3@XZ
_TEXT	SEGMENT
?rbegin@?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAVshared_str@@@3@XZ PROC ; stlp_std::priv::_Impl_vector<shared_str,xalloc<shared_str> >::rbegin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 175  :   reverse_iterator rbegin()              { return reverse_iterator(end()); }

	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	ret	0
?rbegin@?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAVshared_str@@@3@XZ ENDP ; stlp_std::priv::_Impl_vector<shared_str,xalloc<shared_str> >::rbegin
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Vector_base@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_base@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAE@XZ PROC ; stlp_std::priv::_Vector_base<void *,xalloc<void *> >::~_Vector_base<void *,xalloc<void *> >, COMDAT
; _this$ = eax

; 85   :     if (_M_start != _STLP_DEFAULT_CONSTRUCTED(pointer))

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN6@Vector_bas@31

; 86   :       _M_end_of_storage.deallocate(_M_start, _M_end_of_storage._M_data - _M_start);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN6@Vector_bas@31:

; 87   :   }

	ret	0
??1?$_Vector_base@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAE@XZ ENDP ; stlp_std::priv::_Vector_base<void *,xalloc<void *> >::~_Vector_base<void *,xalloc<void *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?rend@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAPAX@3@XZ
_TEXT	SEGMENT
?rend@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAPAX@3@XZ PROC ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::rend, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 177  :   reverse_iterator rend()                { return reverse_iterator(begin()); }

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	ret	0
?rend@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAPAX@3@XZ ENDP ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::rend
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?rbegin@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAPAX@3@XZ
_TEXT	SEGMENT
?rbegin@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAPAX@3@XZ PROC ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::rbegin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 175  :   reverse_iterator rbegin()              { return reverse_iterator(end()); }

	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	ret	0
?rbegin@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAPAX@3@XZ ENDP ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::rbegin
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ?end@?$vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@stlp_std@@QAEPAV?$FastDelegate0@X@fastdelegate@@XZ
_TEXT	SEGMENT
?end@?$vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@stlp_std@@QAEPAV?$FastDelegate0@X@fastdelegate@@XZ PROC ; stlp_std::vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::end, COMDAT
; _this$ = eax

; 81   :   iterator end()               { return cast_traits::to_value_type_ptr(_M_impl.end()); }

	mov	eax, DWORD PTR [eax+4]
	ret	0
?end@?$vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@stlp_std@@QAEPAV?$FastDelegate0@X@fastdelegate@@XZ ENDP ; stlp_std::vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@stlp_std@@QAEPAV?$FastDelegate0@X@fastdelegate@@XZ
_TEXT	SEGMENT
?begin@?$vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@stlp_std@@QAEPAV?$FastDelegate0@X@fastdelegate@@XZ PROC ; stlp_std::vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::begin, COMDAT
; _this$ = eax

; 79   :   iterator begin()             { return cast_traits::to_value_type_ptr(_M_impl.begin()); }

	mov	eax, DWORD PTR [eax]
	ret	0
?begin@?$vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@stlp_std@@QAEPAV?$FastDelegate0@X@fastdelegate@@XZ ENDP ; stlp_std::vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::begin
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\include\xrrender\factoryptr.h
_TEXT	ENDS
;	COMDAT ??4?$FactoryPtr@VIStatsRender@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
??4?$FactoryPtr@VIStatsRender@@@@QAEAAV0@ABV0@@Z PROC	; FactoryPtr<IStatsRender>::operator=, COMDAT
; _this$ = esi
; __in$ = edx

; 35   : 		m_pObject->Copy(*_in.m_pObject);

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+4]
	push	edx
	call	eax

; 36   : 		return *this;

	mov	eax, esi

; 37   : 	}

	ret	0
??4?$FactoryPtr@VIStatsRender@@@@QAEAAV0@ABV0@@Z ENDP	; FactoryPtr<IStatsRender>::operator=
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ?front@?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAEAAUItem@CSheduler@@XZ
_TEXT	SEGMENT
?front@?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAEAAUItem@CSheduler@@XZ PROC ; stlp_std::vector<CSheduler::Item,xalloc<CSheduler::Item> >::front, COMDAT
; _this$ = eax

; 98   :   reference front()             { return cast_traits::to_value_type_ref(_M_impl.front()); }

	mov	eax, DWORD PTR [eax]
	ret	0
?front@?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAEAAUItem@CSheduler@@XZ ENDP ; stlp_std::vector<CSheduler::Item,xalloc<CSheduler::Item> >::front
_TEXT	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtpy
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___s$ = 8						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
; ___t$ = ecx
; ___n$ = eax
; ___f$ = ebx
	push	ebp
	mov	ebp, DWORD PTR ___s$[esp]
	push	esi
	push	edi
	mov	edi, eax
	sub	edi, 1
	mov	esi, ecx
	js	SHORT $LN1@vector@2
$LL2@vector@2:
	mov	ecx, esi
	call	ebx
	add	esi, ebp
	sub	edi, 1
	jns	SHORT $LL2@vector@2
$LN1@vector@2:
	pop	edi
	pop	esi
	pop	ebp
	ret	4
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\device.h
_TEXT	ENDS
;	COMDAT ?StatPhysics@CRenderDevice@@EAGPAVCStatsPhysics@@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?StatPhysics@CRenderDevice@@EAGPAVCStatsPhysics@@XZ PROC ; CRenderDevice::StatPhysics, COMDAT

; 290  : virtual		CStatsPhysics*	_BCL	StatPhysics			()	{ return  Statistic ;}

	mov	eax, DWORD PTR _this$[esp-4]
	mov	eax, DWORD PTR [eax+920]
	test	eax, eax
	je	SHORT $LN3@StatPhysic
	add	eax, 8
	ret	4
$LN3@StatPhysic:
	xor	eax, eax
	ret	4
?StatPhysics@CRenderDevice@@EAGPAVCStatsPhysics@@XZ ENDP ; CRenderDevice::StatPhysics
_TEXT	ENDS
PUBLIC	?time_factor@CRenderDevice@@QBEABMXZ		; CRenderDevice::time_factor
; Function compile flags: /Ogtpy
;	COMDAT ?time_factor@CRenderDevice@@QBEABMXZ
_TEXT	SEGMENT
?time_factor@CRenderDevice@@QBEABMXZ PROC		; CRenderDevice::time_factor, COMDAT
; _this$ = ecx

; 262  : 		VERIFY					(Timer.time_factor() == TimerGlobal.time_factor());
; 263  : 		return					(Timer.time_factor());

	lea	eax, DWORD PTR [ecx+544]

; 264  : 	}

	ret	0
?time_factor@CRenderDevice@@QBEABMXZ ENDP		; CRenderDevice::time_factor
_TEXT	ENDS
PUBLIC	?time_factor@CRenderDevice@@QAEXABM@Z		; CRenderDevice::time_factor
; Function compile flags: /Ogtpy
;	COMDAT ?time_factor@CRenderDevice@@QAEXABM@Z
_TEXT	SEGMENT
_time_factor$ = 8					; size = 4
?time_factor@CRenderDevice@@QAEXABM@Z PROC		; CRenderDevice::time_factor, COMDAT
; _this$ = ecx

; 255  : 	{

	push	esi
	push	edi

; 256  : 		Timer.time_factor		(time_factor);

	mov	edi, DWORD PTR _time_factor$[esp+4]
	mov	esi, ecx
	push	edi
	lea	ecx, DWORD PTR [esi+512]
	call	DWORD PTR __imp_?time_factor@CTimer@@QAEXABM@Z

; 257  : 		TimerGlobal.time_factor	(time_factor);

	push	edi
	lea	ecx, DWORD PTR [esi+584]
	call	DWORD PTR __imp_?time_factor@CTimer@@QAEXABM@Z
	pop	edi
	pop	esi

; 258  : 	}

	ret	4
?time_factor@CRenderDevice@@QAEXABM@Z ENDP		; CRenderDevice::time_factor
_TEXT	ENDS
PUBLIC	?TimerAsync_MMT@CRenderDevice@@QAEIXZ		; CRenderDevice::TimerAsync_MMT
; Function compile flags: /Ogtpy
;	COMDAT ?TimerAsync_MMT@CRenderDevice@@QAEIXZ
_TEXT	SEGMENT
?TimerAsync_MMT@CRenderDevice@@QAEIXZ PROC		; CRenderDevice::TimerAsync_MMT, COMDAT
; _this$ = ecx

; 241  : 	u32	 TimerAsync_MMT						()	{ return TimerMM.GetElapsed_ms() +	Timer_MM_Delta; }

	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+800]
	call	DWORD PTR __imp_?GetElapsed_ms@CTimer@@QBEIXZ
	add	eax, DWORD PTR [esi+500]
	pop	esi
	ret	0
?TimerAsync_MMT@CRenderDevice@@QAEIXZ ENDP		; CRenderDevice::TimerAsync_MMT
_TEXT	ENDS
PUBLIC	?TimerAsync@CRenderDevice@@QAEIXZ		; CRenderDevice::TimerAsync
; Function compile flags: /Ogtpy
;	COMDAT ?TimerAsync@CRenderDevice@@QAEIXZ
_TEXT	SEGMENT
?TimerAsync@CRenderDevice@@QAEIXZ PROC			; CRenderDevice::TimerAsync, COMDAT
; _this$ = ecx

; 240  : 	u32	 TimerAsync							()	{ return TimerGlobal.GetElapsed_ms();				}

	add	ecx, 584				; 00000248H
	jmp	DWORD PTR __imp_?GetElapsed_ms@CTimer@@QBEIXZ
?TimerAsync@CRenderDevice@@QAEIXZ ENDP			; CRenderDevice::TimerAsync
_TEXT	ENDS
PUBLIC	?GetTimerGlobal@CRenderDevice@@QAEPAVCTimer_paused@@XZ ; CRenderDevice::GetTimerGlobal
; Function compile flags: /Ogtpy
;	COMDAT ?GetTimerGlobal@CRenderDevice@@QAEPAVCTimer_paused@@XZ
_TEXT	SEGMENT
?GetTimerGlobal@CRenderDevice@@QAEPAVCTimer_paused@@XZ PROC ; CRenderDevice::GetTimerGlobal, COMDAT
; _this$ = ecx

; 239  : 	IC	 CTimer_paused* GetTimerGlobal		()	{ return &TimerGlobal;								}

	lea	eax, DWORD PTR [ecx+576]
	ret	0
?GetTimerGlobal@CRenderDevice@@QAEPAVCTimer_paused@@XZ ENDP ; CRenderDevice::GetTimerGlobal
_TEXT	ENDS
PUBLIC	?DumpResourcesMemoryUsage@CRenderDevice@@QAEXXZ	; CRenderDevice::DumpResourcesMemoryUsage
; Function compile flags: /Ogtpy
;	COMDAT ?DumpResourcesMemoryUsage@CRenderDevice@@QAEXXZ
_TEXT	SEGMENT
?DumpResourcesMemoryUsage@CRenderDevice@@QAEXXZ PROC	; CRenderDevice::DumpResourcesMemoryUsage, COMDAT
; _this$ = ecx

; 162  : 	void									DumpResourcesMemoryUsage() { m_pRender->ResourcesDumpMemoryUsage();}

	mov	ecx, DWORD PTR [ecx+868]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+84]
	jmp	edx
?DumpResourcesMemoryUsage@CRenderDevice@@QAEXXZ ENDP	; CRenderDevice::DumpResourcesMemoryUsage
_TEXT	ENDS
PUBLIC	?SetNearer@CRenderDevice@@QAEXH@Z		; CRenderDevice::SetNearer
; Function compile flags: /Ogtpy
;	COMDAT ?SetNearer@CRenderDevice@@QAEXH@Z
_TEXT	SEGMENT
_enabled$ = 8						; size = 4
?SetNearer@CRenderDevice@@QAEXH@Z PROC			; CRenderDevice::SetNearer, COMDAT
; _this$ = ecx

; 149  : 		if (enabled&&!m_bNearer){

	cmp	DWORD PTR _enabled$[esp-4], 0
	mov	eax, ecx
	je	SHORT $LN6@SetNearer
	cmp	DWORD PTR [eax+872], 0
	jne	SHORT $LN1@SetNearer

; 150  : 			m_bNearer						= TRUE;
; 151  : 			mProject._43					-= EPS_L;

	movss	xmm0, DWORD PTR [eax+216]
	subss	xmm0, DWORD PTR _EPS_L
	mov	DWORD PTR [eax+872], 1
	jmp	SHORT $LN7@SetNearer
$LN6@SetNearer:

; 152  : 		}else if (!enabled&&m_bNearer){

	cmp	DWORD PTR [eax+872], 0
	je	SHORT $LN1@SetNearer

; 153  : 			m_bNearer						= FALSE;
; 154  : 			mProject._43					+= EPS_L;

	movss	xmm0, DWORD PTR [eax+216]
	addss	xmm0, DWORD PTR _EPS_L
	mov	DWORD PTR [eax+872], 0
$LN7@SetNearer:
	movss	DWORD PTR [eax+216], xmm0
$LN1@SetNearer:

; 155  : 		}
; 156  : 		m_pRender->SetCacheXform(mView, mProject);

	mov	ecx, DWORD PTR [eax+868]
	mov	edx, DWORD PTR [ecx]
	push	esi
	lea	esi, DWORD PTR [eax+160]
	add	eax, 96					; 00000060H
	push	esi
	push	eax
	mov	eax, DWORD PTR [edx+120]
	call	eax
	pop	esi

; 157  : 		//R_ASSERT(0);
; 158  : 		//	TODO: re-implement set projection
; 159  : 		//RCache.set_xform_project			(mProject);
; 160  : 	}

	ret	4
?SetNearer@CRenderDevice@@QAEXH@Z ENDP			; CRenderDevice::SetNearer
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4IRenderDevice@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
??4IRenderDevice@@QAEAAV0@ABV0@@Z PROC			; IRenderDevice::operator=, COMDAT
; _this$ = eax
	ret	0
??4IRenderDevice@@QAEAAV0@ABV0@@Z ENDP			; IRenderDevice::operator=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0IRenderDevice@@QAE@ABV0@@Z
_TEXT	SEGMENT
??0IRenderDevice@@QAE@ABV0@@Z PROC			; IRenderDevice::IRenderDevice, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], OFFSET ??_7IRenderDevice@@6B@
	ret	0
??0IRenderDevice@@QAE@ABV0@@Z ENDP			; IRenderDevice::IRenderDevice
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0IRenderDevice@@QAE@XZ
_TEXT	SEGMENT
??0IRenderDevice@@QAE@XZ PROC				; IRenderDevice::IRenderDevice, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], OFFSET ??_7IRenderDevice@@6B@
	ret	0
??0IRenderDevice@@QAE@XZ ENDP				; IRenderDevice::IRenderDevice
_TEXT	ENDS
PUBLIC	?Font@CStats@@QAEPAVCGameFont@@XZ		; CStats::Font
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\stats.h
;	COMDAT ?Font@CStats@@QAEPAVCGameFont@@XZ
_TEXT	SEGMENT
?Font@CStats@@QAEPAVCGameFont@@XZ PROC			; CStats::Font, COMDAT
; _this$ = ecx

; 117  : 	IC CGameFont*	Font			(){return pFont;}

	mov	eax, DWORD PTR [ecx+224]
	ret	0
?Font@CStats@@QAEPAVCGameFont@@XZ ENDP			; CStats::Font
_TEXT	ENDS
PUBLIC	??4CStatsPhysics@@QAEAAV0@ABV0@@Z		; CStatsPhysics::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4CStatsPhysics@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4CStatsPhysics@@QAEAAV0@ABV0@@Z PROC			; CStatsPhysics::operator=, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, DWORD PTR ___that$[esp]
	push	edi
	mov	eax, ecx
	mov	ecx, 54					; 00000036H
	mov	edi, eax
	rep movsd
	pop	edi
	pop	esi
	ret	4
??4CStatsPhysics@@QAEAAV0@ABV0@@Z ENDP			; CStatsPhysics::operator=
_TEXT	ENDS
PUBLIC	??0CStatsPhysics@@QAE@XZ			; CStatsPhysics::CStatsPhysics
; Function compile flags: /Ogtpy
;	COMDAT ??0CStatsPhysics@@QAE@XZ
_TEXT	SEGMENT
??0CStatsPhysics@@QAE@XZ PROC				; CStatsPhysics::CStatsPhysics, COMDAT
; _this$ = ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR __imp_??0CStatTimer@@QAE@XZ
	mov	esi, ecx
	call	edi
	lea	ecx, DWORD PTR [esi+72]
	call	edi
	lea	ecx, DWORD PTR [esi+144]
	call	edi
	pop	edi
	mov	eax, esi
	pop	esi
	ret	0
??0CStatsPhysics@@QAE@XZ ENDP				; CStatsPhysics::CStatsPhysics
_TEXT	ENDS
PUBLIC	??4pureStats@@QAEAAV0@ABV0@@Z			; pureStats::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4pureStats@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4pureStats@@QAEAAV0@ABV0@@Z PROC			; pureStats::operator=, COMDAT
; _this$ = ecx
	mov	eax, ecx
	ret	4
??4pureStats@@QAEAAV0@ABV0@@Z ENDP			; pureStats::operator=
_TEXT	ENDS
PUBLIC	??0pureStats@@QAE@ABV0@@Z			; pureStats::pureStats
; Function compile flags: /Ogtpy
;	COMDAT ??0pureStats@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0pureStats@@QAE@ABV0@@Z PROC				; pureStats::pureStats, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], OFFSET ??_7pureStats@@6B@
	ret	4
??0pureStats@@QAE@ABV0@@Z ENDP				; pureStats::pureStats
_TEXT	ENDS
PUBLIC	??0pureStats@@QAE@XZ				; pureStats::pureStats
; Function compile flags: /Ogtpy
;	COMDAT ??0pureStats@@QAE@XZ
_TEXT	SEGMENT
??0pureStats@@QAE@XZ PROC				; pureStats::pureStats, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], OFFSET ??_7pureStats@@6B@
	ret	0
??0pureStats@@QAE@XZ ENDP				; pureStats::pureStats
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\include\xrrender\factoryptr.h
_TEXT	ENDS
;	COMDAT ?DestroyObject@?$FactoryPtr@VIStatsRender@@@@AAEXXZ
_TEXT	SEGMENT
?DestroyObject@?$FactoryPtr@VIStatsRender@@@@AAEXXZ PROC ; FactoryPtr<IStatsRender>::DestroyObject, COMDAT
; _this$ = esi

; 67   : 	FACTORY_PTR_INSTANCIATE(StatsRender);

	mov	eax, DWORD PTR __imp_?RenderFactory@@3PAVIRenderFactory@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+60]
	push	eax
	call	edx
	mov	DWORD PTR [esi], 0
	ret	0
?DestroyObject@?$FactoryPtr@VIStatsRender@@@@AAEXXZ ENDP ; FactoryPtr<IStatsRender>::DestroyObject
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?CreateObject@?$FactoryPtr@VIStatsRender@@@@AAEXXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?CreateObject@?$FactoryPtr@VIStatsRender@@@@AAEXXZ PROC	; FactoryPtr<IStatsRender>::CreateObject, COMDAT

; 67   : 	FACTORY_PTR_INSTANCIATE(StatsRender);

	mov	eax, DWORD PTR __imp_?RenderFactory@@3PAVIRenderFactory@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+56]
	call	eax
	mov	ecx, DWORD PTR _this$[esp-4]
	mov	DWORD PTR [ecx], eax
	ret	4
?CreateObject@?$FactoryPtr@VIStatsRender@@@@AAEXXZ ENDP	; FactoryPtr<IStatsRender>::CreateObject
_TEXT	ENDS
PUBLIC	??4pureScreenResolutionChanged@@QAEAAV0@ABV0@@Z	; pureScreenResolutionChanged::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4pureScreenResolutionChanged@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4pureScreenResolutionChanged@@QAEAAV0@ABV0@@Z PROC	; pureScreenResolutionChanged::operator=, COMDAT
; _this$ = ecx
	mov	eax, ecx
	ret	4
??4pureScreenResolutionChanged@@QAEAAV0@ABV0@@Z ENDP	; pureScreenResolutionChanged::operator=
_TEXT	ENDS
PUBLIC	??0pureScreenResolutionChanged@@QAE@ABV0@@Z	; pureScreenResolutionChanged::pureScreenResolutionChanged
; Function compile flags: /Ogtpy
;	COMDAT ??0pureScreenResolutionChanged@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0pureScreenResolutionChanged@@QAE@ABV0@@Z PROC	; pureScreenResolutionChanged::pureScreenResolutionChanged, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], OFFSET ??_7pureScreenResolutionChanged@@6B@
	ret	4
??0pureScreenResolutionChanged@@QAE@ABV0@@Z ENDP	; pureScreenResolutionChanged::pureScreenResolutionChanged
_TEXT	ENDS
PUBLIC	??0pureScreenResolutionChanged@@QAE@XZ		; pureScreenResolutionChanged::pureScreenResolutionChanged
; Function compile flags: /Ogtpy
;	COMDAT ??0pureScreenResolutionChanged@@QAE@XZ
_TEXT	SEGMENT
??0pureScreenResolutionChanged@@QAE@XZ PROC		; pureScreenResolutionChanged::pureScreenResolutionChanged, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], OFFSET ??_7pureScreenResolutionChanged@@6B@
	ret	0
??0pureScreenResolutionChanged@@QAE@XZ ENDP		; pureScreenResolutionChanged::pureScreenResolutionChanged
_TEXT	ENDS
PUBLIC	??4pureDeviceReset@@QAEAAV0@ABV0@@Z		; pureDeviceReset::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4pureDeviceReset@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4pureDeviceReset@@QAEAAV0@ABV0@@Z PROC		; pureDeviceReset::operator=, COMDAT
; _this$ = ecx
	mov	eax, ecx
	ret	4
??4pureDeviceReset@@QAEAAV0@ABV0@@Z ENDP		; pureDeviceReset::operator=
_TEXT	ENDS
PUBLIC	??0pureDeviceReset@@QAE@ABV0@@Z			; pureDeviceReset::pureDeviceReset
; Function compile flags: /Ogtpy
;	COMDAT ??0pureDeviceReset@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0pureDeviceReset@@QAE@ABV0@@Z PROC			; pureDeviceReset::pureDeviceReset, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], OFFSET ??_7pureDeviceReset@@6B@
	ret	4
??0pureDeviceReset@@QAE@ABV0@@Z ENDP			; pureDeviceReset::pureDeviceReset
_TEXT	ENDS
PUBLIC	??0pureDeviceReset@@QAE@XZ			; pureDeviceReset::pureDeviceReset
; Function compile flags: /Ogtpy
;	COMDAT ??0pureDeviceReset@@QAE@XZ
_TEXT	SEGMENT
??0pureDeviceReset@@QAE@XZ PROC				; pureDeviceReset::pureDeviceReset, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], OFFSET ??_7pureDeviceReset@@6B@
	ret	0
??0pureDeviceReset@@QAE@XZ ENDP				; pureDeviceReset::pureDeviceReset
_TEXT	ENDS
PUBLIC	??4pureAppEnd@@QAEAAV0@ABV0@@Z			; pureAppEnd::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4pureAppEnd@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4pureAppEnd@@QAEAAV0@ABV0@@Z PROC			; pureAppEnd::operator=, COMDAT
; _this$ = ecx
	mov	eax, ecx
	ret	4
??4pureAppEnd@@QAEAAV0@ABV0@@Z ENDP			; pureAppEnd::operator=
_TEXT	ENDS
PUBLIC	??0pureAppEnd@@QAE@ABV0@@Z			; pureAppEnd::pureAppEnd
; Function compile flags: /Ogtpy
;	COMDAT ??0pureAppEnd@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0pureAppEnd@@QAE@ABV0@@Z PROC				; pureAppEnd::pureAppEnd, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], OFFSET ??_7pureAppEnd@@6B@
	ret	4
??0pureAppEnd@@QAE@ABV0@@Z ENDP				; pureAppEnd::pureAppEnd
_TEXT	ENDS
PUBLIC	??0pureAppEnd@@QAE@XZ				; pureAppEnd::pureAppEnd
; Function compile flags: /Ogtpy
;	COMDAT ??0pureAppEnd@@QAE@XZ
_TEXT	SEGMENT
??0pureAppEnd@@QAE@XZ PROC				; pureAppEnd::pureAppEnd, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], OFFSET ??_7pureAppEnd@@6B@
	ret	0
??0pureAppEnd@@QAE@XZ ENDP				; pureAppEnd::pureAppEnd
_TEXT	ENDS
PUBLIC	??4pureAppStart@@QAEAAV0@ABV0@@Z		; pureAppStart::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4pureAppStart@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4pureAppStart@@QAEAAV0@ABV0@@Z PROC			; pureAppStart::operator=, COMDAT
; _this$ = ecx
	mov	eax, ecx
	ret	4
??4pureAppStart@@QAEAAV0@ABV0@@Z ENDP			; pureAppStart::operator=
_TEXT	ENDS
PUBLIC	??0pureAppStart@@QAE@ABV0@@Z			; pureAppStart::pureAppStart
; Function compile flags: /Ogtpy
;	COMDAT ??0pureAppStart@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0pureAppStart@@QAE@ABV0@@Z PROC			; pureAppStart::pureAppStart, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], OFFSET ??_7pureAppStart@@6B@
	ret	4
??0pureAppStart@@QAE@ABV0@@Z ENDP			; pureAppStart::pureAppStart
_TEXT	ENDS
PUBLIC	??0pureAppStart@@QAE@XZ				; pureAppStart::pureAppStart
; Function compile flags: /Ogtpy
;	COMDAT ??0pureAppStart@@QAE@XZ
_TEXT	SEGMENT
??0pureAppStart@@QAE@XZ PROC				; pureAppStart::pureAppStart, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], OFFSET ??_7pureAppStart@@6B@
	ret	0
??0pureAppStart@@QAE@XZ ENDP				; pureAppStart::pureAppStart
_TEXT	ENDS
PUBLIC	??4pureAppDeactivate@@QAEAAV0@ABV0@@Z		; pureAppDeactivate::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4pureAppDeactivate@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4pureAppDeactivate@@QAEAAV0@ABV0@@Z PROC		; pureAppDeactivate::operator=, COMDAT
; _this$ = ecx
	mov	eax, ecx
	ret	4
??4pureAppDeactivate@@QAEAAV0@ABV0@@Z ENDP		; pureAppDeactivate::operator=
_TEXT	ENDS
PUBLIC	??0pureAppDeactivate@@QAE@ABV0@@Z		; pureAppDeactivate::pureAppDeactivate
; Function compile flags: /Ogtpy
;	COMDAT ??0pureAppDeactivate@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0pureAppDeactivate@@QAE@ABV0@@Z PROC			; pureAppDeactivate::pureAppDeactivate, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], OFFSET ??_7pureAppDeactivate@@6B@
	ret	4
??0pureAppDeactivate@@QAE@ABV0@@Z ENDP			; pureAppDeactivate::pureAppDeactivate
_TEXT	ENDS
PUBLIC	??0pureAppDeactivate@@QAE@XZ			; pureAppDeactivate::pureAppDeactivate
; Function compile flags: /Ogtpy
;	COMDAT ??0pureAppDeactivate@@QAE@XZ
_TEXT	SEGMENT
??0pureAppDeactivate@@QAE@XZ PROC			; pureAppDeactivate::pureAppDeactivate, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], OFFSET ??_7pureAppDeactivate@@6B@
	ret	0
??0pureAppDeactivate@@QAE@XZ ENDP			; pureAppDeactivate::pureAppDeactivate
_TEXT	ENDS
PUBLIC	??4pureAppActivate@@QAEAAV0@ABV0@@Z		; pureAppActivate::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4pureAppActivate@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4pureAppActivate@@QAEAAV0@ABV0@@Z PROC		; pureAppActivate::operator=, COMDAT
; _this$ = ecx
	mov	eax, ecx
	ret	4
??4pureAppActivate@@QAEAAV0@ABV0@@Z ENDP		; pureAppActivate::operator=
_TEXT	ENDS
PUBLIC	??0pureAppActivate@@QAE@ABV0@@Z			; pureAppActivate::pureAppActivate
; Function compile flags: /Ogtpy
;	COMDAT ??0pureAppActivate@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0pureAppActivate@@QAE@ABV0@@Z PROC			; pureAppActivate::pureAppActivate, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], OFFSET ??_7pureAppActivate@@6B@
	ret	4
??0pureAppActivate@@QAE@ABV0@@Z ENDP			; pureAppActivate::pureAppActivate
_TEXT	ENDS
PUBLIC	??0pureAppActivate@@QAE@XZ			; pureAppActivate::pureAppActivate
; Function compile flags: /Ogtpy
;	COMDAT ??0pureAppActivate@@QAE@XZ
_TEXT	SEGMENT
??0pureAppActivate@@QAE@XZ PROC				; pureAppActivate::pureAppActivate, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], OFFSET ??_7pureAppActivate@@6B@
	ret	0
??0pureAppActivate@@QAE@XZ ENDP				; pureAppActivate::pureAppActivate
_TEXT	ENDS
PUBLIC	??4pureRender@@QAEAAV0@ABV0@@Z			; pureRender::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4pureRender@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4pureRender@@QAEAAV0@ABV0@@Z PROC			; pureRender::operator=, COMDAT
; _this$ = ecx
	mov	eax, ecx
	ret	4
??4pureRender@@QAEAAV0@ABV0@@Z ENDP			; pureRender::operator=
_TEXT	ENDS
PUBLIC	??0pureRender@@QAE@ABV0@@Z			; pureRender::pureRender
; Function compile flags: /Ogtpy
;	COMDAT ??0pureRender@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0pureRender@@QAE@ABV0@@Z PROC				; pureRender::pureRender, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], OFFSET ??_7pureRender@@6B@
	ret	4
??0pureRender@@QAE@ABV0@@Z ENDP				; pureRender::pureRender
_TEXT	ENDS
PUBLIC	??0pureRender@@QAE@XZ				; pureRender::pureRender
; Function compile flags: /Ogtpy
;	COMDAT ??0pureRender@@QAE@XZ
_TEXT	SEGMENT
??0pureRender@@QAE@XZ PROC				; pureRender::pureRender, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], OFFSET ??_7pureRender@@6B@
	ret	0
??0pureRender@@QAE@XZ ENDP				; pureRender::pureRender
_TEXT	ENDS
PUBLIC	??4pureFrame@@QAEAAV0@ABV0@@Z			; pureFrame::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4pureFrame@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4pureFrame@@QAEAAV0@ABV0@@Z PROC			; pureFrame::operator=, COMDAT
; _this$ = ecx
	mov	eax, ecx
	ret	4
??4pureFrame@@QAEAAV0@ABV0@@Z ENDP			; pureFrame::operator=
_TEXT	ENDS
PUBLIC	??0pureFrame@@QAE@ABV0@@Z			; pureFrame::pureFrame
; Function compile flags: /Ogtpy
;	COMDAT ??0pureFrame@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0pureFrame@@QAE@ABV0@@Z PROC				; pureFrame::pureFrame, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], OFFSET ??_7pureFrame@@6B@
	ret	4
??0pureFrame@@QAE@ABV0@@Z ENDP				; pureFrame::pureFrame
_TEXT	ENDS
PUBLIC	??0pureFrame@@QAE@XZ				; pureFrame::pureFrame
; Function compile flags: /Ogtpy
;	COMDAT ??0pureFrame@@QAE@XZ
_TEXT	SEGMENT
??0pureFrame@@QAE@XZ PROC				; pureFrame::pureFrame, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], OFFSET ??_7pureFrame@@6B@
	ret	0
??0pureFrame@@QAE@XZ ENDP				; pureFrame::pureFrame
_TEXT	ENDS
PUBLIC	?Top@CSheduler@@AAEAAUItem@1@XZ			; CSheduler::Top
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\xrsheduler.h
;	COMDAT ?Top@CSheduler@@AAEAAUItem@1@XZ
_TEXT	SEGMENT
?Top@CSheduler@@AAEAAUItem@1@XZ PROC			; CSheduler::Top, COMDAT
; _this$ = ecx

; 38   : 		return Items.front();

	mov	eax, DWORD PTR [ecx+12]

; 39   : 	}

	ret	0
?Top@CSheduler@@AAEAAUItem@1@XZ ENDP			; CSheduler::Top
_TEXT	ENDS
PUBLIC	??4ISheduled@@QAEAAV0@ABV0@@Z			; ISheduled::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4ISheduled@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4ISheduled@@QAEAAV0@ABV0@@Z PROC			; ISheduled::operator=, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	ecx, DWORD PTR ___that$[esp-4]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	ret	4
??4ISheduled@@QAEAAV0@ABV0@@Z ENDP			; ISheduled::operator=
_TEXT	ENDS
PUBLIC	??0ISheduled@@QAE@ABV0@@Z			; ISheduled::ISheduled
; Function compile flags: /Ogtpy
;	COMDAT ??0ISheduled@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0ISheduled@@QAE@ABV0@@Z PROC				; ISheduled::ISheduled, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	ecx, DWORD PTR ___that$[esp-4]
	mov	DWORD PTR [eax], OFFSET ??_7ISheduled@@6B@
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	ret	4
??0ISheduled@@QAE@ABV0@@Z ENDP				; ISheduled::ISheduled
_TEXT	ENDS
PUBLIC	??4IEventReceiver@@QAEAAV0@ABV0@@Z		; IEventReceiver::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4IEventReceiver@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4IEventReceiver@@QAEAAV0@ABV0@@Z PROC			; IEventReceiver::operator=, COMDAT
; _this$ = ecx
	mov	eax, ecx
	ret	4
??4IEventReceiver@@QAEAAV0@ABV0@@Z ENDP			; IEventReceiver::operator=
_TEXT	ENDS
PUBLIC	??0IEventReceiver@@QAE@ABV0@@Z			; IEventReceiver::IEventReceiver
; Function compile flags: /Ogtpy
;	COMDAT ??0IEventReceiver@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0IEventReceiver@@QAE@ABV0@@Z PROC			; IEventReceiver::IEventReceiver, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], OFFSET ??_7IEventReceiver@@6B@
	ret	4
??0IEventReceiver@@QAE@ABV0@@Z ENDP			; IEventReceiver::IEventReceiver
_TEXT	ENDS
PUBLIC	??0IEventReceiver@@QAE@XZ			; IEventReceiver::IEventReceiver
; Function compile flags: /Ogtpy
;	COMDAT ??0IEventReceiver@@QAE@XZ
_TEXT	SEGMENT
??0IEventReceiver@@QAE@XZ PROC				; IEventReceiver::IEventReceiver, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], OFFSET ??_7IEventReceiver@@6B@
	ret	0
??0IEventReceiver@@QAE@XZ ENDP				; IEventReceiver::IEventReceiver
_TEXT	ENDS
PUBLIC	??4CEngineAPI@@QAEAAV0@ABV0@@Z			; CEngineAPI::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4CEngineAPI@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4CEngineAPI@@QAEAAV0@ABV0@@Z PROC			; CEngineAPI::operator=, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, DWORD PTR ___that$[esp]
	push	edi
	mov	eax, ecx
	mov	ecx, 8
	mov	edi, eax
	rep movsd
	pop	edi
	pop	esi
	ret	4
??4CEngineAPI@@QAEAAV0@ABV0@@Z ENDP			; CEngineAPI::operator=
_TEXT	ENDS
PUBLIC	??_I@YGXPAXIHP6EX0@Z@Z				; `vector destructor iterator'
; Function compile flags: /Ogtpy
;	COMDAT ??_I@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT
___f$ = 8						; size = 4
??_I@YGXPAXIHP6EX0@Z@Z PROC				; `vector destructor iterator', COMDAT
; ___t$ = ecx
; ___s$ = ebx
; ___n$ = eax
	push	ebp
	mov	ebp, DWORD PTR ___f$[esp]
	push	esi
	push	edi
	mov	edi, eax
	mov	eax, ebx
	imul	eax, edi
	mov	esi, ecx
	add	esi, eax
	sub	edi, 1
	js	SHORT $LN1@vector@3
$LL2@vector@3:
	sub	esi, ebx
	mov	ecx, esi
	call	ebp
	sub	edi, 1
	jns	SHORT $LL2@vector@3
$LN1@vector@3:
	pop	edi
	pop	esi
	pop	ebp
	ret	4
??_I@YGXPAXIHP6EX0@Z@Z ENDP				; `vector destructor iterator'
_TEXT	ENDS
PUBLIC	??4DLL_Pure@@QAEAAV0@ABV0@@Z			; DLL_Pure::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4DLL_Pure@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4DLL_Pure@@QAEAAV0@ABV0@@Z PROC			; DLL_Pure::operator=, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	ecx, DWORD PTR ___that$[esp-4]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ecx
	ret	4
??4DLL_Pure@@QAEAAV0@ABV0@@Z ENDP			; DLL_Pure::operator=
_TEXT	ENDS
PUBLIC	??0DLL_Pure@@QAE@ABV0@@Z			; DLL_Pure::DLL_Pure
; Function compile flags: /Ogtpy
;	COMDAT ??0DLL_Pure@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0DLL_Pure@@QAE@ABV0@@Z PROC				; DLL_Pure::DLL_Pure, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	ecx, DWORD PTR ___that$[esp-4]
	mov	DWORD PTR [eax], OFFSET ??_7DLL_Pure@@6B@
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ecx
	ret	4
??0DLL_Pure@@QAE@ABV0@@Z ENDP				; DLL_Pure::DLL_Pure
_TEXT	ENDS
PUBLIC	??1DLL_Pure@@UAE@XZ				; DLL_Pure::~DLL_Pure
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\engineapi.h
;	COMDAT ??1DLL_Pure@@UAE@XZ
_TEXT	SEGMENT
??1DLL_Pure@@UAE@XZ PROC				; DLL_Pure::~DLL_Pure, COMDAT
; _this$ = ecx

; 19   : 	virtual ~DLL_Pure()		{};

	mov	DWORD PTR [ecx], OFFSET ??_7DLL_Pure@@6B@
	ret	0
??1DLL_Pure@@UAE@XZ ENDP				; DLL_Pure::~DLL_Pure
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_construct@DLL_Pure@@UAEPAV1@XZ
_TEXT	SEGMENT
?_construct@DLL_Pure@@UAEPAV1@XZ PROC			; DLL_Pure::_construct, COMDAT
; _this$ = ecx

; 18   : 	virtual	DLL_Pure*		_construct		()	{ return this; 	}

	mov	eax, ecx
	ret	0
?_construct@DLL_Pure@@UAEPAV1@XZ ENDP			; DLL_Pure::_construct
_TEXT	ENDS
PUBLIC	??0DLL_Pure@@QAE@XZ				; DLL_Pure::DLL_Pure
; Function compile flags: /Ogtpy
;	COMDAT ??0DLL_Pure@@QAE@XZ
_TEXT	SEGMENT
??0DLL_Pure@@QAE@XZ PROC				; DLL_Pure::DLL_Pure, COMDAT
; _this$ = ecx

; 17   : 	DLL_Pure()				{CLS_ID=0; };

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], OFFSET ??_7DLL_Pure@@6B@
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	ret	0
??0DLL_Pure@@QAE@XZ ENDP				; DLL_Pure::DLL_Pure
_TEXT	ENDS
PUBLIC	??0DLL_Pure@@QAE@PAX@Z				; DLL_Pure::DLL_Pure
; Function compile flags: /Ogtpy
;	COMDAT ??0DLL_Pure@@QAE@PAX@Z
_TEXT	SEGMENT
_params$ = 8						; size = 4
??0DLL_Pure@@QAE@PAX@Z PROC				; DLL_Pure::DLL_Pure, COMDAT
; _this$ = ecx

; 16   : 	DLL_Pure(void *params)	{CLS_ID=0; };

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], OFFSET ??_7DLL_Pure@@6B@
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	ret	4
??0DLL_Pure@@QAE@PAX@Z ENDP				; DLL_Pure::DLL_Pure
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\fastdelegate.h
_TEXT	ENDS
;	COMDAT ?SetMementoFrom@DelegateMemento@fastdelegate@@IAEXABV12@@Z
_TEXT	SEGMENT
?SetMementoFrom@DelegateMemento@fastdelegate@@IAEXABV12@@Z PROC ; fastdelegate::DelegateMemento::SetMementoFrom, COMDAT
; _this$ = ecx
; _right$ = eax

; 646  : 		m_pFunction = right.m_pFunction;

	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx

; 647  : 		m_pthis = right.m_pthis;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 648  : #if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
; 649  : 		m_pStaticFunction = right.m_pStaticFunction;
; 650  : #endif
; 651  : 	}

	ret	0
?SetMementoFrom@DelegateMemento@fastdelegate@@IAEXABV12@@Z ENDP ; fastdelegate::DelegateMemento::SetMementoFrom
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?IsEqual@DelegateMemento@fastdelegate@@QBE_NABV12@@Z
_TEXT	SEGMENT
?IsEqual@DelegateMemento@fastdelegate@@QBE_NABV12@@Z PROC ; fastdelegate::DelegateMemento::IsEqual, COMDAT
; _this$ = ecx
; _x$ = eax

; 603  : 		return m_pthis==x.m_pthis && m_pFunction==x.m_pFunction;

	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN3@IsEqual
	mov	ecx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN3@IsEqual
	mov	eax, 1

; 604  : 	}

	ret	0
$LN3@IsEqual:

; 603  : 		return m_pthis==x.m_pthis && m_pFunction==x.m_pFunction;

	xor	eax, eax

; 604  : 	}

	ret	0
?IsEqual@DelegateMemento@fastdelegate@@QBE_NABV12@@Z ENDP ; fastdelegate::DelegateMemento::IsEqual
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0DelegateMemento@fastdelegate@@QAE@XZ
_TEXT	SEGMENT
??0DelegateMemento@fastdelegate@@QAE@XZ PROC		; fastdelegate::DelegateMemento::DelegateMemento, COMDAT
; _this$ = eax

; 588  : 	DelegateMemento() : m_pthis(0), m_pFunction(0) {};

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	ret	0
??0DelegateMemento@fastdelegate@@QAE@XZ ENDP		; fastdelegate::DelegateMemento::DelegateMemento
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\xrstring.h
_TEXT	ENDS
;	COMDAT ?_dec@shared_str@@IAEXXZ
_TEXT	SEGMENT
?_dec@shared_str@@IAEXXZ PROC				; shared_str::_dec, COMDAT
; _this$ = ecx

; 61   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN1@dec@6
	add	DWORD PTR [eax], -1
	mov	eax, DWORD PTR [ecx]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN1@dec@6
	mov	DWORD PTR [ecx], 0
$LN1@dec@6:
	ret	0
?_dec@shared_str@@IAEXXZ ENDP				; shared_str::_dec
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_uninitialized.h
_TEXT	ENDS
;	COMDAT ?__ucopy_trivial@priv@stlp_std@@YAPAXPBX0PAX@Z
_TEXT	SEGMENT
?__ucopy_trivial@priv@stlp_std@@YAPAXPBX0PAX@Z PROC	; stlp_std::priv::__ucopy_trivial, COMDAT
; ___first$ = ecx
; ___last$ = edx
; ___result$ = eax

; 103  : __ucopy_trivial(const void* __first, const void* __last, void* __result) {

	push	esi
	mov	esi, edx

; 104  :   //dums: this version can use memcpy (__copy_trivial can't)
; 105  :   return (__last == __first) ? __result :
; 106  :     ((char*)memcpy(__result, __first, ((const char*)__last - (const char*)__first))) +
; 107  :     ((const char*)__last - (const char*)__first);

	cmp	esi, ecx
	je	SHORT $LN4@ucopy_triv
	sub	esi, ecx
	push	esi
	push	ecx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	add	eax, esi
$LN4@ucopy_triv:
	pop	esi

; 108  : }

	ret	0
?__ucopy_trivial@priv@stlp_std@@YAPAXPBX0PAX@Z ENDP	; stlp_std::priv::__ucopy_trivial
; Function compile flags: /Ogtpy
; File j:\msvs8\vc\include\new
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT
; __Where$ = eax

; 60   : 	return (_Where);
; 61   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_algobase.h
_TEXT	ENDS
;	COMDAT ?__copy_trivial@priv@stlp_std@@YAPAXPBX0PAX@Z
_TEXT	SEGMENT
?__copy_trivial@priv@stlp_std@@YAPAXPBX0PAX@Z PROC	; stlp_std::priv::__copy_trivial, COMDAT
; ___first$ = edx
; ___last$ = ecx
; ___result$ = eax

; 211  :   size_t __n = (const char*)__last - (const char*)__first;

	sub	ecx, edx
	push	esi
	mov	esi, ecx

; 212  :   return __n ? (void *)((char*)memmove(__result, __first, __n) + __n) : __result;

	je	SHORT $LN4@copy_trivi@2
	push	esi
	push	edx
	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	add	eax, esi
$LN4@copy_trivi@2:
	pop	esi

; 213  : }

	ret	0
?__copy_trivial@priv@stlp_std@@YAPAXPBX0PAX@Z ENDP	; stlp_std::priv::__copy_trivial
; Function compile flags: /Ogtpy
;	COMDAT ??0?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AGXXZP6GXXZP6GXXZ@detail@fastdelegate@@QAE@XZ
_TEXT	SEGMENT
??0?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AGXXZP6GXXZP6GXXZ@detail@fastdelegate@@QAE@XZ PROC ; fastdelegate::detail::ClosurePtr<void (__stdcall fastdelegate::detail::GenericClass::*)(void),void (__stdcall*)(void),void (__stdcall*)(void)>::ClosurePtr<void (__stdcall fastdelegate::detail::GenericClass::*)(void),void (__stdcall*)(void),void (__stdcall*)(void)>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	ret	0
??0?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AGXXZP6GXXZP6GXXZ@detail@fastdelegate@@QAE@XZ ENDP ; fastdelegate::detail::ClosurePtr<void (__stdcall fastdelegate::detail::GenericClass::*)(void),void (__stdcall*)(void),void (__stdcall*)(void)>::ClosurePtr<void (__stdcall fastdelegate::detail::GenericClass::*)(void),void (__stdcall*)(void),void (__stdcall*)(void)>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\fastdelegate.h
_TEXT	ENDS
;	COMDAT ??$CopyFrom@V?$FastDelegate0@X@fastdelegate@@@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AGXXZP6GXXZP6GXXZ@detail@fastdelegate@@QAEXPAV?$FastDelegate0@X@2@ABVDelegateMemento@2@@Z
_TEXT	SEGMENT
??$CopyFrom@V?$FastDelegate0@X@fastdelegate@@@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AGXXZP6GXXZP6GXXZ@detail@fastdelegate@@QAEXPAV?$FastDelegate0@X@2@ABVDelegateMemento@2@@Z PROC ; fastdelegate::detail::ClosurePtr<void (__stdcall fastdelegate::detail::GenericClass::*)(void),void (__stdcall*)(void),void (__stdcall*)(void)>::CopyFrom<fastdelegate::FastDelegate0<void> >, COMDAT
; _this$ = ecx
; _right$ = eax

; 769  : 		SetMementoFrom(right);

	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 770  : 	}

	ret	0
??$CopyFrom@V?$FastDelegate0@X@fastdelegate@@@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AGXXZP6GXXZP6GXXZ@detail@fastdelegate@@QAEXPAV?$FastDelegate0@X@2@ABVDelegateMemento@2@@Z ENDP ; fastdelegate::detail::ClosurePtr<void (__stdcall fastdelegate::detail::GenericClass::*)(void),void (__stdcall*)(void),void (__stdcall*)(void)>::CopyFrom<fastdelegate::FastDelegate0<void> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??8?$FastDelegate0@X@fastdelegate@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$FastDelegate0@X@fastdelegate@@QBE_NABV01@@Z PROC	; fastdelegate::FastDelegate0<void>::operator==, COMDAT
; _this$ = ecx
; _x$ = eax

; 882  : 		return m_Closure.IsEqual(x.m_Closure);	}

	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN5@operator@33
	mov	ecx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN5@operator@33
	mov	eax, 1
	ret	0
$LN5@operator@33:
	xor	eax, eax
	ret	0
??8?$FastDelegate0@X@fastdelegate@@QBE_NABV01@@Z ENDP	; fastdelegate::FastDelegate0<void>::operator==
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4?$FastDelegate0@X@fastdelegate@@QAEXABV01@@Z
_TEXT	SEGMENT
??4?$FastDelegate0@X@fastdelegate@@QAEXABV01@@Z PROC	; fastdelegate::FastDelegate0<void>::operator=, COMDAT
; _this$ = ecx
; _x$ = eax

; 880  : 		m_Closure.CopyFrom(this, x.m_Closure); }

	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	ret	0
??4?$FastDelegate0@X@fastdelegate@@QAEXABV01@@Z ENDP	; fastdelegate::FastDelegate0<void>::operator=
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_algobase.h
_TEXT	ENDS
;	COMDAT ??$__copy@PAV?$FastDelegate0@X@fastdelegate@@PAV12@H@priv@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PAV23@00ABUrandom_access_iterator_tag@1@PAH@Z
_TEXT	SEGMENT
??$__copy@PAV?$FastDelegate0@X@fastdelegate@@PAV12@H@priv@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PAV23@00ABUrandom_access_iterator_tag@1@PAH@Z PROC ; stlp_std::priv::__copy<fastdelegate::FastDelegate0<void> *,fastdelegate::FastDelegate0<void> *,int>, COMDAT
; ___first$ = ecx
; ___last$ = edx
; ___result$ = eax

; 201  :   for (_Distance __n = __last - __first; __n > 0; --__n) {

	sub	edx, ecx
	sar	edx, 3
	test	edx, edx
	jle	SHORT $LN1@copy@9
	push	esi
	npad	6
$LL3@copy@9:

; 202  :     *__result = *__first;

	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	sub	edx, 1

; 203  :     ++__first;

	add	ecx, 8

; 204  :     ++__result;

	add	eax, 8
	test	edx, edx
	jg	SHORT $LL3@copy@9
	pop	esi
$LN1@copy@9:

; 205  :   }
; 206  :   return __result;
; 207  : }

	ret	0
??$__copy@PAV?$FastDelegate0@X@fastdelegate@@PAV12@H@priv@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PAV23@00ABUrandom_access_iterator_tag@1@PAH@Z ENDP ; stlp_std::priv::__copy<fastdelegate::FastDelegate0<void> *,fastdelegate::FastDelegate0<void> *,int>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_construct.h
_TEXT	ENDS
;	COMDAT ??$__destroy_range@V?$reverse_iterator@PAV?$FastDelegate0@X@fastdelegate@@@stlp_std@@V?$FastDelegate0@X@fastdelegate@@@stlp_std@@YAXV?$reverse_iterator@PAV?$FastDelegate0@X@fastdelegate@@@0@0PAV?$FastDelegate0@X@fastdelegate@@@Z
_TEXT	SEGMENT
___first$ = 8						; size = 4
___last$ = 12						; size = 4
??$__destroy_range@V?$reverse_iterator@PAV?$FastDelegate0@X@fastdelegate@@@stlp_std@@V?$FastDelegate0@X@fastdelegate@@@stlp_std@@YAXV?$reverse_iterator@PAV?$FastDelegate0@X@fastdelegate@@@0@0PAV?$FastDelegate0@X@fastdelegate@@@Z PROC ; stlp_std::__destroy_range<stlp_std::reverse_iterator<fastdelegate::FastDelegate0<void> *>,fastdelegate::FastDelegate0<void> >, COMDAT

; 175  :   typedef typename __type_traits<_Tp>::has_trivial_destructor _Trivial_destructor;
; 176  :   __destroy_range_aux(__first, __last, __ptr, _Trivial_destructor());
; 177  : }

	ret	0
??$__destroy_range@V?$reverse_iterator@PAV?$FastDelegate0@X@fastdelegate@@@stlp_std@@V?$FastDelegate0@X@fastdelegate@@@stlp_std@@YAXV?$reverse_iterator@PAV?$FastDelegate0@X@fastdelegate@@@0@0PAV?$FastDelegate0@X@fastdelegate@@@Z ENDP ; stlp_std::__destroy_range<stlp_std::reverse_iterator<fastdelegate::FastDelegate0<void> *>,fastdelegate::FastDelegate0<void> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$__destroy_range@V?$reverse_iterator@PAU_REG_INFO@@@stlp_std@@U_REG_INFO@@@stlp_std@@YAXV?$reverse_iterator@PAU_REG_INFO@@@0@0PAU_REG_INFO@@@Z
_TEXT	SEGMENT
___first$ = 8						; size = 4
___last$ = 12						; size = 4
??$__destroy_range@V?$reverse_iterator@PAU_REG_INFO@@@stlp_std@@U_REG_INFO@@@stlp_std@@YAXV?$reverse_iterator@PAU_REG_INFO@@@0@0PAU_REG_INFO@@@Z PROC ; stlp_std::__destroy_range<stlp_std::reverse_iterator<_REG_INFO *>,_REG_INFO>, COMDAT

; 175  :   typedef typename __type_traits<_Tp>::has_trivial_destructor _Trivial_destructor;
; 176  :   __destroy_range_aux(__first, __last, __ptr, _Trivial_destructor());
; 177  : }

	ret	0
??$__destroy_range@V?$reverse_iterator@PAU_REG_INFO@@@stlp_std@@U_REG_INFO@@@stlp_std@@YAXV?$reverse_iterator@PAU_REG_INFO@@@0@0PAU_REG_INFO@@@Z ENDP ; stlp_std::__destroy_range<stlp_std::reverse_iterator<_REG_INFO *>,_REG_INFO>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$__destroy_range@V?$reverse_iterator@PAUItemReg@CSheduler@@@stlp_std@@UItemReg@CSheduler@@@stlp_std@@YAXV?$reverse_iterator@PAUItemReg@CSheduler@@@0@0PAUItemReg@CSheduler@@@Z
_TEXT	SEGMENT
___first$ = 8						; size = 4
___last$ = 12						; size = 4
??$__destroy_range@V?$reverse_iterator@PAUItemReg@CSheduler@@@stlp_std@@UItemReg@CSheduler@@@stlp_std@@YAXV?$reverse_iterator@PAUItemReg@CSheduler@@@0@0PAUItemReg@CSheduler@@@Z PROC ; stlp_std::__destroy_range<stlp_std::reverse_iterator<CSheduler::ItemReg *>,CSheduler::ItemReg>, COMDAT

; 175  :   typedef typename __type_traits<_Tp>::has_trivial_destructor _Trivial_destructor;
; 176  :   __destroy_range_aux(__first, __last, __ptr, _Trivial_destructor());
; 177  : }

	ret	0
??$__destroy_range@V?$reverse_iterator@PAUItemReg@CSheduler@@@stlp_std@@UItemReg@CSheduler@@@stlp_std@@YAXV?$reverse_iterator@PAUItemReg@CSheduler@@@0@0PAUItemReg@CSheduler@@@Z ENDP ; stlp_std::__destroy_range<stlp_std::reverse_iterator<CSheduler::ItemReg *>,CSheduler::ItemReg>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$__destroy_range@V?$reverse_iterator@PAUDeferred@CEventAPI@@@stlp_std@@UDeferred@CEventAPI@@@stlp_std@@YAXV?$reverse_iterator@PAUDeferred@CEventAPI@@@0@0PAUDeferred@CEventAPI@@@Z
_TEXT	SEGMENT
___first$ = 8						; size = 4
___last$ = 12						; size = 4
??$__destroy_range@V?$reverse_iterator@PAUDeferred@CEventAPI@@@stlp_std@@UDeferred@CEventAPI@@@stlp_std@@YAXV?$reverse_iterator@PAUDeferred@CEventAPI@@@0@0PAUDeferred@CEventAPI@@@Z PROC ; stlp_std::__destroy_range<stlp_std::reverse_iterator<CEventAPI::Deferred *>,CEventAPI::Deferred>, COMDAT

; 175  :   typedef typename __type_traits<_Tp>::has_trivial_destructor _Trivial_destructor;
; 176  :   __destroy_range_aux(__first, __last, __ptr, _Trivial_destructor());
; 177  : }

	ret	0
??$__destroy_range@V?$reverse_iterator@PAUDeferred@CEventAPI@@@stlp_std@@UDeferred@CEventAPI@@@stlp_std@@YAXV?$reverse_iterator@PAUDeferred@CEventAPI@@@0@0PAUDeferred@CEventAPI@@@Z ENDP ; stlp_std::__destroy_range<stlp_std::reverse_iterator<CEventAPI::Deferred *>,CEventAPI::Deferred>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$__destroy_range@V?$reverse_iterator@PAPAX@stlp_std@@PAX@stlp_std@@YAXV?$reverse_iterator@PAPAX@0@0PAPAX@Z
_TEXT	SEGMENT
___first$ = 8						; size = 4
___last$ = 12						; size = 4
??$__destroy_range@V?$reverse_iterator@PAPAX@stlp_std@@PAX@stlp_std@@YAXV?$reverse_iterator@PAPAX@0@0PAPAX@Z PROC ; stlp_std::__destroy_range<stlp_std::reverse_iterator<void * *>,void *>, COMDAT

; 175  :   typedef typename __type_traits<_Tp>::has_trivial_destructor _Trivial_destructor;
; 176  :   __destroy_range_aux(__first, __last, __ptr, _Trivial_destructor());
; 177  : }

	ret	0
??$__destroy_range@V?$reverse_iterator@PAPAX@stlp_std@@PAX@stlp_std@@YAXV?$reverse_iterator@PAPAX@0@0PAPAX@Z ENDP ; stlp_std::__destroy_range<stlp_std::reverse_iterator<void * *>,void *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_algobase.c
_TEXT	ENDS
;	COMDAT ??$__find@PAV?$FastDelegate0@X@fastdelegate@@V12@@priv@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PAV23@0ABV23@ABUrandom_access_iterator_tag@1@@Z
_TEXT	SEGMENT
??$__find@PAV?$FastDelegate0@X@fastdelegate@@V12@@priv@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PAV23@0ABV23@ABUrandom_access_iterator_tag@1@@Z PROC ; stlp_std::priv::__find<fastdelegate::FastDelegate0<void> *,fastdelegate::FastDelegate0<void> >, COMDAT
; ___first$ = eax
; ___last$ = edi
; ___val$ = esi

; 108  :   _STLP_DIFFERENCE_TYPE(_RandomAccessIter) __trip_count = (__last - __first) >> 2;

	mov	ecx, edi
	sub	ecx, eax
	sar	ecx, 5

; 109  : 
; 110  :   for ( ; __trip_count > 0 ; --__trip_count) {

	test	ecx, ecx
	push	ebx
	jle	SHORT $LN14@find@6
	mov	edx, DWORD PTR [esi]
	npad	2
$LL16@find@6:

; 111  :     if (*__first == __val) return __first;

	cmp	DWORD PTR [eax], edx
	jne	SHORT $LN23@find@6
	mov	ebx, DWORD PTR [eax+4]
	cmp	ebx, DWORD PTR [esi+4]
	je	SHORT $LN8@find@6
$LN23@find@6:

; 112  :     ++__first;

	add	eax, 8

; 113  : 
; 114  :     if (*__first == __val) return __first;

	cmp	DWORD PTR [eax], edx
	jne	SHORT $LN29@find@6
	mov	ebx, DWORD PTR [eax+4]
	cmp	ebx, DWORD PTR [esi+4]
	je	SHORT $LN8@find@6
$LN29@find@6:

; 115  :     ++__first;

	add	eax, 8

; 116  : 
; 117  :     if (*__first == __val) return __first;

	cmp	DWORD PTR [eax], edx
	jne	SHORT $LN35@find@6
	mov	ebx, DWORD PTR [eax+4]
	cmp	ebx, DWORD PTR [esi+4]
	je	SHORT $LN8@find@6
$LN35@find@6:

; 118  :     ++__first;

	add	eax, 8

; 119  : 
; 120  :     if (*__first == __val) return __first;

	cmp	DWORD PTR [eax], edx
	jne	SHORT $LN41@find@6
	mov	ebx, DWORD PTR [eax+4]
	cmp	ebx, DWORD PTR [esi+4]
	je	SHORT $LN8@find@6
$LN41@find@6:
	sub	ecx, 1

; 121  :     ++__first;

	add	eax, 8
	test	ecx, ecx
	jg	SHORT $LL16@find@6
$LN14@find@6:

; 122  :   }
; 123  : 
; 124  :   switch (__last - __first) {

	mov	ecx, edi
	sub	ecx, eax
	sar	ecx, 3
	sub	ecx, 1
	je	SHORT $LN3@find@6
	sub	ecx, 1
	je	SHORT $LN5@find@6
	sub	ecx, 1
	jne	SHORT $LN2@find@6

; 125  :   case 3:
; 126  :     if (*__first == __val) return __first;

	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR [esi]
	jne	SHORT $LN6@find@6
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [esi+4]
	je	SHORT $LN8@find@6
$LN6@find@6:

; 127  :     ++__first;

	add	eax, 8
$LN5@find@6:

; 128  :   case 2:
; 129  :     if (*__first == __val) return __first;

	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR [esi]
	jne	SHORT $LN4@find@6
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [esi+4]
	je	SHORT $LN8@find@6
$LN4@find@6:

; 130  :     ++__first;

	add	eax, 8
$LN3@find@6:

; 131  :   case 1:
; 132  :     if (*__first == __val) return __first;

	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR [esi]
	jne	SHORT $LN2@find@6
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [esi+4]
	je	SHORT $LN8@find@6
$LN2@find@6:

; 133  :     //++__first;
; 134  :   case 0:
; 135  :   default:
; 136  :     return __last;

	mov	eax, edi
$LN8@find@6:
	pop	ebx

; 137  :   }
; 138  : }

	ret	0
??$__find@PAV?$FastDelegate0@X@fastdelegate@@V12@@priv@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PAV23@0ABV23@ABUrandom_access_iterator_tag@1@@Z ENDP ; stlp_std::priv::__find<fastdelegate::FastDelegate0<void> *,fastdelegate::FastDelegate0<void> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_algobase.h
_TEXT	ENDS
;	COMDAT ??$__copy_ptrs@PBU_REG_INFO@@PAU1@@priv@stlp_std@@YAPAU_REG_INFO@@PBU2@0PAU2@ABU__true_type@1@@Z
_TEXT	SEGMENT
??$__copy_ptrs@PBU_REG_INFO@@PAU1@@priv@stlp_std@@YAPAU_REG_INFO@@PBU2@0PAU2@ABU__true_type@1@@Z PROC ; stlp_std::priv::__copy_ptrs<_REG_INFO const *,_REG_INFO *>, COMDAT
; ___first$ = edx
; ___last$ = ecx
; ___result$ = eax

; 255  :   // we know they all pointers, so this cast is OK
; 256  :   //  return (_OutputIter)__copy_trivial(&(*__first), &(*__last), &(*__result));
; 257  :   return (_OutputIter)__copy_trivial(__first, __last, __result);

	sub	ecx, edx
	push	esi
	mov	esi, ecx
	je	SHORT $LN6@copy_ptrs@33
	push	esi
	push	edx
	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	add	eax, esi
$LN6@copy_ptrs@33:
	pop	esi

; 258  : }

	ret	0
??$__copy_ptrs@PBU_REG_INFO@@PAU1@@priv@stlp_std@@YAPAU_REG_INFO@@PBU2@0PAU2@ABU__true_type@1@@Z ENDP ; stlp_std::priv::__copy_ptrs<_REG_INFO const *,_REG_INFO *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$__copy_ptrs@PBUItemReg@CSheduler@@PAU12@@priv@stlp_std@@YAPAUItemReg@CSheduler@@PBU23@0PAU23@ABU__true_type@1@@Z
_TEXT	SEGMENT
??$__copy_ptrs@PBUItemReg@CSheduler@@PAU12@@priv@stlp_std@@YAPAUItemReg@CSheduler@@PBU23@0PAU23@ABU__true_type@1@@Z PROC ; stlp_std::priv::__copy_ptrs<CSheduler::ItemReg const *,CSheduler::ItemReg *>, COMDAT
; ___first$ = edx
; ___last$ = ecx
; ___result$ = eax

; 255  :   // we know they all pointers, so this cast is OK
; 256  :   //  return (_OutputIter)__copy_trivial(&(*__first), &(*__last), &(*__result));
; 257  :   return (_OutputIter)__copy_trivial(__first, __last, __result);

	sub	ecx, edx
	push	esi
	mov	esi, ecx
	je	SHORT $LN6@copy_ptrs@34
	push	esi
	push	edx
	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	add	eax, esi
$LN6@copy_ptrs@34:
	pop	esi

; 258  : }

	ret	0
??$__copy_ptrs@PBUItemReg@CSheduler@@PAU12@@priv@stlp_std@@YAPAUItemReg@CSheduler@@PBU23@0PAU23@ABU__true_type@1@@Z ENDP ; stlp_std::priv::__copy_ptrs<CSheduler::ItemReg const *,CSheduler::ItemReg *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_uninitialized.h
_TEXT	ENDS
;	COMDAT ??$__ucopy_ptrs@PBUDeferred@CEventAPI@@PAU12@@priv@stlp_std@@YAPAUDeferred@CEventAPI@@PBU23@0PAU23@ABU__true_type@1@@Z
_TEXT	SEGMENT
??$__ucopy_ptrs@PBUDeferred@CEventAPI@@PAU12@@priv@stlp_std@@YAPAUDeferred@CEventAPI@@PBU23@0PAU23@ABU__true_type@1@@Z PROC ; stlp_std::priv::__ucopy_ptrs<CEventAPI::Deferred const *,CEventAPI::Deferred *>, COMDAT
; ___first$ = ecx
; ___last$ = edx
; ___result$ = eax

; 117  :                                 const __true_type& /*TrivialUCopy*/) {

	push	esi
	mov	esi, edx

; 118  :   // we know they all pointers, so this cast is OK
; 119  :   //  return (_OutputIter)__copy_trivial(&(*__first), &(*__last), &(*__result));
; 120  :   return (_OutputIter)__ucopy_trivial(__first, __last, __result);

	cmp	esi, ecx
	je	SHORT $LN6@ucopy_ptrs@22
	sub	esi, ecx
	push	esi
	push	ecx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	add	eax, esi
$LN6@ucopy_ptrs@22:
	pop	esi

; 121  : }

	ret	0
??$__ucopy_ptrs@PBUDeferred@CEventAPI@@PAU12@@priv@stlp_std@@YAPAUDeferred@CEventAPI@@PBU23@0PAU23@ABU__true_type@1@@Z ENDP ; stlp_std::priv::__ucopy_ptrs<CEventAPI::Deferred const *,CEventAPI::Deferred *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_algobase.h
_TEXT	ENDS
;	COMDAT ??$__copy_ptrs@PBUDeferred@CEventAPI@@PAU12@@priv@stlp_std@@YAPAUDeferred@CEventAPI@@PBU23@0PAU23@ABU__true_type@1@@Z
_TEXT	SEGMENT
??$__copy_ptrs@PBUDeferred@CEventAPI@@PAU12@@priv@stlp_std@@YAPAUDeferred@CEventAPI@@PBU23@0PAU23@ABU__true_type@1@@Z PROC ; stlp_std::priv::__copy_ptrs<CEventAPI::Deferred const *,CEventAPI::Deferred *>, COMDAT
; ___first$ = edx
; ___last$ = ecx
; ___result$ = eax

; 255  :   // we know they all pointers, so this cast is OK
; 256  :   //  return (_OutputIter)__copy_trivial(&(*__first), &(*__last), &(*__result));
; 257  :   return (_OutputIter)__copy_trivial(__first, __last, __result);

	sub	ecx, edx
	push	esi
	mov	esi, ecx
	je	SHORT $LN6@copy_ptrs@35
	push	esi
	push	edx
	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	add	eax, esi
$LN6@copy_ptrs@35:
	pop	esi

; 258  : }

	ret	0
??$__copy_ptrs@PBUDeferred@CEventAPI@@PAU12@@priv@stlp_std@@YAPAUDeferred@CEventAPI@@PBU23@0PAU23@ABU__true_type@1@@Z ENDP ; stlp_std::priv::__copy_ptrs<CEventAPI::Deferred const *,CEventAPI::Deferred *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_uninitialized.h
_TEXT	ENDS
;	COMDAT ??$__ucopy_ptrs@PBQAXPAPAX@priv@stlp_std@@YAPAPAXPBQAX0PAPAXABU__true_type@1@@Z
_TEXT	SEGMENT
??$__ucopy_ptrs@PBQAXPAPAX@priv@stlp_std@@YAPAPAXPBQAX0PAPAXABU__true_type@1@@Z PROC ; stlp_std::priv::__ucopy_ptrs<void * const *,void * *>, COMDAT
; ___first$ = ecx
; ___last$ = edx
; ___result$ = eax

; 117  :                                 const __true_type& /*TrivialUCopy*/) {

	push	esi
	mov	esi, edx

; 118  :   // we know they all pointers, so this cast is OK
; 119  :   //  return (_OutputIter)__copy_trivial(&(*__first), &(*__last), &(*__result));
; 120  :   return (_OutputIter)__ucopy_trivial(__first, __last, __result);

	cmp	esi, ecx
	je	SHORT $LN6@ucopy_ptrs@23
	sub	esi, ecx
	push	esi
	push	ecx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	add	eax, esi
$LN6@ucopy_ptrs@23:
	pop	esi

; 121  : }

	ret	0
??$__ucopy_ptrs@PBQAXPAPAX@priv@stlp_std@@YAPAPAXPBQAX0PAPAXABU__true_type@1@@Z ENDP ; stlp_std::priv::__ucopy_ptrs<void * const *,void * *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_algobase.h
_TEXT	ENDS
;	COMDAT ??$__copy_ptrs@PBQAXPAPAX@priv@stlp_std@@YAPAPAXPBQAX0PAPAXABU__true_type@1@@Z
_TEXT	SEGMENT
??$__copy_ptrs@PBQAXPAPAX@priv@stlp_std@@YAPAPAXPBQAX0PAPAXABU__true_type@1@@Z PROC ; stlp_std::priv::__copy_ptrs<void * const *,void * *>, COMDAT
; ___first$ = edx
; ___last$ = ecx
; ___result$ = eax

; 255  :   // we know they all pointers, so this cast is OK
; 256  :   //  return (_OutputIter)__copy_trivial(&(*__first), &(*__last), &(*__result));
; 257  :   return (_OutputIter)__copy_trivial(__first, __last, __result);

	sub	ecx, edx
	push	esi
	mov	esi, ecx
	je	SHORT $LN6@copy_ptrs@36
	push	esi
	push	edx
	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	add	eax, esi
$LN6@copy_ptrs@36:
	pop	esi

; 258  : }

	ret	0
??$__copy_ptrs@PBQAXPAPAX@priv@stlp_std@@YAPAPAXPBQAX0PAPAXABU__true_type@1@@Z ENDP ; stlp_std::priv::__copy_ptrs<void * const *,void * *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$__copy_ptrs@PAV?$FastDelegate0@X@fastdelegate@@PAV12@@priv@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PAV23@00ABU__false_type@1@@Z
_TEXT	SEGMENT
??$__copy_ptrs@PAV?$FastDelegate0@X@fastdelegate@@PAV12@@priv@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PAV23@00ABU__false_type@1@@Z PROC ; stlp_std::priv::__copy_ptrs<fastdelegate::FastDelegate0<void> *,fastdelegate::FastDelegate0<void> *>, COMDAT
; ___first$ = edx
; ___last$ = ecx
; ___result$ = eax

; 250  :   return __copy(__first, __last, __result, random_access_iterator_tag(), (ptrdiff_t*)0);

	sub	ecx, edx
	sar	ecx, 3
	test	ecx, ecx
	jle	SHORT $LN3@copy_ptrs@37
	sub	edx, eax
	push	esi
	npad	4
$LL5@copy_ptrs@37:
	mov	esi, DWORD PTR [edx+eax+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [edx+eax]
	mov	DWORD PTR [eax], esi
	sub	ecx, 1
	add	eax, 8
	test	ecx, ecx
	jg	SHORT $LL5@copy_ptrs@37
	pop	esi
$LN3@copy_ptrs@37:

; 251  : }

	ret	0
??$__copy_ptrs@PAV?$FastDelegate0@X@fastdelegate@@PAV12@@priv@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PAV23@00ABU__false_type@1@@Z ENDP ; stlp_std::priv::__copy_ptrs<fastdelegate::FastDelegate0<void> *,fastdelegate::FastDelegate0<void> *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_uninitialized.h
_TEXT	ENDS
;	COMDAT ??$__ucopy_ptrs@PBU_REG_INFO@@PAU1@@priv@stlp_std@@YAPAU_REG_INFO@@PBU2@0PAU2@ABU__true_type@1@@Z
_TEXT	SEGMENT
??$__ucopy_ptrs@PBU_REG_INFO@@PAU1@@priv@stlp_std@@YAPAU_REG_INFO@@PBU2@0PAU2@ABU__true_type@1@@Z PROC ; stlp_std::priv::__ucopy_ptrs<_REG_INFO const *,_REG_INFO *>, COMDAT
; ___first$ = ecx
; ___last$ = edx
; ___result$ = eax

; 117  :                                 const __true_type& /*TrivialUCopy*/) {

	push	esi
	mov	esi, edx

; 118  :   // we know they all pointers, so this cast is OK
; 119  :   //  return (_OutputIter)__copy_trivial(&(*__first), &(*__last), &(*__result));
; 120  :   return (_OutputIter)__ucopy_trivial(__first, __last, __result);

	cmp	esi, ecx
	je	SHORT $LN6@ucopy_ptrs@24
	sub	esi, ecx
	push	esi
	push	ecx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	add	eax, esi
$LN6@ucopy_ptrs@24:
	pop	esi

; 121  : }

	ret	0
??$__ucopy_ptrs@PBU_REG_INFO@@PAU1@@priv@stlp_std@@YAPAU_REG_INFO@@PBU2@0PAU2@ABU__true_type@1@@Z ENDP ; stlp_std::priv::__ucopy_ptrs<_REG_INFO const *,_REG_INFO *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$__ucopy_ptrs@PBUItemReg@CSheduler@@PAU12@@priv@stlp_std@@YAPAUItemReg@CSheduler@@PBU23@0PAU23@ABU__true_type@1@@Z
_TEXT	SEGMENT
??$__ucopy_ptrs@PBUItemReg@CSheduler@@PAU12@@priv@stlp_std@@YAPAUItemReg@CSheduler@@PBU23@0PAU23@ABU__true_type@1@@Z PROC ; stlp_std::priv::__ucopy_ptrs<CSheduler::ItemReg const *,CSheduler::ItemReg *>, COMDAT
; ___first$ = ecx
; ___last$ = edx
; ___result$ = eax

; 117  :                                 const __true_type& /*TrivialUCopy*/) {

	push	esi
	mov	esi, edx

; 118  :   // we know they all pointers, so this cast is OK
; 119  :   //  return (_OutputIter)__copy_trivial(&(*__first), &(*__last), &(*__result));
; 120  :   return (_OutputIter)__ucopy_trivial(__first, __last, __result);

	cmp	esi, ecx
	je	SHORT $LN6@ucopy_ptrs@25
	sub	esi, ecx
	push	esi
	push	ecx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	add	eax, esi
$LN6@ucopy_ptrs@25:
	pop	esi

; 121  : }

	ret	0
??$__ucopy_ptrs@PBUItemReg@CSheduler@@PAU12@@priv@stlp_std@@YAPAUItemReg@CSheduler@@PBU23@0PAU23@ABU__true_type@1@@Z ENDP ; stlp_std::priv::__ucopy_ptrs<CSheduler::ItemReg const *,CSheduler::ItemReg *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_construct.h
_TEXT	ENDS
;	COMDAT ??$_Destroy_Range@V?$reverse_iterator@PAV?$FastDelegate0@X@fastdelegate@@@stlp_std@@@stlp_std@@YAXV?$reverse_iterator@PAV?$FastDelegate0@X@fastdelegate@@@0@0@Z
_TEXT	SEGMENT
___first$ = 8						; size = 4
___last$ = 12						; size = 4
??$_Destroy_Range@V?$reverse_iterator@PAV?$FastDelegate0@X@fastdelegate@@@stlp_std@@@stlp_std@@YAXV?$reverse_iterator@PAV?$FastDelegate0@X@fastdelegate@@@0@0@Z PROC ; stlp_std::_Destroy_Range<stlp_std::reverse_iterator<fastdelegate::FastDelegate0<void> *> >, COMDAT

; 181  :   __destroy_range(__first, __last, _STLP_VALUE_TYPE(__first, _ForwardIterator));
; 182  : }

	ret	0
??$_Destroy_Range@V?$reverse_iterator@PAV?$FastDelegate0@X@fastdelegate@@@stlp_std@@@stlp_std@@YAXV?$reverse_iterator@PAV?$FastDelegate0@X@fastdelegate@@@0@0@Z ENDP ; stlp_std::_Destroy_Range<stlp_std::reverse_iterator<fastdelegate::FastDelegate0<void> *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_Range@V?$reverse_iterator@PAU_REG_INFO@@@stlp_std@@@stlp_std@@YAXV?$reverse_iterator@PAU_REG_INFO@@@0@0@Z
_TEXT	SEGMENT
___first$ = 8						; size = 4
___last$ = 12						; size = 4
??$_Destroy_Range@V?$reverse_iterator@PAU_REG_INFO@@@stlp_std@@@stlp_std@@YAXV?$reverse_iterator@PAU_REG_INFO@@@0@0@Z PROC ; stlp_std::_Destroy_Range<stlp_std::reverse_iterator<_REG_INFO *> >, COMDAT

; 181  :   __destroy_range(__first, __last, _STLP_VALUE_TYPE(__first, _ForwardIterator));
; 182  : }

	ret	0
??$_Destroy_Range@V?$reverse_iterator@PAU_REG_INFO@@@stlp_std@@@stlp_std@@YAXV?$reverse_iterator@PAU_REG_INFO@@@0@0@Z ENDP ; stlp_std::_Destroy_Range<stlp_std::reverse_iterator<_REG_INFO *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_Range@V?$reverse_iterator@PAUItemReg@CSheduler@@@stlp_std@@@stlp_std@@YAXV?$reverse_iterator@PAUItemReg@CSheduler@@@0@0@Z
_TEXT	SEGMENT
___first$ = 8						; size = 4
___last$ = 12						; size = 4
??$_Destroy_Range@V?$reverse_iterator@PAUItemReg@CSheduler@@@stlp_std@@@stlp_std@@YAXV?$reverse_iterator@PAUItemReg@CSheduler@@@0@0@Z PROC ; stlp_std::_Destroy_Range<stlp_std::reverse_iterator<CSheduler::ItemReg *> >, COMDAT

; 181  :   __destroy_range(__first, __last, _STLP_VALUE_TYPE(__first, _ForwardIterator));
; 182  : }

	ret	0
??$_Destroy_Range@V?$reverse_iterator@PAUItemReg@CSheduler@@@stlp_std@@@stlp_std@@YAXV?$reverse_iterator@PAUItemReg@CSheduler@@@0@0@Z ENDP ; stlp_std::_Destroy_Range<stlp_std::reverse_iterator<CSheduler::ItemReg *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_Range@V?$reverse_iterator@PAUDeferred@CEventAPI@@@stlp_std@@@stlp_std@@YAXV?$reverse_iterator@PAUDeferred@CEventAPI@@@0@0@Z
_TEXT	SEGMENT
___first$ = 8						; size = 4
___last$ = 12						; size = 4
??$_Destroy_Range@V?$reverse_iterator@PAUDeferred@CEventAPI@@@stlp_std@@@stlp_std@@YAXV?$reverse_iterator@PAUDeferred@CEventAPI@@@0@0@Z PROC ; stlp_std::_Destroy_Range<stlp_std::reverse_iterator<CEventAPI::Deferred *> >, COMDAT

; 181  :   __destroy_range(__first, __last, _STLP_VALUE_TYPE(__first, _ForwardIterator));
; 182  : }

	ret	0
??$_Destroy_Range@V?$reverse_iterator@PAUDeferred@CEventAPI@@@stlp_std@@@stlp_std@@YAXV?$reverse_iterator@PAUDeferred@CEventAPI@@@0@0@Z ENDP ; stlp_std::_Destroy_Range<stlp_std::reverse_iterator<CEventAPI::Deferred *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_Range@V?$reverse_iterator@PAPAX@stlp_std@@@stlp_std@@YAXV?$reverse_iterator@PAPAX@0@0@Z
_TEXT	SEGMENT
___first$ = 8						; size = 4
___last$ = 12						; size = 4
??$_Destroy_Range@V?$reverse_iterator@PAPAX@stlp_std@@@stlp_std@@YAXV?$reverse_iterator@PAPAX@0@0@Z PROC ; stlp_std::_Destroy_Range<stlp_std::reverse_iterator<void * *> >, COMDAT

; 181  :   __destroy_range(__first, __last, _STLP_VALUE_TYPE(__first, _ForwardIterator));
; 182  : }

	ret	0
??$_Destroy_Range@V?$reverse_iterator@PAPAX@stlp_std@@@stlp_std@@YAXV?$reverse_iterator@PAPAX@0@0@Z ENDP ; stlp_std::_Destroy_Range<stlp_std::reverse_iterator<void * *> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_algobase.c
_TEXT	ENDS
;	COMDAT ??$find@PAV?$FastDelegate0@X@fastdelegate@@V12@@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PAV12@0ABV12@@Z
_TEXT	SEGMENT
??$find@PAV?$FastDelegate0@X@fastdelegate@@V12@@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PAV12@0ABV12@@Z PROC ; stlp_std::find<fastdelegate::FastDelegate0<void> *,fastdelegate::FastDelegate0<void> >, COMDAT
; ___first$ = eax
; ___last$ = edi
; ___val$ = esi

; 215  :   _STLP_DEBUG_CHECK(_STLP_PRIV __check_range(__first, __last))
; 216  :   return _STLP_PRIV __find(__first, __last, __val, _STLP_ITERATOR_CATEGORY(__first, _InputIter));

	jmp	??$__find@PAV?$FastDelegate0@X@fastdelegate@@V12@@priv@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PAV23@0ABV23@ABUrandom_access_iterator_tag@1@@Z ; stlp_std::priv::__find<fastdelegate::FastDelegate0<void> *,fastdelegate::FastDelegate0<void> >
??$find@PAV?$FastDelegate0@X@fastdelegate@@V12@@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PAV12@0ABV12@@Z ENDP ; stlp_std::find<fastdelegate::FastDelegate0<void> *,fastdelegate::FastDelegate0<void> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_alloc.h
_TEXT	ENDS
;	COMDAT ??0?$_STLP_alloc_proxy@PAU_REG_INFO@@U1@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE@ABV?$xalloc@U_REG_INFO@@@@PAU_REG_INFO@@@Z
_TEXT	SEGMENT
??0?$_STLP_alloc_proxy@PAU_REG_INFO@@U1@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE@ABV?$xalloc@U_REG_INFO@@@@PAU_REG_INFO@@@Z PROC ; stlp_std::priv::_STLP_alloc_proxy<_REG_INFO *,_REG_INFO,xalloc<_REG_INFO> >::_STLP_alloc_proxy<_REG_INFO *,_REG_INFO,xalloc<_REG_INFO> >, COMDAT
; _this$ = eax

; 571  :     _MaybeReboundAlloc(__a), _M_data(__p) {}

	mov	DWORD PTR [eax], 0
	ret	0
??0?$_STLP_alloc_proxy@PAU_REG_INFO@@U1@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE@ABV?$xalloc@U_REG_INFO@@@@PAU_REG_INFO@@@Z ENDP ; stlp_std::priv::_STLP_alloc_proxy<_REG_INFO *,_REG_INFO,xalloc<_REG_INFO> >::_STLP_alloc_proxy<_REG_INFO *,_REG_INFO,xalloc<_REG_INFO> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_STLP_alloc_proxy@PAUItemReg@CSheduler@@U12@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UItemReg@CSheduler@@@@PAUItemReg@CSheduler@@@Z
_TEXT	SEGMENT
??0?$_STLP_alloc_proxy@PAUItemReg@CSheduler@@U12@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UItemReg@CSheduler@@@@PAUItemReg@CSheduler@@@Z PROC ; stlp_std::priv::_STLP_alloc_proxy<CSheduler::ItemReg *,CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::_STLP_alloc_proxy<CSheduler::ItemReg *,CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >, COMDAT
; _this$ = eax

; 571  :     _MaybeReboundAlloc(__a), _M_data(__p) {}

	mov	DWORD PTR [eax], 0
	ret	0
??0?$_STLP_alloc_proxy@PAUItemReg@CSheduler@@U12@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UItemReg@CSheduler@@@@PAUItemReg@CSheduler@@@Z ENDP ; stlp_std::priv::_STLP_alloc_proxy<CSheduler::ItemReg *,CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::_STLP_alloc_proxy<CSheduler::ItemReg *,CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ??0?$_Vector_base@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UItemReg@CSheduler@@@@@Z
_TEXT	SEGMENT
??0?$_Vector_base@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UItemReg@CSheduler@@@@@Z PROC ; stlp_std::priv::_Vector_base<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::_Vector_base<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >, COMDAT
; _this$ = eax

; 67   :     : _M_start(0), _M_finish(0), _M_end_of_storage(__a, 0) {}

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$_Vector_base@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UItemReg@CSheduler@@@@@Z ENDP ; stlp_std::priv::_Vector_base<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::_Vector_base<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_alloc.h
_TEXT	ENDS
;	COMDAT ??0?$_STLP_alloc_proxy@PAUItem@CSheduler@@U12@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UItem@CSheduler@@@@PAUItem@CSheduler@@@Z
_TEXT	SEGMENT
??0?$_STLP_alloc_proxy@PAUItem@CSheduler@@U12@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UItem@CSheduler@@@@PAUItem@CSheduler@@@Z PROC ; stlp_std::priv::_STLP_alloc_proxy<CSheduler::Item *,CSheduler::Item,xalloc<CSheduler::Item> >::_STLP_alloc_proxy<CSheduler::Item *,CSheduler::Item,xalloc<CSheduler::Item> >, COMDAT
; _this$ = eax

; 571  :     _MaybeReboundAlloc(__a), _M_data(__p) {}

	mov	DWORD PTR [eax], 0
	ret	0
??0?$_STLP_alloc_proxy@PAUItem@CSheduler@@U12@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UItem@CSheduler@@@@PAUItem@CSheduler@@@Z ENDP ; stlp_std::priv::_STLP_alloc_proxy<CSheduler::Item *,CSheduler::Item,xalloc<CSheduler::Item> >::_STLP_alloc_proxy<CSheduler::Item *,CSheduler::Item,xalloc<CSheduler::Item> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ??0?$_Vector_base@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UItem@CSheduler@@@@@Z
_TEXT	SEGMENT
??0?$_Vector_base@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UItem@CSheduler@@@@@Z PROC ; stlp_std::priv::_Vector_base<CSheduler::Item,xalloc<CSheduler::Item> >::_Vector_base<CSheduler::Item,xalloc<CSheduler::Item> >, COMDAT
; _this$ = eax

; 67   :     : _M_start(0), _M_finish(0), _M_end_of_storage(__a, 0) {}

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$_Vector_base@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UItem@CSheduler@@@@@Z ENDP ; stlp_std::priv::_Vector_base<CSheduler::Item,xalloc<CSheduler::Item> >::_Vector_base<CSheduler::Item,xalloc<CSheduler::Item> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_alloc.h
_TEXT	ENDS
;	COMDAT ??0?$_STLP_alloc_proxy@PAVshared_str@@V1@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAE@ABV?$xalloc@Vshared_str@@@@PAVshared_str@@@Z
_TEXT	SEGMENT
??0?$_STLP_alloc_proxy@PAVshared_str@@V1@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAE@ABV?$xalloc@Vshared_str@@@@PAVshared_str@@@Z PROC ; stlp_std::priv::_STLP_alloc_proxy<shared_str *,shared_str,xalloc<shared_str> >::_STLP_alloc_proxy<shared_str *,shared_str,xalloc<shared_str> >, COMDAT
; _this$ = eax
; ___p$ = ecx

; 571  :     _MaybeReboundAlloc(__a), _M_data(__p) {}

	mov	DWORD PTR [eax], ecx
	ret	0
??0?$_STLP_alloc_proxy@PAVshared_str@@V1@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAE@ABV?$xalloc@Vshared_str@@@@PAVshared_str@@@Z ENDP ; stlp_std::priv::_STLP_alloc_proxy<shared_str *,shared_str,xalloc<shared_str> >::_STLP_alloc_proxy<shared_str *,shared_str,xalloc<shared_str> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ?_M_erase@?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@AAEPAV?$FastDelegate0@X@fastdelegate@@PAV45@ABU__false_type@3@@Z
_TEXT	SEGMENT
?_M_erase@?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@AAEPAV?$FastDelegate0@X@fastdelegate@@PAV45@ABU__false_type@3@@Z PROC ; stlp_std::priv::_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::_M_erase, COMDAT
; _this$ = esi
; ___pos$ = eax

; 549  :     if (__pos + 1 != end())

	mov	ecx, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+8]
	cmp	edx, ecx
	je	SHORT $LN22@M_erase@21

; 550  :       _STLP_PRIV __copy_ptrs(__pos + 1, this->_M_finish, __pos, _TrivialCopy());

	sub	ecx, edx
	sar	ecx, 3
	mov	edx, ecx
	test	edx, edx
	jle	SHORT $LN22@M_erase@21
	lea	ecx, DWORD PTR [eax+4]
	push	edi
	npad	7
$LL10@M_erase@21:
	mov	edi, DWORD PTR [ecx+8]
	mov	DWORD PTR [ecx], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx-4], edi
	sub	edx, 1
	add	ecx, 8
	test	edx, edx
	jg	SHORT $LL10@M_erase@21
	pop	edi
$LN22@M_erase@21:

; 551  :     --this->_M_finish;

	add	DWORD PTR [esi+4], -8			; fffffff8H

; 552  :     _STLP_STD::_Destroy(this->_M_finish);
; 553  :     return __pos;
; 554  :   }

	ret	0
?_M_erase@?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@AAEPAV?$FastDelegate0@X@fastdelegate@@PAV45@ABU__false_type@3@@Z ENDP ; stlp_std::priv::_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::_M_erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAE@ABV?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@Z
_TEXT	SEGMENT
??0?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAE@ABV?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@Z PROC ; stlp_std::priv::_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >, COMDAT
; _this$ = eax

; 208  :     : _STLP_PRIV _Vector_base<_Tp, _Alloc>(__a) {}

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAE@ABV?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@Z ENDP ; stlp_std::priv::_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_base@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE@IABV?$xalloc@U_REG_INFO@@@@@Z
_TEXT	SEGMENT
??0?$_Vector_base@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE@IABV?$xalloc@U_REG_INFO@@@@@Z PROC ; stlp_std::priv::_Vector_base<_REG_INFO,xalloc<_REG_INFO> >::_Vector_base<_REG_INFO,xalloc<_REG_INFO> >, COMDAT
; _this$ = esi
; ___n$ = eax

; 70   :     : _M_start(0), _M_finish(0), _M_end_of_storage(__a, 0) {

	push	edi
	xor	ecx, ecx

; 71   :     _M_start = _M_end_of_storage.allocate(__n, __n);

	lea	edi, DWORD PTR [eax+eax*2]
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [esi+4], ecx
	add	edi, edi
	mov	DWORD PTR [esi+8], ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	add	edi, edi
	push	edi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 72   :     _M_finish = _M_start;
; 73   :     _M_end_of_storage._M_data = _M_start + __n;

	add	edi, eax
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], edi

; 74   :     _STLP_MPWFIX_TRY _STLP_MPWFIX_CATCH
; 75   :   }

	mov	eax, esi
	pop	edi
	ret	0
??0?$_Vector_base@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE@IABV?$xalloc@U_REG_INFO@@@@@Z ENDP ; stlp_std::priv::_Vector_base<_REG_INFO,xalloc<_REG_INFO> >::_Vector_base<_REG_INFO,xalloc<_REG_INFO> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_base@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAE@IABV?$xalloc@UItemReg@CSheduler@@@@@Z
_TEXT	SEGMENT
??0?$_Vector_base@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAE@IABV?$xalloc@UItemReg@CSheduler@@@@@Z PROC ; stlp_std::priv::_Vector_base<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::_Vector_base<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >, COMDAT
; _this$ = esi
; ___n$ = eax

; 70   :     : _M_start(0), _M_finish(0), _M_end_of_storage(__a, 0) {

	push	edi
	xor	ecx, ecx

; 71   :     _M_start = _M_end_of_storage.allocate(__n, __n);

	lea	edi, DWORD PTR [eax+eax*2]
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [esi+4], ecx
	add	edi, edi
	mov	DWORD PTR [esi+8], ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	add	edi, edi
	push	edi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 72   :     _M_finish = _M_start;
; 73   :     _M_end_of_storage._M_data = _M_start + __n;

	add	edi, eax
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], edi

; 74   :     _STLP_MPWFIX_TRY _STLP_MPWFIX_CATCH
; 75   :   }

	mov	eax, esi
	pop	edi
	ret	0
??0?$_Vector_base@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAE@IABV?$xalloc@UItemReg@CSheduler@@@@@Z ENDP ; stlp_std::priv::_Vector_base<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::_Vector_base<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UItemReg@CSheduler@@@@@Z
_TEXT	SEGMENT
??0?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UItemReg@CSheduler@@@@@Z PROC ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >, COMDAT
; _this$ = eax

; 208  :     : _STLP_PRIV _Vector_base<_Tp, _Alloc>(__a) {}

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UItemReg@CSheduler@@@@@Z ENDP ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_base@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAE@IABV?$xalloc@UItem@CSheduler@@@@@Z
_TEXT	SEGMENT
??0?$_Vector_base@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAE@IABV?$xalloc@UItem@CSheduler@@@@@Z PROC ; stlp_std::priv::_Vector_base<CSheduler::Item,xalloc<CSheduler::Item> >::_Vector_base<CSheduler::Item,xalloc<CSheduler::Item> >, COMDAT
; _this$ = esi
; ___n$ = eax

; 70   :     : _M_start(0), _M_finish(0), _M_end_of_storage(__a, 0) {

	push	edi
	xor	ecx, ecx

; 71   :     _M_start = _M_end_of_storage.allocate(__n, __n);

	lea	edi, DWORD PTR [eax+eax*4]
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [esi+4], ecx
	add	edi, edi
	mov	DWORD PTR [esi+8], ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	add	edi, edi
	push	edi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 72   :     _M_finish = _M_start;
; 73   :     _M_end_of_storage._M_data = _M_start + __n;

	add	edi, eax
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], edi

; 74   :     _STLP_MPWFIX_TRY _STLP_MPWFIX_CATCH
; 75   :   }

	mov	eax, esi
	pop	edi
	ret	0
??0?$_Vector_base@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAE@IABV?$xalloc@UItem@CSheduler@@@@@Z ENDP ; stlp_std::priv::_Vector_base<CSheduler::Item,xalloc<CSheduler::Item> >::_Vector_base<CSheduler::Item,xalloc<CSheduler::Item> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UItem@CSheduler@@@@@Z
_TEXT	SEGMENT
??0?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UItem@CSheduler@@@@@Z PROC ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >, COMDAT
; _this$ = eax

; 208  :     : _STLP_PRIV _Vector_base<_Tp, _Alloc>(__a) {}

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UItem@CSheduler@@@@@Z ENDP ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UDeferred@CEventAPI@@@@@Z
_TEXT	SEGMENT
??0?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UDeferred@CEventAPI@@@@@Z PROC ; stlp_std::priv::_Impl_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::_Impl_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >, COMDAT
; _this$ = eax

; 208  :     : _STLP_PRIV _Vector_base<_Tp, _Alloc>(__a) {}

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAE@ABV?$xalloc@UDeferred@CEventAPI@@@@@Z ENDP ; stlp_std::priv::_Impl_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::_Impl_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_base@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAE@IABV?$xalloc@Vshared_str@@@@@Z
_TEXT	SEGMENT
??0?$_Vector_base@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAE@IABV?$xalloc@Vshared_str@@@@@Z PROC ; stlp_std::priv::_Vector_base<shared_str,xalloc<shared_str> >::_Vector_base<shared_str,xalloc<shared_str> >, COMDAT
; _this$ = esi
; ___n$ = ecx

; 70   :     : _M_start(0), _M_finish(0), _M_end_of_storage(__a, 0) {

	push	edi

; 71   :     _M_start = _M_end_of_storage.allocate(__n, __n);

	mov	edi, ecx
	xor	eax, eax
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	add	edi, edi
	mov	DWORD PTR [esi+8], eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	add	edi, edi
	push	edi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 72   :     _M_finish = _M_start;
; 73   :     _M_end_of_storage._M_data = _M_start + __n;

	add	edi, eax
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], edi

; 74   :     _STLP_MPWFIX_TRY _STLP_MPWFIX_CATCH
; 75   :   }

	mov	eax, esi
	pop	edi
	ret	0
??0?$_Vector_base@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAE@IABV?$xalloc@Vshared_str@@@@@Z ENDP ; stlp_std::priv::_Vector_base<shared_str,xalloc<shared_str> >::_Vector_base<shared_str,xalloc<shared_str> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAE@ABV?$xalloc@PAX@@@Z
_TEXT	SEGMENT
??0?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAE@ABV?$xalloc@PAX@@@Z PROC ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::_Impl_vector<void *,xalloc<void *> >, COMDAT
; _this$ = eax

; 208  :     : _STLP_PRIV _Vector_base<_Tp, _Alloc>(__a) {}

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAE@ABV?$xalloc@PAX@@@Z ENDP ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::_Impl_vector<void *,xalloc<void *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?erase@?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAEPAV?$FastDelegate0@X@fastdelegate@@PAV45@@Z
_TEXT	SEGMENT
?erase@?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAEPAV?$FastDelegate0@X@fastdelegate@@PAV45@@Z PROC ; stlp_std::priv::_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::erase, COMDAT
; _this$ = esi
; ___pos$ = eax

; 587  :     return _M_erase(__pos, _Movable());

	mov	ecx, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+8]
	cmp	edx, ecx
	je	SHORT $LN24@erase@30
	sub	ecx, edx
	sar	ecx, 3
	mov	edx, ecx
	test	edx, edx
	jle	SHORT $LN24@erase@30
	lea	ecx, DWORD PTR [eax+4]
	push	edi
	npad	7
$LL12@erase@30:
	mov	edi, DWORD PTR [ecx+8]
	mov	DWORD PTR [ecx], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx-4], edi
	sub	edx, 1
	add	ecx, 8
	test	edx, edx
	jg	SHORT $LL12@erase@30
	pop	edi
$LN24@erase@30:
	add	DWORD PTR [esi+4], -8			; fffffff8H

; 588  :   }

	ret	0
?erase@?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAEPAV?$FastDelegate0@X@fastdelegate@@PAV45@@Z ENDP ; stlp_std::priv::_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?rend@?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAV?$FastDelegate0@X@fastdelegate@@@3@XZ
_TEXT	SEGMENT
?rend@?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAV?$FastDelegate0@X@fastdelegate@@@3@XZ PROC ; stlp_std::priv::_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::rend, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 177  :   reverse_iterator rend()                { return reverse_iterator(begin()); }

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	ret	0
?rend@?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAV?$FastDelegate0@X@fastdelegate@@@3@XZ ENDP ; stlp_std::priv::_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::rend
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?rbegin@?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAV?$FastDelegate0@X@fastdelegate@@@3@XZ
_TEXT	SEGMENT
?rbegin@?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAV?$FastDelegate0@X@fastdelegate@@@3@XZ PROC ; stlp_std::priv::_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::rbegin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 175  :   reverse_iterator rbegin()              { return reverse_iterator(end()); }

	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	ret	0
?rbegin@?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAV?$FastDelegate0@X@fastdelegate@@@3@XZ ENDP ; stlp_std::priv::_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::rbegin
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE@ABV012@@Z
_TEXT	SEGMENT
??0?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE@ABV012@@Z PROC ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >, COMDAT
; _this$ = esi
; ___x$ = eax

; 236  :   { this->_M_finish = _STLP_PRIV __ucopy_ptrs(__x.begin(), __x.end(), this->_M_start, _TrivialUCopy()); }

	push	ebx
	mov	ebx, eax
	mov	ecx, DWORD PTR [ebx+4]
	sub	ecx, DWORD PTR [ebx]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	push	edi
	shr	eax, 31					; 0000001fH
	add	eax, edx
	xor	ecx, ecx
	lea	edi, DWORD PTR [eax+eax*2]
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [esi+4], ecx
	add	edi, edi
	mov	DWORD PTR [esi+8], ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	add	edi, edi
	push	edi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	add	edi, eax
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], edi
	mov	ecx, DWORD PTR [ebx+4]
	mov	ebx, DWORD PTR [ebx]
	cmp	ecx, ebx
	je	SHORT $LN35@Impl_vecto@27
	mov	edi, ecx
	sub	edi, ebx
	push	edi
	push	ebx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	add	eax, edi
$LN35@Impl_vecto@27:
	pop	edi
	mov	DWORD PTR [esi+4], eax
	mov	eax, esi
	pop	ebx
	ret	0
??0?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE@ABV012@@Z ENDP ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAE@ABV012@@Z
_TEXT	SEGMENT
??0?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAE@ABV012@@Z PROC ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >, COMDAT
; _this$ = esi
; ___x$ = eax

; 236  :   { this->_M_finish = _STLP_PRIV __ucopy_ptrs(__x.begin(), __x.end(), this->_M_start, _TrivialUCopy()); }

	push	ebx
	mov	ebx, eax
	mov	ecx, DWORD PTR [ebx+4]
	sub	ecx, DWORD PTR [ebx]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	push	edi
	shr	eax, 31					; 0000001fH
	add	eax, edx
	xor	ecx, ecx
	lea	edi, DWORD PTR [eax+eax*2]
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [esi+4], ecx
	add	edi, edi
	mov	DWORD PTR [esi+8], ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	add	edi, edi
	push	edi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	add	edi, eax
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], edi
	mov	ecx, DWORD PTR [ebx+4]
	mov	ebx, DWORD PTR [ebx]
	cmp	ecx, ebx
	je	SHORT $LN35@Impl_vecto@28
	mov	edi, ecx
	sub	edi, ebx
	push	edi
	push	ebx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	add	eax, edi
$LN35@Impl_vecto@28:
	pop	edi
	mov	DWORD PTR [esi+4], eax
	mov	eax, esi
	pop	ebx
	ret	0
??0?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAE@ABV012@@Z ENDP ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAE@XZ PROC ; stlp_std::priv::_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::~_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >, COMDAT
; _this$ = eax

; 286  :   ~vector() { _STLP_STD::_Destroy_Range(rbegin(), rend()); }

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN34@Impl_vecto@29
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN34@Impl_vecto@29:
	ret	0
??1?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAE@XZ ENDP ; stlp_std::priv::_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::~_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ?erase@?$vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@stlp_std@@QAEPAV?$FastDelegate0@X@fastdelegate@@PAV34@@Z
_TEXT	SEGMENT
?erase@?$vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@stlp_std@@QAEPAV?$FastDelegate0@X@fastdelegate@@PAV34@@Z PROC ; stlp_std::vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::erase, COMDAT
; _this$ = esi
; ___pos$ = eax

; 206  :   {return cast_traits::to_value_type_ptr(_M_impl.erase(cast_traits::to_storage_type_ptr(__pos)));}

	mov	ecx, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+8]
	cmp	edx, ecx
	je	SHORT $LN30@erase@31
	sub	ecx, edx
	sar	ecx, 3
	mov	edx, ecx
	test	edx, edx
	jle	SHORT $LN30@erase@31
	lea	ecx, DWORD PTR [eax+4]
	push	edi
	npad	7
$LL16@erase@31:
	mov	edi, DWORD PTR [ecx+8]
	mov	DWORD PTR [ecx], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx-4], edi
	sub	edx, 1
	add	ecx, 8
	test	edx, edx
	jg	SHORT $LL16@erase@31
	pop	edi
$LN30@erase@31:
	add	DWORD PTR [esi+4], -8			; fffffff8H
	ret	0
?erase@?$vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@stlp_std@@QAEPAV?$FastDelegate0@X@fastdelegate@@PAV34@@Z ENDP ; stlp_std::vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::erase
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\include\xrrender\factoryptr.h
_TEXT	ENDS
;	COMDAT ??0?$FactoryPtr@VIStatsRender@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
__in$ = 8						; size = 4
??0?$FactoryPtr@VIStatsRender@@@@QAE@ABV0@@Z PROC	; FactoryPtr<IStatsRender>::FactoryPtr<IStatsRender>, COMDAT
; _this$ = esi

; 28   : 	{
; 29   : 		CreateObject();

	mov	eax, DWORD PTR __imp_?RenderFactory@@3PAVIRenderFactory@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 30   : 		m_pObject->Copy(*_in.m_pObject);

	mov	ecx, DWORD PTR __in$[esp-4]
	mov	DWORD PTR [esi], eax
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx+4]
	push	ecx
	mov	ecx, eax
	call	edx

; 31   : 	}

	mov	eax, esi
	ret	4
??0?$FactoryPtr@VIStatsRender@@@@QAE@ABV0@@Z ENDP	; FactoryPtr<IStatsRender>::FactoryPtr<IStatsRender>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$FactoryPtr@VIStatsRender@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FactoryPtr@VIStatsRender@@@@QAE@XZ PROC		; FactoryPtr<IStatsRender>::~FactoryPtr<IStatsRender>, COMDAT
; _this$ = esi

; 25   : 	~FactoryPtr() { DestroyObject();}

	mov	eax, DWORD PTR __imp_?RenderFactory@@3PAVIRenderFactory@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+60]
	push	eax
	call	edx
	mov	DWORD PTR [esi], 0
	ret	0
??1?$FactoryPtr@VIStatsRender@@@@QAE@XZ ENDP		; FactoryPtr<IStatsRender>::~FactoryPtr<IStatsRender>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ??1?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE@XZ PROC ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::~_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >, COMDAT
; _this$ = eax

; 286  :   ~vector() { _STLP_STD::_Destroy_Range(rbegin(), rend()); }

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN34@Impl_vecto@30
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN34@Impl_vecto@30:
	ret	0
??1?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE@XZ ENDP ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::~_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ??0?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@stlp_std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@stlp_std@@QAE@ABV01@@Z PROC ; stlp_std::vector<_REG_INFO,xalloc<_REG_INFO> >::vector<_REG_INFO,xalloc<_REG_INFO> >, COMDAT
; _this$ = ecx
; ___x$ = eax

; 123  :   vector(const _Self& __x)

	push	esi
	mov	esi, ecx
	call	??0?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE@ABV012@@Z ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >
	mov	eax, esi
	pop	esi
	ret	0
??0?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@stlp_std@@QAE@ABV01@@Z ENDP ; stlp_std::vector<_REG_INFO,xalloc<_REG_INFO> >::vector<_REG_INFO,xalloc<_REG_INFO> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ??1?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAE@XZ PROC ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::~_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >, COMDAT
; _this$ = eax

; 286  :   ~vector() { _STLP_STD::_Destroy_Range(rbegin(), rend()); }

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN34@Impl_vecto@31
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN34@Impl_vecto@31:
	ret	0
??1?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAE@XZ ENDP ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::~_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ??0?$vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@stlp_std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@stlp_std@@QAE@ABV01@@Z PROC ; stlp_std::vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >, COMDAT
; _this$ = ecx
; ___x$ = eax

; 123  :   vector(const _Self& __x)

	push	esi
	mov	esi, ecx
	call	??0?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAE@ABV012@@Z ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >
	mov	eax, esi
	pop	esi
	ret	0
??0?$vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@stlp_std@@QAE@ABV01@@Z ENDP ; stlp_std::vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ??1?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAE@XZ PROC ; stlp_std::priv::_Impl_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::~_Impl_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >, COMDAT
; _this$ = eax

; 286  :   ~vector() { _STLP_STD::_Destroy_Range(rbegin(), rend()); }

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN34@Impl_vecto@32
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN34@Impl_vecto@32:
	ret	0
??1?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAE@XZ ENDP ; stlp_std::priv::_Impl_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::~_Impl_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAE@XZ PROC ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::~_Impl_vector<void *,xalloc<void *> >, COMDAT
; _this$ = eax

; 286  :   ~vector() { _STLP_STD::_Destroy_Range(rbegin(), rend()); }

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN34@Impl_vecto@33
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN34@Impl_vecto@33:
	ret	0
??1?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAE@XZ ENDP ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::~_Impl_vector<void *,xalloc<void *> >
_TEXT	ENDS
PUBLIC	??4CLoadScreenRenderer@@QAEAAV0@ABV0@@Z		; CLoadScreenRenderer::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4CLoadScreenRenderer@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4CLoadScreenRenderer@@QAEAAV0@ABV0@@Z PROC		; CLoadScreenRenderer::operator=, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	ecx, DWORD PTR ___that$[esp-4]
	mov	dl, BYTE PTR [ecx+4]
	mov	BYTE PTR [eax+4], dl
	mov	cl, BYTE PTR [ecx+5]
	mov	BYTE PTR [eax+5], cl
	ret	4
??4CLoadScreenRenderer@@QAEAAV0@ABV0@@Z ENDP		; CLoadScreenRenderer::operator=
_TEXT	ENDS
PUBLIC	??0CLoadScreenRenderer@@QAE@ABV0@@Z		; CLoadScreenRenderer::CLoadScreenRenderer
; Function compile flags: /Ogtpy
;	COMDAT ??0CLoadScreenRenderer@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0CLoadScreenRenderer@@QAE@ABV0@@Z PROC		; CLoadScreenRenderer::CLoadScreenRenderer, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	ecx, DWORD PTR ___that$[esp-4]
	mov	DWORD PTR [eax], OFFSET ??_7CLoadScreenRenderer@@6B@
	mov	dl, BYTE PTR [ecx+4]
	mov	BYTE PTR [eax+4], dl
	mov	cl, BYTE PTR [ecx+5]
	mov	BYTE PTR [eax+5], cl
	ret	4
??0CLoadScreenRenderer@@QAE@ABV0@@Z ENDP		; CLoadScreenRenderer::CLoadScreenRenderer
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@stlp_std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@stlp_std@@QAE@XZ PROC ; stlp_std::vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::~vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >, COMDAT
; _this$ = eax
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN36@vector@15
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN36@vector@15:
	ret	0
??1?$vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@stlp_std@@QAE@XZ ENDP ; stlp_std::vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::~vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$xr_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@@QAE@XZ PROC ; xr_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::~xr_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >, COMDAT
; _this$ = eax
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN38@xr_vector@12
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN38@xr_vector@12:
	ret	0
??1?$xr_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@@QAE@XZ ENDP ; xr_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::~xr_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >
_TEXT	ENDS
PUBLIC	?remove_from_seq_parallel@CRenderDevice@@QAEXABV?$FastDelegate0@X@fastdelegate@@@Z ; CRenderDevice::remove_from_seq_parallel
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\device.h
;	COMDAT ?remove_from_seq_parallel@CRenderDevice@@QAEXABV?$FastDelegate0@X@fastdelegate@@@Z
_TEXT	SEGMENT
_delegate$ = 8						; size = 4
?remove_from_seq_parallel@CRenderDevice@@QAEXABV?$FastDelegate0@X@fastdelegate@@@Z PROC ; CRenderDevice::remove_from_seq_parallel, COMDAT
; _this$ = ecx

; 273  : 		xr_vector<fastdelegate::FastDelegate0<> >::iterator I = std::find(
; 274  : 			seqParallel.begin(),
; 275  : 			seqParallel.end(),
; 276  : 			delegate
; 277  : 		);

	mov	eax, DWORD PTR [ecx+908]
	push	ebx
	push	esi
	mov	esi, DWORD PTR _delegate$[esp+4]
	lea	ebx, DWORD PTR [ecx+908]
	push	edi
	mov	edi, DWORD PTR [ecx+912]
	call	??$__find@PAV?$FastDelegate0@X@fastdelegate@@V12@@priv@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PAV23@0ABV23@ABUrandom_access_iterator_tag@1@@Z ; stlp_std::priv::__find<fastdelegate::FastDelegate0<void> *,fastdelegate::FastDelegate0<void> >

; 278  : 		if (I != seqParallel.end())

	cmp	eax, edi
	je	SHORT $LN1@remove_fro

; 279  : 			seqParallel.erase	(I);

	mov	esi, ebx
	call	?erase@?$vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@stlp_std@@QAEPAV?$FastDelegate0@X@fastdelegate@@PAV34@@Z ; stlp_std::vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::erase
$LN1@remove_fro:
	pop	edi
	pop	esi
	pop	ebx

; 280  : 	}

	ret	4
?remove_from_seq_parallel@CRenderDevice@@QAEXABV?$FastDelegate0@X@fastdelegate@@@Z ENDP ; CRenderDevice::remove_from_seq_parallel
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@stlp_std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@stlp_std@@QAE@XZ PROC ; stlp_std::vector<_REG_INFO,xalloc<_REG_INFO> >::~vector<_REG_INFO,xalloc<_REG_INFO> >, COMDAT
; _this$ = eax
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN36@vector@16
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN36@vector@16:
	ret	0
??1?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@stlp_std@@QAE@XZ ENDP ; stlp_std::vector<_REG_INFO,xalloc<_REG_INFO> >::~vector<_REG_INFO,xalloc<_REG_INFO> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QAE@XZ PROC ; xr_vector<_REG_INFO,xalloc<_REG_INFO> >::~xr_vector<_REG_INFO,xalloc<_REG_INFO> >, COMDAT
; _this$ = eax
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN38@xr_vector@13
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN38@xr_vector@13:
	ret	0
??1?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QAE@XZ ENDP ; xr_vector<_REG_INFO,xalloc<_REG_INFO> >::~xr_vector<_REG_INFO,xalloc<_REG_INFO> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
??0?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QAE@ABV0@@Z PROC ; xr_vector<_REG_INFO,xalloc<_REG_INFO> >::xr_vector<_REG_INFO,xalloc<_REG_INFO> >, COMDAT
; _this$ = ecx
; ___that$ = eax
	push	esi
	mov	esi, ecx
	call	??0?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE@ABV012@@Z ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >
	mov	eax, esi
	pop	esi
	ret	0
??0?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QAE@ABV0@@Z ENDP ; xr_vector<_REG_INFO,xalloc<_REG_INFO> >::xr_vector<_REG_INFO,xalloc<_REG_INFO> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$CRegistrator@VpureStats@@@@QAE@XZ
_TEXT	SEGMENT
??1?$CRegistrator@VpureStats@@@@QAE@XZ PROC		; CRegistrator<pureStats>::~CRegistrator<pureStats>, COMDAT
; _this$ = eax
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN40@CRegistrat
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN40@CRegistrat:
	ret	0
??1?$CRegistrator@VpureStats@@@@QAE@XZ ENDP		; CRegistrator<pureStats>::~CRegistrator<pureStats>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$CRegistrator@VpureStats@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
??0?$CRegistrator@VpureStats@@@@QAE@ABV0@@Z PROC	; CRegistrator<pureStats>::CRegistrator<pureStats>, COMDAT
; _this$ = eax
; ___that$ = edi
	push	esi
	mov	esi, eax
	mov	eax, edi
	call	??0?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE@ABV012@@Z ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >
	mov	eax, DWORD PTR [esi+12]
	xor	eax, DWORD PTR [edi+12]
	and	eax, 1
	xor	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [edi+12]
	xor	ecx, eax
	and	ecx, 2
	xor	ecx, eax
	mov	DWORD PTR [esi+12], ecx
	mov	eax, esi
	pop	esi
	ret	0
??0?$CRegistrator@VpureStats@@@@QAE@ABV0@@Z ENDP	; CRegistrator<pureStats>::CRegistrator<pureStats>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@stlp_std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@stlp_std@@QAE@XZ PROC ; stlp_std::vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::~vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >, COMDAT
; _this$ = eax
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN36@vector@17
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN36@vector@17:
	ret	0
??1?$vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@stlp_std@@QAE@XZ ENDP ; stlp_std::vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::~vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$xr_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
??0?$xr_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@@QAE@ABV0@@Z PROC ; xr_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::xr_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >, COMDAT
; _this$ = ecx
; ___that$ = eax
	push	esi
	mov	esi, ecx
	call	??0?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAE@ABV012@@Z ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >
	mov	eax, esi
	pop	esi
	ret	0
??0?$xr_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@@QAE@ABV0@@Z ENDP ; xr_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::xr_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$xr_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@@QAE@XZ PROC ; xr_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::~xr_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >, COMDAT
; _this$ = eax
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN38@xr_vector@14
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN38@xr_vector@14:
	ret	0
??1?$xr_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@@QAE@XZ ENDP ; xr_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::~xr_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@stlp_std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@stlp_std@@QAE@XZ PROC ; stlp_std::vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::~vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >, COMDAT
; _this$ = eax
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN36@vector@18
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN36@vector@18:
	ret	0
??1?$vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@stlp_std@@QAE@XZ ENDP ; stlp_std::vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::~vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$vector@PAVCEvent@@V?$xalloc@PAVCEvent@@@@@stlp_std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCEvent@@V?$xalloc@PAVCEvent@@@@@stlp_std@@QAE@XZ PROC ; stlp_std::vector<CEvent *,xalloc<CEvent *> >::~vector<CEvent *,xalloc<CEvent *> >, COMDAT
; _this$ = eax
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN36@vector@19
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN36@vector@19:
	ret	0
??1?$vector@PAVCEvent@@V?$xalloc@PAVCEvent@@@@@stlp_std@@QAE@XZ ENDP ; stlp_std::vector<CEvent *,xalloc<CEvent *> >::~vector<CEvent *,xalloc<CEvent *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$xr_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@@QAE@XZ PROC ; xr_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::~xr_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >, COMDAT
; _this$ = eax
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN38@xr_vector@15
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN38@xr_vector@15:
	ret	0
??1?$xr_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@@QAE@XZ ENDP ; xr_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::~xr_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$xr_vector@PAVCEvent@@V?$xalloc@PAVCEvent@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@PAVCEvent@@V?$xalloc@PAVCEvent@@@@@@QAE@XZ PROC ; xr_vector<CEvent *,xalloc<CEvent *> >::~xr_vector<CEvent *,xalloc<CEvent *> >, COMDAT
; _this$ = eax
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN38@xr_vector@16
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN38@xr_vector@16:
	ret	0
??1?$xr_vector@PAVCEvent@@V?$xalloc@PAVCEvent@@@@@@QAE@XZ ENDP ; xr_vector<CEvent *,xalloc<CEvent *> >::~xr_vector<CEvent *,xalloc<CEvent *> >
_TEXT	ENDS
PUBLIC	??1CEventAPI@@QAE@XZ				; CEventAPI::~CEventAPI
; Function compile flags: /Ogtpy
;	COMDAT ??1CEventAPI@@QAE@XZ
_TEXT	SEGMENT
??1CEventAPI@@QAE@XZ PROC				; CEventAPI::~CEventAPI, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	push	edi
	lea	ecx, DWORD PTR [esi+24]
	call	DWORD PTR __imp_??1xrCriticalSection@@QAE@XZ
	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	mov	edi, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	je	SHORT $LN40@CEventAPI
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
$LN40@CEventAPI:
	mov	esi, DWORD PTR [esi]
	test	esi, esi
	je	SHORT $LN80@CEventAPI
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	edi
$LN80@CEventAPI:
	pop	edi
	pop	esi
	ret	0
??1CEventAPI@@QAE@XZ ENDP				; CEventAPI::~CEventAPI
_TEXT	ENDS
PUBLIC	??_GDLL_Pure@@UAEPAXI@Z				; DLL_Pure::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GDLL_Pure@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GDLL_Pure@@UAEPAXI@Z PROC				; DLL_Pure::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7DLL_Pure@@6B@
	je	SHORT $LN11@scalar@21
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN11@scalar@21:
	mov	eax, esi
	pop	esi
	ret	4
??_GDLL_Pure@@UAEPAXI@Z ENDP				; DLL_Pure::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\xrstring.h
_TEXT	ENDS
;	COMDAT ??1shared_str@@QAE@XZ
_TEXT	SEGMENT
??1shared_str@@QAE@XZ PROC				; shared_str::~shared_str, COMDAT
; _this$ = ecx

; 75   : 						~shared_str	()								{	_dec();											}

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@shared_str
	add	DWORD PTR [eax], -1
	mov	eax, DWORD PTR [ecx]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN3@shared_str
	mov	DWORD PTR [ecx], 0
$LN3@shared_str:
	ret	0
??1shared_str@@QAE@XZ ENDP				; shared_str::~shared_str
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_set@shared_str@@QAEXABV1@@Z
_TEXT	SEGMENT
?_set@shared_str@@QAEXABV1@@Z PROC			; shared_str::_set, COMDAT
; _this$ = eax
; _rhs$ = ecx

; 64   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN1@set@14
	add	DWORD PTR [ecx], 1
$LN1@set@14:
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN9@set@14
	add	DWORD PTR [edx], -1
	mov	edx, DWORD PTR [eax]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN9@set@14
	mov	DWORD PTR [eax], 0
$LN9@set@14:
	mov	DWORD PTR [eax], ecx
	ret	0
?_set@shared_str@@QAEXABV1@@Z ENDP			; shared_str::_set
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_set@shared_str@@QAEXPBD@Z
_TEXT	SEGMENT
?_set@shared_str@@QAEXPBD@Z PROC			; shared_str::_set, COMDAT
; _this$ = esi
; _rhs$ = eax

; 63   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}

	mov	ecx, DWORD PTR __imp_?g_pStringContainer@@3PAVstr_container@@A
	mov	ecx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR __imp_?dock@str_container@@QAEPAUstr_value@@PBD@Z
	test	eax, eax
	je	SHORT $LN1@set@15
	add	DWORD PTR [eax], 1
$LN1@set@15:
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN9@set@15
	add	DWORD PTR [ecx], -1
	mov	edx, DWORD PTR [esi]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN9@set@15
	mov	DWORD PTR [esi], 0
$LN9@set@15:
	mov	DWORD PTR [esi], eax
	ret	0
?_set@shared_str@@QAEXPBD@Z ENDP			; shared_str::_set
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\xrmemory.h
_TEXT	ENDS
;	COMDAT ??_V@YAXPAX@Z
_TEXT	SEGMENT
??_V@YAXPAX@Z PROC					; operator delete[], COMDAT
; _p$ = eax

; 131  : 	IC void		operator delete[]	(void* p)			{	xr_free(p);											}

	test	eax, eax
	je	SHORT $LN3@operator@34
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN3@operator@34:
	ret	0
??_V@YAXPAX@Z ENDP					; operator delete[]
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\fastdelegate.h
;	COMDAT ??0?$FastDelegate0@X@fastdelegate@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$FastDelegate0@X@fastdelegate@@QAE@ABV01@@Z PROC	; fastdelegate::FastDelegate0<void>::FastDelegate0<void>, COMDAT
; _this$ = eax
; _x$ = ecx

; 877  : 	FastDelegate0(const FastDelegate0 &x) {

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0

; 878  : 		m_Closure.CopyFrom(this, x.m_Closure); }

	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx
	ret	0
??0?$FastDelegate0@X@fastdelegate@@QAE@ABV01@@Z ENDP	; fastdelegate::FastDelegate0<void>::FastDelegate0<void>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1Item@CSheduler@@QAE@XZ
_TEXT	SEGMENT
??1Item@CSheduler@@QAE@XZ PROC				; CSheduler::Item::~Item, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN5@Item@5
	add	DWORD PTR [eax], -1
	mov	eax, DWORD PTR [ecx+8]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN5@Item@5
	mov	DWORD PTR [ecx+8], 0
$LN5@Item@5:
	ret	0
??1Item@CSheduler@@QAE@XZ ENDP				; CSheduler::Item::~Item
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GItem@CSheduler@@QAEPAXI@Z
_TEXT	SEGMENT
??_GItem@CSheduler@@QAEPAXI@Z PROC			; CSheduler::Item::`scalar deleting destructor', COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN8@scalar@35
	add	DWORD PTR [ecx], -1
	mov	ecx, DWORD PTR [eax+8]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN8@scalar@35
	mov	DWORD PTR [eax+8], 0
$LN8@scalar@35:
	ret	0
??_GItem@CSheduler@@QAEPAXI@Z ENDP			; CSheduler::Item::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Gshared_str@@QAEPAXI@Z
_TEXT	SEGMENT
??_Gshared_str@@QAEPAXI@Z PROC				; shared_str::`scalar deleting destructor', COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN6@scalar@36
	add	DWORD PTR [ecx], -1
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN6@scalar@36
	mov	DWORD PTR [eax], 0
$LN6@scalar@36:
	ret	0
??_Gshared_str@@QAEPAXI@Z ENDP				; shared_str::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_construct.h
_TEXT	ENDS
;	COMDAT ??$__destroy_aux@UItem@CSheduler@@@stlp_std@@YAXPAUItem@CSheduler@@ABU__false_type@0@@Z
_TEXT	SEGMENT
??$__destroy_aux@UItem@CSheduler@@@stlp_std@@YAXPAUItem@CSheduler@@ABU__false_type@0@@Z PROC ; stlp_std::__destroy_aux<CSheduler::Item>, COMDAT
; ___pointer$ = ecx

; 53   : { __pointer->~_Tp(); }

	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN10@destroy_au@5
	add	DWORD PTR [eax], -1
	mov	eax, DWORD PTR [ecx+8]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN10@destroy_au@5
	mov	DWORD PTR [ecx+8], 0
$LN10@destroy_au@5:
	ret	0
??$__destroy_aux@UItem@CSheduler@@@stlp_std@@YAXPAUItem@CSheduler@@ABU__false_type@0@@Z ENDP ; stlp_std::__destroy_aux<CSheduler::Item>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$__destroy_aux@Vshared_str@@@stlp_std@@YAXPAVshared_str@@ABU__false_type@0@@Z
_TEXT	SEGMENT
??$__destroy_aux@Vshared_str@@@stlp_std@@YAXPAVshared_str@@ABU__false_type@0@@Z PROC ; stlp_std::__destroy_aux<shared_str>, COMDAT
; ___pointer$ = ecx

; 53   : { __pointer->~_Tp(); }

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN8@destroy_au@6
	add	DWORD PTR [eax], -1
	mov	eax, DWORD PTR [ecx]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN8@destroy_au@6
	mov	DWORD PTR [ecx], 0
$LN8@destroy_au@6:
	ret	0
??$__destroy_aux@Vshared_str@@@stlp_std@@YAXPAVshared_str@@ABU__false_type@0@@Z ENDP ; stlp_std::__destroy_aux<shared_str>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Param_Construct@V?$FastDelegate0@X@fastdelegate@@V12@@stlp_std@@YAXPAV?$FastDelegate0@X@fastdelegate@@ABV12@@Z
_TEXT	SEGMENT
??$_Param_Construct@V?$FastDelegate0@X@fastdelegate@@V12@@stlp_std@@YAXPAV?$FastDelegate0@X@fastdelegate@@ABV12@@Z PROC ; stlp_std::_Param_Construct<fastdelegate::FastDelegate0<void>,fastdelegate::FastDelegate0<void> >, COMDAT
; ___p$ = eax
; ___val$ = ecx

; 118  : #if defined (_STLP_DEBUG_UNINITIALIZED)
; 119  :   memset((char*)__p, _STLP_SHRED_BYTE, sizeof(_T1));
; 120  : #endif
; 121  :   _STLP_PLACEMENT_NEW (__p) _T1(__val);

	test	eax, eax
	je	SHORT $LN3@Param_Cons@16
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx
$LN3@Param_Cons@16:

; 122  : }

	ret	0
??$_Param_Construct@V?$FastDelegate0@X@fastdelegate@@V12@@stlp_std@@YAXPAV?$FastDelegate0@X@fastdelegate@@ABV12@@Z ENDP ; stlp_std::_Param_Construct<fastdelegate::FastDelegate0<void>,fastdelegate::FastDelegate0<void> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_uninitialized.h
_TEXT	ENDS
;	COMDAT ??$__ucopy_aux@PBU_REG_INFO@@PAU1@@priv@stlp_std@@YAPAU_REG_INFO@@PBU2@0PAU2@ABU__true_type@1@@Z
_TEXT	SEGMENT
??$__ucopy_aux@PBU_REG_INFO@@PAU1@@priv@stlp_std@@YAPAU_REG_INFO@@PBU2@0PAU2@ABU__true_type@1@@Z PROC ; stlp_std::priv::__ucopy_aux<_REG_INFO const *,_REG_INFO *>, COMDAT
; ___first$ = ecx
; ___last$ = edx
; ___result$ = eax

; 125  :                                const __true_type& /*BothPtrType*/) {

	push	esi
	mov	esi, edx

; 126  :   return __ucopy_ptrs(__first, __last, __result,
; 127  :                       _UseTrivialUCopy(_STLP_VALUE_TYPE(__first, _InputIter),
; 128  :                                        _STLP_VALUE_TYPE(__result, _OutputIter))._Answer());

	cmp	esi, ecx
	je	SHORT $LN12@ucopy_aux@16
	sub	esi, ecx
	push	esi
	push	ecx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	add	eax, esi
$LN12@ucopy_aux@16:
	pop	esi

; 129  : }

	ret	0
??$__ucopy_aux@PBU_REG_INFO@@PAU1@@priv@stlp_std@@YAPAU_REG_INFO@@PBU2@0PAU2@ABU__true_type@1@@Z ENDP ; stlp_std::priv::__ucopy_aux<_REG_INFO const *,_REG_INFO *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$__ucopy_aux@PBUItemReg@CSheduler@@PAU12@@priv@stlp_std@@YAPAUItemReg@CSheduler@@PBU23@0PAU23@ABU__true_type@1@@Z
_TEXT	SEGMENT
??$__ucopy_aux@PBUItemReg@CSheduler@@PAU12@@priv@stlp_std@@YAPAUItemReg@CSheduler@@PBU23@0PAU23@ABU__true_type@1@@Z PROC ; stlp_std::priv::__ucopy_aux<CSheduler::ItemReg const *,CSheduler::ItemReg *>, COMDAT
; ___first$ = ecx
; ___last$ = edx
; ___result$ = eax

; 125  :                                const __true_type& /*BothPtrType*/) {

	push	esi
	mov	esi, edx

; 126  :   return __ucopy_ptrs(__first, __last, __result,
; 127  :                       _UseTrivialUCopy(_STLP_VALUE_TYPE(__first, _InputIter),
; 128  :                                        _STLP_VALUE_TYPE(__result, _OutputIter))._Answer());

	cmp	esi, ecx
	je	SHORT $LN12@ucopy_aux@17
	sub	esi, ecx
	push	esi
	push	ecx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	add	eax, esi
$LN12@ucopy_aux@17:
	pop	esi

; 129  : }

	ret	0
??$__ucopy_aux@PBUItemReg@CSheduler@@PAU12@@priv@stlp_std@@YAPAUItemReg@CSheduler@@PBU23@0PAU23@ABU__true_type@1@@Z ENDP ; stlp_std::priv::__ucopy_aux<CSheduler::ItemReg const *,CSheduler::ItemReg *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_construct.h
_TEXT	ENDS
;	COMDAT ??$__destroy_range_aux@PAUItem@CSheduler@@U12@@stlp_std@@YAXPAUItem@CSheduler@@00ABU__false_type@0@@Z
_TEXT	SEGMENT
??$__destroy_range_aux@PAUItem@CSheduler@@U12@@stlp_std@@YAXPAUItem@CSheduler@@00ABU__false_type@0@@Z PROC ; stlp_std::__destroy_range_aux<CSheduler::Item *,CSheduler::Item>, COMDAT
; ___first$ = eax
; ___last$ = esi

; 152  :   for ( ; __first != __last; ++__first) {

	cmp	eax, esi
	je	SHORT $LN1@destroy_ra@16
	xor	edx, edx
$LL3@destroy_ra@16:

; 153  :     __destroy_aux(&(*__first), __false_type());

	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, edx
	je	SHORT $LN15@destroy_ra@16
	add	DWORD PTR [ecx], -1
	mov	ecx, DWORD PTR [eax+8]
	cmp	DWORD PTR [ecx], edx
	jne	SHORT $LN15@destroy_ra@16
	mov	DWORD PTR [eax+8], edx
$LN15@destroy_ra@16:
	add	eax, 20					; 00000014H
	cmp	eax, esi
	jne	SHORT $LL3@destroy_ra@16
$LN1@destroy_ra@16:

; 154  : #if defined (_STLP_DEBUG_UNINITIALIZED)
; 155  :     memset((char*)&(*__first), _STLP_SHRED_BYTE, sizeof(_Tp));
; 156  : #endif
; 157  :   }
; 158  : }

	ret	0
??$__destroy_range_aux@PAUItem@CSheduler@@U12@@stlp_std@@YAXPAUItem@CSheduler@@00ABU__false_type@0@@Z ENDP ; stlp_std::__destroy_range_aux<CSheduler::Item *,CSheduler::Item>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_uninitialized.h
_TEXT	ENDS
;	COMDAT ??$__ucopy_aux@PBUDeferred@CEventAPI@@PAU12@@priv@stlp_std@@YAPAUDeferred@CEventAPI@@PBU23@0PAU23@ABU__true_type@1@@Z
_TEXT	SEGMENT
??$__ucopy_aux@PBUDeferred@CEventAPI@@PAU12@@priv@stlp_std@@YAPAUDeferred@CEventAPI@@PBU23@0PAU23@ABU__true_type@1@@Z PROC ; stlp_std::priv::__ucopy_aux<CEventAPI::Deferred const *,CEventAPI::Deferred *>, COMDAT
; ___first$ = ecx
; ___last$ = edx
; ___result$ = eax

; 125  :                                const __true_type& /*BothPtrType*/) {

	push	esi
	mov	esi, edx

; 126  :   return __ucopy_ptrs(__first, __last, __result,
; 127  :                       _UseTrivialUCopy(_STLP_VALUE_TYPE(__first, _InputIter),
; 128  :                                        _STLP_VALUE_TYPE(__result, _OutputIter))._Answer());

	cmp	esi, ecx
	je	SHORT $LN12@ucopy_aux@18
	sub	esi, ecx
	push	esi
	push	ecx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	add	eax, esi
$LN12@ucopy_aux@18:
	pop	esi

; 129  : }

	ret	0
??$__ucopy_aux@PBUDeferred@CEventAPI@@PAU12@@priv@stlp_std@@YAPAUDeferred@CEventAPI@@PBU23@0PAU23@ABU__true_type@1@@Z ENDP ; stlp_std::priv::__ucopy_aux<CEventAPI::Deferred const *,CEventAPI::Deferred *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_construct.h
_TEXT	ENDS
;	COMDAT ??$__destroy_range_aux@PAVshared_str@@V1@@stlp_std@@YAXPAVshared_str@@00ABU__false_type@0@@Z
_TEXT	SEGMENT
??$__destroy_range_aux@PAVshared_str@@V1@@stlp_std@@YAXPAVshared_str@@00ABU__false_type@0@@Z PROC ; stlp_std::__destroy_range_aux<shared_str *,shared_str>, COMDAT
; ___first$ = eax
; ___last$ = edx

; 152  :   for ( ; __first != __last; ++__first) {

	cmp	eax, edx
	je	SHORT $LN1@destroy_ra@17
$LL3@destroy_ra@17:

; 153  :     __destroy_aux(&(*__first), __false_type());

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN13@destroy_ra@17
	add	DWORD PTR [ecx], -1
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN13@destroy_ra@17
	mov	DWORD PTR [eax], 0
$LN13@destroy_ra@17:
	add	eax, 4
	cmp	eax, edx
	jne	SHORT $LL3@destroy_ra@17
$LN1@destroy_ra@17:

; 154  : #if defined (_STLP_DEBUG_UNINITIALIZED)
; 155  :     memset((char*)&(*__first), _STLP_SHRED_BYTE, sizeof(_Tp));
; 156  : #endif
; 157  :   }
; 158  : }

	ret	0
??$__destroy_range_aux@PAVshared_str@@V1@@stlp_std@@YAXPAVshared_str@@00ABU__false_type@0@@Z ENDP ; stlp_std::__destroy_range_aux<shared_str *,shared_str>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_uninitialized.h
_TEXT	ENDS
;	COMDAT ??$__ucopy_aux@PBQAXPAPAX@priv@stlp_std@@YAPAPAXPBQAX0PAPAXABU__true_type@1@@Z
_TEXT	SEGMENT
??$__ucopy_aux@PBQAXPAPAX@priv@stlp_std@@YAPAPAXPBQAX0PAPAXABU__true_type@1@@Z PROC ; stlp_std::priv::__ucopy_aux<void * const *,void * *>, COMDAT
; ___first$ = ecx
; ___last$ = edx
; ___result$ = eax

; 125  :                                const __true_type& /*BothPtrType*/) {

	push	esi
	mov	esi, edx

; 126  :   return __ucopy_ptrs(__first, __last, __result,
; 127  :                       _UseTrivialUCopy(_STLP_VALUE_TYPE(__first, _InputIter),
; 128  :                                        _STLP_VALUE_TYPE(__result, _OutputIter))._Answer());

	cmp	esi, ecx
	je	SHORT $LN12@ucopy_aux@19
	sub	esi, ecx
	push	esi
	push	ecx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	add	eax, esi
$LN12@ucopy_aux@19:
	pop	esi

; 129  : }

	ret	0
??$__ucopy_aux@PBQAXPAPAX@priv@stlp_std@@YAPAPAXPBQAX0PAPAXABU__true_type@1@@Z ENDP ; stlp_std::priv::__ucopy_aux<void * const *,void * *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_construct.h
_TEXT	ENDS
;	COMDAT ??$__destroy_range_aux@V?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@UItem@CSheduler@@@stlp_std@@YAXV?$reverse_iterator@PAUItem@CSheduler@@@0@0PAUItem@CSheduler@@ABU__false_type@0@@Z
_TEXT	SEGMENT
___first$ = 8						; size = 4
___last$ = 12						; size = 4
??$__destroy_range_aux@V?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@UItem@CSheduler@@@stlp_std@@YAXV?$reverse_iterator@PAUItem@CSheduler@@@0@0PAUItem@CSheduler@@ABU__false_type@0@@Z PROC ; stlp_std::__destroy_range_aux<stlp_std::reverse_iterator<CSheduler::Item *>,CSheduler::Item>, COMDAT

; 152  :   for ( ; __first != __last; ++__first) {

	mov	eax, DWORD PTR ___first$[esp-4]
	push	esi
	mov	esi, DWORD PTR ___last$[esp]
	cmp	eax, esi
	je	SHORT $LN1@destroy_ra@18
	xor	edx, edx
	npad	1
$LL6@destroy_ra@18:

; 153  :     __destroy_aux(&(*__first), __false_type());

	mov	ecx, DWORD PTR [eax-12]
	cmp	ecx, edx
	je	SHORT $LN27@destroy_ra@18
	add	DWORD PTR [ecx], -1
	mov	ecx, DWORD PTR [eax-12]
	cmp	DWORD PTR [ecx], edx
	jne	SHORT $LN27@destroy_ra@18
	mov	DWORD PTR [eax-12], edx
$LN27@destroy_ra@18:
	sub	eax, 20					; 00000014H
	cmp	eax, esi
	jne	SHORT $LL6@destroy_ra@18
$LN1@destroy_ra@18:
	pop	esi

; 154  : #if defined (_STLP_DEBUG_UNINITIALIZED)
; 155  :     memset((char*)&(*__first), _STLP_SHRED_BYTE, sizeof(_Tp));
; 156  : #endif
; 157  :   }
; 158  : }

	ret	0
??$__destroy_range_aux@V?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@UItem@CSheduler@@@stlp_std@@YAXV?$reverse_iterator@PAUItem@CSheduler@@@0@0PAUItem@CSheduler@@ABU__false_type@0@@Z ENDP ; stlp_std::__destroy_range_aux<stlp_std::reverse_iterator<CSheduler::Item *>,CSheduler::Item>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$__destroy_range_aux@V?$reverse_iterator@PAVshared_str@@@stlp_std@@Vshared_str@@@stlp_std@@YAXV?$reverse_iterator@PAVshared_str@@@0@0PAVshared_str@@ABU__false_type@0@@Z
_TEXT	SEGMENT
___first$ = 8						; size = 4
___last$ = 12						; size = 4
??$__destroy_range_aux@V?$reverse_iterator@PAVshared_str@@@stlp_std@@Vshared_str@@@stlp_std@@YAXV?$reverse_iterator@PAVshared_str@@@0@0PAVshared_str@@ABU__false_type@0@@Z PROC ; stlp_std::__destroy_range_aux<stlp_std::reverse_iterator<shared_str *>,shared_str>, COMDAT

; 152  :   for ( ; __first != __last; ++__first) {

	mov	eax, DWORD PTR ___first$[esp-4]
	push	esi
	mov	esi, DWORD PTR ___last$[esp]
	cmp	eax, esi
	je	SHORT $LN1@destroy_ra@19
	xor	edx, edx
	npad	1
$LL6@destroy_ra@19:

; 153  :     __destroy_aux(&(*__first), __false_type());

	mov	ecx, DWORD PTR [eax-4]
	cmp	ecx, edx
	je	SHORT $LN25@destroy_ra@19
	add	DWORD PTR [ecx], -1
	mov	ecx, DWORD PTR [eax-4]
	cmp	DWORD PTR [ecx], edx
	jne	SHORT $LN25@destroy_ra@19
	mov	DWORD PTR [eax-4], edx
$LN25@destroy_ra@19:
	add	eax, -4					; fffffffcH
	cmp	eax, esi
	jne	SHORT $LL6@destroy_ra@19
$LN1@destroy_ra@19:
	pop	esi

; 154  : #if defined (_STLP_DEBUG_UNINITIALIZED)
; 155  :     memset((char*)&(*__first), _STLP_SHRED_BYTE, sizeof(_Tp));
; 156  : #endif
; 157  :   }
; 158  : }

	ret	0
??$__destroy_range_aux@V?$reverse_iterator@PAVshared_str@@@stlp_std@@Vshared_str@@@stlp_std@@YAXV?$reverse_iterator@PAVshared_str@@@0@0PAVshared_str@@ABU__false_type@0@@Z ENDP ; stlp_std::__destroy_range_aux<stlp_std::reverse_iterator<shared_str *>,shared_str>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_uninitialized.h
_TEXT	ENDS
;	COMDAT ??$__ucopy@PBV?$FastDelegate0@X@fastdelegate@@PAV12@H@priv@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PBV23@0PAV23@ABUrandom_access_iterator_tag@1@PAH@Z
_TEXT	SEGMENT
??$__ucopy@PBV?$FastDelegate0@X@fastdelegate@@PAV12@H@priv@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PBV23@0PAV23@ABUrandom_access_iterator_tag@1@PAH@Z PROC ; stlp_std::priv::__ucopy<fastdelegate::FastDelegate0<void> const *,fastdelegate::FastDelegate0<void> *,int>, COMDAT
; ___first$ = edx
; ___last$ = ecx
; ___result$ = eax

; 84   :   _OutputIter __cur = __result;
; 85   :   _STLP_TRY {
; 86   :     for (_Distance __n = __last - __first; __n > 0; --__n) {

	sub	ecx, edx
	sar	ecx, 3
	test	ecx, ecx
	jle	SHORT $LN1@ucopy@13
	push	edi
	npad	6
$LL3@ucopy@13:

; 87   :       _Param_Construct(&*__cur, *__first);

	test	eax, eax
	je	SHORT $LN8@ucopy@13
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	mov	edi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], edi
	mov	edi, DWORD PTR [edx]
	mov	DWORD PTR [eax], edi
$LN8@ucopy@13:
	sub	ecx, 1

; 88   :       ++__first;

	add	edx, 8

; 89   :       ++__cur;

	add	eax, 8
	test	ecx, ecx
	jg	SHORT $LL3@ucopy@13
	pop	edi
$LN1@ucopy@13:

; 90   :     }
; 91   :     return __cur;
; 92   :   }
; 93   :   _STLP_UNWIND(_STLP_STD::_Destroy_Range(__result, __cur))
; 94   :   _STLP_RET_AFTER_THROW(__cur)
; 95   : }

	ret	0
??$__ucopy@PBV?$FastDelegate0@X@fastdelegate@@PAV12@H@priv@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PBV23@0PAV23@ABUrandom_access_iterator_tag@1@PAH@Z ENDP ; stlp_std::priv::__ucopy<fastdelegate::FastDelegate0<void> const *,fastdelegate::FastDelegate0<void> *,int>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_algobase.h
_TEXT	ENDS
;	COMDAT ??$__copy@PBV?$FastDelegate0@X@fastdelegate@@PAV12@H@priv@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PBV23@0PAV23@ABUrandom_access_iterator_tag@1@PAH@Z
_TEXT	SEGMENT
??$__copy@PBV?$FastDelegate0@X@fastdelegate@@PAV12@H@priv@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PBV23@0PAV23@ABUrandom_access_iterator_tag@1@PAH@Z PROC ; stlp_std::priv::__copy<fastdelegate::FastDelegate0<void> const *,fastdelegate::FastDelegate0<void> *,int>, COMDAT
; ___first$ = ecx
; ___last$ = edx
; ___result$ = eax

; 201  :   for (_Distance __n = __last - __first; __n > 0; --__n) {

	sub	edx, ecx
	sar	edx, 3
	test	edx, edx
	jle	SHORT $LN1@copy@17
	push	esi
	npad	6
$LL3@copy@17:

; 202  :     *__result = *__first;

	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	sub	edx, 1

; 203  :     ++__first;

	add	ecx, 8

; 204  :     ++__result;

	add	eax, 8
	test	edx, edx
	jg	SHORT $LL3@copy@17
	pop	esi
$LN1@copy@17:

; 205  :   }
; 206  :   return __result;
; 207  : }

	ret	0
??$__copy@PBV?$FastDelegate0@X@fastdelegate@@PAV12@H@priv@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PBV23@0PAV23@ABUrandom_access_iterator_tag@1@PAH@Z ENDP ; stlp_std::priv::__copy<fastdelegate::FastDelegate0<void> const *,fastdelegate::FastDelegate0<void> *,int>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_uninitialized.h
_TEXT	ENDS
;	COMDAT ??$uninitialized_copy@PBU_REG_INFO@@PAU1@@stlp_std@@YAPAU_REG_INFO@@PBU1@0PAU1@@Z
_TEXT	SEGMENT
??$uninitialized_copy@PBU_REG_INFO@@PAU1@@stlp_std@@YAPAU_REG_INFO@@PBU1@0PAU1@@Z PROC ; stlp_std::uninitialized_copy<_REG_INFO const *,_REG_INFO *>, COMDAT
; ___first$ = ecx
; ___last$ = edx
; ___result$ = eax

; 144  : { return _STLP_PRIV __ucopy_aux(__first, __last, __result, _BothPtrType< _InputIter, _ForwardIter>::_Answer()); }

	push	esi
	mov	esi, edx
	cmp	esi, ecx
	je	SHORT $LN16@uninitiali@27
	sub	esi, ecx
	push	esi
	push	ecx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	add	eax, esi
$LN16@uninitiali@27:
	pop	esi
	ret	0
??$uninitialized_copy@PBU_REG_INFO@@PAU1@@stlp_std@@YAPAU_REG_INFO@@PBU1@0PAU1@@Z ENDP ; stlp_std::uninitialized_copy<_REG_INFO const *,_REG_INFO *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$uninitialized_copy@PBUItemReg@CSheduler@@PAU12@@stlp_std@@YAPAUItemReg@CSheduler@@PBU12@0PAU12@@Z
_TEXT	SEGMENT
??$uninitialized_copy@PBUItemReg@CSheduler@@PAU12@@stlp_std@@YAPAUItemReg@CSheduler@@PBU12@0PAU12@@Z PROC ; stlp_std::uninitialized_copy<CSheduler::ItemReg const *,CSheduler::ItemReg *>, COMDAT
; ___first$ = ecx
; ___last$ = edx
; ___result$ = eax

; 144  : { return _STLP_PRIV __ucopy_aux(__first, __last, __result, _BothPtrType< _InputIter, _ForwardIter>::_Answer()); }

	push	esi
	mov	esi, edx
	cmp	esi, ecx
	je	SHORT $LN16@uninitiali@28
	sub	esi, ecx
	push	esi
	push	ecx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	add	eax, esi
$LN16@uninitiali@28:
	pop	esi
	ret	0
??$uninitialized_copy@PBUItemReg@CSheduler@@PAU12@@stlp_std@@YAPAUItemReg@CSheduler@@PBU12@0PAU12@@Z ENDP ; stlp_std::uninitialized_copy<CSheduler::ItemReg const *,CSheduler::ItemReg *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_construct.h
_TEXT	ENDS
;	COMDAT ??$__destroy_range@PAUItem@CSheduler@@U12@@stlp_std@@YAXPAUItem@CSheduler@@00@Z
_TEXT	SEGMENT
??$__destroy_range@PAUItem@CSheduler@@U12@@stlp_std@@YAXPAUItem@CSheduler@@00@Z PROC ; stlp_std::__destroy_range<CSheduler::Item *,CSheduler::Item>, COMDAT
; ___first$ = eax
; ___last$ = edx

; 175  :   typedef typename __type_traits<_Tp>::has_trivial_destructor _Trivial_destructor;
; 176  :   __destroy_range_aux(__first, __last, __ptr, _Trivial_destructor());

	cmp	eax, edx
	je	SHORT $LN3@destroy_ra@20
	add	eax, 8
$LL5@destroy_ra@20:
	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN17@destroy_ra@20
	add	DWORD PTR [ecx], -1
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN17@destroy_ra@20
	mov	DWORD PTR [eax], 0
$LN17@destroy_ra@20:
	add	eax, 20					; 00000014H
	lea	ecx, DWORD PTR [eax-8]
	cmp	ecx, edx
	jne	SHORT $LL5@destroy_ra@20
$LN3@destroy_ra@20:

; 177  : }

	ret	0
??$__destroy_range@PAUItem@CSheduler@@U12@@stlp_std@@YAXPAUItem@CSheduler@@00@Z ENDP ; stlp_std::__destroy_range<CSheduler::Item *,CSheduler::Item>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_uninitialized.h
_TEXT	ENDS
;	COMDAT ??$uninitialized_copy@PBUDeferred@CEventAPI@@PAU12@@stlp_std@@YAPAUDeferred@CEventAPI@@PBU12@0PAU12@@Z
_TEXT	SEGMENT
??$uninitialized_copy@PBUDeferred@CEventAPI@@PAU12@@stlp_std@@YAPAUDeferred@CEventAPI@@PBU12@0PAU12@@Z PROC ; stlp_std::uninitialized_copy<CEventAPI::Deferred const *,CEventAPI::Deferred *>, COMDAT
; ___first$ = ecx
; ___last$ = edx
; ___result$ = eax

; 144  : { return _STLP_PRIV __ucopy_aux(__first, __last, __result, _BothPtrType< _InputIter, _ForwardIter>::_Answer()); }

	push	esi
	mov	esi, edx
	cmp	esi, ecx
	je	SHORT $LN16@uninitiali@29
	sub	esi, ecx
	push	esi
	push	ecx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	add	eax, esi
$LN16@uninitiali@29:
	pop	esi
	ret	0
??$uninitialized_copy@PBUDeferred@CEventAPI@@PAU12@@stlp_std@@YAPAUDeferred@CEventAPI@@PBU12@0PAU12@@Z ENDP ; stlp_std::uninitialized_copy<CEventAPI::Deferred const *,CEventAPI::Deferred *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_construct.h
_TEXT	ENDS
;	COMDAT ??$__destroy_range@PAVshared_str@@V1@@stlp_std@@YAXPAVshared_str@@00@Z
_TEXT	SEGMENT
??$__destroy_range@PAVshared_str@@V1@@stlp_std@@YAXPAVshared_str@@00@Z PROC ; stlp_std::__destroy_range<shared_str *,shared_str>, COMDAT
; ___first$ = eax
; ___last$ = edx

; 175  :   typedef typename __type_traits<_Tp>::has_trivial_destructor _Trivial_destructor;
; 176  :   __destroy_range_aux(__first, __last, __ptr, _Trivial_destructor());

	cmp	eax, edx
	je	SHORT $LN3@destroy_ra@21
$LL5@destroy_ra@21:
	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN15@destroy_ra@21
	add	DWORD PTR [ecx], -1
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN15@destroy_ra@21
	mov	DWORD PTR [eax], 0
$LN15@destroy_ra@21:
	add	eax, 4
	cmp	eax, edx
	jne	SHORT $LL5@destroy_ra@21
$LN3@destroy_ra@21:

; 177  : }

	ret	0
??$__destroy_range@PAVshared_str@@V1@@stlp_std@@YAXPAVshared_str@@00@Z ENDP ; stlp_std::__destroy_range<shared_str *,shared_str>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_uninitialized.h
_TEXT	ENDS
;	COMDAT ??$uninitialized_copy@PBQAXPAPAX@stlp_std@@YAPAPAXPBQAX0PAPAX@Z
_TEXT	SEGMENT
??$uninitialized_copy@PBQAXPAPAX@stlp_std@@YAPAPAXPBQAX0PAPAX@Z PROC ; stlp_std::uninitialized_copy<void * const *,void * *>, COMDAT
; ___first$ = ecx
; ___last$ = edx
; ___result$ = eax

; 144  : { return _STLP_PRIV __ucopy_aux(__first, __last, __result, _BothPtrType< _InputIter, _ForwardIter>::_Answer()); }

	push	esi
	mov	esi, edx
	cmp	esi, ecx
	je	SHORT $LN16@uninitiali@30
	sub	esi, ecx
	push	esi
	push	ecx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	add	eax, esi
$LN16@uninitiali@30:
	pop	esi
	ret	0
??$uninitialized_copy@PBQAXPAPAX@stlp_std@@YAPAPAXPBQAX0PAPAX@Z ENDP ; stlp_std::uninitialized_copy<void * const *,void * *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_construct.h
_TEXT	ENDS
;	COMDAT ??$__destroy_range@V?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@UItem@CSheduler@@@stlp_std@@YAXV?$reverse_iterator@PAUItem@CSheduler@@@0@0PAUItem@CSheduler@@@Z
_TEXT	SEGMENT
___first$ = 8						; size = 4
___last$ = 12						; size = 4
??$__destroy_range@V?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@UItem@CSheduler@@@stlp_std@@YAXV?$reverse_iterator@PAUItem@CSheduler@@@0@0PAUItem@CSheduler@@@Z PROC ; stlp_std::__destroy_range<stlp_std::reverse_iterator<CSheduler::Item *>,CSheduler::Item>, COMDAT

; 175  :   typedef typename __type_traits<_Tp>::has_trivial_destructor _Trivial_destructor;
; 176  :   __destroy_range_aux(__first, __last, __ptr, _Trivial_destructor());

	mov	eax, DWORD PTR ___first$[esp-4]
	mov	edx, DWORD PTR ___last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN7@destroy_ra@22
	add	eax, -12				; fffffff4H
	npad	1
$LL12@destroy_ra@22:
	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN33@destroy_ra@22
	add	DWORD PTR [ecx], -1
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN33@destroy_ra@22
	mov	DWORD PTR [eax], 0
$LN33@destroy_ra@22:
	sub	eax, 20					; 00000014H
	lea	ecx, DWORD PTR [eax+12]
	cmp	ecx, edx
	jne	SHORT $LL12@destroy_ra@22
$LN7@destroy_ra@22:

; 177  : }

	ret	0
??$__destroy_range@V?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@UItem@CSheduler@@@stlp_std@@YAXV?$reverse_iterator@PAUItem@CSheduler@@@0@0PAUItem@CSheduler@@@Z ENDP ; stlp_std::__destroy_range<stlp_std::reverse_iterator<CSheduler::Item *>,CSheduler::Item>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$__destroy_range@V?$reverse_iterator@PAVshared_str@@@stlp_std@@Vshared_str@@@stlp_std@@YAXV?$reverse_iterator@PAVshared_str@@@0@0PAVshared_str@@@Z
_TEXT	SEGMENT
___first$ = 8						; size = 4
___last$ = 12						; size = 4
??$__destroy_range@V?$reverse_iterator@PAVshared_str@@@stlp_std@@Vshared_str@@@stlp_std@@YAXV?$reverse_iterator@PAVshared_str@@@0@0PAVshared_str@@@Z PROC ; stlp_std::__destroy_range<stlp_std::reverse_iterator<shared_str *>,shared_str>, COMDAT

; 175  :   typedef typename __type_traits<_Tp>::has_trivial_destructor _Trivial_destructor;
; 176  :   __destroy_range_aux(__first, __last, __ptr, _Trivial_destructor());

	mov	eax, DWORD PTR ___first$[esp-4]
	mov	edx, DWORD PTR ___last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN7@destroy_ra@23
	add	eax, -4					; fffffffcH
	npad	1
$LL12@destroy_ra@23:
	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN31@destroy_ra@23
	add	DWORD PTR [ecx], -1
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN31@destroy_ra@23
	mov	DWORD PTR [eax], 0
$LN31@destroy_ra@23:
	sub	eax, 4
	lea	ecx, DWORD PTR [eax+4]
	cmp	ecx, edx
	jne	SHORT $LL12@destroy_ra@23
$LN7@destroy_ra@23:

; 177  : }

	ret	0
??$__destroy_range@V?$reverse_iterator@PAVshared_str@@@stlp_std@@Vshared_str@@@stlp_std@@YAXV?$reverse_iterator@PAVshared_str@@@0@0PAVshared_str@@@Z ENDP ; stlp_std::__destroy_range<stlp_std::reverse_iterator<shared_str *>,shared_str>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_uninitialized.h
_TEXT	ENDS
;	COMDAT ??$__ucopy_ptrs@PBV?$FastDelegate0@X@fastdelegate@@PAV12@@priv@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PBV23@0PAV23@ABU__false_type@1@@Z
_TEXT	SEGMENT
??$__ucopy_ptrs@PBV?$FastDelegate0@X@fastdelegate@@PAV12@@priv@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PBV23@0PAV23@ABU__false_type@1@@Z PROC ; stlp_std::priv::__ucopy_ptrs<fastdelegate::FastDelegate0<void> const *,fastdelegate::FastDelegate0<void> *>, COMDAT
; ___first$ = edx
; ___last$ = ecx
; ___result$ = eax

; 113  : { return __ucopy(__first, __last, __result, random_access_iterator_tag(), (ptrdiff_t*)0); }

	jmp	??$__ucopy@PBV?$FastDelegate0@X@fastdelegate@@PAV12@H@priv@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PBV23@0PAV23@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<fastdelegate::FastDelegate0<void> const *,fastdelegate::FastDelegate0<void> *,int>
??$__ucopy_ptrs@PBV?$FastDelegate0@X@fastdelegate@@PAV12@@priv@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PBV23@0PAV23@ABU__false_type@1@@Z ENDP ; stlp_std::priv::__ucopy_ptrs<fastdelegate::FastDelegate0<void> const *,fastdelegate::FastDelegate0<void> *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_algobase.h
_TEXT	ENDS
;	COMDAT ??$__copy_ptrs@PBV?$FastDelegate0@X@fastdelegate@@PAV12@@priv@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PBV23@0PAV23@ABU__false_type@1@@Z
_TEXT	SEGMENT
??$__copy_ptrs@PBV?$FastDelegate0@X@fastdelegate@@PAV12@@priv@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PBV23@0PAV23@ABU__false_type@1@@Z PROC ; stlp_std::priv::__copy_ptrs<fastdelegate::FastDelegate0<void> const *,fastdelegate::FastDelegate0<void> *>, COMDAT
; ___first$ = edx
; ___last$ = ecx
; ___result$ = eax

; 250  :   return __copy(__first, __last, __result, random_access_iterator_tag(), (ptrdiff_t*)0);

	sub	ecx, edx
	sar	ecx, 3
	test	ecx, ecx
	jle	SHORT $LN3@copy_ptrs@42
	sub	edx, eax
	push	esi
	npad	4
$LL5@copy_ptrs@42:
	mov	esi, DWORD PTR [edx+eax+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [edx+eax]
	mov	DWORD PTR [eax], esi
	sub	ecx, 1
	add	eax, 8
	test	ecx, ecx
	jg	SHORT $LL5@copy_ptrs@42
	pop	esi
$LN3@copy_ptrs@42:

; 251  : }

	ret	0
??$__copy_ptrs@PBV?$FastDelegate0@X@fastdelegate@@PAV12@@priv@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PBV23@0PAV23@ABU__false_type@1@@Z ENDP ; stlp_std::priv::__copy_ptrs<fastdelegate::FastDelegate0<void> const *,fastdelegate::FastDelegate0<void> *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ??$_M_allocate_and_copy@PBU_REG_INFO@@@?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@AAEPAU_REG_INFO@@AAIPBU3@1@Z
_TEXT	SEGMENT
??$_M_allocate_and_copy@PBU_REG_INFO@@@?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@AAEPAU_REG_INFO@@AAIPBU3@1@Z PROC ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::_M_allocate_and_copy<_REG_INFO const *>, COMDAT
; ___n$ = eax
; ___first$ = ebx
; ___last$ = ecx

; 634  :                                _ForwardIterator __first, _ForwardIterator __last)
; 635  : #else /* _STLP_MEMBER_TEMPLATES */
; 636  :   pointer _M_allocate_and_copy(size_type& __n,
; 637  :                                const_pointer __first, const_pointer __last)
; 638  : #endif /* _STLP_MEMBER_TEMPLATES */
; 639  :   {
; 640  :     pointer __result = this->_M_end_of_storage.allocate(__n, __n);

	mov	eax, DWORD PTR [eax]
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [eax+eax*2]
	add	ecx, ecx
	add	ecx, ecx
	push	edi
	push	ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 641  :     _STLP_TRY {
; 642  :       uninitialized_copy(__first, __last, __result);

	cmp	esi, ebx
	mov	edi, eax
	je	SHORT $LN28@M_allocate@15
	sub	esi, ebx
	push	esi
	push	ebx
	push	edi
	call	_memcpy
	add	esp, 12					; 0000000cH

; 643  :       return __result;

	mov	eax, edi
$LN28@M_allocate@15:
	pop	edi
	pop	esi

; 644  :     }
; 645  :     _STLP_UNWIND(this->_M_end_of_storage.deallocate(__result, __n))
; 646  :     _STLP_RET_AFTER_THROW(__result)
; 647  :   }

	ret	0
??$_M_allocate_and_copy@PBU_REG_INFO@@@?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@AAEPAU_REG_INFO@@AAIPBU3@1@Z ENDP ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::_M_allocate_and_copy<_REG_INFO const *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_M_allocate_and_copy@PBUItemReg@CSheduler@@@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@AAEPAUItemReg@CSheduler@@AAIPBU34@1@Z
_TEXT	SEGMENT
??$_M_allocate_and_copy@PBUItemReg@CSheduler@@@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@AAEPAUItemReg@CSheduler@@AAIPBU34@1@Z PROC ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::_M_allocate_and_copy<CSheduler::ItemReg const *>, COMDAT
; ___n$ = eax
; ___first$ = ebx
; ___last$ = ecx

; 634  :                                _ForwardIterator __first, _ForwardIterator __last)
; 635  : #else /* _STLP_MEMBER_TEMPLATES */
; 636  :   pointer _M_allocate_and_copy(size_type& __n,
; 637  :                                const_pointer __first, const_pointer __last)
; 638  : #endif /* _STLP_MEMBER_TEMPLATES */
; 639  :   {
; 640  :     pointer __result = this->_M_end_of_storage.allocate(__n, __n);

	mov	eax, DWORD PTR [eax]
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [eax+eax*2]
	add	ecx, ecx
	add	ecx, ecx
	push	edi
	push	ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 641  :     _STLP_TRY {
; 642  :       uninitialized_copy(__first, __last, __result);

	cmp	esi, ebx
	mov	edi, eax
	je	SHORT $LN28@M_allocate@16
	sub	esi, ebx
	push	esi
	push	ebx
	push	edi
	call	_memcpy
	add	esp, 12					; 0000000cH

; 643  :       return __result;

	mov	eax, edi
$LN28@M_allocate@16:
	pop	edi
	pop	esi

; 644  :     }
; 645  :     _STLP_UNWIND(this->_M_end_of_storage.deallocate(__result, __n))
; 646  :     _STLP_RET_AFTER_THROW(__result)
; 647  :   }

	ret	0
??$_M_allocate_and_copy@PBUItemReg@CSheduler@@@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@AAEPAUItemReg@CSheduler@@AAIPBU34@1@Z ENDP ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::_M_allocate_and_copy<CSheduler::ItemReg const *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_construct.h
_TEXT	ENDS
;	COMDAT ??$_Destroy_Range@PAUItem@CSheduler@@@stlp_std@@YAXPAUItem@CSheduler@@0@Z
_TEXT	SEGMENT
??$_Destroy_Range@PAUItem@CSheduler@@@stlp_std@@YAXPAUItem@CSheduler@@0@Z PROC ; stlp_std::_Destroy_Range<CSheduler::Item *>, COMDAT
; ___first$ = eax
; ___last$ = edx

; 181  :   __destroy_range(__first, __last, _STLP_VALUE_TYPE(__first, _ForwardIterator));

	cmp	eax, edx
	je	SHORT $LN5@Destroy_Ra@3
	add	eax, 8
$LL7@Destroy_Ra@3:
	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN19@Destroy_Ra@3
	add	DWORD PTR [ecx], -1
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN19@Destroy_Ra@3
	mov	DWORD PTR [eax], 0
$LN19@Destroy_Ra@3:
	add	eax, 20					; 00000014H
	lea	ecx, DWORD PTR [eax-8]
	cmp	ecx, edx
	jne	SHORT $LL7@Destroy_Ra@3
$LN5@Destroy_Ra@3:

; 182  : }

	ret	0
??$_Destroy_Range@PAUItem@CSheduler@@@stlp_std@@YAXPAUItem@CSheduler@@0@Z ENDP ; stlp_std::_Destroy_Range<CSheduler::Item *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ??$_M_allocate_and_copy@PBUDeferred@CEventAPI@@@?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@AAEPAUDeferred@CEventAPI@@AAIPBU34@1@Z
_TEXT	SEGMENT
??$_M_allocate_and_copy@PBUDeferred@CEventAPI@@@?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@AAEPAUDeferred@CEventAPI@@AAIPBU34@1@Z PROC ; stlp_std::priv::_Impl_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::_M_allocate_and_copy<CEventAPI::Deferred const *>, COMDAT
; ___n$ = eax
; ___first$ = ebx
; ___last$ = ecx

; 634  :                                _ForwardIterator __first, _ForwardIterator __last)
; 635  : #else /* _STLP_MEMBER_TEMPLATES */
; 636  :   pointer _M_allocate_and_copy(size_type& __n,
; 637  :                                const_pointer __first, const_pointer __last)
; 638  : #endif /* _STLP_MEMBER_TEMPLATES */
; 639  :   {
; 640  :     pointer __result = this->_M_end_of_storage.allocate(__n, __n);

	mov	eax, DWORD PTR [eax]
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [eax+eax*2]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	push	edi
	push	ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 641  :     _STLP_TRY {
; 642  :       uninitialized_copy(__first, __last, __result);

	cmp	esi, ebx
	mov	edi, eax
	je	SHORT $LN28@M_allocate@17
	sub	esi, ebx
	push	esi
	push	ebx
	push	edi
	call	_memcpy
	add	esp, 12					; 0000000cH

; 643  :       return __result;

	mov	eax, edi
$LN28@M_allocate@17:
	pop	edi
	pop	esi

; 644  :     }
; 645  :     _STLP_UNWIND(this->_M_end_of_storage.deallocate(__result, __n))
; 646  :     _STLP_RET_AFTER_THROW(__result)
; 647  :   }

	ret	0
??$_M_allocate_and_copy@PBUDeferred@CEventAPI@@@?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@AAEPAUDeferred@CEventAPI@@AAIPBU34@1@Z ENDP ; stlp_std::priv::_Impl_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::_M_allocate_and_copy<CEventAPI::Deferred const *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_construct.h
_TEXT	ENDS
;	COMDAT ??$_Destroy_Range@PAVshared_str@@@stlp_std@@YAXPAVshared_str@@0@Z
_TEXT	SEGMENT
??$_Destroy_Range@PAVshared_str@@@stlp_std@@YAXPAVshared_str@@0@Z PROC ; stlp_std::_Destroy_Range<shared_str *>, COMDAT
; ___first$ = eax
; ___last$ = edx

; 181  :   __destroy_range(__first, __last, _STLP_VALUE_TYPE(__first, _ForwardIterator));

	cmp	eax, edx
	je	SHORT $LN5@Destroy_Ra@4
$LL7@Destroy_Ra@4:
	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN17@Destroy_Ra@4
	add	DWORD PTR [ecx], -1
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN17@Destroy_Ra@4
	mov	DWORD PTR [eax], 0
$LN17@Destroy_Ra@4:
	add	eax, 4
	cmp	eax, edx
	jne	SHORT $LL7@Destroy_Ra@4
$LN5@Destroy_Ra@4:

; 182  : }

	ret	0
??$_Destroy_Range@PAVshared_str@@@stlp_std@@YAXPAVshared_str@@0@Z ENDP ; stlp_std::_Destroy_Range<shared_str *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ??$_M_allocate_and_copy@PBQAX@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@AAEPAPAXAAIPBQAX1@Z
_TEXT	SEGMENT
??$_M_allocate_and_copy@PBQAX@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@AAEPAPAXAAIPBQAX1@Z PROC ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::_M_allocate_and_copy<void * const *>, COMDAT
; ___n$ = eax
; ___first$ = ebx
; ___last$ = ecx

; 634  :                                _ForwardIterator __first, _ForwardIterator __last)
; 635  : #else /* _STLP_MEMBER_TEMPLATES */
; 636  :   pointer _M_allocate_and_copy(size_type& __n,
; 637  :                                const_pointer __first, const_pointer __last)
; 638  : #endif /* _STLP_MEMBER_TEMPLATES */
; 639  :   {
; 640  :     pointer __result = this->_M_end_of_storage.allocate(__n, __n);

	mov	eax, DWORD PTR [eax]
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [eax*4]
	push	edi
	push	ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 641  :     _STLP_TRY {
; 642  :       uninitialized_copy(__first, __last, __result);

	cmp	esi, ebx
	mov	edi, eax
	je	SHORT $LN28@M_allocate@18
	sub	esi, ebx
	push	esi
	push	ebx
	push	edi
	call	_memcpy
	add	esp, 12					; 0000000cH

; 643  :       return __result;

	mov	eax, edi
$LN28@M_allocate@18:
	pop	edi
	pop	esi

; 644  :     }
; 645  :     _STLP_UNWIND(this->_M_end_of_storage.deallocate(__result, __n))
; 646  :     _STLP_RET_AFTER_THROW(__result)
; 647  :   }

	ret	0
??$_M_allocate_and_copy@PBQAX@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@AAEPAPAXAAIPBQAX1@Z ENDP ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::_M_allocate_and_copy<void * const *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_M_clear@?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@AAEXXZ
_TEXT	SEGMENT
?_M_clear@?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@AAEXXZ PROC ; stlp_std::priv::_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::_M_clear, COMDAT
; _this$ = eax

; 616  :     _STLP_STD::_Destroy_Range(rbegin(), rend());
; 617  :     this->_M_end_of_storage.deallocate(this->_M_start, this->_M_end_of_storage._M_data - this->_M_start);

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN31@M_clear@20
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN31@M_clear@20:

; 618  :   }

	ret	0
?_M_clear@?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@AAEXXZ ENDP ; stlp_std::priv::_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::_M_clear
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_M_clear@?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@AAEXXZ
_TEXT	SEGMENT
?_M_clear@?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@AAEXXZ PROC ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::_M_clear, COMDAT
; _this$ = eax

; 616  :     _STLP_STD::_Destroy_Range(rbegin(), rend());
; 617  :     this->_M_end_of_storage.deallocate(this->_M_start, this->_M_end_of_storage._M_data - this->_M_start);

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN31@M_clear@21
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN31@M_clear@21:

; 618  :   }

	ret	0
?_M_clear@?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@AAEXXZ ENDP ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::_M_clear
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_M_clear@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@AAEXXZ
_TEXT	SEGMENT
?_M_clear@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@AAEXXZ PROC ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::_M_clear, COMDAT
; _this$ = eax

; 616  :     _STLP_STD::_Destroy_Range(rbegin(), rend());
; 617  :     this->_M_end_of_storage.deallocate(this->_M_start, this->_M_end_of_storage._M_data - this->_M_start);

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN31@M_clear@22
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN31@M_clear@22:

; 618  :   }

	ret	0
?_M_clear@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@AAEXXZ ENDP ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::_M_clear
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_M_clear@?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@AAEXXZ
_TEXT	SEGMENT
?_M_clear@?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@AAEXXZ PROC ; stlp_std::priv::_Impl_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::_M_clear, COMDAT
; _this$ = eax

; 616  :     _STLP_STD::_Destroy_Range(rbegin(), rend());
; 617  :     this->_M_end_of_storage.deallocate(this->_M_start, this->_M_end_of_storage._M_data - this->_M_start);

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN31@M_clear@23
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN31@M_clear@23:

; 618  :   }

	ret	0
?_M_clear@?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@AAEXXZ ENDP ; stlp_std::priv::_Impl_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::_M_clear
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_M_clear@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@AAEXXZ
_TEXT	SEGMENT
?_M_clear@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@AAEXXZ PROC ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::_M_clear, COMDAT
; _this$ = eax

; 616  :     _STLP_STD::_Destroy_Range(rbegin(), rend());
; 617  :     this->_M_end_of_storage.deallocate(this->_M_start, this->_M_end_of_storage._M_data - this->_M_start);

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN31@M_clear@24
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN31@M_clear@24:

; 618  :   }

	ret	0
?_M_clear@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@AAEXXZ ENDP ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::_M_clear
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_construct.h
_TEXT	ENDS
;	COMDAT ??$_Destroy_Range@V?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@@stlp_std@@YAXV?$reverse_iterator@PAUItem@CSheduler@@@0@0@Z
_TEXT	SEGMENT
___first$ = 8						; size = 4
___last$ = 12						; size = 4
??$_Destroy_Range@V?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@@stlp_std@@YAXV?$reverse_iterator@PAUItem@CSheduler@@@0@0@Z PROC ; stlp_std::_Destroy_Range<stlp_std::reverse_iterator<CSheduler::Item *> >, COMDAT

; 181  :   __destroy_range(__first, __last, _STLP_VALUE_TYPE(__first, _ForwardIterator));

	mov	edx, DWORD PTR ___first$[esp-4]
	push	ecx
	mov	ecx, DWORD PTR ___last$[esp]
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	push	ecx
	mov	eax, esp
	mov	DWORD PTR [eax], edx
	call	??$__destroy_range@V?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@UItem@CSheduler@@@stlp_std@@YAXV?$reverse_iterator@PAUItem@CSheduler@@@0@0PAUItem@CSheduler@@@Z ; stlp_std::__destroy_range<stlp_std::reverse_iterator<CSheduler::Item *>,CSheduler::Item>
	add	esp, 8

; 182  : }

	ret	0
??$_Destroy_Range@V?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@@stlp_std@@YAXV?$reverse_iterator@PAUItem@CSheduler@@@0@0@Z ENDP ; stlp_std::_Destroy_Range<stlp_std::reverse_iterator<CSheduler::Item *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_Range@V?$reverse_iterator@PAVshared_str@@@stlp_std@@@stlp_std@@YAXV?$reverse_iterator@PAVshared_str@@@0@0@Z
_TEXT	SEGMENT
___first$ = 8						; size = 4
___last$ = 12						; size = 4
??$_Destroy_Range@V?$reverse_iterator@PAVshared_str@@@stlp_std@@@stlp_std@@YAXV?$reverse_iterator@PAVshared_str@@@0@0@Z PROC ; stlp_std::_Destroy_Range<stlp_std::reverse_iterator<shared_str *> >, COMDAT

; 181  :   __destroy_range(__first, __last, _STLP_VALUE_TYPE(__first, _ForwardIterator));

	mov	edx, DWORD PTR ___first$[esp-4]
	push	ecx
	mov	ecx, DWORD PTR ___last$[esp]
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	push	ecx
	mov	eax, esp
	mov	DWORD PTR [eax], edx
	call	??$__destroy_range@V?$reverse_iterator@PAVshared_str@@@stlp_std@@Vshared_str@@@stlp_std@@YAXV?$reverse_iterator@PAVshared_str@@@0@0PAVshared_str@@@Z ; stlp_std::__destroy_range<stlp_std::reverse_iterator<shared_str *>,shared_str>
	add	esp, 8

; 182  : }

	ret	0
??$_Destroy_Range@V?$reverse_iterator@PAVshared_str@@@stlp_std@@@stlp_std@@YAXV?$reverse_iterator@PAVshared_str@@@0@0@Z ENDP ; stlp_std::_Destroy_Range<stlp_std::reverse_iterator<shared_str *> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.c
_TEXT	ENDS
;	COMDAT ??4?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z
_TEXT	SEGMENT
tv420 = -4						; size = 4
___result$339104 = 8					; size = 4
___x$ = 8						; size = 4
??4?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z PROC ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::operator=, COMDAT
; _this$ = edi

; 177  : vector<_Tp, _Alloc>& vector<_Tp, _Alloc>::operator = (const vector<_Tp, _Alloc>& __x) {

	push	ecx

; 178  :   if (&__x != this) {

	mov	eax, DWORD PTR ___x$[esp]
	cmp	eax, edi
	push	ebx
	push	ebp
	push	esi
	je	$LN97@operator@70

; 179  :     const size_type __xlen = __x.size();

	mov	ebp, DWORD PTR [eax+4]
	mov	ebx, DWORD PTR [eax]
	mov	ecx, ebp
	sub	ecx, ebx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx

; 180  :     if (__xlen > capacity()) {

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [edi+8]
	sar	edx, 1
	sub	ecx, eax
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	esi, eax
	jbe	SHORT $LN4@operator@70

; 181  :       size_type __len = __xlen;
; 182  :       pointer __tmp = _M_allocate_and_copy(__len, __CONST_CAST(const_pointer, __x._M_start) + 0,
; 183  :                                                   __CONST_CAST(const_pointer, __x._M_finish) + 0);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	eax, DWORD PTR [esi+esi*2]
	add	eax, eax
	add	eax, eax
	push	eax
	mov	DWORD PTR tv420[esp+20], eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	cmp	ebp, ebx
	mov	DWORD PTR ___result$339104[esp+12], eax
	je	SHORT $LN39@operator@70
	sub	ebp, ebx
	push	ebp
	push	ebx
	push	eax
	call	_memcpy
	mov	eax, DWORD PTR ___result$339104[esp+24]
	add	esp, 12					; 0000000cH
$LN39@operator@70:

; 184  :       _M_clear();

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN70@operator@70
	push	ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	eax, DWORD PTR ___result$339104[esp+12]
$LN70@operator@70:

; 185  :       this->_M_start = __tmp;
; 186  :       this->_M_end_of_storage._M_data = this->_M_start + __len;

	mov	ecx, DWORD PTR tv420[esp+16]
	add	ecx, eax
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+8], ecx

; 196  :     }
; 197  :     this->_M_finish = this->_M_start + __xlen;

	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [esi+esi*2]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edi+4], edx

; 198  :   }
; 199  :   return *this;

	mov	eax, edi

; 200  : }

	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	4
$LN4@operator@70:

; 187  :     } else if (size() >= __xlen) {

	mov	edx, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi]
	sub	edx, ecx
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, esi
	jb	SHORT $LN2@operator@70

; 188  :       pointer __i = _STLP_PRIV __copy_ptrs(__CONST_CAST(const_pointer, __x._M_start) + 0,
; 189  :                                            __CONST_CAST(const_pointer, __x._M_finish) + 0, this->_M_start, _TrivialCopy());

	sub	ebp, ebx
	je	SHORT $LN96@operator@70
	push	ebp
	push	ebx
	push	ecx
	call	DWORD PTR __imp__memmove

; 190  :       _STLP_STD::_Destroy_Range(__i, this->_M_finish);
; 191  :     } else {

	jmp	SHORT $LN98@operator@70
$LN2@operator@70:

; 192  :       _STLP_PRIV __copy_ptrs(__CONST_CAST(const_pointer, __x._M_start),
; 193  :                              __CONST_CAST(const_pointer, __x._M_start) + size(), this->_M_start, _TrivialCopy());

	lea	eax, DWORD PTR [eax+eax*2]
	add	eax, eax
	add	eax, eax
	sub	eax, ebx
	add	eax, ebx
	je	SHORT $LN87@operator@70
	push	eax
	push	ebx
	push	ecx
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
$LN87@operator@70:

; 194  :       _STLP_PRIV __ucopy_ptrs(__CONST_CAST(const_pointer, __x._M_start) + size(),
; 195  :                               __CONST_CAST(const_pointer, __x._M_finish) + 0, this->_M_finish, _TrivialUCopy());

	mov	ebp, DWORD PTR [edi+4]
	mov	edx, DWORD PTR ___x$[esp+12]
	mov	ebx, DWORD PTR [edx+4]
	mov	ecx, ebp
	sub	ecx, DWORD PTR [edi]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	mov	ecx, DWORD PTR ___x$[esp+12]
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [edx+eax*4]
	cmp	ebx, eax
	je	SHORT $LN96@operator@70
	sub	ebx, eax
	push	ebx
	push	eax
	push	ebp
	call	_memcpy
$LN98@operator@70:
	add	esp, 12					; 0000000cH
$LN96@operator@70:

; 196  :     }
; 197  :     this->_M_finish = this->_M_start + __xlen;

	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [esi+esi*2]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edi+4], edx
$LN97@operator@70:

; 200  : }

	pop	esi
	pop	ebp
	mov	eax, edi
	pop	ebx
	pop	ecx
	ret	4
??4?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ENDP ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::operator=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z
_TEXT	SEGMENT
tv420 = -4						; size = 4
___result$339480 = 8					; size = 4
___x$ = 8						; size = 4
??4?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z PROC ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::operator=, COMDAT
; _this$ = edi

; 177  : vector<_Tp, _Alloc>& vector<_Tp, _Alloc>::operator = (const vector<_Tp, _Alloc>& __x) {

	push	ecx

; 178  :   if (&__x != this) {

	mov	eax, DWORD PTR ___x$[esp]
	cmp	eax, edi
	push	ebx
	push	ebp
	push	esi
	je	$LN97@operator@71

; 179  :     const size_type __xlen = __x.size();

	mov	ebp, DWORD PTR [eax+4]
	mov	ebx, DWORD PTR [eax]
	mov	ecx, ebp
	sub	ecx, ebx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx

; 180  :     if (__xlen > capacity()) {

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [edi+8]
	sar	edx, 1
	sub	ecx, eax
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	esi, eax
	jbe	SHORT $LN4@operator@71

; 181  :       size_type __len = __xlen;
; 182  :       pointer __tmp = _M_allocate_and_copy(__len, __CONST_CAST(const_pointer, __x._M_start) + 0,
; 183  :                                                   __CONST_CAST(const_pointer, __x._M_finish) + 0);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	eax, DWORD PTR [esi+esi*2]
	add	eax, eax
	add	eax, eax
	push	eax
	mov	DWORD PTR tv420[esp+20], eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	cmp	ebp, ebx
	mov	DWORD PTR ___result$339480[esp+12], eax
	je	SHORT $LN39@operator@71
	sub	ebp, ebx
	push	ebp
	push	ebx
	push	eax
	call	_memcpy
	mov	eax, DWORD PTR ___result$339480[esp+24]
	add	esp, 12					; 0000000cH
$LN39@operator@71:

; 184  :       _M_clear();

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN70@operator@71
	push	ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	eax, DWORD PTR ___result$339480[esp+12]
$LN70@operator@71:

; 185  :       this->_M_start = __tmp;
; 186  :       this->_M_end_of_storage._M_data = this->_M_start + __len;

	mov	ecx, DWORD PTR tv420[esp+16]
	add	ecx, eax
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+8], ecx

; 196  :     }
; 197  :     this->_M_finish = this->_M_start + __xlen;

	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [esi+esi*2]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edi+4], edx

; 198  :   }
; 199  :   return *this;

	mov	eax, edi

; 200  : }

	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	4
$LN4@operator@71:

; 187  :     } else if (size() >= __xlen) {

	mov	edx, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi]
	sub	edx, ecx
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, esi
	jb	SHORT $LN2@operator@71

; 188  :       pointer __i = _STLP_PRIV __copy_ptrs(__CONST_CAST(const_pointer, __x._M_start) + 0,
; 189  :                                            __CONST_CAST(const_pointer, __x._M_finish) + 0, this->_M_start, _TrivialCopy());

	sub	ebp, ebx
	je	SHORT $LN96@operator@71
	push	ebp
	push	ebx
	push	ecx
	call	DWORD PTR __imp__memmove

; 190  :       _STLP_STD::_Destroy_Range(__i, this->_M_finish);
; 191  :     } else {

	jmp	SHORT $LN98@operator@71
$LN2@operator@71:

; 192  :       _STLP_PRIV __copy_ptrs(__CONST_CAST(const_pointer, __x._M_start),
; 193  :                              __CONST_CAST(const_pointer, __x._M_start) + size(), this->_M_start, _TrivialCopy());

	lea	eax, DWORD PTR [eax+eax*2]
	add	eax, eax
	add	eax, eax
	sub	eax, ebx
	add	eax, ebx
	je	SHORT $LN87@operator@71
	push	eax
	push	ebx
	push	ecx
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
$LN87@operator@71:

; 194  :       _STLP_PRIV __ucopy_ptrs(__CONST_CAST(const_pointer, __x._M_start) + size(),
; 195  :                               __CONST_CAST(const_pointer, __x._M_finish) + 0, this->_M_finish, _TrivialUCopy());

	mov	ebp, DWORD PTR [edi+4]
	mov	edx, DWORD PTR ___x$[esp+12]
	mov	ebx, DWORD PTR [edx+4]
	mov	ecx, ebp
	sub	ecx, DWORD PTR [edi]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	mov	ecx, DWORD PTR ___x$[esp+12]
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [edx+eax*4]
	cmp	ebx, eax
	je	SHORT $LN96@operator@71
	sub	ebx, eax
	push	ebx
	push	eax
	push	ebp
	call	_memcpy
$LN98@operator@71:
	add	esp, 12					; 0000000cH
$LN96@operator@71:

; 196  :     }
; 197  :     this->_M_finish = this->_M_start + __xlen;

	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [esi+esi*2]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edi+4], edx
$LN97@operator@71:

; 200  : }

	pop	esi
	pop	ebp
	mov	eax, edi
	pop	ebx
	pop	ecx
	ret	4
??4?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ENDP ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::operator=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z
_TEXT	SEGMENT
tv420 = -4						; size = 4
___result$339820 = 8					; size = 4
___x$ = 8						; size = 4
??4?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z PROC ; stlp_std::priv::_Impl_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::operator=, COMDAT
; _this$ = edi

; 177  : vector<_Tp, _Alloc>& vector<_Tp, _Alloc>::operator = (const vector<_Tp, _Alloc>& __x) {

	push	ecx

; 178  :   if (&__x != this) {

	mov	eax, DWORD PTR ___x$[esp]
	cmp	eax, edi
	push	ebx
	push	ebp
	push	esi
	je	$LN97@operator@72

; 179  :     const size_type __xlen = __x.size();

	mov	ebp, DWORD PTR [eax+4]
	mov	ebx, DWORD PTR [eax]
	mov	ecx, ebp
	sub	ecx, ebx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx

; 180  :     if (__xlen > capacity()) {

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [edi+8]
	sar	edx, 2
	sub	ecx, eax
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	esi, eax
	jbe	SHORT $LN4@operator@72

; 181  :       size_type __len = __xlen;
; 182  :       pointer __tmp = _M_allocate_and_copy(__len, __CONST_CAST(const_pointer, __x._M_start) + 0,
; 183  :                                                   __CONST_CAST(const_pointer, __x._M_finish) + 0);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	eax, DWORD PTR [esi+esi*2]
	add	eax, eax
	add	eax, eax
	add	eax, eax
	push	eax
	mov	DWORD PTR tv420[esp+20], eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	cmp	ebp, ebx
	mov	DWORD PTR ___result$339820[esp+12], eax
	je	SHORT $LN39@operator@72
	sub	ebp, ebx
	push	ebp
	push	ebx
	push	eax
	call	_memcpy
	mov	eax, DWORD PTR ___result$339820[esp+24]
	add	esp, 12					; 0000000cH
$LN39@operator@72:

; 184  :       _M_clear();

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN70@operator@72
	push	ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	eax, DWORD PTR ___result$339820[esp+12]
$LN70@operator@72:

; 185  :       this->_M_start = __tmp;
; 186  :       this->_M_end_of_storage._M_data = this->_M_start + __len;

	mov	ecx, DWORD PTR tv420[esp+16]
	add	ecx, eax
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+8], ecx

; 196  :     }
; 197  :     this->_M_finish = this->_M_start + __xlen;

	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [esi+esi*2]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR [edi+4], edx

; 198  :   }
; 199  :   return *this;

	mov	eax, edi

; 200  : }

	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	4
$LN4@operator@72:

; 187  :     } else if (size() >= __xlen) {

	mov	edx, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi]
	sub	edx, ecx
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, esi
	jb	SHORT $LN2@operator@72

; 188  :       pointer __i = _STLP_PRIV __copy_ptrs(__CONST_CAST(const_pointer, __x._M_start) + 0,
; 189  :                                            __CONST_CAST(const_pointer, __x._M_finish) + 0, this->_M_start, _TrivialCopy());

	sub	ebp, ebx
	je	SHORT $LN96@operator@72
	push	ebp
	push	ebx
	push	ecx
	call	DWORD PTR __imp__memmove

; 190  :       _STLP_STD::_Destroy_Range(__i, this->_M_finish);
; 191  :     } else {

	jmp	SHORT $LN98@operator@72
$LN2@operator@72:

; 192  :       _STLP_PRIV __copy_ptrs(__CONST_CAST(const_pointer, __x._M_start),
; 193  :                              __CONST_CAST(const_pointer, __x._M_start) + size(), this->_M_start, _TrivialCopy());

	lea	eax, DWORD PTR [eax+eax*2]
	add	eax, eax
	add	eax, eax
	add	eax, eax
	sub	eax, ebx
	add	eax, ebx
	je	SHORT $LN87@operator@72
	push	eax
	push	ebx
	push	ecx
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
$LN87@operator@72:

; 194  :       _STLP_PRIV __ucopy_ptrs(__CONST_CAST(const_pointer, __x._M_start) + size(),
; 195  :                               __CONST_CAST(const_pointer, __x._M_finish) + 0, this->_M_finish, _TrivialUCopy());

	mov	ebp, DWORD PTR [edi+4]
	mov	edx, DWORD PTR ___x$[esp+12]
	mov	ebx, DWORD PTR [edx+4]
	mov	ecx, ebp
	sub	ecx, DWORD PTR [edi]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	mov	ecx, DWORD PTR ___x$[esp+12]
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [edx+eax*8]
	cmp	ebx, eax
	je	SHORT $LN96@operator@72
	sub	ebx, eax
	push	ebx
	push	eax
	push	ebp
	call	_memcpy
$LN98@operator@72:
	add	esp, 12					; 0000000cH
$LN96@operator@72:

; 196  :     }
; 197  :     this->_M_finish = this->_M_start + __xlen;

	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [esi+esi*2]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR [edi+4], edx
$LN97@operator@72:

; 200  : }

	pop	esi
	pop	ebp
	mov	eax, edi
	pop	ebx
	pop	ecx
	ret	4
??4?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ENDP ; stlp_std::priv::_Impl_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::operator=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEAAV012@ABV012@@Z
_TEXT	SEGMENT
___result$340228 = 8					; size = 4
___x$ = 8						; size = 4
??4?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEAAV012@ABV012@@Z PROC ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::operator=, COMDAT
; _this$ = ebx

; 178  :   if (&__x != this) {

	mov	ecx, DWORD PTR ___x$[esp-4]
	cmp	ecx, ebx
	push	ebp
	push	esi
	push	edi
	je	$LN97@operator@73

; 179  :     const size_type __xlen = __x.size();

	mov	edi, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [ecx]

; 180  :     if (__xlen > capacity()) {

	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [ebx+8]
	mov	ebp, edi
	sub	ebp, esi
	sub	eax, edx
	sar	ebp, 2
	sar	eax, 2
	cmp	ebp, eax
	jbe	SHORT $LN4@operator@73

; 181  :       size_type __len = __xlen;
; 182  :       pointer __tmp = _M_allocate_and_copy(__len, __CONST_CAST(const_pointer, __x._M_start) + 0,
; 183  :                                                   __CONST_CAST(const_pointer, __x._M_finish) + 0);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	eax, DWORD PTR [ebp*4]
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	cmp	edi, esi
	mov	DWORD PTR ___result$340228[esp+8], eax
	je	SHORT $LN39@operator@73
	sub	edi, esi
	push	edi
	push	esi
	push	eax
	call	_memcpy
	mov	eax, DWORD PTR ___result$340228[esp+20]
	add	esp, 12					; 0000000cH
$LN39@operator@73:

; 184  :       _M_clear();

	mov	ecx, DWORD PTR [ebx]
	test	ecx, ecx
	je	SHORT $LN70@operator@73
	push	ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	eax, DWORD PTR ___result$340228[esp+8]
$LN70@operator@73:

; 185  :       this->_M_start = __tmp;
; 186  :       this->_M_end_of_storage._M_data = this->_M_start + __len;

	lea	ecx, DWORD PTR [eax+ebp*4]

; 196  :     }
; 197  :     this->_M_finish = this->_M_start + __xlen;

	mov	edx, eax
	mov	DWORD PTR [ebx], eax
	lea	eax, DWORD PTR [edx+ebp*4]
	mov	DWORD PTR [ebx+4], eax
	mov	DWORD PTR [ebx+8], ecx

; 198  :   }
; 199  :   return *this;

	mov	eax, ebx

; 200  : }

	pop	edi
	pop	esi
	pop	ebp
	ret	4
$LN4@operator@73:

; 187  :     } else if (size() >= __xlen) {

	mov	eax, DWORD PTR [ebx+4]
	sub	eax, edx
	sar	eax, 2
	cmp	eax, ebp
	jb	SHORT $LN2@operator@73

; 188  :       pointer __i = _STLP_PRIV __copy_ptrs(__CONST_CAST(const_pointer, __x._M_start) + 0,
; 189  :                                            __CONST_CAST(const_pointer, __x._M_finish) + 0, this->_M_start, _TrivialCopy());

	sub	edi, esi
	je	SHORT $LN96@operator@73
	push	edi
	push	esi
	push	edx
	call	DWORD PTR __imp__memmove

; 196  :     }
; 197  :     this->_M_finish = this->_M_start + __xlen;

	mov	edx, DWORD PTR [ebx]
	lea	eax, DWORD PTR [edx+ebp*4]
	mov	DWORD PTR [ebx+4], eax
	add	esp, 12					; 0000000cH

; 198  :   }
; 199  :   return *this;

	mov	eax, ebx

; 200  : }

	pop	edi
	pop	esi
	pop	ebp
	ret	4
$LN2@operator@73:

; 190  :       _STLP_STD::_Destroy_Range(__i, this->_M_finish);
; 191  :     } else {
; 192  :       _STLP_PRIV __copy_ptrs(__CONST_CAST(const_pointer, __x._M_start),
; 193  :                              __CONST_CAST(const_pointer, __x._M_start) + size(), this->_M_start, _TrivialCopy());

	add	eax, eax
	add	eax, eax
	sub	eax, esi
	add	eax, esi
	je	SHORT $LN87@operator@73
	push	eax
	push	esi
	push	edx
	call	DWORD PTR __imp__memmove
	mov	ecx, DWORD PTR ___x$[esp+20]
	add	esp, 12					; 0000000cH
$LN87@operator@73:

; 194  :       _STLP_PRIV __ucopy_ptrs(__CONST_CAST(const_pointer, __x._M_start) + size(),
; 195  :                               __CONST_CAST(const_pointer, __x._M_finish) + 0, this->_M_finish, _TrivialUCopy());

	mov	edx, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	mov	esi, edx
	sub	esi, DWORD PTR [ebx]
	sar	esi, 2
	lea	ecx, DWORD PTR [ecx+esi*4]
	cmp	eax, ecx
	je	SHORT $LN96@operator@73
	sub	eax, ecx
	push	eax
	push	ecx
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN96@operator@73:

; 196  :     }
; 197  :     this->_M_finish = this->_M_start + __xlen;

	mov	edx, DWORD PTR [ebx]
	lea	eax, DWORD PTR [edx+ebp*4]
	mov	DWORD PTR [ebx+4], eax
$LN97@operator@73:

; 200  : }

	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebp
	ret	4
??4?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ENDP ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::operator=
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ??0?$_Vector_base@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE@ABV?$xalloc@U_REG_INFO@@@@@Z
_TEXT	SEGMENT
??0?$_Vector_base@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE@ABV?$xalloc@U_REG_INFO@@@@@Z PROC ; stlp_std::priv::_Vector_base<_REG_INFO,xalloc<_REG_INFO> >::_Vector_base<_REG_INFO,xalloc<_REG_INFO> >, COMDAT
; _this$ = eax

; 67   :     : _M_start(0), _M_finish(0), _M_end_of_storage(__a, 0) {}

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$_Vector_base@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE@ABV?$xalloc@U_REG_INFO@@@@@Z ENDP ; stlp_std::priv::_Vector_base<_REG_INFO,xalloc<_REG_INFO> >::_Vector_base<_REG_INFO,xalloc<_REG_INFO> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE@ABV?$xalloc@U_REG_INFO@@@@@Z
_TEXT	SEGMENT
??0?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE@ABV?$xalloc@U_REG_INFO@@@@@Z PROC ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >, COMDAT
; _this$ = eax

; 208  :     : _STLP_PRIV _Vector_base<_Tp, _Alloc>(__a) {}

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE@ABV?$xalloc@U_REG_INFO@@@@@Z ENDP ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ??0?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@stlp_std@@QAE@ABV?$xalloc@U_REG_INFO@@@@@Z
_TEXT	SEGMENT
??0?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@stlp_std@@QAE@ABV?$xalloc@U_REG_INFO@@@@@Z PROC ; stlp_std::vector<_REG_INFO,xalloc<_REG_INFO> >::vector<_REG_INFO,xalloc<_REG_INFO> >, COMDAT
; _this$ = eax

; 106  :   explicit vector(const allocator_type& __a = allocator_type())

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@stlp_std@@QAE@ABV?$xalloc@U_REG_INFO@@@@@Z ENDP ; stlp_std::vector<_REG_INFO,xalloc<_REG_INFO> >::vector<_REG_INFO,xalloc<_REG_INFO> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@stlp_std@@QAE@ABV?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@Z
_TEXT	SEGMENT
??0?$vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@stlp_std@@QAE@ABV?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@Z PROC ; stlp_std::vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >, COMDAT
; _this$ = eax

; 106  :   explicit vector(const allocator_type& __a = allocator_type())

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@stlp_std@@QAE@ABV?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@Z ENDP ; stlp_std::vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ??0?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QAE@XZ PROC ; xr_vector<_REG_INFO,xalloc<_REG_INFO> >::xr_vector<_REG_INFO,xalloc<_REG_INFO> >, COMDAT
; _this$ = eax

; 123  : 			xr_vector			()									: inherited	()					{}

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QAE@XZ ENDP ; xr_vector<_REG_INFO,xalloc<_REG_INFO> >::xr_vector<_REG_INFO,xalloc<_REG_INFO> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ??0?$vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@stlp_std@@QAE@ABV?$xalloc@UItemReg@CSheduler@@@@@Z
_TEXT	SEGMENT
??0?$vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@stlp_std@@QAE@ABV?$xalloc@UItemReg@CSheduler@@@@@Z PROC ; stlp_std::vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >, COMDAT
; _this$ = eax

; 106  :   explicit vector(const allocator_type& __a = allocator_type())

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@stlp_std@@QAE@ABV?$xalloc@UItemReg@CSheduler@@@@@Z ENDP ; stlp_std::vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@stlp_std@@QAE@ABV?$xalloc@UDeferred@CEventAPI@@@@@Z
_TEXT	SEGMENT
??0?$vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@stlp_std@@QAE@ABV?$xalloc@UDeferred@CEventAPI@@@@@Z PROC ; stlp_std::vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >, COMDAT
; _this$ = eax

; 106  :   explicit vector(const allocator_type& __a = allocator_type())

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@stlp_std@@QAE@ABV?$xalloc@UDeferred@CEventAPI@@@@@Z ENDP ; stlp_std::vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$vector@PAVCEvent@@V?$xalloc@PAVCEvent@@@@@stlp_std@@QAE@ABV?$xalloc@PAVCEvent@@@@@Z
_TEXT	SEGMENT
??0?$vector@PAVCEvent@@V?$xalloc@PAVCEvent@@@@@stlp_std@@QAE@ABV?$xalloc@PAVCEvent@@@@@Z PROC ; stlp_std::vector<CEvent *,xalloc<CEvent *> >::vector<CEvent *,xalloc<CEvent *> >, COMDAT
; _this$ = eax

; 106  :   explicit vector(const allocator_type& __a = allocator_type())

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$vector@PAVCEvent@@V?$xalloc@PAVCEvent@@@@@stlp_std@@QAE@ABV?$xalloc@PAVCEvent@@@@@Z ENDP ; stlp_std::vector<CEvent *,xalloc<CEvent *> >::vector<CEvent *,xalloc<CEvent *> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ??0?$xr_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@@QAE@XZ PROC ; xr_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::xr_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >, COMDAT
; _this$ = eax

; 123  : 			xr_vector			()									: inherited	()					{}

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$xr_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@@QAE@XZ ENDP ; xr_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::xr_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\pure.h
_TEXT	ENDS
;	COMDAT ??0?$CRegistrator@VpureDeviceReset@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CRegistrator@VpureDeviceReset@@@@QAE@XZ PROC	; CRegistrator<pureDeviceReset>::CRegistrator<pureDeviceReset>, COMDAT
; _this$ = eax

; 53   : 	CRegistrator()			{ in_process=false; changed=false;}

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	and	DWORD PTR [eax+12], -4			; fffffffcH
	ret	0
??0?$CRegistrator@VpureDeviceReset@@@@QAE@XZ ENDP	; CRegistrator<pureDeviceReset>::CRegistrator<pureDeviceReset>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$CRegistrator@VpureScreenResolutionChanged@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CRegistrator@VpureScreenResolutionChanged@@@@QAE@XZ PROC ; CRegistrator<pureScreenResolutionChanged>::CRegistrator<pureScreenResolutionChanged>, COMDAT
; _this$ = eax

; 53   : 	CRegistrator()			{ in_process=false; changed=false;}

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	and	DWORD PTR [eax+12], -4			; fffffffcH
	ret	0
??0?$CRegistrator@VpureScreenResolutionChanged@@@@QAE@XZ ENDP ; CRegistrator<pureScreenResolutionChanged>::CRegistrator<pureScreenResolutionChanged>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$CRegistrator@VpureFrame@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CRegistrator@VpureFrame@@@@QAE@XZ PROC		; CRegistrator<pureFrame>::CRegistrator<pureFrame>, COMDAT
; _this$ = eax

; 53   : 	CRegistrator()			{ in_process=false; changed=false;}

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	and	DWORD PTR [eax+12], -4			; fffffffcH
	ret	0
??0?$CRegistrator@VpureFrame@@@@QAE@XZ ENDP		; CRegistrator<pureFrame>::CRegistrator<pureFrame>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$CRegistrator@VpureAppEnd@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CRegistrator@VpureAppEnd@@@@QAE@XZ PROC		; CRegistrator<pureAppEnd>::CRegistrator<pureAppEnd>, COMDAT
; _this$ = eax

; 53   : 	CRegistrator()			{ in_process=false; changed=false;}

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	and	DWORD PTR [eax+12], -4			; fffffffcH
	ret	0
??0?$CRegistrator@VpureAppEnd@@@@QAE@XZ ENDP		; CRegistrator<pureAppEnd>::CRegistrator<pureAppEnd>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$CRegistrator@VpureAppStart@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CRegistrator@VpureAppStart@@@@QAE@XZ PROC		; CRegistrator<pureAppStart>::CRegistrator<pureAppStart>, COMDAT
; _this$ = eax

; 53   : 	CRegistrator()			{ in_process=false; changed=false;}

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	and	DWORD PTR [eax+12], -4			; fffffffcH
	ret	0
??0?$CRegistrator@VpureAppStart@@@@QAE@XZ ENDP		; CRegistrator<pureAppStart>::CRegistrator<pureAppStart>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$CRegistrator@VpureAppDeactivate@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CRegistrator@VpureAppDeactivate@@@@QAE@XZ PROC	; CRegistrator<pureAppDeactivate>::CRegistrator<pureAppDeactivate>, COMDAT
; _this$ = eax

; 53   : 	CRegistrator()			{ in_process=false; changed=false;}

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	and	DWORD PTR [eax+12], -4			; fffffffcH
	ret	0
??0?$CRegistrator@VpureAppDeactivate@@@@QAE@XZ ENDP	; CRegistrator<pureAppDeactivate>::CRegistrator<pureAppDeactivate>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$CRegistrator@VpureAppActivate@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CRegistrator@VpureAppActivate@@@@QAE@XZ PROC	; CRegistrator<pureAppActivate>::CRegistrator<pureAppActivate>, COMDAT
; _this$ = eax

; 53   : 	CRegistrator()			{ in_process=false; changed=false;}

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	and	DWORD PTR [eax+12], -4			; fffffffcH
	ret	0
??0?$CRegistrator@VpureAppActivate@@@@QAE@XZ ENDP	; CRegistrator<pureAppActivate>::CRegistrator<pureAppActivate>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$CRegistrator@VpureRender@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CRegistrator@VpureRender@@@@QAE@XZ PROC		; CRegistrator<pureRender>::CRegistrator<pureRender>, COMDAT
; _this$ = eax

; 53   : 	CRegistrator()			{ in_process=false; changed=false;}

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	and	DWORD PTR [eax+12], -4			; fffffffcH
	ret	0
??0?$CRegistrator@VpureRender@@@@QAE@XZ ENDP		; CRegistrator<pureRender>::CRegistrator<pureRender>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ??4?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@stlp_std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
??4?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@stlp_std@@QAEAAV01@ABV01@@Z PROC ; stlp_std::vector<_REG_INFO,xalloc<_REG_INFO> >::operator=, COMDAT
; _this$ = ecx
; ___x$ = eax

; 149  :   _Self& operator=(const _Self& __x) { _M_impl = __x._M_impl; return *this; }

	push	edi
	mov	edi, ecx
	push	eax
	call	??4?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::operator=
	mov	eax, edi
	pop	edi
	ret	0
??4?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@stlp_std@@QAEAAV01@ABV01@@Z ENDP ; stlp_std::vector<_REG_INFO,xalloc<_REG_INFO> >::operator=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4?$vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@stlp_std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
??4?$vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@stlp_std@@QAEAAV01@ABV01@@Z PROC ; stlp_std::vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::operator=, COMDAT
; _this$ = ecx
; ___x$ = eax

; 149  :   _Self& operator=(const _Self& __x) { _M_impl = __x._M_impl; return *this; }

	push	edi
	mov	edi, ecx
	push	eax
	call	??4?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::operator=
	mov	eax, edi
	pop	edi
	ret	0
??4?$vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@stlp_std@@QAEAAV01@ABV01@@Z ENDP ; stlp_std::vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::operator=
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ??0?$xr_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@@QAE@XZ PROC ; xr_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::xr_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >, COMDAT
; _this$ = eax

; 123  : 			xr_vector			()									: inherited	()					{}

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$xr_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@@QAE@XZ ENDP ; xr_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::xr_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ??1?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAE@XZ PROC ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::~_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >, COMDAT
; _this$ = eax

; 286  :   ~vector() { _STLP_STD::_Destroy_Range(rbegin(), rend()); }

	push	esi
	mov	esi, eax
	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi]
	push	ecx
	mov	edx, esp
	mov	DWORD PTR [edx], eax
	push	ecx
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	call	??$__destroy_range@V?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@UItem@CSheduler@@@stlp_std@@YAXV?$reverse_iterator@PAUItem@CSheduler@@@0@0PAUItem@CSheduler@@@Z ; stlp_std::__destroy_range<stlp_std::reverse_iterator<CSheduler::Item *>,CSheduler::Item>
	mov	esi, DWORD PTR [esi]
	add	esp, 8
	test	esi, esi
	je	SHORT $LN26@Impl_vecto@41
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN26@Impl_vecto@41:
	pop	esi
	ret	0
??1?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAE@XZ ENDP ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::~_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ??4?$vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@stlp_std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
??4?$vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@stlp_std@@QAEAAV01@ABV01@@Z PROC ; stlp_std::vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::operator=, COMDAT
; _this$ = ecx
; ___x$ = eax

; 149  :   _Self& operator=(const _Self& __x) { _M_impl = __x._M_impl; return *this; }

	push	edi
	mov	edi, ecx
	push	eax
	call	??4?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::operator=
	mov	eax, edi
	pop	edi
	ret	0
??4?$vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@stlp_std@@QAEAAV01@ABV01@@Z ENDP ; stlp_std::vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::operator=
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ??0?$xr_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@@QAE@XZ PROC ; xr_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::xr_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >, COMDAT
; _this$ = eax

; 123  : 			xr_vector			()									: inherited	()					{}

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$xr_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@@QAE@XZ ENDP ; xr_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::xr_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ??4?$vector@PAVCEvent@@V?$xalloc@PAVCEvent@@@@@stlp_std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
??4?$vector@PAVCEvent@@V?$xalloc@PAVCEvent@@@@@stlp_std@@QAEAAV01@ABV01@@Z PROC ; stlp_std::vector<CEvent *,xalloc<CEvent *> >::operator=, COMDAT
; _this$ = ecx
; ___x$ = eax

; 149  :   _Self& operator=(const _Self& __x) { _M_impl = __x._M_impl; return *this; }

	push	ebx
	mov	ebx, ecx
	push	eax
	call	??4?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::operator=
	mov	eax, ebx
	pop	ebx
	ret	0
??4?$vector@PAVCEvent@@V?$xalloc@PAVCEvent@@@@@stlp_std@@QAEAAV01@ABV01@@Z ENDP ; stlp_std::vector<CEvent *,xalloc<CEvent *> >::operator=
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ??0?$xr_vector@PAVCEvent@@V?$xalloc@PAVCEvent@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@PAVCEvent@@V?$xalloc@PAVCEvent@@@@@@QAE@XZ PROC ; xr_vector<CEvent *,xalloc<CEvent *> >::xr_vector<CEvent *,xalloc<CEvent *> >, COMDAT
; _this$ = eax

; 123  : 			xr_vector			()									: inherited	()					{}

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$xr_vector@PAVCEvent@@V?$xalloc@PAVCEvent@@@@@@QAE@XZ ENDP ; xr_vector<CEvent *,xalloc<CEvent *> >::xr_vector<CEvent *,xalloc<CEvent *> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ??1?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAE@XZ PROC ; stlp_std::priv::_Impl_vector<shared_str,xalloc<shared_str> >::~_Impl_vector<shared_str,xalloc<shared_str> >, COMDAT
; _this$ = eax

; 286  :   ~vector() { _STLP_STD::_Destroy_Range(rbegin(), rend()); }

	push	esi
	mov	esi, eax
	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi]
	push	ecx
	mov	edx, esp
	mov	DWORD PTR [edx], eax
	push	ecx
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	call	??$__destroy_range@V?$reverse_iterator@PAVshared_str@@@stlp_std@@Vshared_str@@@stlp_std@@YAXV?$reverse_iterator@PAVshared_str@@@0@0PAVshared_str@@@Z ; stlp_std::__destroy_range<stlp_std::reverse_iterator<shared_str *>,shared_str>
	mov	esi, DWORD PTR [esi]
	add	esp, 8
	test	esi, esi
	je	SHORT $LN26@Impl_vecto@42
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN26@Impl_vecto@42:
	pop	esi
	ret	0
??1?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAE@XZ ENDP ; stlp_std::priv::_Impl_vector<shared_str,xalloc<shared_str> >::~_Impl_vector<shared_str,xalloc<shared_str> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$CRegistrator@VpureDeviceReset@@@@QAE@XZ
_TEXT	SEGMENT
??1?$CRegistrator@VpureDeviceReset@@@@QAE@XZ PROC	; CRegistrator<pureDeviceReset>::~CRegistrator<pureDeviceReset>, COMDAT
; _this$ = eax
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN40@CRegistrat@2
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN40@CRegistrat@2:
	ret	0
??1?$CRegistrator@VpureDeviceReset@@@@QAE@XZ ENDP	; CRegistrator<pureDeviceReset>::~CRegistrator<pureDeviceReset>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$CRegistrator@VpureScreenResolutionChanged@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
??0?$CRegistrator@VpureScreenResolutionChanged@@@@QAE@ABV0@@Z PROC ; CRegistrator<pureScreenResolutionChanged>::CRegistrator<pureScreenResolutionChanged>, COMDAT
; _this$ = eax
; ___that$ = edi
	push	esi
	mov	esi, eax
	mov	eax, edi
	call	??0?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE@ABV012@@Z ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >
	mov	eax, DWORD PTR [esi+12]
	xor	eax, DWORD PTR [edi+12]
	and	eax, 1
	xor	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [edi+12]
	xor	ecx, eax
	and	ecx, 2
	xor	ecx, eax
	mov	DWORD PTR [esi+12], ecx
	mov	eax, esi
	pop	esi
	ret	0
??0?$CRegistrator@VpureScreenResolutionChanged@@@@QAE@ABV0@@Z ENDP ; CRegistrator<pureScreenResolutionChanged>::CRegistrator<pureScreenResolutionChanged>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$CRegistrator@VpureFrame@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
??0?$CRegistrator@VpureFrame@@@@QAE@ABV0@@Z PROC	; CRegistrator<pureFrame>::CRegistrator<pureFrame>, COMDAT
; _this$ = eax
; ___that$ = edi
	push	esi
	mov	esi, eax
	mov	eax, edi
	call	??0?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE@ABV012@@Z ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >
	mov	eax, DWORD PTR [esi+12]
	xor	eax, DWORD PTR [edi+12]
	and	eax, 1
	xor	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [edi+12]
	xor	ecx, eax
	and	ecx, 2
	xor	ecx, eax
	mov	DWORD PTR [esi+12], ecx
	mov	eax, esi
	pop	esi
	ret	0
??0?$CRegistrator@VpureFrame@@@@QAE@ABV0@@Z ENDP	; CRegistrator<pureFrame>::CRegistrator<pureFrame>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$CRegistrator@VpureAppEnd@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
??0?$CRegistrator@VpureAppEnd@@@@QAE@ABV0@@Z PROC	; CRegistrator<pureAppEnd>::CRegistrator<pureAppEnd>, COMDAT
; _this$ = eax
; ___that$ = edi
	push	esi
	mov	esi, eax
	mov	eax, edi
	call	??0?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE@ABV012@@Z ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >
	mov	eax, DWORD PTR [esi+12]
	xor	eax, DWORD PTR [edi+12]
	and	eax, 1
	xor	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [edi+12]
	xor	ecx, eax
	and	ecx, 2
	xor	ecx, eax
	mov	DWORD PTR [esi+12], ecx
	mov	eax, esi
	pop	esi
	ret	0
??0?$CRegistrator@VpureAppEnd@@@@QAE@ABV0@@Z ENDP	; CRegistrator<pureAppEnd>::CRegistrator<pureAppEnd>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$CRegistrator@VpureAppStart@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
??0?$CRegistrator@VpureAppStart@@@@QAE@ABV0@@Z PROC	; CRegistrator<pureAppStart>::CRegistrator<pureAppStart>, COMDAT
; _this$ = eax
; ___that$ = edi
	push	esi
	mov	esi, eax
	mov	eax, edi
	call	??0?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE@ABV012@@Z ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >
	mov	eax, DWORD PTR [esi+12]
	xor	eax, DWORD PTR [edi+12]
	and	eax, 1
	xor	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [edi+12]
	xor	ecx, eax
	and	ecx, 2
	xor	ecx, eax
	mov	DWORD PTR [esi+12], ecx
	mov	eax, esi
	pop	esi
	ret	0
??0?$CRegistrator@VpureAppStart@@@@QAE@ABV0@@Z ENDP	; CRegistrator<pureAppStart>::CRegistrator<pureAppStart>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$CRegistrator@VpureAppDeactivate@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
??0?$CRegistrator@VpureAppDeactivate@@@@QAE@ABV0@@Z PROC ; CRegistrator<pureAppDeactivate>::CRegistrator<pureAppDeactivate>, COMDAT
; _this$ = eax
; ___that$ = edi
	push	esi
	mov	esi, eax
	mov	eax, edi
	call	??0?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE@ABV012@@Z ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >
	mov	eax, DWORD PTR [esi+12]
	xor	eax, DWORD PTR [edi+12]
	and	eax, 1
	xor	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [edi+12]
	xor	ecx, eax
	and	ecx, 2
	xor	ecx, eax
	mov	DWORD PTR [esi+12], ecx
	mov	eax, esi
	pop	esi
	ret	0
??0?$CRegistrator@VpureAppDeactivate@@@@QAE@ABV0@@Z ENDP ; CRegistrator<pureAppDeactivate>::CRegistrator<pureAppDeactivate>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$CRegistrator@VpureAppActivate@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
??0?$CRegistrator@VpureAppActivate@@@@QAE@ABV0@@Z PROC	; CRegistrator<pureAppActivate>::CRegistrator<pureAppActivate>, COMDAT
; _this$ = eax
; ___that$ = edi
	push	esi
	mov	esi, eax
	mov	eax, edi
	call	??0?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE@ABV012@@Z ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >
	mov	eax, DWORD PTR [esi+12]
	xor	eax, DWORD PTR [edi+12]
	and	eax, 1
	xor	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [edi+12]
	xor	ecx, eax
	and	ecx, 2
	xor	ecx, eax
	mov	DWORD PTR [esi+12], ecx
	mov	eax, esi
	pop	esi
	ret	0
??0?$CRegistrator@VpureAppActivate@@@@QAE@ABV0@@Z ENDP	; CRegistrator<pureAppActivate>::CRegistrator<pureAppActivate>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$CRegistrator@VpureRender@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
??0?$CRegistrator@VpureRender@@@@QAE@ABV0@@Z PROC	; CRegistrator<pureRender>::CRegistrator<pureRender>, COMDAT
; _this$ = eax
; ___that$ = edi
	push	esi
	mov	esi, eax
	mov	eax, edi
	call	??0?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE@ABV012@@Z ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >
	mov	eax, DWORD PTR [esi+12]
	xor	eax, DWORD PTR [edi+12]
	and	eax, 1
	xor	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [edi+12]
	xor	ecx, eax
	and	ecx, 2
	xor	ecx, eax
	mov	DWORD PTR [esi+12], ecx
	mov	eax, esi
	pop	esi
	ret	0
??0?$CRegistrator@VpureRender@@@@QAE@ABV0@@Z ENDP	; CRegistrator<pureRender>::CRegistrator<pureRender>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$CRegistrator@VpureScreenResolutionChanged@@@@QAE@XZ
_TEXT	SEGMENT
??1?$CRegistrator@VpureScreenResolutionChanged@@@@QAE@XZ PROC ; CRegistrator<pureScreenResolutionChanged>::~CRegistrator<pureScreenResolutionChanged>, COMDAT
; _this$ = eax
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN40@CRegistrat@3
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN40@CRegistrat@3:
	ret	0
??1?$CRegistrator@VpureScreenResolutionChanged@@@@QAE@XZ ENDP ; CRegistrator<pureScreenResolutionChanged>::~CRegistrator<pureScreenResolutionChanged>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$CRegistrator@VpureFrame@@@@QAE@XZ
_TEXT	SEGMENT
??1?$CRegistrator@VpureFrame@@@@QAE@XZ PROC		; CRegistrator<pureFrame>::~CRegistrator<pureFrame>, COMDAT
; _this$ = eax
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN40@CRegistrat@4
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN40@CRegistrat@4:
	ret	0
??1?$CRegistrator@VpureFrame@@@@QAE@XZ ENDP		; CRegistrator<pureFrame>::~CRegistrator<pureFrame>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$CRegistrator@VpureAppEnd@@@@QAE@XZ
_TEXT	SEGMENT
??1?$CRegistrator@VpureAppEnd@@@@QAE@XZ PROC		; CRegistrator<pureAppEnd>::~CRegistrator<pureAppEnd>, COMDAT
; _this$ = eax
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN40@CRegistrat@5
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN40@CRegistrat@5:
	ret	0
??1?$CRegistrator@VpureAppEnd@@@@QAE@XZ ENDP		; CRegistrator<pureAppEnd>::~CRegistrator<pureAppEnd>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$CRegistrator@VpureAppStart@@@@QAE@XZ
_TEXT	SEGMENT
??1?$CRegistrator@VpureAppStart@@@@QAE@XZ PROC		; CRegistrator<pureAppStart>::~CRegistrator<pureAppStart>, COMDAT
; _this$ = eax
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN40@CRegistrat@6
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN40@CRegistrat@6:
	ret	0
??1?$CRegistrator@VpureAppStart@@@@QAE@XZ ENDP		; CRegistrator<pureAppStart>::~CRegistrator<pureAppStart>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$CRegistrator@VpureAppDeactivate@@@@QAE@XZ
_TEXT	SEGMENT
??1?$CRegistrator@VpureAppDeactivate@@@@QAE@XZ PROC	; CRegistrator<pureAppDeactivate>::~CRegistrator<pureAppDeactivate>, COMDAT
; _this$ = eax
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN40@CRegistrat@7
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN40@CRegistrat@7:
	ret	0
??1?$CRegistrator@VpureAppDeactivate@@@@QAE@XZ ENDP	; CRegistrator<pureAppDeactivate>::~CRegistrator<pureAppDeactivate>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$CRegistrator@VpureAppActivate@@@@QAE@XZ
_TEXT	SEGMENT
??1?$CRegistrator@VpureAppActivate@@@@QAE@XZ PROC	; CRegistrator<pureAppActivate>::~CRegistrator<pureAppActivate>, COMDAT
; _this$ = eax
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN40@CRegistrat@8
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN40@CRegistrat@8:
	ret	0
??1?$CRegistrator@VpureAppActivate@@@@QAE@XZ ENDP	; CRegistrator<pureAppActivate>::~CRegistrator<pureAppActivate>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$CRegistrator@VpureRender@@@@QAE@XZ
_TEXT	SEGMENT
??1?$CRegistrator@VpureRender@@@@QAE@XZ PROC		; CRegistrator<pureRender>::~CRegistrator<pureRender>, COMDAT
; _this$ = eax
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN40@CRegistrat@9
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN40@CRegistrat@9:
	ret	0
??1?$CRegistrator@VpureRender@@@@QAE@XZ ENDP		; CRegistrator<pureRender>::~CRegistrator<pureRender>
_TEXT	ENDS
PUBLIC	??0CRenderDeviceData@@QAE@ABV0@@Z		; CRenderDeviceData::CRenderDeviceData
; Function compile flags: /Ogtpy
;	COMDAT ??0CRenderDeviceData@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0CRenderDeviceData@@QAE@ABV0@@Z PROC			; CRenderDeviceData::CRenderDeviceData, COMDAT
; _this$ = ecx
	push	ebx
	mov	ebx, ecx
	push	ebp
	mov	ebp, DWORD PTR ___that$[esp+4]
	mov	eax, DWORD PTR [ebp]
	mov	DWORD PTR [ebx], eax
	mov	ecx, DWORD PTR [ebp+4]
	mov	DWORD PTR [ebx+4], ecx
	mov	edx, DWORD PTR [ebp+8]
	mov	DWORD PTR [ebx+8], edx
	mov	eax, DWORD PTR [ebp+12]
	mov	DWORD PTR [ebx+12], eax
	mov	ecx, DWORD PTR [ebp+16]
	mov	DWORD PTR [ebx+16], ecx
	mov	edx, DWORD PTR [ebp+20]
	mov	DWORD PTR [ebx+20], edx
	fld	DWORD PTR [ebp+24]
	fstp	DWORD PTR [ebx+24]
	push	esi
	fld	DWORD PTR [ebp+28]
	push	edi
	fstp	DWORD PTR [ebx+28]
	mov	eax, DWORD PTR [ebp+32]
	mov	DWORD PTR [ebx+32], eax
	mov	ecx, DWORD PTR [ebp+36]
	mov	DWORD PTR [ebx+36], ecx
	mov	edx, DWORD PTR [ebp+40]
	mov	DWORD PTR [ebx+40], edx
	mov	eax, DWORD PTR [ebp+44]
	mov	DWORD PTR [ebx+44], eax
	mov	ecx, DWORD PTR [ebp+48]
	mov	DWORD PTR [ebx+48], ecx
	mov	edx, DWORD PTR [ebp+52]
	mov	DWORD PTR [ebx+52], edx
	mov	eax, DWORD PTR [ebp+56]
	mov	DWORD PTR [ebx+56], eax
	mov	ecx, DWORD PTR [ebp+60]
	mov	DWORD PTR [ebx+60], ecx
	mov	edx, DWORD PTR [ebp+64]
	mov	DWORD PTR [ebx+64], edx
	mov	eax, DWORD PTR [ebp+68]
	mov	DWORD PTR [ebx+68], eax
	mov	ecx, DWORD PTR [ebp+72]
	mov	DWORD PTR [ebx+72], ecx
	mov	edx, DWORD PTR [ebp+76]
	mov	DWORD PTR [ebx+76], edx
	mov	eax, DWORD PTR [ebp+80]
	mov	DWORD PTR [ebx+80], eax
	mov	ecx, DWORD PTR [ebp+84]
	mov	DWORD PTR [ebx+84], ecx
	mov	edx, DWORD PTR [ebp+88]
	mov	DWORD PTR [ebx+88], edx
	lea	esi, DWORD PTR [ebp+92]
	lea	edi, DWORD PTR [ebx+92]
	mov	ecx, 16					; 00000010H
	rep movsd
	lea	esi, DWORD PTR [ebp+156]
	lea	edi, DWORD PTR [ebx+156]
	mov	ecx, 16					; 00000010H
	rep movsd
	lea	esi, DWORD PTR [ebp+220]
	lea	edi, DWORD PTR [ebx+220]
	mov	ecx, 16					; 00000010H
	rep movsd
	mov	eax, DWORD PTR [ebp+284]
	mov	DWORD PTR [ebx+284], eax
	mov	ecx, DWORD PTR [ebp+288]
	mov	DWORD PTR [ebx+288], ecx
	mov	edx, DWORD PTR [ebp+292]
	mov	DWORD PTR [ebx+292], edx
	lea	esi, DWORD PTR [ebp+296]
	lea	edi, DWORD PTR [ebx+296]
	mov	ecx, 16					; 00000010H
	rep movsd
	lea	esi, DWORD PTR [ebp+360]
	lea	edi, DWORD PTR [ebx+360]
	mov	ecx, 16					; 00000010H
	rep movsd
	lea	esi, DWORD PTR [ebp+424]
	lea	edi, DWORD PTR [ebx+424]
	mov	ecx, 16					; 00000010H
	rep movsd
	fld	DWORD PTR [ebp+488]
	fstp	DWORD PTR [ebx+488]
	fld	DWORD PTR [ebp+492]
	fstp	DWORD PTR [ebx+492]
	mov	eax, DWORD PTR [ebp+496]
	mov	DWORD PTR [ebx+496], eax
	lea	eax, DWORD PTR [ebp+500]
	test	eax, eax
	je	SHORT $LN7@CRenderDev
	lea	esi, DWORD PTR [eax+8]
	jmp	SHORT $LN8@CRenderDev
$LN7@CRenderDev:
	xor	esi, esi
$LN8@CRenderDev:
	lea	edi, DWORD PTR [ebx+508]
	mov	ecx, 14					; 0000000eH
	rep movsd
	mov	ecx, DWORD PTR __imp_??_7CTimer_paused_ex@@6B@
	mov	DWORD PTR [ebx+500], ecx
	mov	edx, DWORD PTR [eax+64]
	mov	DWORD PTR [ebx+564], edx
	mov	eax, DWORD PTR [eax+68]
	mov	DWORD PTR [ebx+568], eax
	mov	ecx, DWORD PTR __imp_??_7CTimer_paused@@6B@
	lea	eax, DWORD PTR [ebp+572]
	test	eax, eax
	mov	DWORD PTR [ebx+500], ecx
	je	SHORT $LN13@CRenderDev
	lea	esi, DWORD PTR [eax+8]
	jmp	SHORT $LN14@CRenderDev
$LN13@CRenderDev:
	xor	esi, esi
$LN14@CRenderDev:
	lea	edi, DWORD PTR [ebx+580]
	mov	ecx, 14					; 0000000eH
	rep movsd
	mov	edx, DWORD PTR __imp_??_7CTimer_paused_ex@@6B@
	mov	DWORD PTR [ebx+572], edx
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR [ebx+636], ecx
	mov	edx, DWORD PTR [eax+68]
	mov	DWORD PTR [ebx+640], edx
	mov	eax, DWORD PTR __imp_??_7CTimer_paused@@6B@
	mov	DWORD PTR [ebx+572], eax
	lea	edi, DWORD PTR [ebp+644]
	lea	esi, DWORD PTR [ebx+644]
	mov	eax, edi
	call	??0?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE@ABV012@@Z ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >
	mov	ecx, DWORD PTR [esi+12]
	xor	ecx, DWORD PTR [edi+12]
	and	ecx, 1
	xor	DWORD PTR [esi+12], ecx
	mov	eax, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [edi+12]
	xor	edx, eax
	and	edx, 2
	xor	edx, eax
	mov	DWORD PTR [esi+12], edx
	lea	edi, DWORD PTR [ebp+660]
	lea	esi, DWORD PTR [ebx+660]
	mov	eax, edi
	call	??0?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE@ABV012@@Z ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >
	mov	eax, DWORD PTR [esi+12]
	xor	eax, DWORD PTR [edi+12]
	and	eax, 1
	xor	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [edi+12]
	xor	ecx, eax
	and	ecx, 2
	xor	ecx, eax
	mov	DWORD PTR [esi+12], ecx
	lea	edi, DWORD PTR [ebp+676]
	lea	esi, DWORD PTR [ebx+676]
	mov	eax, edi
	call	??0?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE@ABV012@@Z ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >
	mov	edx, DWORD PTR [esi+12]
	xor	edx, DWORD PTR [edi+12]
	and	edx, 1
	xor	DWORD PTR [esi+12], edx
	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [edi+12]
	xor	ecx, eax
	and	ecx, 2
	xor	ecx, eax
	mov	DWORD PTR [esi+12], ecx
	lea	edi, DWORD PTR [ebp+692]
	lea	esi, DWORD PTR [ebx+692]
	mov	eax, edi
	call	??0?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE@ABV012@@Z ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >
	mov	edx, DWORD PTR [esi+12]
	xor	edx, DWORD PTR [edi+12]
	and	edx, 1
	xor	DWORD PTR [esi+12], edx
	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [edi+12]
	xor	ecx, eax
	and	ecx, 2
	xor	ecx, eax
	mov	DWORD PTR [esi+12], ecx
	lea	edi, DWORD PTR [ebp+708]
	lea	esi, DWORD PTR [ebx+708]
	mov	eax, edi
	call	??0?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE@ABV012@@Z ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >
	mov	edx, DWORD PTR [esi+12]
	xor	edx, DWORD PTR [edi+12]
	and	edx, 1
	xor	DWORD PTR [esi+12], edx
	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [edi+12]
	xor	ecx, eax
	and	ecx, 2
	xor	ecx, eax
	mov	DWORD PTR [esi+12], ecx
	lea	edi, DWORD PTR [ebp+724]
	lea	esi, DWORD PTR [ebx+724]
	mov	eax, edi
	call	??0?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE@ABV012@@Z ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >
	mov	edx, DWORD PTR [esi+12]
	xor	edx, DWORD PTR [edi+12]
	and	edx, 1
	xor	DWORD PTR [esi+12], edx
	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [edi+12]
	xor	ecx, eax
	and	ecx, 2
	xor	ecx, eax
	mov	DWORD PTR [esi+12], ecx
	lea	edi, DWORD PTR [ebp+740]
	lea	esi, DWORD PTR [ebx+740]
	mov	eax, edi
	call	??0?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE@ABV012@@Z ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >
	mov	edx, DWORD PTR [esi+12]
	xor	edx, DWORD PTR [edi+12]
	and	edx, 1
	xor	DWORD PTR [esi+12], edx
	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [edi+12]
	xor	ecx, eax
	and	ecx, 2
	xor	ecx, eax
	pop	edi
	mov	DWORD PTR [esi+12], ecx
	mov	edx, DWORD PTR [ebp+756]
	pop	esi
	pop	ebp
	mov	DWORD PTR [ebx+756], edx
	mov	eax, ebx
	pop	ebx
	ret	4
??0CRenderDeviceData@@QAE@ABV0@@Z ENDP			; CRenderDeviceData::CRenderDeviceData
_TEXT	ENDS
PUBLIC	??1CRenderDeviceData@@QAE@XZ			; CRenderDeviceData::~CRenderDeviceData
; Function compile flags: /Ogtpy
;	COMDAT ??1CRenderDeviceData@@QAE@XZ
_TEXT	SEGMENT
??1CRenderDeviceData@@QAE@XZ PROC			; CRenderDeviceData::~CRenderDeviceData, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+740]
	test	eax, eax
	push	edi
	mov	edi, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	je	SHORT $LN42@CRenderDev@2
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
$LN42@CRenderDev@2:
	mov	eax, DWORD PTR [esi+724]
	test	eax, eax
	je	SHORT $LN84@CRenderDev@2
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
$LN84@CRenderDev@2:
	mov	eax, DWORD PTR [esi+708]
	test	eax, eax
	je	SHORT $LN126@CRenderDev@2
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
$LN126@CRenderDev@2:
	mov	eax, DWORD PTR [esi+692]
	test	eax, eax
	je	SHORT $LN168@CRenderDev@2
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
$LN168@CRenderDev@2:
	mov	eax, DWORD PTR [esi+676]
	test	eax, eax
	je	SHORT $LN210@CRenderDev@2
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
$LN210@CRenderDev@2:
	mov	eax, DWORD PTR [esi+660]
	test	eax, eax
	je	SHORT $LN252@CRenderDev@2
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
$LN252@CRenderDev@2:
	mov	eax, DWORD PTR [esi+644]
	test	eax, eax
	je	SHORT $LN294@CRenderDev@2
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
$LN294@CRenderDev@2:
	lea	ecx, DWORD PTR [esi+572]
	call	DWORD PTR __imp_??1CTimer_paused@@UAE@XZ
	lea	ecx, DWORD PTR [esi+500]
	pop	edi
	pop	esi
	jmp	DWORD PTR __imp_??1CTimer_paused@@UAE@XZ
??1CRenderDeviceData@@QAE@XZ ENDP			; CRenderDeviceData::~CRenderDeviceData
_TEXT	ENDS
PUBLIC	??0CRenderDeviceData@@QAE@XZ			; CRenderDeviceData::CRenderDeviceData
; Function compile flags: /Ogtpy
;	COMDAT ??0CRenderDeviceData@@QAE@XZ
_TEXT	SEGMENT
??0CRenderDeviceData@@QAE@XZ PROC			; CRenderDeviceData::CRenderDeviceData, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+500]
	call	DWORD PTR __imp_??0CTimer_paused@@QAE@XZ
	lea	ecx, DWORD PTR [esi+572]
	call	DWORD PTR __imp_??0CTimer_paused@@QAE@XZ
	xor	eax, eax
	mov	DWORD PTR [esi+644], eax
	mov	DWORD PTR [esi+648], eax
	mov	DWORD PTR [esi+652], eax
	mov	ecx, -4					; fffffffcH
	and	DWORD PTR [esi+656], ecx
	mov	DWORD PTR [esi+660], eax
	mov	DWORD PTR [esi+664], eax
	mov	DWORD PTR [esi+668], eax
	and	DWORD PTR [esi+672], ecx
	mov	DWORD PTR [esi+676], eax
	mov	DWORD PTR [esi+680], eax
	mov	DWORD PTR [esi+684], eax
	and	DWORD PTR [esi+688], ecx
	mov	DWORD PTR [esi+692], eax
	mov	DWORD PTR [esi+696], eax
	mov	DWORD PTR [esi+700], eax
	and	DWORD PTR [esi+704], ecx
	mov	DWORD PTR [esi+708], eax
	mov	DWORD PTR [esi+712], eax
	mov	DWORD PTR [esi+716], eax
	and	DWORD PTR [esi+720], ecx
	mov	DWORD PTR [esi+724], eax
	mov	DWORD PTR [esi+728], eax
	mov	DWORD PTR [esi+732], eax
	and	DWORD PTR [esi+736], ecx
	mov	DWORD PTR [esi+740], eax
	mov	DWORD PTR [esi+744], eax
	mov	DWORD PTR [esi+748], eax
	and	DWORD PTR [esi+752], ecx
	mov	eax, esi
	pop	esi
	ret	0
??0CRenderDeviceData@@QAE@XZ ENDP			; CRenderDeviceData::CRenderDeviceData
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
??4?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QAEAAV0@ABV0@@Z PROC ; xr_vector<_REG_INFO,xalloc<_REG_INFO> >::operator=, COMDAT
; _this$ = ecx
; ___that$ = eax
	push	edi
	mov	edi, ecx
	push	eax
	call	??4?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::operator=
	mov	eax, edi
	pop	edi
	ret	0
??4?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QAEAAV0@ABV0@@Z ENDP ; xr_vector<_REG_INFO,xalloc<_REG_INFO> >::operator=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@stlp_std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@stlp_std@@QAE@XZ PROC ; stlp_std::vector<shared_str,xalloc<shared_str> >::~vector<shared_str,xalloc<shared_str> >, COMDAT
; _this$ = eax
	push	esi
	mov	esi, eax
	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi]
	push	ecx
	mov	edx, esp
	mov	DWORD PTR [edx], eax
	push	ecx
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	call	??$__destroy_range@V?$reverse_iterator@PAVshared_str@@@stlp_std@@Vshared_str@@@stlp_std@@YAXV?$reverse_iterator@PAVshared_str@@@0@0PAVshared_str@@@Z ; stlp_std::__destroy_range<stlp_std::reverse_iterator<shared_str *>,shared_str>
	mov	esi, DWORD PTR [esi]
	add	esp, 8
	test	esi, esi
	je	SHORT $LN28@vector@63
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN28@vector@63:
	pop	esi
	ret	0
??1?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@stlp_std@@QAE@XZ ENDP ; stlp_std::vector<shared_str,xalloc<shared_str> >::~vector<shared_str,xalloc<shared_str> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4?$CRegistrator@VpureStats@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
??4?$CRegistrator@VpureStats@@@@QAEAAV0@ABV0@@Z PROC	; CRegistrator<pureStats>::operator=, COMDAT
; _this$ = eax
; ___that$ = esi
	push	edi
	mov	edi, eax
	push	esi
	call	??4?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::operator=
	mov	eax, DWORD PTR [edi+12]
	xor	eax, DWORD PTR [esi+12]
	and	eax, 1
	xor	DWORD PTR [edi+12], eax
	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [esi+12]
	xor	ecx, eax
	and	ecx, 2
	xor	ecx, eax
	mov	DWORD PTR [edi+12], ecx
	mov	eax, edi
	pop	edi
	ret	0
??4?$CRegistrator@VpureStats@@@@QAEAAV0@ABV0@@Z ENDP	; CRegistrator<pureStats>::operator=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@QAE@XZ PROC ; xr_vector<shared_str,xalloc<shared_str> >::~xr_vector<shared_str,xalloc<shared_str> >, COMDAT
; _this$ = eax
	push	esi
	mov	esi, eax
	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi]
	push	ecx
	mov	edx, esp
	mov	DWORD PTR [edx], eax
	push	ecx
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	call	??$__destroy_range@V?$reverse_iterator@PAVshared_str@@@stlp_std@@Vshared_str@@@stlp_std@@YAXV?$reverse_iterator@PAVshared_str@@@0@0PAVshared_str@@@Z ; stlp_std::__destroy_range<stlp_std::reverse_iterator<shared_str *>,shared_str>
	mov	esi, DWORD PTR [esi]
	add	esp, 8
	test	esi, esi
	je	SHORT $LN30@xr_vector@39
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN30@xr_vector@39:
	pop	esi
	ret	0
??1?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@QAE@XZ ENDP ; xr_vector<shared_str,xalloc<shared_str> >::~xr_vector<shared_str,xalloc<shared_str> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAE@XZ PROC ; stlp_std::vector<CSheduler::Item,xalloc<CSheduler::Item> >::~vector<CSheduler::Item,xalloc<CSheduler::Item> >, COMDAT
; _this$ = eax
	push	esi
	mov	esi, eax
	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi]
	push	ecx
	mov	edx, esp
	mov	DWORD PTR [edx], eax
	push	ecx
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	call	??$__destroy_range@V?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@UItem@CSheduler@@@stlp_std@@YAXV?$reverse_iterator@PAUItem@CSheduler@@@0@0PAUItem@CSheduler@@@Z ; stlp_std::__destroy_range<stlp_std::reverse_iterator<CSheduler::Item *>,CSheduler::Item>
	mov	esi, DWORD PTR [esi]
	add	esp, 8
	test	esi, esi
	je	SHORT $LN28@vector@64
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN28@vector@64:
	pop	esi
	ret	0
??1?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAE@XZ ENDP ; stlp_std::vector<CSheduler::Item,xalloc<CSheduler::Item> >::~vector<CSheduler::Item,xalloc<CSheduler::Item> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4?$xr_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
??4?$xr_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@@QAEAAV0@ABV0@@Z PROC ; xr_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::operator=, COMDAT
; _this$ = ecx
; ___that$ = eax
	push	edi
	mov	edi, ecx
	push	eax
	call	??4?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::operator=
	mov	eax, edi
	pop	edi
	ret	0
??4?$xr_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@@QAEAAV0@ABV0@@Z ENDP ; xr_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::operator=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$xr_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@@QAE@XZ PROC ; xr_vector<CSheduler::Item,xalloc<CSheduler::Item> >::~xr_vector<CSheduler::Item,xalloc<CSheduler::Item> >, COMDAT
; _this$ = eax
	push	esi
	mov	esi, eax
	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi]
	push	ecx
	mov	edx, esp
	mov	DWORD PTR [edx], eax
	push	ecx
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	call	??$__destroy_range@V?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@UItem@CSheduler@@@stlp_std@@YAXV?$reverse_iterator@PAUItem@CSheduler@@@0@0PAUItem@CSheduler@@@Z ; stlp_std::__destroy_range<stlp_std::reverse_iterator<CSheduler::Item *>,CSheduler::Item>
	mov	esi, DWORD PTR [esi]
	add	esp, 8
	test	esi, esi
	je	SHORT $LN30@xr_vector@40
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN30@xr_vector@40:
	pop	esi
	ret	0
??1?$xr_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@@QAE@XZ ENDP ; xr_vector<CSheduler::Item,xalloc<CSheduler::Item> >::~xr_vector<CSheduler::Item,xalloc<CSheduler::Item> >
_TEXT	ENDS
PUBLIC	??1CSheduler@@QAE@XZ				; CSheduler::~CSheduler
; Function compile flags: /Ogtpy
;	COMDAT ??1CSheduler@@QAE@XZ
_TEXT	SEGMENT
??1CSheduler@@QAE@XZ PROC				; CSheduler::~CSheduler, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	push	edi
	mov	edi, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	je	SHORT $LN40@CSheduler
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
$LN40@CSheduler:
	mov	ecx, DWORD PTR [esi+28]
	mov	eax, DWORD PTR [esi+24]
	push	ecx
	mov	edx, esp
	mov	DWORD PTR [edx], eax
	push	ecx
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	call	??$__destroy_range@V?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@UItem@CSheduler@@@stlp_std@@YAXV?$reverse_iterator@PAUItem@CSheduler@@@0@0PAUItem@CSheduler@@@Z ; stlp_std::__destroy_range<stlp_std::reverse_iterator<CSheduler::Item *>,CSheduler::Item>
	mov	eax, DWORD PTR [esi+24]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN72@CSheduler
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
$LN72@CSheduler:
	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [esi+12]
	push	ecx
	mov	edx, esp
	mov	DWORD PTR [edx], eax
	push	ecx
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	call	??$__destroy_range@V?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@UItem@CSheduler@@@stlp_std@@YAXV?$reverse_iterator@PAUItem@CSheduler@@@0@0PAUItem@CSheduler@@@Z ; stlp_std::__destroy_range<stlp_std::reverse_iterator<CSheduler::Item *>,CSheduler::Item>
	mov	eax, DWORD PTR [esi+12]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN104@CSheduler
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
$LN104@CSheduler:
	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi]
	push	ecx
	mov	edx, esp
	mov	DWORD PTR [edx], eax
	push	ecx
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	call	??$__destroy_range@V?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@UItem@CSheduler@@@stlp_std@@YAXV?$reverse_iterator@PAUItem@CSheduler@@@0@0PAUItem@CSheduler@@@Z ; stlp_std::__destroy_range<stlp_std::reverse_iterator<CSheduler::Item *>,CSheduler::Item>
	mov	esi, DWORD PTR [esi]
	add	esp, 8
	test	esi, esi
	je	SHORT $LN136@CSheduler
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	edi
$LN136@CSheduler:
	pop	edi
	pop	esi
	ret	0
??1CSheduler@@QAE@XZ ENDP				; CSheduler::~CSheduler
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4?$xr_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
??4?$xr_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@@QAEAAV0@ABV0@@Z PROC ; xr_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::operator=, COMDAT
; _this$ = ecx
; ___that$ = eax
	push	edi
	mov	edi, ecx
	push	eax
	call	??4?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::operator=
	mov	eax, edi
	pop	edi
	ret	0
??4?$xr_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@@QAEAAV0@ABV0@@Z ENDP ; xr_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::operator=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4?$xr_vector@PAVCEvent@@V?$xalloc@PAVCEvent@@@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
??4?$xr_vector@PAVCEvent@@V?$xalloc@PAVCEvent@@@@@@QAEAAV0@ABV0@@Z PROC ; xr_vector<CEvent *,xalloc<CEvent *> >::operator=, COMDAT
; _this$ = ecx
; ___that$ = eax
	push	ebx
	mov	ebx, ecx
	push	eax
	call	??4?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::operator=
	mov	eax, ebx
	pop	ebx
	ret	0
??4?$xr_vector@PAVCEvent@@V?$xalloc@PAVCEvent@@@@@@QAEAAV0@ABV0@@Z ENDP ; xr_vector<CEvent *,xalloc<CEvent *> >::operator=
_TEXT	ENDS
PUBLIC	??4CEventAPI@@QAEAAV0@ABV0@@Z			; CEventAPI::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4CEventAPI@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4CEventAPI@@QAEAAV0@ABV0@@Z PROC			; CEventAPI::operator=, COMDAT
; _this$ = ecx
	push	ebx
	push	esi
	mov	esi, DWORD PTR ___that$[esp+4]
	push	edi
	mov	ebx, ecx
	push	esi
	call	??4?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::operator=
	lea	eax, DWORD PTR [esi+12]
	push	eax
	lea	edi, DWORD PTR [ebx+12]
	call	??4?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::operator=
	mov	ecx, DWORD PTR [esi+24]
	pop	edi
	pop	esi
	mov	DWORD PTR [ebx+24], ecx
	mov	eax, ebx
	pop	ebx
	ret	4
??4CEventAPI@@QAEAAV0@ABV0@@Z ENDP			; CEventAPI::operator=
_TEXT	ENDS
PUBLIC	??0CEventAPI@@QAE@XZ				; CEventAPI::CEventAPI
; Function compile flags: /Ogtpy
;	COMDAT ??0CEventAPI@@QAE@XZ
_TEXT	SEGMENT
??0CEventAPI@@QAE@XZ PROC				; CEventAPI::CEventAPI, COMDAT
; _this$ = ecx
	xor	eax, eax
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	lea	ecx, DWORD PTR [esi+24]
	mov	DWORD PTR [esi+20], eax
	call	DWORD PTR __imp_??0xrCriticalSection@@QAE@XZ
	mov	eax, esi
	pop	esi
	ret	0
??0CEventAPI@@QAE@XZ ENDP				; CEventAPI::CEventAPI
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_EDLL_Pure@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_EDLL_Pure@@UAEPAXI@Z PROC				; DLL_Pure::`vector deleting destructor', COMDAT
; _this$ = ecx
	mov	dl, BYTE PTR ___flags$[esp-4]
	test	dl, 2
	push	esi
	mov	esi, ecx
	je	SHORT $LN3@vector@65
	mov	ecx, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	mov	eax, ecx
	shl	eax, 4
	add	eax, esi
	sub	ecx, 1
	js	SHORT $LN6@vector@65
	npad	1
$LL7@vector@65:
	sub	eax, 16					; 00000010H
	sub	ecx, 1
	mov	DWORD PTR [eax], OFFSET ??_7DLL_Pure@@6B@
	jns	SHORT $LL7@vector@65
$LN6@vector@65:
	test	dl, 1
	je	SHORT $LN14@vector@65
	test	edi, edi
	je	SHORT $LN14@vector@65
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN14@vector@65:
	mov	eax, edi
	pop	edi
	pop	esi
	ret	4
$LN3@vector@65:
	test	dl, 1
	mov	DWORD PTR [esi], OFFSET ??_7DLL_Pure@@6B@
	je	SHORT $LN21@vector@65
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN21@vector@65:
	mov	eax, esi
	pop	esi
	ret	4
??_EDLL_Pure@@UAEPAXI@Z ENDP				; DLL_Pure::`vector deleting destructor'
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\xrstring.h
_TEXT	ENDS
;	COMDAT ??4shared_str@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
??4shared_str@@QAEAAV0@ABV0@@Z PROC			; shared_str::operator=, COMDAT
; _this$ = eax
; _rhs$ = ecx

; 79   : 	shared_str&			operator=	(shared_str const &rhs)			{	_set(rhs);	return (shared_str&)*this;			}

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN3@operator@74
	add	DWORD PTR [ecx], 1
$LN3@operator@74:
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN11@operator@74
	add	DWORD PTR [edx], -1
	mov	edx, DWORD PTR [eax]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN11@operator@74
	mov	DWORD PTR [eax], 0
$LN11@operator@74:
	mov	DWORD PTR [eax], ecx
	ret	0
??4shared_str@@QAEAAV0@ABV0@@Z ENDP			; shared_str::operator=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0shared_str@@QAE@ABV0@@Z
_TEXT	SEGMENT
??0shared_str@@QAE@ABV0@@Z PROC				; shared_str::shared_str, COMDAT
; _this$ = eax
; _rhs$ = ecx

; 74   : 						shared_str	(shared_str const &rhs)			{	p_ = 0;	_set(rhs);								}

	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN3@shared_str@2
	add	DWORD PTR [ecx], 1
$LN3@shared_str@2:
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN11@shared_str@2
	add	DWORD PTR [edx], -1
	mov	edx, DWORD PTR [eax]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN11@shared_str@2
	mov	DWORD PTR [eax], 0
$LN11@shared_str@2:
	mov	DWORD PTR [eax], ecx
	ret	0
??0shared_str@@QAE@ABV0@@Z ENDP				; shared_str::shared_str
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0shared_str@@QAE@PBD@Z
_TEXT	SEGMENT
??0shared_str@@QAE@PBD@Z PROC				; shared_str::shared_str, COMDAT
; _this$ = esi
; _rhs$ = eax

; 73   : 						shared_str	(str_c rhs) 					{	p_ = 0;	_set(rhs);								}

	mov	ecx, DWORD PTR __imp_?g_pStringContainer@@3PAVstr_container@@A
	mov	DWORD PTR [esi], 0
	mov	ecx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR __imp_?dock@str_container@@QAEPAUstr_value@@PBD@Z
	test	eax, eax
	je	SHORT $LN3@shared_str@3
	add	DWORD PTR [eax], 1
$LN3@shared_str@3:
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN11@shared_str@3
	add	DWORD PTR [ecx], -1
	mov	edx, DWORD PTR [esi]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN11@shared_str@3
	mov	DWORD PTR [esi], 0
$LN11@shared_str@3:
	mov	DWORD PTR [esi], eax
	mov	eax, esi
	ret	0
??0shared_str@@QAE@PBD@Z ENDP				; shared_str::shared_str
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_uninitialized.h
;	COMDAT ??$__ucopy_aux@PBV?$FastDelegate0@X@fastdelegate@@PAV12@@priv@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PBV23@0PAV23@ABU__true_type@1@@Z
_TEXT	SEGMENT
??$__ucopy_aux@PBV?$FastDelegate0@X@fastdelegate@@PAV12@@priv@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PBV23@0PAV23@ABU__true_type@1@@Z PROC ; stlp_std::priv::__ucopy_aux<fastdelegate::FastDelegate0<void> const *,fastdelegate::FastDelegate0<void> *>, COMDAT
; ___first$ = edx
; ___last$ = ecx
; ___result$ = eax

; 126  :   return __ucopy_ptrs(__first, __last, __result,
; 127  :                       _UseTrivialUCopy(_STLP_VALUE_TYPE(__first, _InputIter),
; 128  :                                        _STLP_VALUE_TYPE(__result, _OutputIter))._Answer());

	jmp	??$__ucopy@PBV?$FastDelegate0@X@fastdelegate@@PAV12@H@priv@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PBV23@0PAV23@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<fastdelegate::FastDelegate0<void> const *,fastdelegate::FastDelegate0<void> *,int>
??$__ucopy_aux@PBV?$FastDelegate0@X@fastdelegate@@PAV12@@priv@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PBV23@0PAV23@ABU__true_type@1@@Z ENDP ; stlp_std::priv::__ucopy_aux<fastdelegate::FastDelegate0<void> const *,fastdelegate::FastDelegate0<void> *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0Item@CSheduler@@QAE@ABU01@@Z
_TEXT	SEGMENT
??0Item@CSheduler@@QAE@ABU01@@Z PROC			; CSheduler::Item::Item, COMDAT
; _this$ = eax
; ___that$ = ecx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	push	esi
	mov	DWORD PTR [eax+8], 0
	mov	esi, DWORD PTR [ecx+8]
	test	esi, esi
	je	SHORT $LN5@Item@6
	add	DWORD PTR [esi], 1
$LN5@Item@6:
	mov	edx, DWORD PTR [eax+8]
	test	edx, edx
	je	SHORT $LN8@Item@6
	add	DWORD PTR [edx], -1
	mov	edx, DWORD PTR [eax+8]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN8@Item@6
	mov	DWORD PTR [eax+8], 0
$LN8@Item@6:
	mov	DWORD PTR [eax+8], esi
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], ecx
	pop	esi
	ret	0
??0Item@CSheduler@@QAE@ABU01@@Z ENDP			; CSheduler::Item::Item
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4Item@CSheduler@@QAEAAU01@ABU01@@Z
_TEXT	SEGMENT
??4Item@CSheduler@@QAEAAU01@ABU01@@Z PROC		; CSheduler::Item::operator=, COMDAT
; _this$ = eax
; ___that$ = ecx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	push	esi
	mov	DWORD PTR [eax+4], edx
	mov	esi, DWORD PTR [ecx+8]
	test	esi, esi
	je	SHORT $LN5@operator@102
	add	DWORD PTR [esi], 1
$LN5@operator@102:
	mov	edx, DWORD PTR [eax+8]
	test	edx, edx
	je	SHORT $LN8@operator@102
	add	DWORD PTR [edx], -1
	mov	edx, DWORD PTR [eax+8]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN8@operator@102
	mov	DWORD PTR [eax+8], 0
$LN8@operator@102:
	mov	DWORD PTR [eax+8], esi
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], ecx
	pop	esi
	ret	0
??4Item@CSheduler@@QAEAAU01@ABU01@@Z ENDP		; CSheduler::Item::operator=
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_construct.h
_TEXT	ENDS
;	COMDAT ??$_Param_Construct@UItem@CSheduler@@U12@@stlp_std@@YAXPAUItem@CSheduler@@ABU12@@Z
_TEXT	SEGMENT
??$_Param_Construct@UItem@CSheduler@@U12@@stlp_std@@YAXPAUItem@CSheduler@@ABU12@@Z PROC ; stlp_std::_Param_Construct<CSheduler::Item,CSheduler::Item>, COMDAT
; ___p$ = eax
; ___val$ = ecx

; 118  : #if defined (_STLP_DEBUG_UNINITIALIZED)
; 119  :   memset((char*)__p, _STLP_SHRED_BYTE, sizeof(_T1));
; 120  : #endif
; 121  :   _STLP_PLACEMENT_NEW (__p) _T1(__val);

	test	eax, eax
	je	SHORT $LN3@Param_Cons@19
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	push	esi
	mov	DWORD PTR [eax+8], 0
	mov	esi, DWORD PTR [ecx+8]
	test	esi, esi
	je	SHORT $LN11@Param_Cons@19
	add	DWORD PTR [esi], 1
$LN11@Param_Cons@19:
	mov	edx, DWORD PTR [eax+8]
	test	edx, edx
	je	SHORT $LN14@Param_Cons@19
	add	DWORD PTR [edx], -1
	mov	edx, DWORD PTR [eax+8]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN14@Param_Cons@19
	mov	DWORD PTR [eax+8], 0
$LN14@Param_Cons@19:
	mov	DWORD PTR [eax+8], esi
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], ecx
	pop	esi
$LN3@Param_Cons@19:

; 122  : }

	ret	0
??$_Param_Construct@UItem@CSheduler@@U12@@stlp_std@@YAXPAUItem@CSheduler@@ABU12@@Z ENDP ; stlp_std::_Param_Construct<CSheduler::Item,CSheduler::Item>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Param_Construct@Vshared_str@@V1@@stlp_std@@YAXPAVshared_str@@ABV1@@Z
_TEXT	SEGMENT
??$_Param_Construct@Vshared_str@@V1@@stlp_std@@YAXPAVshared_str@@ABV1@@Z PROC ; stlp_std::_Param_Construct<shared_str,shared_str>, COMDAT
; ___p$ = eax
; ___val$ = ecx

; 118  : #if defined (_STLP_DEBUG_UNINITIALIZED)
; 119  :   memset((char*)__p, _STLP_SHRED_BYTE, sizeof(_T1));
; 120  : #endif
; 121  :   _STLP_PLACEMENT_NEW (__p) _T1(__val);

	test	eax, eax
	je	SHORT $LN3@Param_Cons@20
	mov	DWORD PTR [eax], 0
	mov	edx, DWORD PTR [ecx]
	test	edx, edx
	je	SHORT $LN9@Param_Cons@20
	add	DWORD PTR [edx], 1
$LN9@Param_Cons@20:
	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN12@Param_Cons@20
	add	DWORD PTR [ecx], -1
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN12@Param_Cons@20
	mov	DWORD PTR [eax], 0
$LN12@Param_Cons@20:
	mov	DWORD PTR [eax], edx
$LN3@Param_Cons@20:

; 122  : }

	ret	0
??$_Param_Construct@Vshared_str@@V1@@stlp_std@@YAXPAVshared_str@@ABV1@@Z ENDP ; stlp_std::_Param_Construct<shared_str,shared_str>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_uninitialized.h
_TEXT	ENDS
;	COMDAT ??$uninitialized_copy@PBV?$FastDelegate0@X@fastdelegate@@PAV12@@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PBV12@0PAV12@@Z
_TEXT	SEGMENT
??$uninitialized_copy@PBV?$FastDelegate0@X@fastdelegate@@PAV12@@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PBV12@0PAV12@@Z PROC ; stlp_std::uninitialized_copy<fastdelegate::FastDelegate0<void> const *,fastdelegate::FastDelegate0<void> *>, COMDAT
; ___first$ = edx
; ___last$ = ecx
; ___result$ = eax

; 144  : { return _STLP_PRIV __ucopy_aux(__first, __last, __result, _BothPtrType< _InputIter, _ForwardIter>::_Answer()); }

	jmp	??$__ucopy@PBV?$FastDelegate0@X@fastdelegate@@PAV12@H@priv@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PBV23@0PAV23@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<fastdelegate::FastDelegate0<void> const *,fastdelegate::FastDelegate0<void> *,int>
??$uninitialized_copy@PBV?$FastDelegate0@X@fastdelegate@@PAV12@@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PBV12@0PAV12@@Z ENDP ; stlp_std::uninitialized_copy<fastdelegate::FastDelegate0<void> const *,fastdelegate::FastDelegate0<void> *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_algobase.h
_TEXT	ENDS
;	COMDAT ??$__copy@PBUItem@CSheduler@@PAU12@H@priv@stlp_std@@YAPAUItem@CSheduler@@PBU23@0PAU23@ABUrandom_access_iterator_tag@1@PAH@Z
_TEXT	SEGMENT
??$__copy@PBUItem@CSheduler@@PAU12@H@priv@stlp_std@@YAPAUItem@CSheduler@@PBU23@0PAU23@ABUrandom_access_iterator_tag@1@PAH@Z PROC ; stlp_std::priv::__copy<CSheduler::Item const *,CSheduler::Item *,int>, COMDAT
; ___first$ = edx
; ___last$ = eax
; ___result$ = ecx

; 200  :        _OutputIter __result, const random_access_iterator_tag &, _Distance*) {

	push	esi
	mov	esi, edx

; 201  :   for (_Distance __n = __last - __first; __n > 0; --__n) {

	sub	eax, esi
	mov	edx, eax
	mov	eax, 1717986919				; 66666667H
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	test	eax, eax
	jle	SHORT $LN19@copy@22
	push	edi
	npad	3
$LL3@copy@22:

; 202  :     *__result = *__first;

	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [esi+8]
	test	edx, edx
	je	SHORT $LN10@copy@22
	add	DWORD PTR [edx], 1
$LN10@copy@22:
	mov	edi, DWORD PTR [ecx+8]
	test	edi, edi
	je	SHORT $LN13@copy@22
	add	DWORD PTR [edi], -1
	mov	edi, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edi], 0
	jne	SHORT $LN13@copy@22
	mov	DWORD PTR [ecx+8], 0
$LN13@copy@22:
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [ecx+16], edx
	sub	eax, 1

; 203  :     ++__first;

	add	esi, 20					; 00000014H

; 204  :     ++__result;

	add	ecx, 20					; 00000014H
	test	eax, eax
	jg	SHORT $LL3@copy@22
	pop	edi
$LN19@copy@22:

; 205  :   }
; 206  :   return __result;

	mov	eax, ecx
	pop	esi

; 207  : }

	ret	0
??$__copy@PBUItem@CSheduler@@PAU12@H@priv@stlp_std@@YAPAUItem@CSheduler@@PBU23@0PAU23@ABUrandom_access_iterator_tag@1@PAH@Z ENDP ; stlp_std::priv::__copy<CSheduler::Item const *,CSheduler::Item *,int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$__copy@PBVshared_str@@PAV1@H@priv@stlp_std@@YAPAVshared_str@@PBV2@0PAV2@ABUrandom_access_iterator_tag@1@PAH@Z
_TEXT	SEGMENT
??$__copy@PBVshared_str@@PAV1@H@priv@stlp_std@@YAPAVshared_str@@PBV2@0PAV2@ABUrandom_access_iterator_tag@1@PAH@Z PROC ; stlp_std::priv::__copy<shared_str const *,shared_str *,int>, COMDAT
; ___first$ = edx
; ___last$ = ecx
; ___result$ = eax

; 200  :        _OutputIter __result, const random_access_iterator_tag &, _Distance*) {

	push	esi
	push	edi
	mov	esi, ecx
	mov	edi, edx

; 201  :   for (_Distance __n = __last - __first; __n > 0; --__n) {

	sub	esi, edi
	sar	esi, 2
	test	esi, esi
	jle	SHORT $LN1@copy@23
	npad	1
$LL3@copy@23:

; 202  :     *__result = *__first;

	mov	edx, DWORD PTR [edi]
	test	edx, edx
	je	SHORT $LN8@copy@23
	add	DWORD PTR [edx], 1
$LN8@copy@23:
	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN11@copy@23
	add	DWORD PTR [ecx], -1
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN11@copy@23
	mov	DWORD PTR [eax], 0
$LN11@copy@23:
	mov	DWORD PTR [eax], edx
	sub	esi, 1

; 203  :     ++__first;

	add	edi, 4

; 204  :     ++__result;

	add	eax, 4
	test	esi, esi
	jg	SHORT $LL3@copy@23
$LN1@copy@23:
	pop	edi
	pop	esi

; 205  :   }
; 206  :   return __result;
; 207  : }

	ret	0
??$__copy@PBVshared_str@@PAV1@H@priv@stlp_std@@YAPAVshared_str@@PBV2@0PAV2@ABUrandom_access_iterator_tag@1@PAH@Z ENDP ; stlp_std::priv::__copy<shared_str const *,shared_str *,int>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_uninitialized.h
_TEXT	ENDS
;	COMDAT ??$__ucopy@PBUItem@CSheduler@@PAU12@H@priv@stlp_std@@YAPAUItem@CSheduler@@PBU23@0PAU23@ABUrandom_access_iterator_tag@1@PAH@Z
_TEXT	SEGMENT
??$__ucopy@PBUItem@CSheduler@@PAU12@H@priv@stlp_std@@YAPAUItem@CSheduler@@PBU23@0PAU23@ABUrandom_access_iterator_tag@1@PAH@Z PROC ; stlp_std::priv::__ucopy<CSheduler::Item const *,CSheduler::Item *,int>, COMDAT
; ___first$ = edx
; ___last$ = eax
; ___result$ = ecx

; 83   :                            _OutputIter __result, const random_access_iterator_tag &, _Distance*) {

	push	ebx
	push	esi
	mov	esi, edx

; 84   :   _OutputIter __cur = __result;
; 85   :   _STLP_TRY {
; 86   :     for (_Distance __n = __last - __first; __n > 0; --__n) {

	sub	eax, esi
	mov	edx, eax
	mov	eax, 1717986919				; 66666667H
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	xor	ebx, ebx
	cmp	eax, ebx
	jle	SHORT $LN25@ucopy@17
	push	edi
$LL3@ucopy@17:

; 87   :       _Param_Construct(&*__cur, *__first);

	cmp	ecx, ebx
	je	SHORT $LN8@ucopy@17
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], edx
	mov	DWORD PTR [ecx+8], ebx
	mov	edi, DWORD PTR [esi+8]
	cmp	edi, ebx
	je	SHORT $LN16@ucopy@17
	add	DWORD PTR [edi], 1
$LN16@ucopy@17:
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, ebx
	je	SHORT $LN19@ucopy@17
	add	DWORD PTR [edx], -1
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx], ebx
	jne	SHORT $LN19@ucopy@17
	mov	DWORD PTR [ecx+8], ebx
$LN19@ucopy@17:
	mov	DWORD PTR [ecx+8], edi
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [ecx+16], edx
$LN8@ucopy@17:
	sub	eax, 1

; 88   :       ++__first;

	add	esi, 20					; 00000014H

; 89   :       ++__cur;

	add	ecx, 20					; 00000014H
	cmp	eax, ebx
	jg	SHORT $LL3@ucopy@17
	pop	edi
$LN25@ucopy@17:
	pop	esi

; 90   :     }
; 91   :     return __cur;

	mov	eax, ecx
	pop	ebx

; 92   :   }
; 93   :   _STLP_UNWIND(_STLP_STD::_Destroy_Range(__result, __cur))
; 94   :   _STLP_RET_AFTER_THROW(__cur)
; 95   : }

	ret	0
??$__ucopy@PBUItem@CSheduler@@PAU12@H@priv@stlp_std@@YAPAUItem@CSheduler@@PBU23@0PAU23@ABUrandom_access_iterator_tag@1@PAH@Z ENDP ; stlp_std::priv::__ucopy<CSheduler::Item const *,CSheduler::Item *,int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$__ucopy@PBVshared_str@@PAV1@H@priv@stlp_std@@YAPAVshared_str@@PBV2@0PAV2@ABUrandom_access_iterator_tag@1@PAH@Z
_TEXT	SEGMENT
??$__ucopy@PBVshared_str@@PAV1@H@priv@stlp_std@@YAPAVshared_str@@PBV2@0PAV2@ABUrandom_access_iterator_tag@1@PAH@Z PROC ; stlp_std::priv::__ucopy<shared_str const *,shared_str *,int>, COMDAT
; ___first$ = edx
; ___last$ = ecx
; ___result$ = eax

; 83   :                            _OutputIter __result, const random_access_iterator_tag &, _Distance*) {

	push	esi
	push	edi
	mov	edi, edx

; 84   :   _OutputIter __cur = __result;
; 85   :   _STLP_TRY {
; 86   :     for (_Distance __n = __last - __first; __n > 0; --__n) {

	sub	ecx, edi
	sar	ecx, 2
	mov	esi, ecx
	test	esi, esi
	jle	SHORT $LN1@ucopy@18
	npad	1
$LL3@ucopy@18:

; 87   :       _Param_Construct(&*__cur, *__first);

	test	eax, eax
	je	SHORT $LN8@ucopy@18
	mov	DWORD PTR [eax], 0
	mov	edx, DWORD PTR [edi]
	test	edx, edx
	je	SHORT $LN14@ucopy@18
	add	DWORD PTR [edx], 1
$LN14@ucopy@18:
	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN17@ucopy@18
	add	DWORD PTR [ecx], -1
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN17@ucopy@18
	mov	DWORD PTR [eax], 0
$LN17@ucopy@18:
	mov	DWORD PTR [eax], edx
$LN8@ucopy@18:
	sub	esi, 1

; 88   :       ++__first;

	add	edi, 4

; 89   :       ++__cur;

	add	eax, 4
	test	esi, esi
	jg	SHORT $LL3@ucopy@18
$LN1@ucopy@18:
	pop	edi
	pop	esi

; 90   :     }
; 91   :     return __cur;
; 92   :   }
; 93   :   _STLP_UNWIND(_STLP_STD::_Destroy_Range(__result, __cur))
; 94   :   _STLP_RET_AFTER_THROW(__cur)
; 95   : }

	ret	0
??$__ucopy@PBVshared_str@@PAV1@H@priv@stlp_std@@YAPAVshared_str@@PBV2@0PAV2@ABUrandom_access_iterator_tag@1@PAH@Z ENDP ; stlp_std::priv::__ucopy<shared_str const *,shared_str *,int>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ??$_M_allocate_and_copy@PBV?$FastDelegate0@X@fastdelegate@@@?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@AAEPAV?$FastDelegate0@X@fastdelegate@@AAIPBV34@1@Z
_TEXT	SEGMENT
___first$ = 8						; size = 4
___last$ = 12						; size = 4
??$_M_allocate_and_copy@PBV?$FastDelegate0@X@fastdelegate@@@?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@AAEPAV?$FastDelegate0@X@fastdelegate@@AAIPBV34@1@Z PROC ; stlp_std::priv::_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::_M_allocate_and_copy<fastdelegate::FastDelegate0<void> const *>, COMDAT
; ___n$ = eax

; 634  :                                _ForwardIterator __first, _ForwardIterator __last)
; 635  : #else /* _STLP_MEMBER_TEMPLATES */
; 636  :   pointer _M_allocate_and_copy(size_type& __n,
; 637  :                                const_pointer __first, const_pointer __last)
; 638  : #endif /* _STLP_MEMBER_TEMPLATES */
; 639  :   {
; 640  :     pointer __result = this->_M_end_of_storage.allocate(__n, __n);

	mov	eax, DWORD PTR [eax]
	lea	ecx, DWORD PTR [eax*8]
	push	esi
	push	ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 641  :     _STLP_TRY {
; 642  :       uninitialized_copy(__first, __last, __result);

	mov	ecx, DWORD PTR ___last$[esp]
	mov	edx, DWORD PTR ___first$[esp]
	mov	esi, eax
	call	??$__ucopy@PBV?$FastDelegate0@X@fastdelegate@@PAV12@H@priv@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PBV23@0PAV23@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<fastdelegate::FastDelegate0<void> const *,fastdelegate::FastDelegate0<void> *,int>

; 643  :       return __result;

	mov	eax, esi
	pop	esi

; 644  :     }
; 645  :     _STLP_UNWIND(this->_M_end_of_storage.deallocate(__result, __n))
; 646  :     _STLP_RET_AFTER_THROW(__result)
; 647  :   }

	ret	8
??$_M_allocate_and_copy@PBV?$FastDelegate0@X@fastdelegate@@@?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@AAEPAV?$FastDelegate0@X@fastdelegate@@AAIPBV34@1@Z ENDP ; stlp_std::priv::_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::_M_allocate_and_copy<fastdelegate::FastDelegate0<void> const *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_algobase.h
_TEXT	ENDS
;	COMDAT ??$__copy_ptrs@PBUItem@CSheduler@@PAU12@@priv@stlp_std@@YAPAUItem@CSheduler@@PBU23@0PAU23@ABU__false_type@1@@Z
_TEXT	SEGMENT
??$__copy_ptrs@PBUItem@CSheduler@@PAU12@@priv@stlp_std@@YAPAUItem@CSheduler@@PBU23@0PAU23@ABU__false_type@1@@Z PROC ; stlp_std::priv::__copy_ptrs<CSheduler::Item const *,CSheduler::Item *>, COMDAT
; ___first$ = edx
; ___last$ = eax
; ___result$ = ecx

; 250  :   return __copy(__first, __last, __result, random_access_iterator_tag(), (ptrdiff_t*)0);

	jmp	??$__copy@PBUItem@CSheduler@@PAU12@H@priv@stlp_std@@YAPAUItem@CSheduler@@PBU23@0PAU23@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__copy<CSheduler::Item const *,CSheduler::Item *,int>
??$__copy_ptrs@PBUItem@CSheduler@@PAU12@@priv@stlp_std@@YAPAUItem@CSheduler@@PBU23@0PAU23@ABU__false_type@1@@Z ENDP ; stlp_std::priv::__copy_ptrs<CSheduler::Item const *,CSheduler::Item *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$__copy_ptrs@PBVshared_str@@PAV1@@priv@stlp_std@@YAPAVshared_str@@PBV2@0PAV2@ABU__false_type@1@@Z
_TEXT	SEGMENT
??$__copy_ptrs@PBVshared_str@@PAV1@@priv@stlp_std@@YAPAVshared_str@@PBV2@0PAV2@ABU__false_type@1@@Z PROC ; stlp_std::priv::__copy_ptrs<shared_str const *,shared_str *>, COMDAT
; ___first$ = edx
; ___last$ = ecx
; ___result$ = eax

; 250  :   return __copy(__first, __last, __result, random_access_iterator_tag(), (ptrdiff_t*)0);

	jmp	??$__copy@PBVshared_str@@PAV1@H@priv@stlp_std@@YAPAVshared_str@@PBV2@0PAV2@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__copy<shared_str const *,shared_str *,int>
??$__copy_ptrs@PBVshared_str@@PAV1@@priv@stlp_std@@YAPAVshared_str@@PBV2@0PAV2@ABU__false_type@1@@Z ENDP ; stlp_std::priv::__copy_ptrs<shared_str const *,shared_str *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ?_M_clear@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@AAEXXZ
_TEXT	SEGMENT
?_M_clear@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@AAEXXZ PROC ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::_M_clear, COMDAT
; _this$ = eax

; 615  :   void _M_clear() {

	push	esi
	mov	esi, eax

; 616  :     _STLP_STD::_Destroy_Range(rbegin(), rend());

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi]
	push	ecx
	mov	edx, esp
	mov	DWORD PTR [edx], eax
	push	ecx
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	call	??$__destroy_range@V?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@UItem@CSheduler@@@stlp_std@@YAXV?$reverse_iterator@PAUItem@CSheduler@@@0@0PAUItem@CSheduler@@@Z ; stlp_std::__destroy_range<stlp_std::reverse_iterator<CSheduler::Item *>,CSheduler::Item>

; 617  :     this->_M_end_of_storage.deallocate(this->_M_start, this->_M_end_of_storage._M_data - this->_M_start);

	mov	esi, DWORD PTR [esi]
	add	esp, 8
	test	esi, esi
	je	SHORT $LN23@M_clear@28
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN23@M_clear@28:

; 618  :   }

	pop	esi
	ret	0
?_M_clear@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@AAEXXZ ENDP ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::_M_clear
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_M_clear@?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@AAEXXZ
_TEXT	SEGMENT
?_M_clear@?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@AAEXXZ PROC ; stlp_std::priv::_Impl_vector<shared_str,xalloc<shared_str> >::_M_clear, COMDAT
; _this$ = eax

; 615  :   void _M_clear() {

	push	esi
	mov	esi, eax

; 616  :     _STLP_STD::_Destroy_Range(rbegin(), rend());

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi]
	push	ecx
	mov	edx, esp
	mov	DWORD PTR [edx], eax
	push	ecx
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	call	??$__destroy_range@V?$reverse_iterator@PAVshared_str@@@stlp_std@@Vshared_str@@@stlp_std@@YAXV?$reverse_iterator@PAVshared_str@@@0@0PAVshared_str@@@Z ; stlp_std::__destroy_range<stlp_std::reverse_iterator<shared_str *>,shared_str>

; 617  :     this->_M_end_of_storage.deallocate(this->_M_start, this->_M_end_of_storage._M_data - this->_M_start);

	mov	esi, DWORD PTR [esi]
	add	esp, 8
	test	esi, esi
	je	SHORT $LN23@M_clear@29
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN23@M_clear@29:

; 618  :   }

	pop	esi
	ret	0
?_M_clear@?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@AAEXXZ ENDP ; stlp_std::priv::_Impl_vector<shared_str,xalloc<shared_str> >::_M_clear
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_uninitialized.h
_TEXT	ENDS
;	COMDAT ??$__ucopy_ptrs@PBUItem@CSheduler@@PAU12@@priv@stlp_std@@YAPAUItem@CSheduler@@PBU23@0PAU23@ABU__false_type@1@@Z
_TEXT	SEGMENT
??$__ucopy_ptrs@PBUItem@CSheduler@@PAU12@@priv@stlp_std@@YAPAUItem@CSheduler@@PBU23@0PAU23@ABU__false_type@1@@Z PROC ; stlp_std::priv::__ucopy_ptrs<CSheduler::Item const *,CSheduler::Item *>, COMDAT
; ___first$ = edx
; ___last$ = eax
; ___result$ = ecx

; 113  : { return __ucopy(__first, __last, __result, random_access_iterator_tag(), (ptrdiff_t*)0); }

	jmp	??$__ucopy@PBUItem@CSheduler@@PAU12@H@priv@stlp_std@@YAPAUItem@CSheduler@@PBU23@0PAU23@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<CSheduler::Item const *,CSheduler::Item *,int>
??$__ucopy_ptrs@PBUItem@CSheduler@@PAU12@@priv@stlp_std@@YAPAUItem@CSheduler@@PBU23@0PAU23@ABU__false_type@1@@Z ENDP ; stlp_std::priv::__ucopy_ptrs<CSheduler::Item const *,CSheduler::Item *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$__ucopy_ptrs@PBVshared_str@@PAV1@@priv@stlp_std@@YAPAVshared_str@@PBV2@0PAV2@ABU__false_type@1@@Z
_TEXT	SEGMENT
??$__ucopy_ptrs@PBVshared_str@@PAV1@@priv@stlp_std@@YAPAVshared_str@@PBV2@0PAV2@ABU__false_type@1@@Z PROC ; stlp_std::priv::__ucopy_ptrs<shared_str const *,shared_str *>, COMDAT
; ___first$ = edx
; ___last$ = ecx
; ___result$ = eax

; 113  : { return __ucopy(__first, __last, __result, random_access_iterator_tag(), (ptrdiff_t*)0); }

	jmp	??$__ucopy@PBVshared_str@@PAV1@H@priv@stlp_std@@YAPAVshared_str@@PBV2@0PAV2@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<shared_str const *,shared_str *,int>
??$__ucopy_ptrs@PBVshared_str@@PAV1@@priv@stlp_std@@YAPAVshared_str@@PBV2@0PAV2@ABU__false_type@1@@Z ENDP ; stlp_std::priv::__ucopy_ptrs<shared_str const *,shared_str *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.c
_TEXT	ENDS
;	COMDAT ??4?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z
_TEXT	SEGMENT
tv323 = 8						; size = 4
___x$ = 8						; size = 4
??4?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z PROC ; stlp_std::priv::_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::operator=, COMDAT
; _this$ = esi

; 177  : vector<_Tp, _Alloc>& vector<_Tp, _Alloc>::operator = (const vector<_Tp, _Alloc>& __x) {

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR ___x$[esp+4]

; 178  :   if (&__x != this) {

	cmp	ebp, esi
	push	edi
	je	$LN77@operator@103

; 179  :     const size_type __xlen = __x.size();

	mov	edx, DWORD PTR [ebp+4]
	mov	ebx, DWORD PTR [ebp]

; 180  :     if (__xlen > capacity()) {

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+8]
	mov	edi, edx
	sub	edi, ebx
	sub	ecx, eax
	sar	edi, 3
	sar	ecx, 3
	cmp	edi, ecx
	mov	DWORD PTR tv323[esp+8], edx
	jbe	SHORT $LN4@operator@103

; 181  :       size_type __len = __xlen;
; 182  :       pointer __tmp = _M_allocate_and_copy(__len, __CONST_CAST(const_pointer, __x._M_start) + 0,
; 183  :                                                   __CONST_CAST(const_pointer, __x._M_finish) + 0);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	eax, DWORD PTR [edi*8]
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	mov	ecx, DWORD PTR tv323[esp+8]
	mov	edx, ebx
	mov	ebp, eax
	call	??$__ucopy@PBV?$FastDelegate0@X@fastdelegate@@PAV12@H@priv@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PBV23@0PAV23@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<fastdelegate::FastDelegate0<void> const *,fastdelegate::FastDelegate0<void> *,int>

; 184  :       _M_clear();

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN66@operator@103
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN66@operator@103:

; 196  :     }
; 197  :     this->_M_finish = this->_M_start + __xlen;

	mov	eax, ebp
	lea	ecx, DWORD PTR [eax+edi*8]
	lea	edx, DWORD PTR [ebp+edi*8]
	mov	DWORD PTR [esi], ebp
	mov	DWORD PTR [esi+8], edx
	mov	DWORD PTR [esi+4], ecx

; 198  :   }
; 199  :   return *this;

	mov	eax, esi

; 200  : }

	pop	edi
	pop	ebp
	pop	ebx
	ret	4
$LN4@operator@103:

; 185  :       this->_M_start = __tmp;
; 186  :       this->_M_end_of_storage._M_data = this->_M_start + __len;
; 187  :     } else if (size() >= __xlen) {

	mov	ecx, DWORD PTR [esi+4]
	sub	ecx, eax
	sar	ecx, 3
	cmp	ecx, edi
	jb	SHORT $LN2@operator@103

; 188  :       pointer __i = _STLP_PRIV __copy_ptrs(__CONST_CAST(const_pointer, __x._M_start) + 0,
; 189  :                                            __CONST_CAST(const_pointer, __x._M_finish) + 0, this->_M_start, _TrivialCopy());

	mov	ecx, edx
	mov	edx, ebx
	call	??$__copy_ptrs@PBV?$FastDelegate0@X@fastdelegate@@PAV12@@priv@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PBV23@0PAV23@ABU__false_type@1@@Z ; stlp_std::priv::__copy_ptrs<fastdelegate::FastDelegate0<void> const *,fastdelegate::FastDelegate0<void> *>

; 196  :     }
; 197  :     this->_M_finish = this->_M_start + __xlen;

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [eax+edi*8]
	mov	DWORD PTR [esi+4], ecx

; 198  :   }
; 199  :   return *this;

	mov	eax, esi

; 200  : }

	pop	edi
	pop	ebp
	pop	ebx
	ret	4
$LN2@operator@103:

; 190  :       _STLP_STD::_Destroy_Range(__i, this->_M_finish);
; 191  :     } else {
; 192  :       _STLP_PRIV __copy_ptrs(__CONST_CAST(const_pointer, __x._M_start),
; 193  :                              __CONST_CAST(const_pointer, __x._M_start) + size(), this->_M_start, _TrivialCopy());

	lea	ecx, DWORD PTR [ebx+ecx*8]
	mov	edx, ebx
	call	??$__copy_ptrs@PBV?$FastDelegate0@X@fastdelegate@@PAV12@@priv@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PBV23@0PAV23@ABU__false_type@1@@Z ; stlp_std::priv::__copy_ptrs<fastdelegate::FastDelegate0<void> const *,fastdelegate::FastDelegate0<void> *>

; 194  :       _STLP_PRIV __ucopy_ptrs(__CONST_CAST(const_pointer, __x._M_start) + size(),
; 195  :                               __CONST_CAST(const_pointer, __x._M_finish) + 0, this->_M_finish, _TrivialUCopy());

	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ebp]
	mov	ecx, eax
	sub	ecx, DWORD PTR [esi]
	sar	ecx, 3
	lea	edx, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR [ebp+4]
	call	??$__ucopy@PBV?$FastDelegate0@X@fastdelegate@@PAV12@H@priv@stlp_std@@YAPAV?$FastDelegate0@X@fastdelegate@@PBV23@0PAV23@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<fastdelegate::FastDelegate0<void> const *,fastdelegate::FastDelegate0<void> *,int>

; 196  :     }
; 197  :     this->_M_finish = this->_M_start + __xlen;

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [eax+edi*8]
	mov	DWORD PTR [esi+4], ecx
$LN77@operator@103:

; 200  : }

	pop	edi
	pop	ebp
	mov	eax, esi
	pop	ebx
	ret	4
??4?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ENDP ; stlp_std::priv::_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::operator=
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ??0?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAE@ABV012@@Z
_TEXT	SEGMENT
??0?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAE@ABV012@@Z PROC ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >, COMDAT
; _this$ = esi
; ___x$ = ebx

; 236  :   { this->_M_finish = _STLP_PRIV __ucopy_ptrs(__x.begin(), __x.end(), this->_M_start, _TrivialUCopy()); }

	mov	ecx, DWORD PTR [ebx+4]
	sub	ecx, DWORD PTR [ebx]
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	push	edi
	shr	eax, 31					; 0000001fH
	add	eax, edx
	xor	ecx, ecx
	lea	edi, DWORD PTR [eax+eax*4]
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [esi+4], ecx
	add	edi, edi
	mov	DWORD PTR [esi+8], ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	add	edi, edi
	push	edi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	mov	ecx, eax
	add	edi, ecx
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [esi+4], ecx
	mov	DWORD PTR [esi+8], edi
	mov	eax, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR [ebx]
	call	??$__ucopy@PBUItem@CSheduler@@PAU12@H@priv@stlp_std@@YAPAUItem@CSheduler@@PBU23@0PAU23@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<CSheduler::Item const *,CSheduler::Item *,int>
	mov	DWORD PTR [esi+4], eax
	mov	eax, esi
	pop	edi
	ret	0
??0?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAE@ABV012@@Z ENDP ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ??0?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAE@ABV?$xalloc@UItem@CSheduler@@@@@Z
_TEXT	SEGMENT
??0?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAE@ABV?$xalloc@UItem@CSheduler@@@@@Z PROC ; stlp_std::vector<CSheduler::Item,xalloc<CSheduler::Item> >::vector<CSheduler::Item,xalloc<CSheduler::Item> >, COMDAT
; _this$ = eax

; 106  :   explicit vector(const allocator_type& __a = allocator_type())

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAE@ABV?$xalloc@UItem@CSheduler@@@@@Z ENDP ; stlp_std::vector<CSheduler::Item,xalloc<CSheduler::Item> >::vector<CSheduler::Item,xalloc<CSheduler::Item> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ??0?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAE@ABV012@@Z
_TEXT	SEGMENT
??0?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAE@ABV012@@Z PROC ; stlp_std::priv::_Impl_vector<shared_str,xalloc<shared_str> >::_Impl_vector<shared_str,xalloc<shared_str> >, COMDAT
; _this$ = esi
; ___x$ = edi

; 236  :   { this->_M_finish = _STLP_PRIV __ucopy_ptrs(__x.begin(), __x.end(), this->_M_start, _TrivialUCopy()); }

	mov	eax, DWORD PTR [edi+4]
	sub	eax, DWORD PTR [edi]
	xor	ecx, ecx
	push	ebx
	sar	eax, 2
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [esi+4], ecx
	lea	ebx, DWORD PTR [eax*4]
	mov	DWORD PTR [esi+8], ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	ebx
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	add	ebx, eax
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], ebx
	mov	ecx, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [edi]
	call	??$__ucopy@PBVshared_str@@PAV1@H@priv@stlp_std@@YAPAVshared_str@@PBV2@0PAV2@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<shared_str const *,shared_str *,int>
	mov	DWORD PTR [esi+4], eax
	mov	eax, esi
	pop	ebx
	ret	0
??0?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAE@ABV012@@Z ENDP ; stlp_std::priv::_Impl_vector<shared_str,xalloc<shared_str> >::_Impl_vector<shared_str,xalloc<shared_str> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ??4?$vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@stlp_std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
??4?$vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@stlp_std@@QAEAAV01@ABV01@@Z PROC ; stlp_std::vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::operator=, COMDAT
; _this$ = ecx
; ___x$ = eax

; 149  :   _Self& operator=(const _Self& __x) { _M_impl = __x._M_impl; return *this; }

	push	esi
	mov	esi, ecx
	push	eax
	call	??4?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::operator=
	mov	eax, esi
	pop	esi
	ret	0
??4?$vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@stlp_std@@QAEAAV01@ABV01@@Z ENDP ; stlp_std::vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::operator=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAE@ABV01@@Z PROC ; stlp_std::vector<CSheduler::Item,xalloc<CSheduler::Item> >::vector<CSheduler::Item,xalloc<CSheduler::Item> >, COMDAT
; _this$ = esi
; ___x$ = ebx

; 123  :   vector(const _Self& __x)

	mov	ecx, DWORD PTR [ebx+4]
	sub	ecx, DWORD PTR [ebx]
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	push	edi
	shr	eax, 31					; 0000001fH
	add	eax, edx
	xor	ecx, ecx
	lea	edi, DWORD PTR [eax+eax*4]
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [esi+4], ecx
	add	edi, edi
	mov	DWORD PTR [esi+8], ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	add	edi, edi
	push	edi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	mov	ecx, eax
	add	edi, ecx
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [esi+4], ecx
	mov	DWORD PTR [esi+8], edi
	mov	eax, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR [ebx]
	call	??$__ucopy@PBUItem@CSheduler@@PAU12@H@priv@stlp_std@@YAPAUItem@CSheduler@@PBU23@0PAU23@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<CSheduler::Item const *,CSheduler::Item *,int>
	mov	DWORD PTR [esi+4], eax
	mov	eax, esi
	pop	edi
	ret	0
??0?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAE@ABV01@@Z ENDP ; stlp_std::vector<CSheduler::Item,xalloc<CSheduler::Item> >::vector<CSheduler::Item,xalloc<CSheduler::Item> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ??0?$xr_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@@QAE@XZ PROC ; xr_vector<CSheduler::Item,xalloc<CSheduler::Item> >::xr_vector<CSheduler::Item,xalloc<CSheduler::Item> >, COMDAT
; _this$ = eax

; 123  : 			xr_vector			()									: inherited	()					{}

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$xr_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@@QAE@XZ ENDP ; xr_vector<CSheduler::Item,xalloc<CSheduler::Item> >::xr_vector<CSheduler::Item,xalloc<CSheduler::Item> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ??0?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@stlp_std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@stlp_std@@QAE@ABV01@@Z PROC ; stlp_std::vector<shared_str,xalloc<shared_str> >::vector<shared_str,xalloc<shared_str> >, COMDAT
; _this$ = esi
; ___x$ = edi

; 123  :   vector(const _Self& __x)

	mov	eax, DWORD PTR [edi+4]
	sub	eax, DWORD PTR [edi]
	xor	ecx, ecx
	push	ebx
	sar	eax, 2
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [esi+4], ecx
	lea	ebx, DWORD PTR [eax*4]
	mov	DWORD PTR [esi+8], ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	ebx
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	add	ebx, eax
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], ebx
	mov	ecx, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [edi]
	call	??$__ucopy@PBVshared_str@@PAV1@H@priv@stlp_std@@YAPAVshared_str@@PBV2@0PAV2@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<shared_str const *,shared_str *,int>
	mov	DWORD PTR [esi+4], eax
	mov	eax, esi
	pop	ebx
	ret	0
??0?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@stlp_std@@QAE@ABV01@@Z ENDP ; stlp_std::vector<shared_str,xalloc<shared_str> >::vector<shared_str,xalloc<shared_str> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4?$xr_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
??4?$xr_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@@QAEAAV0@ABV0@@Z PROC ; xr_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::operator=, COMDAT
; _this$ = ecx
; ___that$ = eax
	push	esi
	mov	esi, ecx
	push	eax
	call	??4?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::operator=
	mov	eax, esi
	pop	esi
	ret	0
??4?$xr_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@@QAEAAV0@ABV0@@Z ENDP ; xr_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::operator=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4?$CRegistrator@VpureDeviceReset@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
??4?$CRegistrator@VpureDeviceReset@@@@QAEAAV0@ABV0@@Z PROC ; CRegistrator<pureDeviceReset>::operator=, COMDAT
; _this$ = eax
; ___that$ = esi
	push	edi
	mov	edi, eax
	push	esi
	call	??4?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::operator=
	mov	eax, DWORD PTR [edi+12]
	xor	eax, DWORD PTR [esi+12]
	and	eax, 1
	xor	DWORD PTR [edi+12], eax
	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [esi+12]
	xor	ecx, eax
	and	ecx, 2
	xor	ecx, eax
	mov	DWORD PTR [edi+12], ecx
	mov	eax, edi
	pop	edi
	ret	0
??4?$CRegistrator@VpureDeviceReset@@@@QAEAAV0@ABV0@@Z ENDP ; CRegistrator<pureDeviceReset>::operator=
_TEXT	ENDS
PUBLIC	??0CRenderDeviceBase@@QAE@ABV0@@Z		; CRenderDeviceBase::CRenderDeviceBase
; Function compile flags: /Ogtpy
;	COMDAT ??0CRenderDeviceBase@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0CRenderDeviceBase@@QAE@ABV0@@Z PROC			; CRenderDeviceBase::CRenderDeviceBase, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	test	eax, eax
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7IRenderDevice@@6B@
	je	SHORT $LN3@CRenderDev@3
	add	eax, 4
	jmp	SHORT $LN4@CRenderDev@3
$LN3@CRenderDev@3:
	xor	eax, eax
$LN4@CRenderDev@3:
	push	eax
	lea	ecx, DWORD PTR [esi+4]
	call	??0CRenderDeviceData@@QAE@ABV0@@Z
	mov	DWORD PTR [esi], OFFSET ??_7CRenderDeviceBase@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0CRenderDeviceBase@@QAE@ABV0@@Z ENDP			; CRenderDeviceBase::CRenderDeviceBase
_TEXT	ENDS
PUBLIC	??1CRenderDeviceBase@@QAE@XZ			; CRenderDeviceBase::~CRenderDeviceBase
; Function compile flags: /Ogtpy
;	COMDAT ??1CRenderDeviceBase@@QAE@XZ
_TEXT	SEGMENT
??1CRenderDeviceBase@@QAE@XZ PROC			; CRenderDeviceBase::~CRenderDeviceBase, COMDAT
; _this$ = ecx
	test	ecx, ecx
	je	SHORT $LN3@CRenderDev@4
	add	ecx, 4
	jmp	??1CRenderDeviceData@@QAE@XZ
$LN3@CRenderDev@4:
	xor	ecx, ecx
	jmp	??1CRenderDeviceData@@QAE@XZ
??1CRenderDeviceBase@@QAE@XZ ENDP			; CRenderDeviceBase::~CRenderDeviceBase
_TEXT	ENDS
PUBLIC	??0CRenderDeviceBase@@QAE@XZ			; CRenderDeviceBase::CRenderDeviceBase
; Function compile flags: /Ogtpy
;	COMDAT ??0CRenderDeviceBase@@QAE@XZ
_TEXT	SEGMENT
??0CRenderDeviceBase@@QAE@XZ PROC			; CRenderDeviceBase::CRenderDeviceBase, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7IRenderDevice@@6B@
	call	??0CRenderDeviceData@@QAE@XZ
	mov	DWORD PTR [esi], OFFSET ??_7CRenderDeviceBase@@6B@
	mov	eax, esi
	pop	esi
	ret	0
??0CRenderDeviceBase@@QAE@XZ ENDP			; CRenderDeviceBase::CRenderDeviceBase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4?$CRegistrator@VpureScreenResolutionChanged@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
??4?$CRegistrator@VpureScreenResolutionChanged@@@@QAEAAV0@ABV0@@Z PROC ; CRegistrator<pureScreenResolutionChanged>::operator=, COMDAT
; _this$ = eax
; ___that$ = esi
	push	edi
	mov	edi, eax
	push	esi
	call	??4?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::operator=
	mov	eax, DWORD PTR [edi+12]
	xor	eax, DWORD PTR [esi+12]
	and	eax, 1
	xor	DWORD PTR [edi+12], eax
	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [esi+12]
	xor	ecx, eax
	and	ecx, 2
	xor	ecx, eax
	mov	DWORD PTR [edi+12], ecx
	mov	eax, edi
	pop	edi
	ret	0
??4?$CRegistrator@VpureScreenResolutionChanged@@@@QAEAAV0@ABV0@@Z ENDP ; CRegistrator<pureScreenResolutionChanged>::operator=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4?$CRegistrator@VpureFrame@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
??4?$CRegistrator@VpureFrame@@@@QAEAAV0@ABV0@@Z PROC	; CRegistrator<pureFrame>::operator=, COMDAT
; _this$ = eax
; ___that$ = esi
	push	edi
	mov	edi, eax
	push	esi
	call	??4?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::operator=
	mov	eax, DWORD PTR [edi+12]
	xor	eax, DWORD PTR [esi+12]
	and	eax, 1
	xor	DWORD PTR [edi+12], eax
	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [esi+12]
	xor	ecx, eax
	and	ecx, 2
	xor	ecx, eax
	mov	DWORD PTR [edi+12], ecx
	mov	eax, edi
	pop	edi
	ret	0
??4?$CRegistrator@VpureFrame@@@@QAEAAV0@ABV0@@Z ENDP	; CRegistrator<pureFrame>::operator=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4?$CRegistrator@VpureAppEnd@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
??4?$CRegistrator@VpureAppEnd@@@@QAEAAV0@ABV0@@Z PROC	; CRegistrator<pureAppEnd>::operator=, COMDAT
; _this$ = eax
; ___that$ = esi
	push	edi
	mov	edi, eax
	push	esi
	call	??4?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::operator=
	mov	eax, DWORD PTR [edi+12]
	xor	eax, DWORD PTR [esi+12]
	and	eax, 1
	xor	DWORD PTR [edi+12], eax
	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [esi+12]
	xor	ecx, eax
	and	ecx, 2
	xor	ecx, eax
	mov	DWORD PTR [edi+12], ecx
	mov	eax, edi
	pop	edi
	ret	0
??4?$CRegistrator@VpureAppEnd@@@@QAEAAV0@ABV0@@Z ENDP	; CRegistrator<pureAppEnd>::operator=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4?$CRegistrator@VpureAppStart@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
??4?$CRegistrator@VpureAppStart@@@@QAEAAV0@ABV0@@Z PROC	; CRegistrator<pureAppStart>::operator=, COMDAT
; _this$ = eax
; ___that$ = esi
	push	edi
	mov	edi, eax
	push	esi
	call	??4?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::operator=
	mov	eax, DWORD PTR [edi+12]
	xor	eax, DWORD PTR [esi+12]
	and	eax, 1
	xor	DWORD PTR [edi+12], eax
	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [esi+12]
	xor	ecx, eax
	and	ecx, 2
	xor	ecx, eax
	mov	DWORD PTR [edi+12], ecx
	mov	eax, edi
	pop	edi
	ret	0
??4?$CRegistrator@VpureAppStart@@@@QAEAAV0@ABV0@@Z ENDP	; CRegistrator<pureAppStart>::operator=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4?$CRegistrator@VpureAppDeactivate@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
??4?$CRegistrator@VpureAppDeactivate@@@@QAEAAV0@ABV0@@Z PROC ; CRegistrator<pureAppDeactivate>::operator=, COMDAT
; _this$ = eax
; ___that$ = esi
	push	edi
	mov	edi, eax
	push	esi
	call	??4?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::operator=
	mov	eax, DWORD PTR [edi+12]
	xor	eax, DWORD PTR [esi+12]
	and	eax, 1
	xor	DWORD PTR [edi+12], eax
	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [esi+12]
	xor	ecx, eax
	and	ecx, 2
	xor	ecx, eax
	mov	DWORD PTR [edi+12], ecx
	mov	eax, edi
	pop	edi
	ret	0
??4?$CRegistrator@VpureAppDeactivate@@@@QAEAAV0@ABV0@@Z ENDP ; CRegistrator<pureAppDeactivate>::operator=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4?$CRegistrator@VpureAppActivate@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
??4?$CRegistrator@VpureAppActivate@@@@QAEAAV0@ABV0@@Z PROC ; CRegistrator<pureAppActivate>::operator=, COMDAT
; _this$ = eax
; ___that$ = esi
	push	edi
	mov	edi, eax
	push	esi
	call	??4?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::operator=
	mov	eax, DWORD PTR [edi+12]
	xor	eax, DWORD PTR [esi+12]
	and	eax, 1
	xor	DWORD PTR [edi+12], eax
	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [esi+12]
	xor	ecx, eax
	and	ecx, 2
	xor	ecx, eax
	mov	DWORD PTR [edi+12], ecx
	mov	eax, edi
	pop	edi
	ret	0
??4?$CRegistrator@VpureAppActivate@@@@QAEAAV0@ABV0@@Z ENDP ; CRegistrator<pureAppActivate>::operator=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4?$CRegistrator@VpureRender@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
??4?$CRegistrator@VpureRender@@@@QAEAAV0@ABV0@@Z PROC	; CRegistrator<pureRender>::operator=, COMDAT
; _this$ = eax
; ___that$ = esi
	push	edi
	mov	edi, eax
	push	esi
	call	??4?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::operator=
	mov	eax, DWORD PTR [edi+12]
	xor	eax, DWORD PTR [esi+12]
	and	eax, 1
	xor	DWORD PTR [edi+12], eax
	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [esi+12]
	xor	ecx, eax
	and	ecx, 2
	xor	ecx, eax
	mov	DWORD PTR [edi+12], ecx
	mov	eax, edi
	pop	edi
	ret	0
??4?$CRegistrator@VpureRender@@@@QAEAAV0@ABV0@@Z ENDP	; CRegistrator<pureRender>::operator=
_TEXT	ENDS
PUBLIC	??4CRenderDeviceData@@QAEAAV0@ABV0@@Z		; CRenderDeviceData::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4CRenderDeviceData@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4CRenderDeviceData@@QAEAAV0@ABV0@@Z PROC		; CRenderDeviceData::operator=, COMDAT
; _this$ = ecx
	push	ebx
	mov	ebx, ecx
	push	ebp
	mov	ebp, DWORD PTR ___that$[esp+4]
	mov	eax, DWORD PTR [ebp]
	mov	DWORD PTR [ebx], eax
	mov	ecx, DWORD PTR [ebp+4]
	mov	DWORD PTR [ebx+4], ecx
	mov	edx, DWORD PTR [ebp+8]
	mov	DWORD PTR [ebx+8], edx
	mov	eax, DWORD PTR [ebp+12]
	mov	DWORD PTR [ebx+12], eax
	mov	ecx, DWORD PTR [ebp+16]
	mov	DWORD PTR [ebx+16], ecx
	mov	edx, DWORD PTR [ebp+20]
	mov	DWORD PTR [ebx+20], edx
	fld	DWORD PTR [ebp+24]
	fstp	DWORD PTR [ebx+24]
	push	esi
	fld	DWORD PTR [ebp+28]
	push	edi
	fstp	DWORD PTR [ebx+28]
	mov	eax, DWORD PTR [ebp+32]
	mov	DWORD PTR [ebx+32], eax
	mov	ecx, DWORD PTR [ebp+36]
	mov	DWORD PTR [ebx+36], ecx
	mov	edx, DWORD PTR [ebp+40]
	mov	DWORD PTR [ebx+40], edx
	mov	eax, DWORD PTR [ebp+44]
	mov	DWORD PTR [ebx+44], eax
	mov	ecx, DWORD PTR [ebp+48]
	mov	DWORD PTR [ebx+48], ecx
	mov	edx, DWORD PTR [ebp+52]
	mov	DWORD PTR [ebx+52], edx
	mov	eax, DWORD PTR [ebp+56]
	mov	DWORD PTR [ebx+56], eax
	mov	ecx, DWORD PTR [ebp+60]
	mov	DWORD PTR [ebx+60], ecx
	mov	edx, DWORD PTR [ebp+64]
	mov	DWORD PTR [ebx+64], edx
	mov	eax, DWORD PTR [ebp+68]
	mov	DWORD PTR [ebx+68], eax
	mov	ecx, DWORD PTR [ebp+72]
	mov	DWORD PTR [ebx+72], ecx
	mov	edx, DWORD PTR [ebp+76]
	mov	DWORD PTR [ebx+76], edx
	mov	eax, DWORD PTR [ebp+80]
	mov	DWORD PTR [ebx+80], eax
	mov	ecx, DWORD PTR [ebp+84]
	mov	DWORD PTR [ebx+84], ecx
	mov	edx, DWORD PTR [ebp+88]
	mov	DWORD PTR [ebx+88], edx
	lea	esi, DWORD PTR [ebp+92]
	lea	edi, DWORD PTR [ebx+92]
	mov	ecx, 16					; 00000010H
	rep movsd
	lea	esi, DWORD PTR [ebp+156]
	lea	edi, DWORD PTR [ebx+156]
	mov	ecx, 16					; 00000010H
	rep movsd
	lea	esi, DWORD PTR [ebp+220]
	lea	edi, DWORD PTR [ebx+220]
	mov	ecx, 16					; 00000010H
	rep movsd
	mov	eax, DWORD PTR [ebp+284]
	mov	DWORD PTR [ebx+284], eax
	mov	ecx, DWORD PTR [ebp+288]
	mov	DWORD PTR [ebx+288], ecx
	mov	edx, DWORD PTR [ebp+292]
	mov	DWORD PTR [ebx+292], edx
	lea	esi, DWORD PTR [ebp+296]
	lea	edi, DWORD PTR [ebx+296]
	mov	ecx, 16					; 00000010H
	rep movsd
	lea	esi, DWORD PTR [ebp+360]
	lea	edi, DWORD PTR [ebx+360]
	mov	ecx, 16					; 00000010H
	rep movsd
	lea	esi, DWORD PTR [ebp+424]
	lea	edi, DWORD PTR [ebx+424]
	mov	ecx, 16					; 00000010H
	rep movsd
	fld	DWORD PTR [ebp+488]
	fstp	DWORD PTR [ebx+488]
	fld	DWORD PTR [ebp+492]
	fstp	DWORD PTR [ebx+492]
	mov	eax, DWORD PTR [ebp+496]
	mov	DWORD PTR [ebx+496], eax
	lea	eax, DWORD PTR [ebp+500]
	test	eax, eax
	je	SHORT $LN7@operator@104
	lea	esi, DWORD PTR [eax+8]
	jmp	SHORT $LN8@operator@104
$LN7@operator@104:
	xor	esi, esi
$LN8@operator@104:
	lea	edi, DWORD PTR [ebx+508]
	mov	ecx, 14					; 0000000eH
	rep movsd
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR [ebx+564], ecx
	mov	edx, DWORD PTR [eax+68]
	lea	eax, DWORD PTR [ebp+572]
	test	eax, eax
	mov	DWORD PTR [ebx+568], edx
	je	SHORT $LN13@operator@104
	lea	esi, DWORD PTR [eax+8]
	jmp	SHORT $LN14@operator@104
$LN13@operator@104:
	xor	esi, esi
$LN14@operator@104:
	lea	edi, DWORD PTR [ebx+580]
	mov	ecx, 14					; 0000000eH
	rep movsd
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR [ebx+636], ecx
	mov	edx, DWORD PTR [eax+68]
	lea	esi, DWORD PTR [ebp+644]
	lea	edi, DWORD PTR [ebx+644]
	push	esi
	mov	DWORD PTR [ebx+640], edx
	call	??4?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::operator=
	mov	eax, DWORD PTR [edi+12]
	xor	eax, DWORD PTR [esi+12]
	and	eax, 1
	xor	DWORD PTR [edi+12], eax
	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [esi+12]
	xor	ecx, eax
	and	ecx, 2
	xor	ecx, eax
	mov	DWORD PTR [edi+12], ecx
	lea	esi, DWORD PTR [ebp+660]
	lea	edi, DWORD PTR [ebx+660]
	push	esi
	call	??4?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::operator=
	mov	edx, DWORD PTR [edi+12]
	xor	edx, DWORD PTR [esi+12]
	and	edx, 1
	xor	DWORD PTR [edi+12], edx
	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [esi+12]
	xor	ecx, eax
	and	ecx, 2
	xor	ecx, eax
	mov	DWORD PTR [edi+12], ecx
	lea	esi, DWORD PTR [ebp+676]
	lea	edi, DWORD PTR [ebx+676]
	push	esi
	call	??4?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::operator=
	mov	edx, DWORD PTR [edi+12]
	xor	edx, DWORD PTR [esi+12]
	and	edx, 1
	xor	DWORD PTR [edi+12], edx
	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [esi+12]
	xor	ecx, eax
	and	ecx, 2
	xor	ecx, eax
	mov	DWORD PTR [edi+12], ecx
	lea	esi, DWORD PTR [ebp+692]
	lea	edi, DWORD PTR [ebx+692]
	push	esi
	call	??4?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::operator=
	mov	edx, DWORD PTR [edi+12]
	xor	edx, DWORD PTR [esi+12]
	and	edx, 1
	xor	DWORD PTR [edi+12], edx
	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [esi+12]
	xor	ecx, eax
	and	ecx, 2
	xor	ecx, eax
	mov	DWORD PTR [edi+12], ecx
	lea	esi, DWORD PTR [ebp+708]
	lea	edi, DWORD PTR [ebx+708]
	push	esi
	call	??4?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::operator=
	mov	edx, DWORD PTR [edi+12]
	xor	edx, DWORD PTR [esi+12]
	and	edx, 1
	xor	DWORD PTR [edi+12], edx
	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [esi+12]
	xor	ecx, eax
	and	ecx, 2
	xor	ecx, eax
	mov	DWORD PTR [edi+12], ecx
	lea	esi, DWORD PTR [ebp+724]
	lea	edi, DWORD PTR [ebx+724]
	push	esi
	call	??4?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::operator=
	mov	edx, DWORD PTR [edi+12]
	xor	edx, DWORD PTR [esi+12]
	and	edx, 1
	xor	DWORD PTR [edi+12], edx
	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [esi+12]
	xor	ecx, eax
	and	ecx, 2
	xor	ecx, eax
	mov	DWORD PTR [edi+12], ecx
	lea	esi, DWORD PTR [ebp+740]
	lea	edi, DWORD PTR [ebx+740]
	push	esi
	call	??4?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::operator=
	mov	edx, DWORD PTR [edi+12]
	xor	edx, DWORD PTR [esi+12]
	and	edx, 1
	xor	DWORD PTR [edi+12], edx
	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [esi+12]
	xor	ecx, eax
	and	ecx, 2
	xor	ecx, eax
	mov	DWORD PTR [edi+12], ecx
	mov	edx, DWORD PTR [ebp+756]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [ebx+756], edx
	mov	eax, ebx
	pop	ebx
	ret	4
??4CRenderDeviceData@@QAEAAV0@ABV0@@Z ENDP		; CRenderDeviceData::operator=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
??0?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@QAE@ABV0@@Z PROC ; xr_vector<shared_str,xalloc<shared_str> >::xr_vector<shared_str,xalloc<shared_str> >, COMDAT
; _this$ = esi
; ___that$ = edi
	mov	eax, DWORD PTR [edi+4]
	sub	eax, DWORD PTR [edi]
	xor	ecx, ecx
	push	ebx
	sar	eax, 2
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [esi+4], ecx
	lea	ebx, DWORD PTR [eax*4]
	mov	DWORD PTR [esi+8], ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	ebx
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	add	ebx, eax
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], ebx
	mov	ecx, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [edi]
	call	??$__ucopy@PBVshared_str@@PAV1@H@priv@stlp_std@@YAPAVshared_str@@PBV2@0PAV2@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<shared_str const *,shared_str *,int>
	mov	DWORD PTR [esi+4], eax
	mov	eax, esi
	pop	ebx
	ret	0
??0?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@QAE@ABV0@@Z ENDP ; xr_vector<shared_str,xalloc<shared_str> >::xr_vector<shared_str,xalloc<shared_str> >
_TEXT	ENDS
PUBLIC	??0CStats@@QAE@ABV0@@Z				; CStats::CStats
; Function compile flags: /Ogtpy
;	COMDAT ??0CStats@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0CStats@@QAE@ABV0@@Z PROC				; CStats::CStats, COMDAT
; _this$ = ecx
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR ___that$[esp+4]
	xor	edx, edx
	cmp	ebp, edx
	push	esi
	mov	ebx, ecx
	push	edi
	mov	DWORD PTR [ebx], OFFSET ??_7pureRender@@6B@
	je	SHORT $LN3@CStats@2
	lea	esi, DWORD PTR [ebp+8]
	jmp	SHORT $LN4@CStats@2
$LN3@CStats@2:
	xor	esi, esi
$LN4@CStats@2:
	lea	edi, DWORD PTR [ebx+8]
	mov	ecx, 54					; 00000036H
	rep movsd
	mov	DWORD PTR [ebx], OFFSET ??_7CStats@@6B@
	mov	eax, DWORD PTR [ebp+224]
	mov	DWORD PTR [ebx+224], eax
	lea	esi, DWORD PTR [ebp+264]
	fld	DWORD PTR [ebp+228]
	lea	edi, DWORD PTR [ebx+264]
	fstp	DWORD PTR [ebx+228]
	fld	DWORD PTR [ebp+232]
	fstp	DWORD PTR [ebx+232]
	fld	DWORD PTR [ebp+236]
	fstp	DWORD PTR [ebx+236]
	fld	DWORD PTR [ebp+240]
	fstp	DWORD PTR [ebx+240]
	mov	ecx, DWORD PTR [ebp+244]
	mov	DWORD PTR [ebx+244], ecx
	mov	eax, DWORD PTR [ebp+248]
	mov	DWORD PTR [ebx+248], eax
	mov	ecx, DWORD PTR [ebp+252]
	mov	DWORD PTR [ebx+252], ecx
	fld	DWORD PTR [ebp+256]
	fstp	DWORD PTR [ebx+256]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+336]
	lea	edi, DWORD PTR [ebx+336]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+408]
	lea	edi, DWORD PTR [ebx+408]
	mov	ecx, 18					; 00000012H
	rep movsd
	mov	eax, DWORD PTR [ebp+480]
	mov	DWORD PTR [ebx+480], eax
	mov	ecx, DWORD PTR [ebp+484]
	mov	DWORD PTR [ebx+484], ecx
	mov	eax, DWORD PTR [ebp+488]
	mov	DWORD PTR [ebx+488], eax
	mov	ecx, DWORD PTR [ebp+492]
	mov	DWORD PTR [ebx+492], ecx
	mov	eax, DWORD PTR [ebp+496]
	mov	DWORD PTR [ebx+496], eax
	mov	ecx, DWORD PTR [ebp+500]
	mov	DWORD PTR [ebx+500], ecx
	mov	eax, DWORD PTR [ebp+504]
	mov	DWORD PTR [ebx+504], eax
	lea	esi, DWORD PTR [ebp+512]
	lea	edi, DWORD PTR [ebx+512]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+584]
	lea	edi, DWORD PTR [ebx+584]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+656]
	lea	edi, DWORD PTR [ebx+656]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+728]
	lea	edi, DWORD PTR [ebx+728]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+800]
	lea	edi, DWORD PTR [ebx+800]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+872]
	lea	edi, DWORD PTR [ebx+872]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+944]
	lea	edi, DWORD PTR [ebx+944]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+1016]
	lea	edi, DWORD PTR [ebx+1016]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+1088]
	lea	edi, DWORD PTR [ebx+1088]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+1160]
	lea	edi, DWORD PTR [ebx+1160]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+1232]
	lea	edi, DWORD PTR [ebx+1232]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+1304]
	lea	edi, DWORD PTR [ebx+1304]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+1376]
	lea	edi, DWORD PTR [ebx+1376]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+1448]
	lea	edi, DWORD PTR [ebx+1448]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+1520]
	lea	edi, DWORD PTR [ebx+1520]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+1592]
	lea	edi, DWORD PTR [ebx+1592]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+1664]
	lea	edi, DWORD PTR [ebx+1664]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+1736]
	lea	edi, DWORD PTR [ebx+1736]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+1808]
	lea	edi, DWORD PTR [ebx+1808]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+1880]
	lea	edi, DWORD PTR [ebx+1880]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+1952]
	lea	edi, DWORD PTR [ebx+1952]
	mov	ecx, 18					; 00000012H
	rep movsd
	mov	ecx, DWORD PTR [ebp+2024]
	mov	DWORD PTR [ebx+2024], ecx
	mov	eax, DWORD PTR [ebp+2028]
	mov	DWORD PTR [ebx+2028], eax
	mov	ecx, DWORD PTR [ebp+2032]
	mov	DWORD PTR [ebx+2032], ecx
	lea	esi, DWORD PTR [ebp+2040]
	lea	edi, DWORD PTR [ebx+2040]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+2112]
	lea	edi, DWORD PTR [ebx+2112]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+2184]
	lea	edi, DWORD PTR [ebx+2184]
	mov	ecx, 18					; 00000012H
	rep movsd
	mov	eax, DWORD PTR [ebp+2256]
	mov	DWORD PTR [ebx+2256], eax
	lea	esi, DWORD PTR [ebp+2264]
	lea	edi, DWORD PTR [ebx+2264]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+2336]
	lea	edi, DWORD PTR [ebx+2336]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+2408]
	lea	edi, DWORD PTR [ebx+2408]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+2480]
	lea	edi, DWORD PTR [ebx+2480]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+2552]
	lea	edi, DWORD PTR [ebx+2552]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+2624]
	lea	edi, DWORD PTR [ebx+2624]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+2696]
	lea	edi, DWORD PTR [ebx+2696]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+2768]
	lea	edi, DWORD PTR [ebx+2768]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+2840]
	lea	edi, DWORD PTR [ebx+2840]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+2912]
	lea	edi, DWORD PTR [ebx+2912]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+2984]
	lea	edi, DWORD PTR [ebx+2984]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+3056]
	lea	edi, DWORD PTR [ebx+3056]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+3128]
	lea	edi, DWORD PTR [ebx+3128]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+3200]
	lea	edi, DWORD PTR [ebx+3200]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+3272]
	lea	edi, DWORD PTR [ebx+3272]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+3344]
	lea	edi, DWORD PTR [ebx+3344]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+3416]
	lea	edi, DWORD PTR [ebx+3416]
	mov	ecx, 18					; 00000012H
	rep movsd
	mov	DWORD PTR [ebx+3488], edx
	mov	eax, DWORD PTR [ebp+3488]
	cmp	eax, edx
	je	SHORT $LN78@CStats@2
	add	DWORD PTR [eax], 1
$LN78@CStats@2:
	mov	ecx, DWORD PTR [ebx+3488]
	cmp	ecx, edx
	je	SHORT $LN12@CStats@2
	add	DWORD PTR [ecx], -1
	mov	ecx, DWORD PTR [ebx+3488]
	cmp	DWORD PTR [ecx], edx
	jne	SHORT $LN12@CStats@2
	mov	DWORD PTR [ebx+3488], edx
$LN12@CStats@2:
	mov	DWORD PTR [ebx+3488], eax
	mov	DWORD PTR [ebx+3492], edx
	mov	eax, DWORD PTR [ebp+3492]
	cmp	eax, edx
	je	SHORT $LN79@CStats@2
	add	DWORD PTR [eax], 1
$LN79@CStats@2:
	mov	ecx, DWORD PTR [ebx+3492]
	cmp	ecx, edx
	je	SHORT $LN21@CStats@2
	add	DWORD PTR [ecx], -1
	mov	ecx, DWORD PTR [ebx+3492]
	cmp	DWORD PTR [ecx], edx
	jne	SHORT $LN21@CStats@2
	mov	DWORD PTR [ebx+3492], edx
$LN21@CStats@2:
	mov	DWORD PTR [ebx+3492], eax
	mov	DWORD PTR [ebx+3496], edx
	mov	eax, DWORD PTR [ebp+3496]
	cmp	eax, edx
	je	SHORT $LN27@CStats@2
	add	DWORD PTR [eax], 1
$LN27@CStats@2:
	mov	ecx, DWORD PTR [ebx+3496]
	cmp	ecx, edx
	je	SHORT $LN30@CStats@2
	add	DWORD PTR [ecx], -1
	mov	ecx, DWORD PTR [ebx+3496]
	cmp	DWORD PTR [ecx], edx
	jne	SHORT $LN30@CStats@2
	mov	DWORD PTR [ebx+3496], edx
$LN30@CStats@2:
	mov	DWORD PTR [ebx+3496], eax
	mov	eax, DWORD PTR [ebp+3504]
	sub	eax, DWORD PTR [ebp+3500]
	mov	DWORD PTR [ebx+3500], edx
	sar	eax, 2
	mov	DWORD PTR [ebx+3504], edx
	lea	esi, DWORD PTR [eax*4]
	mov	DWORD PTR [ebx+3508], edx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	lea	edx, DWORD PTR [eax+esi]
	mov	DWORD PTR [ebx+3500], eax
	mov	DWORD PTR [ebx+3504], eax
	mov	DWORD PTR [ebx+3508], edx
	mov	ecx, DWORD PTR [ebp+3504]
	mov	edx, DWORD PTR [ebp+3500]
	call	??$__ucopy@PBVshared_str@@PAV1@H@priv@stlp_std@@YAPAVshared_str@@PBV2@0PAV2@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<shared_str const *,shared_str *,int>
	mov	DWORD PTR [ebx+3504], eax
	lea	edi, DWORD PTR [ebp+3512]
	lea	esi, DWORD PTR [ebx+3512]
	mov	eax, edi
	call	??0?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAE@ABV012@@Z ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >
	mov	eax, DWORD PTR [esi+12]
	xor	eax, DWORD PTR [edi+12]
	mov	edx, DWORD PTR __imp_?RenderFactory@@3PAVIRenderFactory@@A
	and	eax, 1
	xor	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [edi+12]
	xor	ecx, eax
	and	ecx, 2
	xor	ecx, eax
	mov	DWORD PTR [esi+12], ecx
	mov	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+56]
	call	edx
	mov	DWORD PTR [ebx+3528], eax
	mov	ecx, DWORD PTR [ebp+3528]
	mov	edx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx+4]
	push	ecx
	mov	ecx, eax
	call	edx
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ebx
	pop	ebx
	ret	4
??0CStats@@QAE@ABV0@@Z ENDP				; CStats::CStats
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$xr_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
??0?$xr_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@@QAE@ABV0@@Z PROC ; xr_vector<CSheduler::Item,xalloc<CSheduler::Item> >::xr_vector<CSheduler::Item,xalloc<CSheduler::Item> >, COMDAT
; _this$ = esi
; ___that$ = ebx
	mov	ecx, DWORD PTR [ebx+4]
	sub	ecx, DWORD PTR [ebx]
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	push	edi
	shr	eax, 31					; 0000001fH
	add	eax, edx
	xor	ecx, ecx
	lea	edi, DWORD PTR [eax+eax*4]
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [esi+4], ecx
	add	edi, edi
	mov	DWORD PTR [esi+8], ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	add	edi, edi
	push	edi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	mov	ecx, eax
	add	edi, ecx
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [esi+4], ecx
	mov	DWORD PTR [esi+8], edi
	mov	eax, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR [ebx]
	call	??$__ucopy@PBUItem@CSheduler@@PAU12@H@priv@stlp_std@@YAPAUItem@CSheduler@@PBU23@0PAU23@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<CSheduler::Item const *,CSheduler::Item *,int>
	mov	DWORD PTR [esi+4], eax
	mov	eax, esi
	pop	edi
	ret	0
??0?$xr_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@@QAE@ABV0@@Z ENDP ; xr_vector<CSheduler::Item,xalloc<CSheduler::Item> >::xr_vector<CSheduler::Item,xalloc<CSheduler::Item> >
_TEXT	ENDS
PUBLIC	??0CSheduler@@QAE@ABV0@@Z			; CSheduler::CSheduler
; Function compile flags: /Ogtpy
;	COMDAT ??0CSheduler@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0CSheduler@@QAE@ABV0@@Z PROC				; CSheduler::CSheduler, COMDAT
; _this$ = ecx
	push	ebx
	mov	ebx, DWORD PTR ___that$[esp]
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx
	mov	ecx, DWORD PTR [ebx+4]
	sub	ecx, DWORD PTR [ebx]
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	lea	esi, DWORD PTR [eax+eax*4]
	xor	ebp, ebp
	mov	DWORD PTR [edi], ebp
	mov	DWORD PTR [edi+4], ebp
	add	esi, esi
	mov	DWORD PTR [edi+8], ebp
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	add	esi, esi
	push	esi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	mov	ecx, eax
	add	esi, ecx
	mov	DWORD PTR [edi], ecx
	mov	DWORD PTR [edi+4], ecx
	mov	DWORD PTR [edi+8], esi
	mov	eax, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR [ebx]
	call	??$__ucopy@PBUItem@CSheduler@@PAU12@H@priv@stlp_std@@YAPAUItem@CSheduler@@PBU23@0PAU23@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<CSheduler::Item const *,CSheduler::Item *,int>
	mov	DWORD PTR [edi+4], eax
	mov	ecx, DWORD PTR [ebx+16]
	sub	ecx, DWORD PTR [ebx+12]
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	lea	esi, DWORD PTR [eax+eax*4]
	mov	DWORD PTR [edi+12], ebp
	mov	DWORD PTR [edi+16], ebp
	add	esi, esi
	mov	DWORD PTR [edi+20], ebp
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	add	esi, esi
	push	esi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	mov	ecx, eax
	add	esi, ecx
	mov	DWORD PTR [edi+12], ecx
	mov	DWORD PTR [edi+16], ecx
	mov	DWORD PTR [edi+20], esi
	mov	eax, DWORD PTR [ebx+16]
	mov	edx, DWORD PTR [ebx+12]
	call	??$__ucopy@PBUItem@CSheduler@@PAU12@H@priv@stlp_std@@YAPAUItem@CSheduler@@PBU23@0PAU23@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<CSheduler::Item const *,CSheduler::Item *,int>
	mov	DWORD PTR [edi+16], eax
	mov	ecx, DWORD PTR [ebx+28]
	sub	ecx, DWORD PTR [ebx+24]
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	lea	esi, DWORD PTR [eax+eax*4]
	mov	DWORD PTR [edi+24], ebp
	mov	DWORD PTR [edi+28], ebp
	add	esi, esi
	mov	DWORD PTR [edi+32], ebp
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	add	esi, esi
	push	esi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	mov	ecx, eax
	add	esi, ecx
	mov	DWORD PTR [edi+24], ecx
	mov	DWORD PTR [edi+28], ecx
	mov	DWORD PTR [edi+32], esi
	mov	eax, DWORD PTR [ebx+28]
	mov	edx, DWORD PTR [ebx+24]
	call	??$__ucopy@PBUItem@CSheduler@@PAU12@H@priv@stlp_std@@YAPAUItem@CSheduler@@PBU23@0PAU23@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<CSheduler::Item const *,CSheduler::Item *,int>
	mov	DWORD PTR [edi+28], eax
	lea	eax, DWORD PTR [ebx+36]
	lea	esi, DWORD PTR [edi+36]
	call	??0?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAE@ABV012@@Z ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >
	mov	eax, DWORD PTR [ebx+48]
	mov	DWORD PTR [edi+48], eax
	mov	cl, BYTE PTR [ebx+52]
	mov	BYTE PTR [edi+52], cl
	mov	edx, DWORD PTR [ebx+56]
	mov	DWORD PTR [edi+56], edx
	mov	eax, DWORD PTR [ebx+60]
	mov	DWORD PTR [edi+60], eax
	mov	ecx, DWORD PTR [ebx+64]
	mov	DWORD PTR [edi+64], ecx
	mov	edx, DWORD PTR [ebx+68]
	mov	DWORD PTR [edi+68], edx
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
??0CSheduler@@QAE@ABV0@@Z ENDP				; CSheduler::CSheduler
_TEXT	ENDS
PUBLIC	??0CSheduler@@QAE@XZ				; CSheduler::CSheduler
; Function compile flags: /Ogtpy
;	COMDAT ??0CSheduler@@QAE@XZ
_TEXT	SEGMENT
??0CSheduler@@QAE@XZ PROC				; CSheduler::CSheduler, COMDAT
; _this$ = ecx
	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+28], ecx
	mov	DWORD PTR [eax+32], ecx
	mov	DWORD PTR [eax+36], ecx
	mov	DWORD PTR [eax+40], ecx
	mov	DWORD PTR [eax+44], ecx
	ret	0
??0CSheduler@@QAE@XZ ENDP				; CSheduler::CSheduler
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\isheduled.h
_TEXT	ENDS
;	COMDAT ?shedule_Name@ISheduled@@UBE?AVshared_str@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?shedule_Name@ISheduled@@UBE?AVshared_str@@XZ PROC	; ISheduled::shedule_Name, COMDAT
; _this$ = ecx

; 27   : 	virtual	shared_str					shedule_Name		() const	{ return shared_str("unknown"); };

	mov	eax, DWORD PTR __imp_?g_pStringContainer@@3PAVstr_container@@A
	mov	ecx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp]
	push	OFFSET ??_C@_07CIFAGBMG@unknown?$AA@
	mov	DWORD PTR [esi], 0
	call	DWORD PTR __imp_?dock@str_container@@QAEPAUstr_value@@PBD@Z
	test	eax, eax
	je	SHORT $LN5@shedule_Na@2
	add	DWORD PTR [eax], 1
$LN5@shedule_Na@2:
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN13@shedule_Na@2
	add	DWORD PTR [ecx], -1
	jne	SHORT $LN13@shedule_Na@2
	mov	DWORD PTR [esi], 0
$LN13@shedule_Na@2:
	mov	DWORD PTR [esi], eax
	mov	eax, esi
	pop	esi
	ret	4
?shedule_Name@ISheduled@@UBE?AVshared_str@@XZ ENDP	; ISheduled::shedule_Name
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_uninitialized.h
;	COMDAT ??$__ucopy_aux@PBUItem@CSheduler@@PAU12@@priv@stlp_std@@YAPAUItem@CSheduler@@PBU23@0PAU23@ABU__true_type@1@@Z
_TEXT	SEGMENT
??$__ucopy_aux@PBUItem@CSheduler@@PAU12@@priv@stlp_std@@YAPAUItem@CSheduler@@PBU23@0PAU23@ABU__true_type@1@@Z PROC ; stlp_std::priv::__ucopy_aux<CSheduler::Item const *,CSheduler::Item *>, COMDAT
; ___first$ = edx
; ___last$ = eax
; ___result$ = ecx

; 126  :   return __ucopy_ptrs(__first, __last, __result,
; 127  :                       _UseTrivialUCopy(_STLP_VALUE_TYPE(__first, _InputIter),
; 128  :                                        _STLP_VALUE_TYPE(__result, _OutputIter))._Answer());

	jmp	??$__ucopy@PBUItem@CSheduler@@PAU12@H@priv@stlp_std@@YAPAUItem@CSheduler@@PBU23@0PAU23@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<CSheduler::Item const *,CSheduler::Item *,int>
??$__ucopy_aux@PBUItem@CSheduler@@PAU12@@priv@stlp_std@@YAPAUItem@CSheduler@@PBU23@0PAU23@ABU__true_type@1@@Z ENDP ; stlp_std::priv::__ucopy_aux<CSheduler::Item const *,CSheduler::Item *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$__ucopy_aux@PBVshared_str@@PAV1@@priv@stlp_std@@YAPAVshared_str@@PBV2@0PAV2@ABU__true_type@1@@Z
_TEXT	SEGMENT
??$__ucopy_aux@PBVshared_str@@PAV1@@priv@stlp_std@@YAPAVshared_str@@PBV2@0PAV2@ABU__true_type@1@@Z PROC ; stlp_std::priv::__ucopy_aux<shared_str const *,shared_str *>, COMDAT
; ___first$ = edx
; ___last$ = ecx
; ___result$ = eax

; 126  :   return __ucopy_ptrs(__first, __last, __result,
; 127  :                       _UseTrivialUCopy(_STLP_VALUE_TYPE(__first, _InputIter),
; 128  :                                        _STLP_VALUE_TYPE(__result, _OutputIter))._Answer());

	jmp	??$__ucopy@PBVshared_str@@PAV1@H@priv@stlp_std@@YAPAVshared_str@@PBV2@0PAV2@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<shared_str const *,shared_str *,int>
??$__ucopy_aux@PBVshared_str@@PAV1@@priv@stlp_std@@YAPAVshared_str@@PBV2@0PAV2@ABU__true_type@1@@Z ENDP ; stlp_std::priv::__ucopy_aux<shared_str const *,shared_str *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$uninitialized_copy@PBUItem@CSheduler@@PAU12@@stlp_std@@YAPAUItem@CSheduler@@PBU12@0PAU12@@Z
_TEXT	SEGMENT
??$uninitialized_copy@PBUItem@CSheduler@@PAU12@@stlp_std@@YAPAUItem@CSheduler@@PBU12@0PAU12@@Z PROC ; stlp_std::uninitialized_copy<CSheduler::Item const *,CSheduler::Item *>, COMDAT
; ___first$ = edx
; ___last$ = eax
; ___result$ = ecx

; 144  : { return _STLP_PRIV __ucopy_aux(__first, __last, __result, _BothPtrType< _InputIter, _ForwardIter>::_Answer()); }

	jmp	??$__ucopy@PBUItem@CSheduler@@PAU12@H@priv@stlp_std@@YAPAUItem@CSheduler@@PBU23@0PAU23@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<CSheduler::Item const *,CSheduler::Item *,int>
??$uninitialized_copy@PBUItem@CSheduler@@PAU12@@stlp_std@@YAPAUItem@CSheduler@@PBU12@0PAU12@@Z ENDP ; stlp_std::uninitialized_copy<CSheduler::Item const *,CSheduler::Item *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$uninitialized_copy@PBVshared_str@@PAV1@@stlp_std@@YAPAVshared_str@@PBV1@0PAV1@@Z
_TEXT	SEGMENT
??$uninitialized_copy@PBVshared_str@@PAV1@@stlp_std@@YAPAVshared_str@@PBV1@0PAV1@@Z PROC ; stlp_std::uninitialized_copy<shared_str const *,shared_str *>, COMDAT
; ___first$ = edx
; ___last$ = ecx
; ___result$ = eax

; 144  : { return _STLP_PRIV __ucopy_aux(__first, __last, __result, _BothPtrType< _InputIter, _ForwardIter>::_Answer()); }

	jmp	??$__ucopy@PBVshared_str@@PAV1@H@priv@stlp_std@@YAPAVshared_str@@PBV2@0PAV2@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<shared_str const *,shared_str *,int>
??$uninitialized_copy@PBVshared_str@@PAV1@@stlp_std@@YAPAVshared_str@@PBV1@0PAV1@@Z ENDP ; stlp_std::uninitialized_copy<shared_str const *,shared_str *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ??$_M_allocate_and_copy@PBUItem@CSheduler@@@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@AAEPAUItem@CSheduler@@AAIPBU34@1@Z
_TEXT	SEGMENT
___first$ = 8						; size = 4
___last$ = 12						; size = 4
??$_M_allocate_and_copy@PBUItem@CSheduler@@@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@AAEPAUItem@CSheduler@@AAIPBU34@1@Z PROC ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::_M_allocate_and_copy<CSheduler::Item const *>, COMDAT
; ___n$ = eax

; 634  :                                _ForwardIterator __first, _ForwardIterator __last)
; 635  : #else /* _STLP_MEMBER_TEMPLATES */
; 636  :   pointer _M_allocate_and_copy(size_type& __n,
; 637  :                                const_pointer __first, const_pointer __last)
; 638  : #endif /* _STLP_MEMBER_TEMPLATES */
; 639  :   {
; 640  :     pointer __result = this->_M_end_of_storage.allocate(__n, __n);

	mov	eax, DWORD PTR [eax]
	lea	ecx, DWORD PTR [eax+eax*4]
	add	ecx, ecx
	add	ecx, ecx
	push	esi
	push	ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 641  :     _STLP_TRY {
; 642  :       uninitialized_copy(__first, __last, __result);

	mov	edx, DWORD PTR ___first$[esp]
	mov	esi, eax
	mov	eax, DWORD PTR ___last$[esp]
	mov	ecx, esi
	call	??$__ucopy@PBUItem@CSheduler@@PAU12@H@priv@stlp_std@@YAPAUItem@CSheduler@@PBU23@0PAU23@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<CSheduler::Item const *,CSheduler::Item *,int>

; 643  :       return __result;

	mov	eax, esi
	pop	esi

; 644  :     }
; 645  :     _STLP_UNWIND(this->_M_end_of_storage.deallocate(__result, __n))
; 646  :     _STLP_RET_AFTER_THROW(__result)
; 647  :   }

	ret	8
??$_M_allocate_and_copy@PBUItem@CSheduler@@@?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@AAEPAUItem@CSheduler@@AAIPBU34@1@Z ENDP ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::_M_allocate_and_copy<CSheduler::Item const *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_M_allocate_and_copy@PBVshared_str@@@?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@AAEPAVshared_str@@AAIPBV3@1@Z
_TEXT	SEGMENT
___first$ = 8						; size = 4
___last$ = 12						; size = 4
??$_M_allocate_and_copy@PBVshared_str@@@?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@AAEPAVshared_str@@AAIPBV3@1@Z PROC ; stlp_std::priv::_Impl_vector<shared_str,xalloc<shared_str> >::_M_allocate_and_copy<shared_str const *>, COMDAT
; ___n$ = eax

; 634  :                                _ForwardIterator __first, _ForwardIterator __last)
; 635  : #else /* _STLP_MEMBER_TEMPLATES */
; 636  :   pointer _M_allocate_and_copy(size_type& __n,
; 637  :                                const_pointer __first, const_pointer __last)
; 638  : #endif /* _STLP_MEMBER_TEMPLATES */
; 639  :   {
; 640  :     pointer __result = this->_M_end_of_storage.allocate(__n, __n);

	mov	eax, DWORD PTR [eax]
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	push	ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 641  :     _STLP_TRY {
; 642  :       uninitialized_copy(__first, __last, __result);

	mov	ecx, DWORD PTR ___last$[esp]
	mov	edx, DWORD PTR ___first$[esp]
	mov	esi, eax
	call	??$__ucopy@PBVshared_str@@PAV1@H@priv@stlp_std@@YAPAVshared_str@@PBV2@0PAV2@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<shared_str const *,shared_str *,int>

; 643  :       return __result;

	mov	eax, esi
	pop	esi

; 644  :     }
; 645  :     _STLP_UNWIND(this->_M_end_of_storage.deallocate(__result, __n))
; 646  :     _STLP_RET_AFTER_THROW(__result)
; 647  :   }

	ret	8
??$_M_allocate_and_copy@PBVshared_str@@@?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@AAEPAVshared_str@@AAIPBV3@1@Z ENDP ; stlp_std::priv::_Impl_vector<shared_str,xalloc<shared_str> >::_M_allocate_and_copy<shared_str const *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.c
_TEXT	ENDS
;	COMDAT ??4?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z
_TEXT	SEGMENT
___result$476345 = -4					; size = 4
tv323 = 8						; size = 4
___x$ = 8						; size = 4
??4?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z PROC ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::operator=, COMDAT
; _this$ = esi

; 177  : vector<_Tp, _Alloc>& vector<_Tp, _Alloc>::operator = (const vector<_Tp, _Alloc>& __x) {

	push	ecx
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR ___x$[esp+8]

; 178  :   if (&__x != this) {

	cmp	ebp, esi
	push	edi
	je	$LN73@operator@118

; 179  :     const size_type __xlen = __x.size();

	mov	ecx, DWORD PTR [ebp+4]
	mov	ebx, DWORD PTR [ebp]
	mov	DWORD PTR tv323[esp+12], ecx
	sub	ecx, ebx
	mov	eax, 1717986919				; 66666667H
	imul	ecx

; 180  :     if (__xlen > capacity()) {

	mov	ecx, DWORD PTR [esi]
	sar	edx, 3
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	add	edi, edx
	mov	edx, DWORD PTR [esi+8]
	sub	edx, ecx
	mov	eax, 1717986919				; 66666667H
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	edi, eax
	jbe	SHORT $LN4@operator@118

; 181  :       size_type __len = __xlen;
; 182  :       pointer __tmp = _M_allocate_and_copy(__len, __CONST_CAST(const_pointer, __x._M_start) + 0,
; 183  :                                                   __CONST_CAST(const_pointer, __x._M_finish) + 0);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	ebp, DWORD PTR [edi+edi*4]
	add	ebp, ebp
	add	ebp, ebp
	push	ebp
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	mov	DWORD PTR ___result$476345[esp+16], eax
	mov	ecx, eax
	mov	eax, DWORD PTR tv323[esp+12]
	mov	edx, ebx
	call	??$__ucopy@PBUItem@CSheduler@@PAU12@H@priv@stlp_std@@YAPAUItem@CSheduler@@PBU23@0PAU23@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<CSheduler::Item const *,CSheduler::Item *,int>

; 184  :       _M_clear();

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi]
	push	ecx
	mov	edx, esp
	mov	DWORD PTR [edx], eax
	push	ecx
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	call	??$__destroy_range@V?$reverse_iterator@PAUItem@CSheduler@@@stlp_std@@UItem@CSheduler@@@stlp_std@@YAXV?$reverse_iterator@PAUItem@CSheduler@@@0@0PAUItem@CSheduler@@@Z ; stlp_std::__destroy_range<stlp_std::reverse_iterator<CSheduler::Item *>,CSheduler::Item>
	mov	eax, DWORD PTR [esi]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN58@operator@118
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN58@operator@118:

; 185  :       this->_M_start = __tmp;

	mov	eax, DWORD PTR ___result$476345[esp+16]
	mov	DWORD PTR [esi], eax

; 196  :     }
; 197  :     this->_M_finish = this->_M_start + __xlen;

	mov	ecx, DWORD PTR [esi]
	add	ebp, eax
	lea	eax, DWORD PTR [edi+edi*4]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+8], ebp
	mov	DWORD PTR [esi+4], edx

; 198  :   }
; 199  :   return *this;

	mov	eax, esi

; 200  : }

	pop	edi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	4
$LN4@operator@118:

; 186  :       this->_M_end_of_storage._M_data = this->_M_start + __len;
; 187  :     } else if (size() >= __xlen) {

	mov	edx, DWORD PTR [esi+4]
	sub	edx, ecx
	mov	eax, 1717986919				; 66666667H
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, edi
	jb	SHORT $LN2@operator@118

; 188  :       pointer __i = _STLP_PRIV __copy_ptrs(__CONST_CAST(const_pointer, __x._M_start) + 0,
; 189  :                                            __CONST_CAST(const_pointer, __x._M_finish) + 0, this->_M_start, _TrivialCopy());

	mov	eax, DWORD PTR tv323[esp+12]
	mov	edx, ebx
	call	??$__copy@PBUItem@CSheduler@@PAU12@H@priv@stlp_std@@YAPAUItem@CSheduler@@PBU23@0PAU23@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__copy<CSheduler::Item const *,CSheduler::Item *,int>

; 190  :       _STLP_STD::_Destroy_Range(__i, this->_M_finish);

	mov	edx, DWORD PTR [esi+4]
	call	??$_Destroy_Range@PAUItem@CSheduler@@@stlp_std@@YAXPAUItem@CSheduler@@0@Z ; stlp_std::_Destroy_Range<CSheduler::Item *>

; 196  :     }
; 197  :     this->_M_finish = this->_M_start + __xlen;

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edi+edi*4]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+4], edx

; 198  :   }
; 199  :   return *this;

	mov	eax, esi

; 200  : }

	pop	edi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	4
$LN2@operator@118:

; 191  :     } else {
; 192  :       _STLP_PRIV __copy_ptrs(__CONST_CAST(const_pointer, __x._M_start),
; 193  :                              __CONST_CAST(const_pointer, __x._M_start) + size(), this->_M_start, _TrivialCopy());

	lea	edx, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [ebx+edx*4]
	mov	edx, ebx
	call	??$__copy@PBUItem@CSheduler@@PAU12@H@priv@stlp_std@@YAPAUItem@CSheduler@@PBU23@0PAU23@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__copy<CSheduler::Item const *,CSheduler::Item *,int>

; 194  :       _STLP_PRIV __ucopy_ptrs(__CONST_CAST(const_pointer, __x._M_start) + size(),
; 195  :                               __CONST_CAST(const_pointer, __x._M_finish) + 0, this->_M_finish, _TrivialUCopy());

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, ecx
	sub	edx, DWORD PTR [esi]
	mov	eax, 1717986919				; 66666667H
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	edx, DWORD PTR [ebp]
	lea	eax, DWORD PTR [eax+eax*4]
	lea	edx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [ebp+4]
	call	??$__ucopy@PBUItem@CSheduler@@PAU12@H@priv@stlp_std@@YAPAUItem@CSheduler@@PBU23@0PAU23@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<CSheduler::Item const *,CSheduler::Item *,int>

; 196  :     }
; 197  :     this->_M_finish = this->_M_start + __xlen;

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edi+edi*4]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+4], edx
$LN73@operator@118:

; 200  : }

	pop	edi
	pop	ebp
	mov	eax, esi
	pop	ebx
	pop	ecx
	ret	4
??4?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ENDP ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::operator=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z
_TEXT	SEGMENT
tv323 = 8						; size = 4
___x$ = 8						; size = 4
??4?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z PROC ; stlp_std::priv::_Impl_vector<shared_str,xalloc<shared_str> >::operator=, COMDAT
; _this$ = esi

; 177  : vector<_Tp, _Alloc>& vector<_Tp, _Alloc>::operator = (const vector<_Tp, _Alloc>& __x) {

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR ___x$[esp+4]

; 178  :   if (&__x != this) {

	cmp	ebp, esi
	push	edi
	je	$LN73@operator@119

; 179  :     const size_type __xlen = __x.size();

	mov	ecx, DWORD PTR [ebp+4]
	mov	ebx, DWORD PTR [ebp]

; 180  :     if (__xlen > capacity()) {

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [esi+8]
	mov	edi, ecx
	sub	edi, ebx
	sub	edx, eax
	sar	edi, 2
	sar	edx, 2
	cmp	edi, edx
	mov	DWORD PTR tv323[esp+8], ecx
	jbe	SHORT $LN4@operator@119

; 181  :       size_type __len = __xlen;
; 182  :       pointer __tmp = _M_allocate_and_copy(__len, __CONST_CAST(const_pointer, __x._M_start) + 0,
; 183  :                                                   __CONST_CAST(const_pointer, __x._M_finish) + 0);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	eax, DWORD PTR [edi*4]
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	mov	ecx, DWORD PTR tv323[esp+8]
	mov	edx, ebx
	mov	ebp, eax
	call	??$__ucopy@PBVshared_str@@PAV1@H@priv@stlp_std@@YAPAVshared_str@@PBV2@0PAV2@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<shared_str const *,shared_str *,int>

; 184  :       _M_clear();

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi]
	push	ecx
	mov	edx, esp
	mov	DWORD PTR [edx], eax
	push	ecx
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	call	??$__destroy_range@V?$reverse_iterator@PAVshared_str@@@stlp_std@@Vshared_str@@@stlp_std@@YAXV?$reverse_iterator@PAVshared_str@@@0@0PAVshared_str@@@Z ; stlp_std::__destroy_range<stlp_std::reverse_iterator<shared_str *>,shared_str>
	mov	eax, DWORD PTR [esi]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN58@operator@119
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN58@operator@119:

; 185  :       this->_M_start = __tmp;
; 186  :       this->_M_end_of_storage._M_data = this->_M_start + __len;

	lea	eax, DWORD PTR [ebp+edi*4]
	mov	DWORD PTR [esi+8], eax

; 196  :     }
; 197  :     this->_M_finish = this->_M_start + __xlen;

	mov	eax, ebp
	lea	ecx, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi], ebp
	mov	DWORD PTR [esi+4], ecx

; 198  :   }
; 199  :   return *this;

	mov	eax, esi

; 200  : }

	pop	edi
	pop	ebp
	pop	ebx
	ret	4
$LN4@operator@119:

; 187  :     } else if (size() >= __xlen) {

	mov	edx, DWORD PTR [esi+4]
	sub	edx, eax
	sar	edx, 2
	cmp	edx, edi
	jb	SHORT $LN2@operator@119

; 188  :       pointer __i = _STLP_PRIV __copy_ptrs(__CONST_CAST(const_pointer, __x._M_start) + 0,
; 189  :                                            __CONST_CAST(const_pointer, __x._M_finish) + 0, this->_M_start, _TrivialCopy());

	mov	edx, ebx
	call	??$__copy@PBVshared_str@@PAV1@H@priv@stlp_std@@YAPAVshared_str@@PBV2@0PAV2@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__copy<shared_str const *,shared_str *,int>

; 190  :       _STLP_STD::_Destroy_Range(__i, this->_M_finish);

	mov	edx, DWORD PTR [esi+4]
	call	??$_Destroy_Range@PAVshared_str@@@stlp_std@@YAXPAVshared_str@@0@Z ; stlp_std::_Destroy_Range<shared_str *>

; 196  :     }
; 197  :     this->_M_finish = this->_M_start + __xlen;

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+4], ecx

; 198  :   }
; 199  :   return *this;

	mov	eax, esi

; 200  : }

	pop	edi
	pop	ebp
	pop	ebx
	ret	4
$LN2@operator@119:

; 191  :     } else {
; 192  :       _STLP_PRIV __copy_ptrs(__CONST_CAST(const_pointer, __x._M_start),
; 193  :                              __CONST_CAST(const_pointer, __x._M_start) + size(), this->_M_start, _TrivialCopy());

	lea	ecx, DWORD PTR [ebx+edx*4]
	mov	edx, ebx
	call	??$__copy@PBVshared_str@@PAV1@H@priv@stlp_std@@YAPAVshared_str@@PBV2@0PAV2@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__copy<shared_str const *,shared_str *,int>

; 194  :       _STLP_PRIV __ucopy_ptrs(__CONST_CAST(const_pointer, __x._M_start) + size(),
; 195  :                               __CONST_CAST(const_pointer, __x._M_finish) + 0, this->_M_finish, _TrivialUCopy());

	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ebp]
	mov	ecx, eax
	sub	ecx, DWORD PTR [esi]
	sar	ecx, 2
	lea	edx, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [ebp+4]
	call	??$__ucopy@PBVshared_str@@PAV1@H@priv@stlp_std@@YAPAVshared_str@@PBV2@0PAV2@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ucopy<shared_str const *,shared_str *,int>

; 196  :     }
; 197  :     this->_M_finish = this->_M_start + __xlen;

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+4], ecx
$LN73@operator@119:

; 200  : }

	pop	edi
	pop	ebp
	mov	eax, esi
	pop	ebx
	ret	4
??4?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ENDP ; stlp_std::priv::_Impl_vector<shared_str,xalloc<shared_str> >::operator=
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ??4?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
??4?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAEAAV01@ABV01@@Z PROC ; stlp_std::vector<CSheduler::Item,xalloc<CSheduler::Item> >::operator=, COMDAT
; _this$ = ecx
; ___x$ = eax

; 149  :   _Self& operator=(const _Self& __x) { _M_impl = __x._M_impl; return *this; }

	push	esi
	mov	esi, ecx
	push	eax
	call	??4?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::operator=
	mov	eax, esi
	pop	esi
	ret	0
??4?$vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@stlp_std@@QAEAAV01@ABV01@@Z ENDP ; stlp_std::vector<CSheduler::Item,xalloc<CSheduler::Item> >::operator=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@stlp_std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
??4?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@stlp_std@@QAEAAV01@ABV01@@Z PROC ; stlp_std::vector<shared_str,xalloc<shared_str> >::operator=, COMDAT
; _this$ = ecx
; ___x$ = eax

; 149  :   _Self& operator=(const _Self& __x) { _M_impl = __x._M_impl; return *this; }

	push	esi
	mov	esi, ecx
	push	eax
	call	??4?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<shared_str,xalloc<shared_str> >::operator=
	mov	eax, esi
	pop	esi
	ret	0
??4?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@stlp_std@@QAEAAV01@ABV01@@Z ENDP ; stlp_std::vector<shared_str,xalloc<shared_str> >::operator=
_TEXT	ENDS
PUBLIC	??1CRenderDevice@@QAE@XZ			; CRenderDevice::~CRenderDevice
; Function compile flags: /Ogtpy
;	COMDAT ??1CRenderDevice@@QAE@XZ
_TEXT	SEGMENT
??1CRenderDevice@@QAE@XZ PROC				; CRenderDevice::~CRenderDevice, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR __imp_??1xrCriticalSection@@QAE@XZ
	lea	ecx, DWORD PTR [esi+992]
	call	edi
	lea	ecx, DWORD PTR [esi+988]
	call	edi
	mov	eax, DWORD PTR [esi+908]
	test	eax, eax
	mov	edi, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	je	SHORT $LN40@CRenderDev@5
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
$LN40@CRenderDev@5:
	mov	eax, DWORD PTR [esi+892]
	test	eax, eax
	je	SHORT $LN82@CRenderDev@5
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
$LN82@CRenderDev@5:
	mov	eax, DWORD PTR [esi+876]
	test	eax, eax
	je	SHORT $LN124@CRenderDev@5
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
$LN124@CRenderDev@5:
	test	esi, esi
	je	SHORT $LN129@CRenderDev@5
	lea	ecx, DWORD PTR [esi+4]
	pop	edi
	pop	esi
	jmp	??1CRenderDeviceData@@QAE@XZ
$LN129@CRenderDev@5:
	xor	ecx, ecx
	pop	edi
	pop	esi
	jmp	??1CRenderDeviceData@@QAE@XZ
??1CRenderDevice@@QAE@XZ ENDP				; CRenderDevice::~CRenderDevice
_TEXT	ENDS
PUBLIC	??0CRenderDevice@@QAE@XZ			; CRenderDevice::CRenderDevice
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\device.h
;	COMDAT ??0CRenderDevice@@QAE@XZ
_TEXT	SEGMENT
??0CRenderDevice@@QAE@XZ PROC				; CRenderDevice::CRenderDevice, COMDAT
; _this$ = ecx

; 216  : 	{

	push	ebx
	push	esi
	mov	esi, ecx
	push	edi
	lea	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7IRenderDevice@@6B@
	call	??0CRenderDeviceData@@QAE@XZ
	lea	ecx, DWORD PTR [esi+800]
	mov	DWORD PTR [esi], OFFSET ??_7CRenderDevice@@6B@
	call	DWORD PTR __imp_??0CTimer@@QAE@XZ
	mov	ebx, DWORD PTR __imp_??0xrCriticalSection@@QAE@XZ
	xor	edi, edi
	mov	DWORD PTR [esi+868], edi
	mov	DWORD PTR [esi+876], edi
	mov	DWORD PTR [esi+880], edi
	mov	DWORD PTR [esi+884], edi
	mov	eax, -4					; fffffffcH
	and	DWORD PTR [esi+888], eax
	mov	DWORD PTR [esi+892], edi
	mov	DWORD PTR [esi+896], edi
	mov	DWORD PTR [esi+900], edi
	and	DWORD PTR [esi+904], eax
	mov	DWORD PTR [esi+908], edi
	mov	DWORD PTR [esi+912], edi
	lea	ecx, DWORD PTR [esi+988]
	mov	DWORD PTR [esi+916], edi
	call	ebx
	lea	ecx, DWORD PTR [esi+992]
	call	ebx

; 217  : 	    m_hWnd              = NULL;

	mov	DWORD PTR [esi+760], edi

; 218  : 		b_is_Active			= FALSE;

	mov	DWORD PTR [esi+20], edi

; 219  : 		b_is_Ready			= FALSE;

	mov	DWORD PTR [esi+16], edi

; 220  : 		Timer.Start			();

	cmp	DWORD PTR [esi+536], edi
	jne	SHORT $LN63@CRenderDev@6
	call	DWORD PTR __imp_?QPC@CPU@@YA_KXZ
	sub	eax, DWORD PTR [esi+528]
	mov	DWORD PTR [esi+552], edi
	sbb	edx, DWORD PTR [esi+532]
	mov	DWORD PTR [esi+512], eax
	mov	DWORD PTR [esi+516], edx
	mov	DWORD PTR [esi+556], edi
	mov	DWORD PTR [esi+560], edi
	mov	DWORD PTR [esi+564], edi
$LN63@CRenderDev@6:

; 221  : 		m_bNearer			= FALSE;

	mov	DWORD PTR [esi+872], edi
	pop	edi

; 222  : 	};

	mov	eax, esi
	pop	esi
	pop	ebx
	ret	0
??0CRenderDevice@@QAE@XZ ENDP				; CRenderDevice::CRenderDevice
_TEXT	ENDS
PUBLIC	??4CRenderDeviceBase@@QAEAAV0@ABV0@@Z		; CRenderDeviceBase::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4CRenderDeviceBase@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4CRenderDeviceBase@@QAEAAV0@ABV0@@Z PROC		; CRenderDeviceBase::operator=, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	test	eax, eax
	push	esi
	mov	esi, ecx
	je	SHORT $LN3@operator@120
	add	eax, 4
	push	eax
	lea	ecx, DWORD PTR [esi+4]
	call	??4CRenderDeviceData@@QAEAAV0@ABV0@@Z
	mov	eax, esi
	pop	esi
	ret	4
$LN3@operator@120:
	xor	eax, eax
	push	eax
	lea	ecx, DWORD PTR [esi+4]
	call	??4CRenderDeviceData@@QAEAAV0@ABV0@@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CRenderDeviceBase@@QAEAAV0@ABV0@@Z ENDP		; CRenderDeviceBase::operator=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
??4?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@QAEAAV0@ABV0@@Z PROC ; xr_vector<shared_str,xalloc<shared_str> >::operator=, COMDAT
; _this$ = ecx
; ___that$ = eax
	push	esi
	mov	esi, ecx
	push	eax
	call	??4?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<shared_str,xalloc<shared_str> >::operator=
	mov	eax, esi
	pop	esi
	ret	0
??4?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@QAEAAV0@ABV0@@Z ENDP ; xr_vector<shared_str,xalloc<shared_str> >::operator=
_TEXT	ENDS
PUBLIC	??4CStats@@QAEAAV0@ABV0@@Z			; CStats::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4CStats@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4CStats@@QAEAAV0@ABV0@@Z PROC				; CStats::operator=, COMDAT
; _this$ = ecx
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR ___that$[esp+4]
	xor	edx, edx
	cmp	ebp, edx
	push	esi
	push	edi
	mov	ebx, ecx
	je	SHORT $LN3@operator@121
	lea	esi, DWORD PTR [ebp+8]
	jmp	SHORT $LN4@operator@121
$LN3@operator@121:
	xor	esi, esi
$LN4@operator@121:
	lea	edi, DWORD PTR [ebx+8]
	mov	ecx, 54					; 00000036H
	rep movsd
	mov	eax, DWORD PTR [ebp+224]
	mov	DWORD PTR [ebx+224], eax
	lea	esi, DWORD PTR [ebp+264]
	fld	DWORD PTR [ebp+228]
	lea	edi, DWORD PTR [ebx+264]
	fstp	DWORD PTR [ebx+228]
	fld	DWORD PTR [ebp+232]
	fstp	DWORD PTR [ebx+232]
	fld	DWORD PTR [ebp+236]
	fstp	DWORD PTR [ebx+236]
	fld	DWORD PTR [ebp+240]
	fstp	DWORD PTR [ebx+240]
	mov	ecx, DWORD PTR [ebp+244]
	mov	DWORD PTR [ebx+244], ecx
	mov	eax, DWORD PTR [ebp+248]
	mov	DWORD PTR [ebx+248], eax
	mov	ecx, DWORD PTR [ebp+252]
	mov	DWORD PTR [ebx+252], ecx
	fld	DWORD PTR [ebp+256]
	fstp	DWORD PTR [ebx+256]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+336]
	lea	edi, DWORD PTR [ebx+336]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+408]
	lea	edi, DWORD PTR [ebx+408]
	mov	ecx, 18					; 00000012H
	rep movsd
	mov	eax, DWORD PTR [ebp+480]
	mov	DWORD PTR [ebx+480], eax
	mov	ecx, DWORD PTR [ebp+484]
	mov	DWORD PTR [ebx+484], ecx
	mov	eax, DWORD PTR [ebp+488]
	mov	DWORD PTR [ebx+488], eax
	mov	ecx, DWORD PTR [ebp+492]
	mov	DWORD PTR [ebx+492], ecx
	mov	eax, DWORD PTR [ebp+496]
	mov	DWORD PTR [ebx+496], eax
	mov	ecx, DWORD PTR [ebp+500]
	mov	DWORD PTR [ebx+500], ecx
	mov	eax, DWORD PTR [ebp+504]
	mov	DWORD PTR [ebx+504], eax
	lea	esi, DWORD PTR [ebp+512]
	lea	edi, DWORD PTR [ebx+512]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+584]
	lea	edi, DWORD PTR [ebx+584]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+656]
	lea	edi, DWORD PTR [ebx+656]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+728]
	lea	edi, DWORD PTR [ebx+728]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+800]
	lea	edi, DWORD PTR [ebx+800]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+872]
	lea	edi, DWORD PTR [ebx+872]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+944]
	lea	edi, DWORD PTR [ebx+944]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+1016]
	lea	edi, DWORD PTR [ebx+1016]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+1088]
	lea	edi, DWORD PTR [ebx+1088]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+1160]
	lea	edi, DWORD PTR [ebx+1160]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+1232]
	lea	edi, DWORD PTR [ebx+1232]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+1304]
	lea	edi, DWORD PTR [ebx+1304]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+1376]
	lea	edi, DWORD PTR [ebx+1376]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+1448]
	lea	edi, DWORD PTR [ebx+1448]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+1520]
	lea	edi, DWORD PTR [ebx+1520]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+1592]
	lea	edi, DWORD PTR [ebx+1592]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+1664]
	lea	edi, DWORD PTR [ebx+1664]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+1736]
	lea	edi, DWORD PTR [ebx+1736]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+1808]
	lea	edi, DWORD PTR [ebx+1808]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+1880]
	lea	edi, DWORD PTR [ebx+1880]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+1952]
	lea	edi, DWORD PTR [ebx+1952]
	mov	ecx, 18					; 00000012H
	rep movsd
	mov	ecx, DWORD PTR [ebp+2024]
	mov	DWORD PTR [ebx+2024], ecx
	mov	eax, DWORD PTR [ebp+2028]
	mov	DWORD PTR [ebx+2028], eax
	mov	ecx, DWORD PTR [ebp+2032]
	mov	DWORD PTR [ebx+2032], ecx
	lea	esi, DWORD PTR [ebp+2040]
	lea	edi, DWORD PTR [ebx+2040]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+2112]
	lea	edi, DWORD PTR [ebx+2112]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+2184]
	lea	edi, DWORD PTR [ebx+2184]
	mov	ecx, 18					; 00000012H
	rep movsd
	mov	eax, DWORD PTR [ebp+2256]
	mov	DWORD PTR [ebx+2256], eax
	lea	esi, DWORD PTR [ebp+2264]
	lea	edi, DWORD PTR [ebx+2264]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+2336]
	lea	edi, DWORD PTR [ebx+2336]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+2408]
	lea	edi, DWORD PTR [ebx+2408]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+2480]
	lea	edi, DWORD PTR [ebx+2480]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+2552]
	lea	edi, DWORD PTR [ebx+2552]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+2624]
	lea	edi, DWORD PTR [ebx+2624]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+2696]
	lea	edi, DWORD PTR [ebx+2696]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+2768]
	lea	edi, DWORD PTR [ebx+2768]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+2840]
	lea	edi, DWORD PTR [ebx+2840]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+2912]
	lea	edi, DWORD PTR [ebx+2912]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+2984]
	lea	edi, DWORD PTR [ebx+2984]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+3056]
	lea	edi, DWORD PTR [ebx+3056]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+3128]
	lea	edi, DWORD PTR [ebx+3128]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+3200]
	lea	edi, DWORD PTR [ebx+3200]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+3272]
	lea	edi, DWORD PTR [ebx+3272]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+3344]
	lea	edi, DWORD PTR [ebx+3344]
	mov	ecx, 18					; 00000012H
	rep movsd
	lea	esi, DWORD PTR [ebp+3416]
	lea	edi, DWORD PTR [ebx+3416]
	mov	ecx, 18					; 00000012H
	rep movsd
	mov	eax, DWORD PTR [ebp+3488]
	cmp	eax, edx
	je	SHORT $LN46@operator@121
	add	DWORD PTR [eax], 1
$LN46@operator@121:
	mov	ecx, DWORD PTR [ebx+3488]
	cmp	ecx, edx
	je	SHORT $LN12@operator@121
	add	DWORD PTR [ecx], -1
	mov	ecx, DWORD PTR [ebx+3488]
	cmp	DWORD PTR [ecx], edx
	jne	SHORT $LN12@operator@121
	mov	DWORD PTR [ebx+3488], edx
$LN12@operator@121:
	mov	DWORD PTR [ebx+3488], eax
	mov	eax, DWORD PTR [ebp+3492]
	cmp	eax, edx
	je	SHORT $LN47@operator@121
	add	DWORD PTR [eax], 1
$LN47@operator@121:
	mov	ecx, DWORD PTR [ebx+3492]
	cmp	ecx, edx
	je	SHORT $LN21@operator@121
	add	DWORD PTR [ecx], -1
	mov	ecx, DWORD PTR [ebx+3492]
	cmp	DWORD PTR [ecx], edx
	jne	SHORT $LN21@operator@121
	mov	DWORD PTR [ebx+3492], edx
$LN21@operator@121:
	mov	DWORD PTR [ebx+3492], eax
	mov	eax, DWORD PTR [ebp+3496]
	cmp	eax, edx
	je	SHORT $LN27@operator@121
	add	DWORD PTR [eax], 1
$LN27@operator@121:
	mov	ecx, DWORD PTR [ebx+3496]
	cmp	ecx, edx
	je	SHORT $LN30@operator@121
	add	DWORD PTR [ecx], -1
	mov	ecx, DWORD PTR [ebx+3496]
	cmp	DWORD PTR [ecx], edx
	jne	SHORT $LN30@operator@121
	mov	DWORD PTR [ebx+3496], edx
$LN30@operator@121:
	lea	edx, DWORD PTR [ebp+3500]
	push	edx
	lea	esi, DWORD PTR [ebx+3500]
	mov	DWORD PTR [ebx+3496], eax
	call	??4?$_Impl_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<shared_str,xalloc<shared_str> >::operator=
	lea	esi, DWORD PTR [ebp+3512]
	lea	edi, DWORD PTR [ebx+3512]
	push	esi
	call	??4?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::operator=
	mov	eax, DWORD PTR [edi+12]
	xor	eax, DWORD PTR [esi+12]
	and	eax, 1
	xor	DWORD PTR [edi+12], eax
	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [esi+12]
	xor	ecx, eax
	and	ecx, 2
	xor	ecx, eax
	mov	DWORD PTR [edi+12], ecx
	mov	ecx, DWORD PTR [ebx+3528]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ebp+3528]
	mov	edx, DWORD PTR [edx+4]
	push	eax
	call	edx
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ebx
	pop	ebx
	ret	4
??4CStats@@QAEAAV0@ABV0@@Z ENDP				; CStats::operator=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4?$xr_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
??4?$xr_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@@QAEAAV0@ABV0@@Z PROC ; xr_vector<CSheduler::Item,xalloc<CSheduler::Item> >::operator=, COMDAT
; _this$ = ecx
; ___that$ = eax
	push	esi
	mov	esi, ecx
	push	eax
	call	??4?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::operator=
	mov	eax, esi
	pop	esi
	ret	0
??4?$xr_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@@QAEAAV0@ABV0@@Z ENDP ; xr_vector<CSheduler::Item,xalloc<CSheduler::Item> >::operator=
_TEXT	ENDS
PUBLIC	??4CSheduler@@QAEAAV0@ABV0@@Z			; CSheduler::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4CSheduler@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4CSheduler@@QAEAAV0@ABV0@@Z PROC			; CSheduler::operator=, COMDAT
; _this$ = ecx
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR ___that$[esp+4]
	push	esi
	push	edi
	mov	ebx, ecx
	push	ebp
	mov	esi, ebx
	call	??4?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::operator=
	lea	eax, DWORD PTR [ebp+12]
	push	eax
	lea	esi, DWORD PTR [ebx+12]
	call	??4?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::operator=
	lea	ecx, DWORD PTR [ebp+24]
	push	ecx
	lea	esi, DWORD PTR [ebx+24]
	call	??4?$_Impl_vector@UItem@CSheduler@@V?$xalloc@UItem@CSheduler@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<CSheduler::Item,xalloc<CSheduler::Item> >::operator=
	lea	edx, DWORD PTR [ebp+36]
	push	edx
	lea	edi, DWORD PTR [ebx+36]
	call	??4?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::operator=
	mov	eax, DWORD PTR [ebp+48]
	mov	DWORD PTR [ebx+48], eax
	mov	cl, BYTE PTR [ebp+52]
	mov	BYTE PTR [ebx+52], cl
	mov	edx, DWORD PTR [ebp+56]
	mov	DWORD PTR [ebx+56], edx
	mov	eax, DWORD PTR [ebp+60]
	mov	DWORD PTR [ebx+60], eax
	mov	ecx, DWORD PTR [ebp+64]
	pop	edi
	mov	DWORD PTR [ebx+64], ecx
	mov	edx, DWORD PTR [ebp+68]
	pop	esi
	pop	ebp
	mov	DWORD PTR [ebx+68], edx
	mov	eax, ebx
	pop	ebx
	ret	4
??4CSheduler@@QAEAAV0@ABV0@@Z ENDP			; CSheduler::operator=
PUBLIC	??4CRenderDevice@@QAEAAV0@ABV0@@Z		; CRenderDevice::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4CRenderDevice@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4CRenderDevice@@QAEAAV0@ABV0@@Z PROC			; CRenderDevice::operator=, COMDAT
; _this$ = ecx
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR ___that$[esp+4]
	test	ebp, ebp
	push	esi
	push	edi
	mov	ebx, ecx
	je	SHORT $LN5@operator@130
	lea	eax, DWORD PTR [ebp+4]
	jmp	SHORT $LN6@operator@130
$LN5@operator@130:
	xor	eax, eax
$LN6@operator@130:
	push	eax
	lea	ecx, DWORD PTR [ebx+4]
	call	??4CRenderDeviceData@@QAEAAV0@ABV0@@Z
	mov	eax, DWORD PTR [ebp+764]
	mov	DWORD PTR [ebx+764], eax
	mov	ecx, DWORD PTR [ebp+768]
	mov	DWORD PTR [ebx+768], ecx
	mov	edx, DWORD PTR [ebp+772]
	mov	DWORD PTR [ebx+772], edx
	mov	eax, DWORD PTR [ebp+776]
	mov	DWORD PTR [ebx+776], eax
	mov	ecx, DWORD PTR [ebp+780]
	mov	DWORD PTR [ebx+780], ecx
	mov	edx, DWORD PTR [ebp+784]
	mov	DWORD PTR [ebx+784], edx
	mov	eax, DWORD PTR [ebp+788]
	mov	DWORD PTR [ebx+788], eax
	mov	ecx, DWORD PTR [ebp+792]
	mov	DWORD PTR [ebx+792], ecx
	mov	edx, DWORD PTR [ebp+796]
	mov	DWORD PTR [ebx+796], edx
	lea	esi, DWORD PTR [ebp+800]
	lea	edi, DWORD PTR [ebx+800]
	mov	ecx, 14					; 0000000eH
	rep movsd
	mov	eax, DWORD PTR [ebp+856]
	mov	DWORD PTR [ebx+856], eax
	lea	esi, DWORD PTR [ebp+876]
	fld	DWORD PTR [ebp+860]
	lea	edi, DWORD PTR [ebx+876]
	fstp	DWORD PTR [ebx+860]
	push	esi
	fld	DWORD PTR [ebp+864]
	fstp	DWORD PTR [ebx+864]
	mov	ecx, DWORD PTR [ebp+868]
	mov	DWORD PTR [ebx+868], ecx
	mov	edx, DWORD PTR [ebp+872]
	mov	DWORD PTR [ebx+872], edx
	call	??4?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::operator=
	mov	eax, DWORD PTR [edi+12]
	xor	eax, DWORD PTR [esi+12]
	and	eax, 1
	xor	DWORD PTR [edi+12], eax
	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [esi+12]
	xor	ecx, eax
	and	ecx, 2
	xor	ecx, eax
	mov	DWORD PTR [edi+12], ecx
	lea	esi, DWORD PTR [ebp+892]
	lea	edi, DWORD PTR [ebx+892]
	push	esi
	call	??4?$_Impl_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<_REG_INFO,xalloc<_REG_INFO> >::operator=
	mov	edx, DWORD PTR [edi+12]
	xor	edx, DWORD PTR [esi+12]
	and	edx, 1
	xor	DWORD PTR [edi+12], edx
	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [esi+12]
	xor	ecx, eax
	and	ecx, 2
	lea	edx, DWORD PTR [ebp+908]
	xor	ecx, eax
	push	edx
	lea	esi, DWORD PTR [ebx+908]
	mov	DWORD PTR [edi+12], ecx
	call	??4?$_Impl_vector@V?$FastDelegate0@X@fastdelegate@@V?$xalloc@V?$FastDelegate0@X@fastdelegate@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<fastdelegate::FastDelegate0<void>,xalloc<fastdelegate::FastDelegate0<void> > >::operator=
	mov	eax, DWORD PTR [ebp+920]
	mov	DWORD PTR [ebx+920], eax
	lea	esi, DWORD PTR [ebp+924]
	lea	edi, DWORD PTR [ebx+924]
	mov	ecx, 16					; 00000010H
	rep movsd
	mov	ecx, DWORD PTR [ebp+988]
	mov	DWORD PTR [ebx+988], ecx
	mov	edx, DWORD PTR [ebp+992]
	mov	DWORD PTR [ebx+992], edx
	mov	eax, DWORD PTR [ebp+996]
	mov	DWORD PTR [ebx+996], eax
	mov	eax, ebx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
??4CRenderDevice@@QAEAAV0@ABV0@@Z ENDP			; CRenderDevice::operator=
_TEXT	ENDS
PUBLIC	??4CEngine@@QAEAAV0@ABV0@@Z			; CEngine::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4CEngine@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4CEngine@@QAEAAV0@ABV0@@Z PROC			; CEngine::operator=, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	ebx
	push	ebp
	mov	ebp, ecx
	mov	ecx, DWORD PTR [eax]
	push	esi
	push	edi
	mov	DWORD PTR [ebp], ecx
	lea	esi, DWORD PTR [eax+4]
	lea	edi, DWORD PTR [ebp+4]
	mov	ecx, 8
	rep movsd
	lea	esi, DWORD PTR [eax+36]
	lea	ebx, DWORD PTR [ebp+36]
	push	esi
	call	??4?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::operator=
	lea	edx, DWORD PTR [esi+12]
	push	edx
	lea	edi, DWORD PTR [ebx+12]
	call	??4?$_Impl_vector@UDeferred@CEventAPI@@V?$xalloc@UDeferred@CEventAPI@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<CEventAPI::Deferred,xalloc<CEventAPI::Deferred> >::operator=
	mov	ecx, DWORD PTR ___that$[esp+12]
	mov	eax, DWORD PTR [esi+24]
	add	ecx, 64					; 00000040H
	push	ecx
	lea	ecx, DWORD PTR [ebp+64]
	mov	DWORD PTR [ebx+24], eax
	call	??4CSheduler@@QAEAAV0@ABV0@@Z
	pop	edi
	pop	esi
	mov	eax, ebp
	pop	ebp
	pop	ebx
	ret	4
??4CEngine@@QAEAAV0@ABV0@@Z ENDP			; CEngine::operator=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_EISheduled@@UAEPAXI@Z
_TEXT	SEGMENT
_R$515634 = -12						; size = 12
___flags$ = 8						; size = 4
??_EISheduled@@UAEPAXI@Z PROC				; ISheduled::`vector deleting destructor', COMDAT
; _this$ = ecx
	sub	esp, 12					; 0000000cH
	test	BYTE PTR ___flags$[esp+8], 2
	push	esi
	mov	esi, ecx
	je	$LN3@vector@99
	push	ebx
	lea	ebx, DWORD PTR [esi-4]
	push	ebp
	mov	ebp, DWORD PTR [ebx]
	lea	esi, DWORD PTR [esi+ebp*8]
	sub	ebp, 1
	js	$LN6@vector@99
	push	edi
	npad	11
$LL7@vector@99:
	sub	esi, 8
	mov	DWORD PTR [esi], OFFSET ??_7ISheduled@@6B@
	cmp	BYTE PTR ?Engine@@3VCEngine@@A+116, 0
	je	SHORT $LN52@vector@99
	mov	eax, DWORD PTR [esi+4]
	shr	eax, 28					; 0000001cH
	push	0
	and	eax, 1
	push	eax
	push	esi
	mov	ecx, OFFSET ?Engine@@3VCEngine@@A+64
	call	?internal_Unregister@CSheduler@@AAE_NPAVISheduled@@H_N@Z ; CSheduler::internal_Unregister
	test	al, al
	jne	SHORT $LN26@vector@99
$LN52@vector@99:
	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR ?Engine@@3VCEngine@@A+104
	shr	ecx, 28					; 0000001cH
	xor	edx, edx
	and	ecx, 1
	cmp	eax, DWORD PTR ?Engine@@3VCEngine@@A+108
	mov	DWORD PTR _R$515634[esp+28], edx
	mov	DWORD PTR _R$515634[esp+32], ecx
	mov	DWORD PTR _R$515634[esp+36], esi
	je	SHORT $LN27@vector@99
	test	eax, eax
	je	SHORT $LN32@vector@99
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], esi
	mov	eax, DWORD PTR ?Engine@@3VCEngine@@A+104
$LN32@vector@99:
	add	eax, 12					; 0000000cH
	mov	DWORD PTR ?Engine@@3VCEngine@@A+104, eax
	jmp	SHORT $LN26@vector@99
$LN27@vector@99:
	lea	ecx, DWORD PTR _R$515634[esp+28]
	push	ecx
	mov	edi, OFFSET ?Engine@@3VCEngine@@A+100
	call	?_M_insert_overflow@?$_Impl_vector@UItemReg@CSheduler@@V?$xalloc@UItemReg@CSheduler@@@@@priv@stlp_std@@AAEXPAUItemReg@CSheduler@@ABU45@ABU__true_type@3@I_N@Z ; stlp_std::priv::_Impl_vector<CSheduler::ItemReg,xalloc<CSheduler::ItemReg> >::_M_insert_overflow
$LN26@vector@99:
	sub	ebp, 1
	jns	SHORT $LL7@vector@99
	pop	edi
$LN6@vector@99:
	test	BYTE PTR ___flags$[esp+20], 1
	je	SHORT $LN38@vector@99
	test	ebx, ebx
	je	SHORT $LN38@vector@99
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	ebx
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN38@vector@99:
	pop	ebp
	mov	eax, ebx
	pop	ebx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	4
$LN3@vector@99:
	push	esi
	mov	ecx, OFFSET ?Engine@@3VCEngine@@A+64
	mov	DWORD PTR [esi], OFFSET ??_7ISheduled@@6B@
	call	?Unregister@CSheduler@@QAEXPAVISheduled@@@Z ; CSheduler::Unregister
	test	BYTE PTR ___flags$[esp+12], 1
	je	SHORT $LN48@vector@99
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN48@vector@99:
	mov	eax, esi
	pop	esi
	add	esp, 12					; 0000000cH
	ret	4
??_EISheduled@@UAEPAXI@Z ENDP				; ISheduled::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_GISheduled@@UAEPAXI@Z			; ISheduled::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GISheduled@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GISheduled@@UAEPAXI@Z PROC				; ISheduled::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	push	esi
	mov	ecx, OFFSET ?Engine@@3VCEngine@@A+64
	mov	DWORD PTR [esi], OFFSET ??_7ISheduled@@6B@
	call	?Unregister@CSheduler@@QAEXPAVISheduled@@@Z ; CSheduler::Unregister
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN14@scalar@87
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN14@scalar@87:
	mov	eax, esi
	pop	esi
	ret	4
??_GISheduled@@UAEPAXI@Z ENDP				; ISheduled::`scalar deleting destructor'
END

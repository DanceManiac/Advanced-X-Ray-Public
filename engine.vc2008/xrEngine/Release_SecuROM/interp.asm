; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	D:\CLEARSKY\sources\engine\xrEngine\interp.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_floorf
PUBLIC	?floor@@YAMM@Z					; floor
EXTRN	_floor:PROC
; Function compile flags: /Ogtpy
; File j:\msvs8\vc\include\math.h
;	COMDAT _floorf
_TEXT	SEGMENT
__X$ = 8						; size = 4
_floorf	PROC						; COMDAT

; 405  :         {return ((float)floor((double)_X)); }

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	mov	esp, ebp
	pop	ebp
	ret	0
_floorf	ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?floor@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?floor@@YAMM@Z PROC					; floor, COMDAT

; 512  :         {return (floorf(_X)); }

	fld	DWORD PTR __X$[esp-4]
	push	ecx
	fstp	DWORD PTR [esp]
	call	_floorf
	add	esp, 4
	ret	0
?floor@@YAMM@Z ENDP					; floor
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\interp.cpp
_TEXT	ENDS
;	COMDAT ?bezier@@YAMMMMMM@Z
_TEXT	SEGMENT
_x3$ = 8						; size = 4
?bezier@@YAMMMMMM@Z PROC				; bezier, COMDAT
; _x0$ = xmm5s
; _x1$ = xmm0s
; _x2$ = xmm2s
; _t$ = xmm4s

; 65   :    float a, b, c, t2, t3;
; 66   : 
; 67   :    t2 = t * t;
; 68   :    t3 = t2 * t;
; 69   : 
; 70   :    c = 3.0f * ( x1 - x0 );

	movss	xmm6, DWORD PTR _drop_angle

; 71   :    b = 3.0f * ( x2 - x1 ) - c;

	subss	xmm2, xmm0
	movaps	xmm1, xmm0

; 72   :    a = x3 - x0 - c - b;

	movss	xmm0, DWORD PTR _x3$[esp-4]
	subss	xmm0, xmm5
	mulss	xmm2, xmm6
	subss	xmm1, xmm5
	mulss	xmm1, xmm6
	subss	xmm0, xmm1
	movaps	xmm3, xmm4
	mulss	xmm3, xmm4
	subss	xmm2, xmm1
	subss	xmm0, xmm2
	movaps	xmm6, xmm3
	mulss	xmm6, xmm4

; 73   : 
; 74   :    return a * t3 + b * t2 + c * t + x0;

	mulss	xmm0, xmm6
	mulss	xmm2, xmm3
	addss	xmm0, xmm2
	mulss	xmm1, xmm4
	addss	xmm0, xmm1
	addss	xmm0, xmm5

; 75   : }

	ret	0
?bezier@@YAMMMMMM@Z ENDP				; bezier
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?hermite@@YAXMPAM000@Z
_TEXT	SEGMENT
_h3$ = 8						; size = 4
?hermite@@YAXMPAM000@Z PROC				; hermite, COMDAT
; _t$ = xmm3s
; _h1$ = ecx
; _h2$ = eax
; _h4$ = edx

; 47   :    float t2, t3;
; 48   : 
; 49   :    t2 = t * t;
; 50   :    t3 = t * t2;
; 51   : 
; 52   :    *h2 = 3.0f * t2 - t3 - t3;
; 53   :    *h1 = 1.0f - *h2;

	movss	xmm4, DWORD PTR __real@3f800000
	movaps	xmm2, xmm3
	mulss	xmm2, xmm3
	movaps	xmm0, xmm2
	mulss	xmm0, xmm3
	movaps	xmm1, xmm2
	mulss	xmm1, DWORD PTR _drop_angle
	subss	xmm1, xmm0
	subss	xmm1, xmm0

; 54   :    *h4 = t3 - t2;

	subss	xmm0, xmm2
	movss	DWORD PTR [edx], xmm0
	movss	DWORD PTR [eax], xmm1

; 55   :    *h3 = *h4 - t2 + t;

	mov	eax, DWORD PTR _h3$[esp-4]
	subss	xmm0, xmm2
	subss	xmm4, xmm1
	addss	xmm0, xmm3
	movss	DWORD PTR [ecx], xmm4
	movss	DWORD PTR [eax], xmm0

; 56   : }

	ret	0
?hermite@@YAXMPAM000@Z ENDP				; hermite
_TEXT	ENDS
PUBLIC	__real@bfe0000000000000
PUBLIC	__real@3fe0000000000000
EXTRN	__ftol2_sse:PROC
;	COMDAT __real@bfe0000000000000
; File j:\msvs8\vc\include\math.h
CONST	SEGMENT
__real@bfe0000000000000 DQ 0bfe0000000000000r	; -0.5
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\interp.cpp
CONST	ENDS
;	COMDAT ?range@@YAMMMMPAH@Z
_TEXT	SEGMENT
_r$ = -8						; size = 4
tv133 = -4						; size = 4
_v$ = 8							; size = 4
tv83 = 12						; size = 4
_v2$ = 12						; size = 4
_lo$ = 12						; size = 4
?range@@YAMMMMPAH@Z PROC				; range, COMDAT
; _hi$ = xmm1s
; _i$ = esi

; 29   : static float range( float v, float lo, float hi, int *i ){

	sub	esp, 12					; 0000000cH

; 30   :    float v2, r = hi - lo;

	movss	xmm0, DWORD PTR _lo$[esp+8]
	subss	xmm1, xmm0

; 31   :    if ( r == 0.0 ){

	ucomiss	xmm1, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	movss	DWORD PTR _r$[esp+12], xmm1
	jp	SHORT $LN3@range

; 32   :       if ( i ) *i = 0;

	test	esi, esi
	je	$LN4@range
	mov	DWORD PTR [esi], 0

; 38   : }

	add	esp, 12					; 0000000cH
	ret	0
$LN3@range:

; 33   :       return lo;
; 34   :    }
; 35   :    v2 = lo + v - r * ( float ) floor(( float ) v / r );

	fld	DWORD PTR _v$[esp+8]
	movss	xmm0, DWORD PTR __real@3f800000
	fadd	DWORD PTR _lo$[esp+8]
	divss	xmm0, xmm1
	movss	DWORD PTR tv133[esp+12], xmm0
	mulss	xmm0, DWORD PTR _v$[esp+8]
	push	ecx
	fstp	DWORD PTR tv83[esp+12]
	movss	DWORD PTR [esp], xmm0
	call	_floorf
	fmul	DWORD PTR _r$[esp+16]
	add	esp, 4

; 36   :    if ( i ) *i = -( int )(( v2 - v ) / r + ( v2 > v ? 0.5 : -0.5 ));

	test	esi, esi
	fsubr	DWORD PTR tv83[esp+8]
	fst	DWORD PTR _v2$[esp+8]
	je	SHORT $LN13@range
	movss	xmm0, DWORD PTR _v2$[esp+8]
	comiss	xmm0, DWORD PTR _v$[esp+8]
	jbe	SHORT $LN6@range
	fld	QWORD PTR __real@3fe0000000000000
	jmp	SHORT $LN7@range
$LN6@range:
	fld	QWORD PTR __real@bfe0000000000000
$LN7@range:
	fxch	ST(1)
	fsub	DWORD PTR _v$[esp+8]
	fmul	DWORD PTR tv133[esp+12]
	faddp	ST(1), ST(0)
	call	__ftol2_sse

; 37   :    return v2;

	movss	xmm0, DWORD PTR _v2$[esp+8]
	neg	eax
	mov	DWORD PTR [esi], eax

; 38   : }

	add	esp, 12					; 0000000cH
	ret	0
$LN13@range:

; 37   :    return v2;

	movss	xmm0, DWORD PTR _v2$[esp+8]
	fstp	ST(0)
$LN4@range:

; 38   : }

	add	esp, 12					; 0000000cH
	ret	0
?range@@YAMMMMPAH@Z ENDP				; range
PUBLIC	__real@47c35000
;	COMDAT __real@47c35000
; File j:\msvs8\vc\include\math.h
CONST	SEGMENT
__real@47c35000 DD 047c35000r			; 100000
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\interp.cpp
CONST	ENDS
;	COMDAT ?incoming@@YAMPAUst_Key@@00@Z
_TEXT	SEGMENT
_in$ = -8						; size = 4
tv328 = -4						; size = 4
?incoming@@YAMPAUst_Key@@00@Z PROC			; incoming, COMDAT
; _key0$ = edx
; _key1$ = eax
; _key1n$ = ecx

; 191  : static float incoming( st_Key *key0, st_Key *key1, st_Key *key1n ){

	sub	esp, 8
	push	esi

; 192  :    float a, b, d, t, in;
; 193  : 
; 194  :    switch ( key1->shape ){

	movzx	esi, BYTE PTR [eax+8]
	cmp	esi, 5
	ja	$LN1@incoming
	jmp	DWORD PTR $LN21@incoming[esi*4]
$LN12@incoming:

; 195  :       case SHAPE_LINE:
; 196  :          d = key1->value - key0->value;
; 197  :          if ( key1n ) {

	test	ecx, ecx
	movss	xmm3, DWORD PTR [eax]
	movaps	xmm2, xmm3
	subss	xmm2, DWORD PTR [edx]
	je	$LN11@incoming

; 198  :             t = ( key1->time - key0->time ) / ( key1n->time - key0->time );

	movss	xmm1, DWORD PTR [edx+4]
	movss	xmm0, DWORD PTR [eax+4]
	movss	xmm4, DWORD PTR [ecx+4]
	subss	xmm0, xmm1
	subss	xmm4, xmm1

; 199  :             in = t * ( key1n->value - key1->value + d );

	movss	xmm1, DWORD PTR [ecx]
	subss	xmm1, xmm3
	divss	xmm0, xmm4
	addss	xmm1, xmm2
	mulss	xmm0, xmm1

; 236  :          break;
; 237  :    }
; 238  : 
; 239  :    return in;
; 240  : }

	pop	esi
	add	esp, 8
	ret	0
$LN9@incoming:

; 200  :          }
; 201  :          else
; 202  :             in = d;
; 203  :          break;
; 204  : 
; 205  :       case SHAPE_TCB:
; 206  :          a = ( 1.0f - key1->tension ) * ( 1.0f - key1->continuity ) * ( 1.0f + key1->bias );
; 207  :          b = ( 1.0f - key1->tension ) * ( 1.0f + key1->continuity ) * ( 1.0f - key1->bias );
; 208  :          d = key1->value - key0->value;
; 209  : 
; 210  :          if ( key1n ) {

	test	ecx, ecx
	movss	xmm3, DWORD PTR __real@3f800000
	movss	xmm7, DWORD PTR [eax+17]
	movss	xmm2, DWORD PTR [eax+13]
	movss	xmm5, DWORD PTR [eax]
	subss	xmm5, DWORD PTR [edx]
	movaps	xmm1, xmm3
	subss	xmm1, xmm2
	movaps	xmm0, xmm7
	movaps	xmm4, xmm3
	subss	xmm4, DWORD PTR [eax+9]
	addss	xmm0, xmm3
	mulss	xmm1, xmm0
	mulss	xmm1, xmm4

; 211  :             t = ( key1->time - key0->time ) / ( key1n->time - key0->time );
; 212  :             in = t * ( b * ( key1n->value - key1->value ) + a * d );

	mulss	xmm1, xmm5
	je	SHORT $LN8@incoming
	movss	xmm6, DWORD PTR [edx+4]
	addss	xmm2, xmm3
	movaps	xmm0, xmm3
	movss	xmm3, DWORD PTR [ecx]
	subss	xmm0, xmm7
	mulss	xmm0, xmm2
	movss	xmm2, DWORD PTR [eax]
	mulss	xmm0, xmm4
	subss	xmm3, xmm2
	movss	xmm2, DWORD PTR [ecx+4]
	mulss	xmm0, xmm3
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR [eax+4]
	subss	xmm1, xmm6
	subss	xmm2, xmm6
	divss	xmm1, xmm2
	mulss	xmm0, xmm1

; 236  :          break;
; 237  :    }
; 238  : 
; 239  :    return in;
; 240  : }

	pop	esi
	add	esp, 8
	ret	0
$LN8@incoming:

; 213  :          }
; 214  :          else
; 215  :             in = a * d;

	movaps	xmm0, xmm1

; 236  :          break;
; 237  :    }
; 238  : 
; 239  :    return in;
; 240  : }

	pop	esi
	add	esp, 8
	ret	0
$LN6@incoming:

; 216  :          break;
; 217  : 
; 218  :       case SHAPE_BEZI:
; 219  :       case SHAPE_HERM:
; 220  :          in = key1->param[ 0 ];
; 221  :          if ( key1n )

	test	ecx, ecx
	movss	xmm0, DWORD PTR [eax+21]
	je	SHORT $LN13@incoming

; 222  :             in *= ( key1->time - key0->time ) / ( key1n->time - key0->time );

	movss	xmm1, DWORD PTR [edx+4]
	movss	xmm2, DWORD PTR [eax+4]
	movss	xmm3, DWORD PTR [ecx+4]
	subss	xmm2, xmm1
	subss	xmm3, xmm1
	divss	xmm2, xmm3
	mulss	xmm2, xmm0
$LN11@incoming:
	movaps	xmm0, xmm2

; 236  :          break;
; 237  :    }
; 238  : 
; 239  :    return in;
; 240  : }

	pop	esi
	add	esp, 8
	ret	0
$LN4@incoming:

; 223  :          break;
; 224  : 
; 225  :       case SHAPE_BEZ2:
; 226  :          in = key1->param[ 1 ] * ( key1->time - key0->time );
; 227  :          if ( _abs( key1->param[ 0 ] ) > 1e-5f )

	fld	DWORD PTR [eax+21]
	movss	xmm0, DWORD PTR [eax+4]
	subss	xmm0, DWORD PTR [edx+4]
	fst	DWORD PTR tv328[esp+12]
	mulss	xmm0, DWORD PTR [eax+25]
	push	ecx
	fstp	DWORD PTR [esp]
	movss	DWORD PTR _in$[esp+16], xmm0
	call	_fabsf
	fld	DWORD PTR _EPS

; 228  :             in /= key1->param[ 0 ];

	movss	xmm0, DWORD PTR _in$[esp+16]
	fxch	ST(1)
	add	esp, 4
	fcomip	ST(1)
	fstp	ST(0)
	jbe	SHORT $LN3@incoming
	divss	xmm0, DWORD PTR tv328[esp+12]

; 236  :          break;
; 237  :    }
; 238  : 
; 239  :    return in;
; 240  : }

	pop	esi
	add	esp, 8
	ret	0
$LN3@incoming:

; 229  :          else
; 230  :             in *= 1e5f;

	mulss	xmm0, DWORD PTR __real@47c35000

; 236  :          break;
; 237  :    }
; 238  : 
; 239  :    return in;
; 240  : }

	pop	esi
	add	esp, 8
	ret	0
$LN1@incoming:

; 231  :          break;
; 232  : 
; 233  :       case SHAPE_STEP:
; 234  :       default:
; 235  :          in = 0.0f;

	xorps	xmm0, xmm0
$LN13@incoming:

; 236  :          break;
; 237  :    }
; 238  : 
; 239  :    return in;
; 240  : }

	pop	esi
	add	esp, 8
	ret	0
	npad	2
$LN21@incoming:
	DD	$LN9@incoming
	DD	$LN6@incoming
	DD	$LN6@incoming
	DD	$LN12@incoming
	DD	$LN1@incoming
	DD	$LN4@incoming
?incoming@@YAMPAUst_Key@@00@Z ENDP			; incoming
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?outgoing@@YAMPAUst_Key@@00@Z
_TEXT	SEGMENT
tv275 = -8						; size = 4
_out$ = -8						; size = 4
tv347 = -4						; size = 4
?outgoing@@YAMPAUst_Key@@00@Z PROC			; outgoing, COMDAT
; _key0p$ = ecx
; _key0$ = eax
; _key1$ = edx

; 135  : static float outgoing( st_Key *key0p, st_Key *key0, st_Key *key1 ){

	sub	esp, 8
	push	esi

; 136  :    float a, b, d, t, out;
; 137  : 
; 138  :    switch ( key0->shape ){

	movzx	esi, BYTE PTR [eax+8]
	cmp	esi, 5
	ja	$LN1@outgoing
	jmp	DWORD PTR $LN21@outgoing[esi*4]
$LN12@outgoing:

; 139  :       case SHAPE_TCB:
; 140  :          a = ( 1.0f - key0->tension ) * ( 1.0f + key0->continuity ) * ( 1.0f + key0->bias );
; 141  :          b = ( 1.0f - key0->tension ) * ( 1.0f - key0->continuity ) * ( 1.0f - key0->bias );
; 142  :          d = key1->value - key0->value;
; 143  : 
; 144  :          if ( key0p ) {

	test	ecx, ecx
	movss	xmm7, DWORD PTR __real@3f800000
	movss	xmm5, DWORD PTR [eax+17]
	movss	xmm1, DWORD PTR [eax+13]
	movss	xmm6, DWORD PTR [eax]
	movaps	xmm3, xmm7
	subss	xmm3, xmm1
	movaps	xmm2, xmm7
	subss	xmm2, xmm5
	mulss	xmm3, xmm2
	movss	xmm2, DWORD PTR [edx]
	movaps	xmm0, xmm7
	subss	xmm0, DWORD PTR [eax+9]
	mulss	xmm3, xmm0
	subss	xmm2, xmm6
	movss	DWORD PTR tv275[esp+12], xmm0

; 145  :             t = ( key1->time - key0->time ) / ( key1->time - key0p->time );
; 146  :             out = t * ( a * ( key0->value - key0p->value ) + b * d );

	mulss	xmm2, xmm3
	je	$LN11@outgoing
	movss	xmm4, DWORD PTR [edx+4]
	subss	xmm6, DWORD PTR [ecx]
	addss	xmm1, xmm7
	addss	xmm5, xmm7
	mulss	xmm1, xmm5
	mulss	xmm1, DWORD PTR tv275[esp+12]
	movaps	xmm0, xmm4
	subss	xmm0, DWORD PTR [eax+4]
	subss	xmm4, DWORD PTR [ecx+4]
	mulss	xmm1, xmm6
	divss	xmm0, xmm4
	addss	xmm1, xmm2
	mulss	xmm0, xmm1

; 179  :          break;
; 180  :    }
; 181  : 
; 182  :    return out;
; 183  : }

	pop	esi
	add	esp, 8
	ret	0
$LN9@outgoing:

; 147  :          }else
; 148  :             out = b * d;
; 149  :          break;
; 150  : 
; 151  :       case SHAPE_LINE:
; 152  :          d = key1->value - key0->value;
; 153  :          if ( key0p ) {

	test	ecx, ecx
	movss	xmm2, DWORD PTR [eax]
	movss	xmm3, DWORD PTR [edx]
	subss	xmm3, xmm2
	je	SHORT $LN8@outgoing

; 154  :             t = ( key1->time - key0->time ) / ( key1->time - key0p->time );

	movss	xmm1, DWORD PTR [edx+4]

; 155  :             out = t * ( key0->value - key0p->value + d );

	subss	xmm2, DWORD PTR [ecx]
	movaps	xmm0, xmm1
	subss	xmm0, DWORD PTR [eax+4]
	subss	xmm1, DWORD PTR [ecx+4]
	divss	xmm0, xmm1
	addss	xmm2, xmm3
	mulss	xmm0, xmm2

; 179  :          break;
; 180  :    }
; 181  : 
; 182  :    return out;
; 183  : }

	pop	esi
	add	esp, 8
	ret	0
$LN8@outgoing:

; 156  :          }
; 157  :          else
; 158  :             out = d;

	movaps	xmm0, xmm3

; 179  :          break;
; 180  :    }
; 181  : 
; 182  :    return out;
; 183  : }

	pop	esi
	add	esp, 8
	ret	0
$LN6@outgoing:

; 159  :          break;
; 160  : 
; 161  :       case SHAPE_BEZI:
; 162  :       case SHAPE_HERM:
; 163  :          out = key0->param[ 1 ];
; 164  :          if ( key0p )

	test	ecx, ecx
	movss	xmm0, DWORD PTR [eax+25]
	je	SHORT $LN13@outgoing

; 165  :             out *= ( key1->time - key0->time ) / ( key1->time - key0p->time );

	movss	xmm1, DWORD PTR [edx+4]
	movaps	xmm2, xmm1
	subss	xmm2, DWORD PTR [eax+4]
	subss	xmm1, DWORD PTR [ecx+4]
	divss	xmm2, xmm1
	mulss	xmm2, xmm0
$LN11@outgoing:
	movaps	xmm0, xmm2

; 179  :          break;
; 180  :    }
; 181  : 
; 182  :    return out;
; 183  : }

	pop	esi
	add	esp, 8
	ret	0
$LN4@outgoing:

; 166  :          break;
; 167  : 
; 168  :       case SHAPE_BEZ2:
; 169  :          out = key0->param[ 3 ] * ( key1->time - key0->time );
; 170  :          if ( _abs( key0->param[ 2 ] ) > 1e-5f )

	fld	DWORD PTR [eax+29]
	movss	xmm0, DWORD PTR [edx+4]
	subss	xmm0, DWORD PTR [eax+4]
	fst	DWORD PTR tv347[esp+12]
	mulss	xmm0, DWORD PTR [eax+33]
	push	ecx
	fstp	DWORD PTR [esp]
	movss	DWORD PTR _out$[esp+16], xmm0
	call	_fabsf
	fld	DWORD PTR _EPS

; 171  :             out /= key0->param[ 2 ];

	movss	xmm0, DWORD PTR _out$[esp+16]
	fxch	ST(1)
	add	esp, 4
	fcomip	ST(1)
	fstp	ST(0)
	jbe	SHORT $LN3@outgoing
	divss	xmm0, DWORD PTR tv347[esp+12]

; 179  :          break;
; 180  :    }
; 181  : 
; 182  :    return out;
; 183  : }

	pop	esi
	add	esp, 8
	ret	0
$LN3@outgoing:

; 172  :          else
; 173  :             out *= 1e5f;

	mulss	xmm0, DWORD PTR __real@47c35000

; 179  :          break;
; 180  :    }
; 181  : 
; 182  :    return out;
; 183  : }

	pop	esi
	add	esp, 8
	ret	0
$LN1@outgoing:

; 174  :          break;
; 175  : 
; 176  :       case SHAPE_STEP:
; 177  :       default:
; 178  :          out = 0.0f;

	xorps	xmm0, xmm0
$LN13@outgoing:

; 179  :          break;
; 180  :    }
; 181  : 
; 182  :    return out;
; 183  : }

	pop	esi
	add	esp, 8
	ret	0
	npad	3
$LN21@outgoing:
	DD	$LN12@outgoing
	DD	$LN6@outgoing
	DD	$LN6@outgoing
	DD	$LN9@outgoing
	DD	$LN1@outgoing
	DD	$LN4@outgoing
?outgoing@@YAMPAUst_Key@@00@Z ENDP			; outgoing
_TEXT	ENDS
PUBLIC	__real@38d1b717
;	COMDAT __real@38d1b717
; File j:\msvs8\vc\include\math.h
CONST	SEGMENT
__real@38d1b717 DD 038d1b717r			; 0.0001
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\interp.cpp
CONST	ENDS
;	COMDAT ?bez2_time@@YAMMMMMMPAM0@Z
_TEXT	SEGMENT
_t$ = -20						; size = 4
_v$ = -16						; size = 4
tv203 = -12						; size = 4
_c$246051 = -12						; size = 4
tv206 = -8						; size = 4
_b$246050 = -8						; size = 4
tv210 = -4						; size = 4
tv208 = -4						; size = 4
_x0$ = 8						; size = 4
_x1$ = 12						; size = 4
_x3$ = 16						; size = 4
_time$ = 20						; size = 4
?bez2_time@@YAMMMMMMPAM0@Z PROC				; bez2_time, COMDAT
; _x2$ = xmm2s
; _t0$ = edi
; _t1$ = esi

; 86   : static float bez2_time( float x0, float x1, float x2, float x3, float time, float *t0, float *t1 ){

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 24					; 00000018H

; 87   :    float v, t;
; 88   : 
; 89   :    t = *t0 + ( *t1 - *t0 ) * 0.5f;

	movss	xmm1, DWORD PTR [edi]
	movss	xmm0, DWORD PTR [esi]

; 90   :    v = bezier( x0, x1, x2, x3, t );

	movss	xmm5, DWORD PTR _x0$[ebp]
	movss	xmm6, DWORD PTR _drop_angle
	subss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR _x1$[ebp]
	subss	xmm2, xmm1
	movaps	xmm3, xmm1
	movss	xmm1, DWORD PTR _x3$[ebp]
	subss	xmm1, xmm5
	mulss	xmm2, xmm6
	movss	DWORD PTR tv208[esp+24], xmm1
	movaps	xmm4, xmm0
	mulss	xmm4, xmm0
	subss	xmm3, xmm5
	mulss	xmm3, xmm6
	subss	xmm1, xmm3
	movss	DWORD PTR tv206[esp+24], xmm2
	subss	xmm2, xmm3
	subss	xmm1, xmm2
	movaps	xmm6, xmm4
	mulss	xmm6, xmm0
	mulss	xmm1, xmm6
	movss	DWORD PTR tv203[esp+24], xmm3
	mulss	xmm3, xmm0
	mulss	xmm2, xmm4
	addss	xmm1, xmm2
	movss	DWORD PTR _t$[esp+24], xmm0

; 91   :    if ( _abs( time - v ) > .0001f ) {

	movss	xmm0, DWORD PTR _time$[ebp]
	addss	xmm1, xmm3
	addss	xmm1, xmm5
	push	ecx
	subss	xmm0, xmm1
	movss	DWORD PTR _v$[esp+28], xmm1
	movss	DWORD PTR [esp], xmm0
	call	_fabsf
	fld	DWORD PTR __real@38d1b717
	fxch	ST(1)
	add	esp, 4
	fcomip	ST(1)
	fstp	ST(0)
	jbe	$LN16@bez2_time@4
	movss	xmm3, DWORD PTR tv203[esp+24]
	movss	xmm4, DWORD PTR tv206[esp+24]
	movss	xmm0, DWORD PTR tv208[esp+24]
	subss	xmm4, xmm3
	subss	xmm0, xmm3
	subss	xmm0, xmm4
	movss	DWORD PTR _c$246051[esp+24], xmm3
	movss	DWORD PTR _b$246050[esp+24], xmm4
	movss	DWORD PTR tv210[esp+24], xmm0
	jmp	SHORT $LN13@bez2_time@4
	npad	6
$LL17@bez2_time@4:

; 90   :    v = bezier( x0, x1, x2, x3, t );

	movss	xmm3, DWORD PTR _c$246051[esp+24]
	movss	xmm4, DWORD PTR _b$246050[esp+24]
$LN13@bez2_time@4:

; 92   :       if ( v > time )

	movss	xmm0, DWORD PTR _v$[esp+24]
	movss	xmm5, DWORD PTR _time$[ebp]
	comiss	xmm0, xmm5

; 93   :          *t1 = t;

	movss	xmm0, DWORD PTR _t$[esp+24]
	jbe	SHORT $LN3@bez2_time@4
	movss	DWORD PTR [esi], xmm0

; 94   :       else

	jmp	SHORT $LN2@bez2_time@4
$LN3@bez2_time@4:

; 95   :          *t0 = t;

	movss	DWORD PTR [edi], xmm0
$LN2@bez2_time@4:

; 87   :    float v, t;
; 88   : 
; 89   :    t = *t0 + ( *t1 - *t0 ) * 0.5f;

	movss	xmm1, DWORD PTR [edi]
	movss	xmm0, DWORD PTR [esi]
	subss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, xmm1

; 90   :    v = bezier( x0, x1, x2, x3, t );

	movaps	xmm2, xmm0
	mulss	xmm2, xmm0
	movaps	xmm1, xmm2
	mulss	xmm1, xmm0
	mulss	xmm1, DWORD PTR tv210[esp+24]
	mulss	xmm4, xmm2
	addss	xmm1, xmm4
	mulss	xmm3, xmm0
	addss	xmm1, xmm3
	addss	xmm1, DWORD PTR _x0$[ebp]

; 91   :    if ( _abs( time - v ) > .0001f ) {

	push	ecx
	subss	xmm5, xmm1
	movss	DWORD PTR _t$[esp+28], xmm0
	movss	DWORD PTR _v$[esp+28], xmm1
	movss	DWORD PTR [esp], xmm5
	call	_fabsf
	fld	DWORD PTR __real@38d1b717
	fxch	ST(1)
	add	esp, 4
	fcomip	ST(1)
	fstp	ST(0)
	ja	$LL17@bez2_time@4
$LN16@bez2_time@4:

; 96   :       return bez2_time( x0, x1, x2, x3, time, t0, t1 );
; 97   :    }
; 98   :    else
; 99   :       return t;

	movss	xmm0, DWORD PTR _t$[esp+24]

; 100  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?bez2_time@@YAMMMMMMPAM0@Z ENDP				; bez2_time
; Function compile flags: /Ogtpy
;	COMDAT ?bez2@@YAMPAUst_Key@@0M@Z
_TEXT	SEGMENT
tv213 = -12						; size = 4
_t1$ = -8						; size = 4
_t0$ = -4						; size = 4
_x$ = 8							; size = 4
_key0$ = 8						; size = 4
_time$ = 12						; size = 4
?bez2@@YAMPAUst_Key@@0M@Z PROC				; bez2, COMDAT
; _key1$ = ebx

; 108  : static float bez2( st_Key *key0, st_Key *key1, float time ){

	sub	esp, 12					; 0000000cH

; 109  :    float x, y, t, t0 = 0.0f, t1 = 1.0f;

	xorps	xmm0, xmm0
	push	ebp
	mov	ebp, DWORD PTR _key0$[esp+12]

; 110  : 
; 111  :    if ( key0->shape == SHAPE_BEZ2 )

	cmp	BYTE PTR [ebp+8], 5
	movss	DWORD PTR _t0$[esp+16], xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _t1$[esp+16], xmm0
	jne	SHORT $LN4@bez2

; 112  :       x = key0->time + key0->param[ 2 ];

	movss	xmm0, DWORD PTR [ebp+29]
	addss	xmm0, DWORD PTR [ebp+4]
	movss	DWORD PTR _x$[esp+12], xmm0

; 113  :    else

	jmp	SHORT $LN3@bez2
$LN4@bez2:

; 114  :       x = key0->time + ( key1->time - key0->time ) / 3.0f;

	movss	xmm0, DWORD PTR [ebp+4]
	movss	xmm1, DWORD PTR [ebx+4]
	subss	xmm1, xmm0
	mulss	xmm1, DWORD PTR __real@3eaaaaab
	addss	xmm1, xmm0
	movss	DWORD PTR _x$[esp+12], xmm1
$LN3@bez2:

; 115  : 
; 116  :    t = bez2_time( key0->time, x, key1->time + key1->param[ 0 ], key1->time,
; 117  :       time, &t0, &t1 );

	movss	xmm0, DWORD PTR [ebx+4]
	fld	DWORD PTR _time$[esp+12]
	movss	xmm2, DWORD PTR [ebx+21]
	push	esi
	push	edi
	sub	esp, 16					; 00000010H
	fstp	DWORD PTR [esp+12]
	movss	DWORD PTR tv213[esp+40], xmm0
	fld	DWORD PTR tv213[esp+40]
	lea	esi, DWORD PTR _t1$[esp+40]
	fstp	DWORD PTR [esp+8]
	lea	edi, DWORD PTR _t0$[esp+40]
	fld	DWORD PTR _x$[esp+36]
	addss	xmm2, xmm0
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR [ebp+4]
	fstp	DWORD PTR [esp]
	call	?bez2_time@@YAMMMMMMPAM0@Z		; bez2_time

; 118  : 
; 119  :    if ( key0->shape == SHAPE_BEZ2 )
; 120  :       y = key0->value + key0->param[ 3 ];

	movss	xmm4, DWORD PTR [ebp]
	add	esp, 16					; 00000010H
	cmp	BYTE PTR [ebp+8], 5
	pop	edi
	movaps	xmm6, xmm0
	pop	esi
	jne	SHORT $LN2@bez2
	movss	xmm5, DWORD PTR [ebp+33]

; 121  :    else

	jmp	SHORT $LN9@bez2
$LN2@bez2:

; 122  :       y = key0->value + key0->param[ 1 ] / 3.0f;

	movss	xmm5, DWORD PTR [ebp+25]
	mulss	xmm5, DWORD PTR __real@3eaaaaab
$LN9@bez2:

; 123  : 
; 124  :    return bezier( key0->value, y, key1->param[ 1 ] + key1->value, key1->value, t );

	movss	xmm0, DWORD PTR [ebx]
	movss	xmm1, DWORD PTR [ebx+25]
	movss	xmm7, DWORD PTR _drop_angle
	addss	xmm1, xmm0
	addss	xmm5, xmm4
	subss	xmm1, xmm5
	subss	xmm0, xmm4
	movaps	xmm2, xmm5
	subss	xmm2, xmm4
	mulss	xmm2, xmm7
	subss	xmm0, xmm2
	movaps	xmm3, xmm6
	mulss	xmm3, xmm6
	mulss	xmm1, xmm7
	subss	xmm1, xmm2
	subss	xmm0, xmm1
	movaps	xmm5, xmm3
	mulss	xmm5, xmm6
	mulss	xmm0, xmm5
	mulss	xmm1, xmm3
	addss	xmm0, xmm1
	mulss	xmm2, xmm6
	addss	xmm0, xmm2
	addss	xmm0, xmm4
	pop	ebp

; 125  : }

	add	esp, 12					; 0000000cH
	ret	0
?bez2@@YAMPAUst_Key@@0M@Z ENDP				; bez2
PUBLIC	?evalEnvelope@@YAMPAVCEnvelope@@M@Z		; evalEnvelope
; Function compile flags: /Ogtpy
;	COMDAT ?evalEnvelope@@YAMPAVCEnvelope@@M@Z
_TEXT	SEGMENT
_offset$ = -28						; size = 4
tv776 = -24						; size = 4
tv786 = -20						; size = 4
_skey_n$ = -20						; size = 4
_h2$ = -16						; size = 4
_ekey$ = -16						; size = 4
_r$373533 = -12						; size = 4
_r$373485 = -12						; size = 4
_t$ = -12						; size = 4
_ekey_p$ = -12						; size = 4
tv910 = -8						; size = 4
tv849 = -8						; size = 4
_key0_p$ = -8						; size = 4
tv1005 = -4						; size = 4
_t2$373710 = -4						; size = 4
_key1_n$ = -4						; size = 4
tv999 = 8						; size = 4
tv997 = 8						; size = 4
_in$373554 = 8						; size = 4
_out$373506 = 8						; size = 4
$T373543 = 8						; size = 4
$T373495 = 8						; size = 4
_h4$ = 8						; size = 4
_key1$ = 8						; size = 4
_noff$ = 8						; size = 4
_env$ = 8						; size = 4
_time$ = 12						; size = 4
?evalEnvelope@@YAMPAVCEnvelope@@M@Z PROC		; evalEnvelope, COMDAT

; 250  : float evalEnvelope( CEnvelope *env, float time ){

	sub	esp, 28					; 0000001cH

; 251  :    	st_Key *key0, *key1, *skey, *ekey, *skey_n, *ekey_p, *key0_p=0, *key1_n=0;
; 252  :    	float t, h1, h2, h3, h4, in, out, offset = 0.0f;

	xorps	xmm0, xmm0
	push	ebx
	push	ebp
	push	esi
	push	edi

; 253  :    	int noff;
; 254  : 
; 255  : 
; 256  :    	// if there's no key, the value is 0
; 257  :    	if ( env->keys.empty() ) return 0.0f;

	mov	edi, DWORD PTR _env$[esp+40]
	xor	eax, eax
	add	edi, 4
	mov	ecx, edi
	mov	DWORD PTR _key0_p$[esp+44], eax
	mov	DWORD PTR _key1_n$[esp+44], eax
	movss	DWORD PTR _offset$[esp+44], xmm0
	call	?empty@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QBE_NXZ ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::empty
	test	al, al
	jne	$LN35@evalEnvelo

; 258  : 
; 259  :    	// if there's only one key, the value is constant
; 260  :    	if ( env->keys.size() == 1 )

	mov	eax, DWORD PTR [edi+4]
	sub	eax, DWORD PTR [edi]
	and	eax, -4					; fffffffcH
	cmp	eax, 4
	jne	SHORT $LN39@evalEnvelo

; 261  :       	return env->keys[0]->value;

	mov	edi, DWORD PTR [edi]
	push	edi
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	mov	ecx, DWORD PTR [eax]
	movss	xmm0, DWORD PTR [ecx]
	add	esp, 4

; 345  :    	}
; 346  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	0
$LN39@evalEnvelo:

; 262  : 
; 263  :    // find the first and last keys
; 264  : 	int sz = env->keys.size();

	mov	ebp, DWORD PTR [edi+4]
	sub	ebp, DWORD PTR [edi]

; 265  :    	skey = env->keys[0];

	mov	eax, DWORD PTR [edi]
	push	eax
	sar	ebp, 2
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	mov	ebx, DWORD PTR [eax]

; 266  :    	ekey = env->keys[sz-1];

	mov	eax, DWORD PTR [edi]
	add	esp, 4
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	mov	esi, DWORD PTR [eax+ebp*4-4]

; 267  :    	skey_n=env->keys[1];

	mov	eax, DWORD PTR [edi]
	add	esp, 4
	push	eax
	mov	DWORD PTR _ekey$[esp+48], esi
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	mov	edx, DWORD PTR [eax+4]

; 268  :    	ekey_p=env->keys[sz-2];

	mov	eax, DWORD PTR [edi]
	add	esp, 4
	push	eax
	mov	DWORD PTR _skey_n$[esp+48], edx
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr

; 269  : 
; 270  :    	// use pre-behavior if time is before first key time
; 271  :    	if ( time < skey->time ){

	movss	xmm0, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [eax+ebp*4-8]
	movss	xmm2, DWORD PTR _time$[esp+44]
	add	esp, 4
	comiss	xmm0, xmm2
	mov	DWORD PTR _ekey_p$[esp+44], eax
	movss	DWORD PTR tv776[esp+44], xmm0
	jbe	$LN38@evalEnvelo

; 272  :       	switch ( env->behavior[ 0 ] ){

	mov	eax, DWORD PTR _env$[esp+40]
	mov	eax, DWORD PTR [eax+16]
	cmp	eax, 5
	ja	SHORT $LN25@evalEnvelo
	jmp	DWORD PTR $LN264@evalEnvelo[eax*4]
$LN35@evalEnvelo:

; 273  :          	case BEH_RESET:            return 0.0f;

	xorps	xmm0, xmm0

; 345  :    	}
; 346  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	0
$LN34@evalEnvelo:

; 274  :          	case BEH_CONSTANT:			return skey->value;

	movss	xmm0, DWORD PTR [ebx]

; 345  :    	}
; 346  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	0
$LN33@evalEnvelo:

; 275  :          	case BEH_REPEAT:
; 276  :             	time = range( time, skey->time, ekey->time, NULL );

	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR [esi+4]
	subss	xmm0, xmm1
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	movss	DWORD PTR $T373495[esp+40], xmm1
	movss	DWORD PTR _r$373485[esp+44], xmm0
	jp	SHORT $LN126@evalEnvelo
	movss	DWORD PTR _time$[esp+40], xmm1
	jmp	SHORT $LN25@evalEnvelo
$LN126@evalEnvelo:
	fld	DWORD PTR $T373495[esp+40]
	movaps	xmm1, xmm2
	fadd	DWORD PTR _time$[esp+40]
	push	ecx
	divss	xmm1, xmm0
	movss	DWORD PTR [esp], xmm1
	fstp	DWORD PTR tv997[esp+44]
	call	_floorf
	fmul	DWORD PTR _r$373485[esp+48]
	add	esp, 4
	fsubr	DWORD PTR tv997[esp+40]
$LN262@evalEnvelo:
	fstp	DWORD PTR _time$[esp+40]
$LN25@evalEnvelo:

; 312  :       	}
; 313  :    	}
; 314  :    	// get the endpoints of the interval being evaluated
; 315  :     int k=0;
; 316  :     while (time>env->keys[k+1]->time) k++;

	mov	eax, DWORD PTR [edi]
	push	eax
	xor	esi, esi
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	mov	edx, DWORD PTR [eax+4]
	movss	xmm0, DWORD PTR _time$[esp+44]
	add	eax, 4
	add	esp, 4
	comiss	xmm0, DWORD PTR [edx+4]
	jbe	SHORT $LN15@evalEnvelo
$LL17@evalEnvelo:
	mov	eax, DWORD PTR [edi]
	push	eax
	add	esi, 1
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	movss	xmm0, DWORD PTR _time$[esp+44]
	lea	eax, DWORD PTR [eax+esi*4+4]
	mov	eax, DWORD PTR [eax]
	add	esp, 4
	comiss	xmm0, DWORD PTR [eax+4]
	ja	SHORT $LL17@evalEnvelo
$LN15@evalEnvelo:

; 317  :     VERIFY((k+1)<sz);
; 318  : 
; 319  :     key1 = env->keys[k+1];

	mov	eax, DWORD PTR [edi]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	mov	ecx, DWORD PTR [eax+esi*4+4]

; 320  : 	key0 = env->keys[k];

	mov	eax, DWORD PTR [edi]
	add	esp, 4
	push	eax
	mov	DWORD PTR _key1$[esp+44], ecx
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	mov	ebx, DWORD PTR [eax+esi*4]
	add	esp, 4

; 321  :     if (k>0)  		key0_p = env->keys[k-1];

	test	esi, esi
	jle	SHORT $LN12@evalEnvelo
	mov	eax, DWORD PTR [edi]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	mov	edx, DWORD PTR [eax+esi*4-4]
	add	esp, 4
	mov	DWORD PTR _key0_p$[esp+44], edx
$LN12@evalEnvelo:

; 322  :     if ((k+2)<sz) 	key1_n = env->keys[k+2];

	add	esi, 2
	cmp	esi, ebp
	jge	$LN258@evalEnvelo
	mov	edi, DWORD PTR [edi]
	push	edi
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	mov	edi, DWORD PTR [eax+esi*4]
	add	esp, 4
	jmp	$LN11@evalEnvelo
$LN32@evalEnvelo:

; 277  :             break;
; 278  :          	case BEH_OSCILLATE:
; 279  :             	time = range( time, skey->time, ekey->time, &noff );

	fld	DWORD PTR tv776[esp+44]
	movss	xmm1, DWORD PTR [esi+4]
	sub	esp, 8
	fstp	DWORD PTR [esp+4]
	lea	esi, DWORD PTR _noff$[esp+48]
	fld	DWORD PTR _time$[esp+48]
	movss	DWORD PTR tv786[esp+52], xmm1
	fstp	DWORD PTR [esp]
	call	?range@@YAMMMMPAH@Z			; range

; 280  :             	if ( noff % 2 )

	mov	ecx, DWORD PTR _noff$[esp+48]
	add	esp, 8
	and	ecx, -2147483647			; 80000001H
	movss	DWORD PTR _time$[esp+40], xmm0
	jns	SHORT $LN259@evalEnvelo
	dec	ecx
	or	ecx, -2					; fffffffeH
	inc	ecx
$LN259@evalEnvelo:
	je	$LN25@evalEnvelo

; 281  :                		time = ekey->time - skey->time - time;

	movss	xmm1, DWORD PTR tv786[esp+44]
	subss	xmm1, DWORD PTR tv776[esp+44]
	subss	xmm1, xmm0
	movss	DWORD PTR _time$[esp+40], xmm1

; 282  :             break;

	jmp	$LN25@evalEnvelo
$LN30@evalEnvelo:

; 283  :          	case BEH_OFFSET:
; 284  :             	time = range( time, skey->time, ekey->time, &noff );

	fld	DWORD PTR tv776[esp+44]
	mov	edx, DWORD PTR _ekey$[esp+44]
	movss	xmm1, DWORD PTR [edx+4]
	sub	esp, 8
	fstp	DWORD PTR [esp+4]
	lea	esi, DWORD PTR _noff$[esp+48]
	fld	DWORD PTR _time$[esp+48]
	fstp	DWORD PTR [esp]
	call	?range@@YAMMMMPAH@Z			; range

; 285  :             	offset = noff * ( ekey->value - skey->value );

	mov	eax, DWORD PTR _ekey$[esp+52]
	movss	DWORD PTR _time$[esp+48], xmm0
	movss	xmm0, DWORD PTR [eax]

; 286  :             break;

	jmp	$LN263@evalEnvelo
$LN29@evalEnvelo:

; 287  :          	case BEH_LINEAR:
; 288  :             	out = outgoing( 0, skey, skey_n ) / ( skey_n->time - skey->time );

	movzx	eax, BYTE PTR [ebx+8]
	cmp	eax, 5
	ja	$LN135@evalEnvelo
	jmp	DWORD PTR $LN265@evalEnvelo[eax*4]
$LN146@evalEnvelo:
	movss	xmm1, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR _skey_n$[esp+44]
	movaps	xmm0, xmm1
	subss	xmm0, DWORD PTR [ebx+17]
	movaps	xmm3, xmm1
	subss	xmm1, DWORD PTR [ebx+9]
	subss	xmm3, DWORD PTR [ebx+13]
	mulss	xmm0, xmm3
	mulss	xmm0, xmm1
	movss	xmm1, DWORD PTR [ecx]
	subss	xmm1, DWORD PTR [ebx]
	mulss	xmm0, xmm1
	jmp	SHORT $LN147@evalEnvelo
$LN143@evalEnvelo:
	mov	edx, DWORD PTR _skey_n$[esp+44]
	movss	xmm0, DWORD PTR [edx]
	subss	xmm0, DWORD PTR [ebx]
	jmp	SHORT $LN147@evalEnvelo
$LN140@evalEnvelo:
	movss	xmm0, DWORD PTR [ebx+25]
	jmp	SHORT $LN147@evalEnvelo
$LN138@evalEnvelo:
	mov	eax, DWORD PTR _skey_n$[esp+44]
	fld	DWORD PTR [ebx+29]
	movss	xmm1, DWORD PTR [eax+4]
	fst	DWORD PTR tv849[esp+44]
	subss	xmm1, xmm0
	mulss	xmm1, DWORD PTR [ebx+33]
	push	ecx
	fstp	DWORD PTR [esp]
	movss	DWORD PTR _out$373506[esp+44], xmm1
	call	_fabsf
	fld	DWORD PTR _EPS
	movss	xmm0, DWORD PTR _out$373506[esp+44]
	fxch	ST(1)
	movss	xmm2, DWORD PTR _time$[esp+44]
	add	esp, 4
	fcomip	ST(1)
	fstp	ST(0)
	jbe	SHORT $LN137@evalEnvelo
	divss	xmm0, DWORD PTR tv849[esp+44]
	jmp	SHORT $LN147@evalEnvelo
$LN137@evalEnvelo:
	mulss	xmm0, DWORD PTR __real@47c35000
	jmp	SHORT $LN147@evalEnvelo
$LN135@evalEnvelo:
	xorps	xmm0, xmm0
$LN147@evalEnvelo:
	mov	ecx, DWORD PTR _skey_n$[esp+44]
	movss	xmm1, DWORD PTR [ebx+4]
	movss	xmm3, DWORD PTR [ecx+4]
	subss	xmm3, xmm1
	divss	xmm0, xmm3

; 289  :             	return out * ( time - skey->time ) + skey->value;

	subss	xmm2, xmm1
	mulss	xmm0, xmm2
	addss	xmm0, DWORD PTR [ebx]

; 345  :    	}
; 346  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	0
$LN38@evalEnvelo:

; 290  :       	}
; 291  :    	}
; 292  :    	// use post-behavior if time is after last key time
; 293  :    	else if ( time > ekey->time ) {

	movss	xmm1, DWORD PTR [esi+4]
	comiss	xmm2, xmm1
	movss	DWORD PTR tv786[esp+44], xmm1
	jbe	$LN25@evalEnvelo

; 294  :       	switch ( env->behavior[ 1 ] ){

	mov	edx, DWORD PTR _env$[esp+40]
	mov	ecx, DWORD PTR [edx+20]
	cmp	ecx, 5
	ja	$LN25@evalEnvelo
	jmp	DWORD PTR $LN266@evalEnvelo[ecx*4]
$LN23@evalEnvelo:

; 295  :          	case BEH_RESET:            return 0.0f;
; 296  :          	case BEH_CONSTANT:			return ekey->value;

	movss	xmm0, DWORD PTR [esi]

; 345  :    	}
; 346  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	0
$LN22@evalEnvelo:

; 297  :          	case BEH_REPEAT:
; 298  :             	time = range( time, skey->time, ekey->time, NULL );

	subss	xmm1, xmm0
	ucomiss	xmm1, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	movss	DWORD PTR $T373543[esp+40], xmm0
	movss	DWORD PTR _r$373533[esp+44], xmm1
	jp	SHORT $LN157@evalEnvelo
	movss	DWORD PTR _time$[esp+40], xmm0
	jmp	$LN25@evalEnvelo
$LN157@evalEnvelo:
	fld	DWORD PTR $T373543[esp+40]
	movaps	xmm0, xmm2
	fadd	DWORD PTR _time$[esp+40]
	push	ecx
	divss	xmm0, xmm1
	movss	DWORD PTR [esp], xmm0
	fstp	DWORD PTR tv999[esp+44]
	call	_floorf
	fmul	DWORD PTR _r$373533[esp+48]
	add	esp, 4
	fsubr	DWORD PTR tv999[esp+40]

; 299  :             break;

	jmp	$LN262@evalEnvelo
$LN21@evalEnvelo:

; 300  :          	case BEH_OSCILLATE:
; 301  :             	time = range( time, skey->time, ekey->time, &noff );

	fld	DWORD PTR tv776[esp+44]
	sub	esp, 8
	fstp	DWORD PTR [esp+4]
	lea	esi, DWORD PTR _noff$[esp+48]
	fld	DWORD PTR _time$[esp+48]
	fstp	DWORD PTR [esp]
	call	?range@@YAMMMMPAH@Z			; range

; 302  :             	if ( noff % 2 )

	mov	eax, DWORD PTR _noff$[esp+48]
	add	esp, 8
	and	eax, -2147483647			; 80000001H
	movss	DWORD PTR _time$[esp+40], xmm0
	jns	SHORT $LN260@evalEnvelo
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN260@evalEnvelo:
	je	$LN25@evalEnvelo

; 303  :                		time = ekey->time - skey->time - time;

	movss	xmm1, DWORD PTR tv786[esp+44]
	subss	xmm1, DWORD PTR tv776[esp+44]
	subss	xmm1, xmm0
	movss	DWORD PTR _time$[esp+40], xmm1

; 304  :             break;

	jmp	$LN25@evalEnvelo
$LN19@evalEnvelo:

; 305  :          	case BEH_OFFSET:
; 306  :             	time = range( time, skey->time, ekey->time, &noff );

	fld	DWORD PTR tv776[esp+44]
	sub	esp, 8
	fstp	DWORD PTR [esp+4]
	lea	esi, DWORD PTR _noff$[esp+48]
	fld	DWORD PTR _time$[esp+48]
	fstp	DWORD PTR [esp]
	call	?range@@YAMMMMPAH@Z			; range

; 307  :             	offset = noff * ( ekey->value - skey->value );

	mov	ecx, DWORD PTR _ekey$[esp+52]
	movss	DWORD PTR _time$[esp+48], xmm0
	movss	xmm0, DWORD PTR [ecx]
$LN263@evalEnvelo:
	subss	xmm0, DWORD PTR [ebx]
	cvtsi2ss xmm1, DWORD PTR _noff$[esp+48]
	mulss	xmm0, xmm1
	add	esp, 8
	movss	DWORD PTR _offset$[esp+44], xmm0

; 308  :             break;

	jmp	$LN25@evalEnvelo
$LN18@evalEnvelo:

; 309  :          	case BEH_LINEAR:
; 310  :             	in = incoming( ekey_p, ekey, 0 ) / ( ekey->time - ekey_p->time );

	movzx	ecx, BYTE PTR [esi+8]
	cmp	ecx, 5
	ja	$LN166@evalEnvelo
	jmp	DWORD PTR $LN267@evalEnvelo[ecx*4]
$LN177@evalEnvelo:
	movss	xmm0, DWORD PTR [esi]
	subss	xmm0, DWORD PTR [eax]
	jmp	$LN178@evalEnvelo
$LN174@evalEnvelo:
	movss	xmm1, DWORD PTR __real@3f800000
	movaps	xmm0, xmm1
	subss	xmm0, DWORD PTR [esi+13]
	movaps	xmm3, xmm1
	subss	xmm3, DWORD PTR [esi+9]
	mulss	xmm0, xmm3
	movss	xmm3, DWORD PTR [esi+17]
	addss	xmm3, xmm1
	movss	xmm1, DWORD PTR [esi]
	subss	xmm1, DWORD PTR [eax]
	mulss	xmm0, xmm3
	mulss	xmm0, xmm1
	jmp	SHORT $LN178@evalEnvelo
$LN171@evalEnvelo:
	movss	xmm0, DWORD PTR [esi+21]
	jmp	SHORT $LN178@evalEnvelo
$LN169@evalEnvelo:
	fld	DWORD PTR [esi+21]
	subss	xmm1, DWORD PTR [eax+4]
	mulss	xmm1, DWORD PTR [esi+25]
	fst	DWORD PTR tv910[esp+44]
	push	ecx
	fstp	DWORD PTR [esp]
	movss	DWORD PTR _in$373554[esp+44], xmm1
	call	_fabsf
	fld	DWORD PTR _EPS
	movss	xmm0, DWORD PTR _in$373554[esp+44]
	fxch	ST(1)
	movss	xmm2, DWORD PTR _time$[esp+44]
	mov	eax, DWORD PTR _ekey_p$[esp+48]
	add	esp, 4
	fcomip	ST(1)
	fstp	ST(0)
	jbe	SHORT $LN168@evalEnvelo
	divss	xmm0, DWORD PTR tv910[esp+44]
	jmp	SHORT $LN178@evalEnvelo
$LN168@evalEnvelo:
	mulss	xmm0, DWORD PTR __real@47c35000
	jmp	SHORT $LN178@evalEnvelo
$LN166@evalEnvelo:
	xorps	xmm0, xmm0
$LN178@evalEnvelo:
	movss	xmm1, DWORD PTR [esi+4]
	movaps	xmm3, xmm1
	subss	xmm3, DWORD PTR [eax+4]
	divss	xmm0, xmm3

; 311  :             	return in * ( time - ekey->time ) + ekey->value;

	subss	xmm2, xmm1
	mulss	xmm0, xmm2
	addss	xmm0, DWORD PTR [esi]

; 345  :    	}
; 346  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	0
$LN258@evalEnvelo:

; 322  :     if ((k+2)<sz) 	key1_n = env->keys[k+2];

	mov	edi, DWORD PTR _key1_n$[esp+44]
$LN11@evalEnvelo:

; 323  : 
; 324  :    	// check for singularities first
; 325  :    	if ( time == key0->time )		return key0->value + offset;

	movss	xmm2, DWORD PTR _time$[esp+40]
	ucomiss	xmm2, DWORD PTR [ebx+4]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN10@evalEnvelo
$LN2@evalEnvelo:
	movss	xmm0, DWORD PTR _offset$[esp+44]
	addss	xmm0, DWORD PTR [ebx]

; 345  :    	}
; 346  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	0
$LN10@evalEnvelo:

; 326  :    	else if ( time == key1->time )	return key1->value + offset;

	mov	esi, DWORD PTR _key1$[esp+40]
	movss	xmm0, DWORD PTR [esi+4]
	ucomiss	xmm2, xmm0
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN8@evalEnvelo
	movss	xmm0, DWORD PTR [esi]
	addss	xmm0, DWORD PTR _offset$[esp+44]

; 345  :    	}
; 346  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	0
$LN8@evalEnvelo:

; 327  : 
; 328  :    	// get interval length, time in [0, 1]
; 329  :    	t = ( time - key0->time ) / ( key1->time - key0->time );
; 330  : 
; 331  :    	// interpolate
; 332  :    	switch ( key1->shape ){

	movzx	eax, BYTE PTR [esi+8]
	cmp	eax, 5
	movss	xmm1, DWORD PTR [ebx+4]
	subss	xmm2, xmm1
	subss	xmm0, xmm1
	divss	xmm2, xmm0
	movss	DWORD PTR _t$[esp+44], xmm2
	ja	$LN1@evalEnvelo
	jmp	DWORD PTR $LN268@evalEnvelo[eax*4]
$LN5@evalEnvelo:

; 333  :       	case SHAPE_TCB:
; 334  :       	case SHAPE_BEZI:
; 335  :       	case SHAPE_HERM:
; 336  :          	out = outgoing( key0_p, key0, key1 );

	mov	ecx, DWORD PTR _key0_p$[esp+44]

; 337  :          	in = incoming( key0, key1, key1_n );
; 338  :          	hermite( t, &h1, &h2, &h3, &h4 );

	movaps	xmm1, xmm2
	mulss	xmm1, xmm2
	movaps	xmm0, xmm1
	mulss	xmm0, xmm2
	movaps	xmm2, xmm1
	mulss	xmm2, DWORD PTR _drop_angle
	subss	xmm2, xmm0
	subss	xmm2, xmm0
	subss	xmm0, xmm1
	mov	edx, esi
	mov	eax, ebx
	movss	DWORD PTR _t2$373710[esp+44], xmm1
	movss	DWORD PTR _h2$[esp+44], xmm2
	movss	DWORD PTR _h4$[esp+40], xmm0
	call	?outgoing@@YAMPAUst_Key@@00@Z		; outgoing
	movss	xmm1, DWORD PTR _h4$[esp+40]
	subss	xmm1, DWORD PTR _t2$373710[esp+44]
	addss	xmm1, DWORD PTR _t$[esp+44]

; 339  :          	return h1 * key0->value + h2 * key1->value + h3 * out + h4 * in + offset;

	mulss	xmm0, xmm1
	mov	ecx, edi
	mov	eax, esi
	mov	edx, ebx
	movss	DWORD PTR tv1005[esp+44], xmm0
	call	?incoming@@YAMPAUst_Key@@00@Z		; incoming
	mulss	xmm0, DWORD PTR _h4$[esp+40]
	movss	xmm1, DWORD PTR tv1005[esp+44]
	movss	xmm2, DWORD PTR __real@3f800000
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR _h2$[esp+44]
	subss	xmm2, xmm0
	mulss	xmm2, DWORD PTR [ebx]
	addss	xmm1, xmm2
	movss	xmm2, DWORD PTR [esi]
	mulss	xmm2, xmm0
	addss	xmm1, xmm2
	addss	xmm1, DWORD PTR _offset$[esp+44]
	movaps	xmm0, xmm1

; 345  :    	}
; 346  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	0
$LN4@evalEnvelo:

; 340  :       	case SHAPE_BEZ2:         return bez2( key0, key1, time ) + offset;

	fld	DWORD PTR _time$[esp+40]
	push	ecx
	fstp	DWORD PTR [esp]
	push	ebx
	mov	ebx, esi
	call	?bez2@@YAMPAUst_Key@@0M@Z		; bez2
	addss	xmm0, DWORD PTR _offset$[esp+52]
	add	esp, 8

; 345  :    	}
; 346  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	0
$LN3@evalEnvelo:

; 341  :       	case SHAPE_LINE:         return key0->value + t * ( key1->value - key0->value ) + offset;

	movss	xmm1, DWORD PTR [ebx]
	movss	xmm0, DWORD PTR [esi]
	subss	xmm0, xmm1
	mulss	xmm0, xmm2
	addss	xmm0, xmm1
	addss	xmm0, DWORD PTR _offset$[esp+44]

; 345  :    	}
; 346  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	0
$LN1@evalEnvelo:

; 342  :       	case SHAPE_STEP:         return key0->value + offset;
; 343  :       	default:
; 344  :          	return offset;

	movss	xmm0, DWORD PTR _offset$[esp+44]

; 345  :    	}
; 346  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	0
	npad	1
$LN264@evalEnvelo:
	DD	$LN35@evalEnvelo
	DD	$LN34@evalEnvelo
	DD	$LN33@evalEnvelo
	DD	$LN32@evalEnvelo
	DD	$LN30@evalEnvelo
	DD	$LN29@evalEnvelo
$LN265@evalEnvelo:
	DD	$LN146@evalEnvelo
	DD	$LN140@evalEnvelo
	DD	$LN140@evalEnvelo
	DD	$LN143@evalEnvelo
	DD	$LN135@evalEnvelo
	DD	$LN138@evalEnvelo
$LN266@evalEnvelo:
	DD	$LN35@evalEnvelo
	DD	$LN23@evalEnvelo
	DD	$LN22@evalEnvelo
	DD	$LN21@evalEnvelo
	DD	$LN19@evalEnvelo
	DD	$LN18@evalEnvelo
$LN267@evalEnvelo:
	DD	$LN174@evalEnvelo
	DD	$LN171@evalEnvelo
	DD	$LN171@evalEnvelo
	DD	$LN177@evalEnvelo
	DD	$LN166@evalEnvelo
	DD	$LN169@evalEnvelo
$LN268@evalEnvelo:
	DD	$LN5@evalEnvelo
	DD	$LN5@evalEnvelo
	DD	$LN5@evalEnvelo
	DD	$LN3@evalEnvelo
	DD	$LN2@evalEnvelo
	DD	$LN4@evalEnvelo
?evalEnvelope@@YAMPAVCEnvelope@@M@Z ENDP		; evalEnvelope
END

; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	D:\CLEARSKY\sources\engine\xrEngine\Xr_input.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	?OnAppDeactivate@CInput@@UAEXXZ			; CInput::OnAppDeactivate
PUBLIC	?OnAppActivate@CInput@@UAEXXZ			; CInput::OnAppActivate
PUBLIC	?OnFrame@CInput@@UAGXXZ				; CInput::OnFrame
PUBLIC	?Add@?$CRegistrator@VpureAppActivate@@@@QAEXPAVpureAppActivate@@HI@Z ; CRegistrator<pureAppActivate>::Add
PUBLIC	?Add@?$CRegistrator@VpureAppDeactivate@@@@QAEXPAVpureAppDeactivate@@HI@Z ; CRegistrator<pureAppDeactivate>::Add
PUBLIC	??0?$xalloc@PAVIInputReceiver@@@@QAE@XZ		; xalloc<IInputReceiver *>::xalloc<IInputReceiver *>
PUBLIC	??$?0PAVIInputReceiver@@@?$xalloc@PAX@@QAE@ABV?$xalloc@PAVIInputReceiver@@@@@Z ; xalloc<void *>::xalloc<void *><IInputReceiver *>
PUBLIC	??0?$vector@PAVIInputReceiver@@V?$xalloc@PAVIInputReceiver@@@@@stlp_std@@QAE@ABV?$xalloc@PAVIInputReceiver@@@@@Z ; stlp_std::vector<IInputReceiver *,xalloc<IInputReceiver *> >::vector<IInputReceiver *,xalloc<IInputReceiver *> >
PUBLIC	??0?$xr_vector@PAVIInputReceiver@@V?$xalloc@PAVIInputReceiver@@@@@@QAE@XZ ; xr_vector<IInputReceiver *,xalloc<IInputReceiver *> >::xr_vector<IInputReceiver *,xalloc<IInputReceiver *> >
PUBLIC	?_REG_Compare@?$CRegistrator@VpureAppActivate@@@@CAHPBX0@Z ; CRegistrator<pureAppActivate>::_REG_Compare
PUBLIC	?Resort@?$CRegistrator@VpureAppActivate@@@@QAEXXZ ; CRegistrator<pureAppActivate>::Resort
PUBLIC	?Remove@?$CRegistrator@VpureAppActivate@@@@QAEXPAVpureAppActivate@@@Z ; CRegistrator<pureAppActivate>::Remove
PUBLIC	?_REG_Compare@?$CRegistrator@VpureAppDeactivate@@@@CAHPBX0@Z ; CRegistrator<pureAppDeactivate>::_REG_Compare
PUBLIC	?Resort@?$CRegistrator@VpureAppDeactivate@@@@QAEXXZ ; CRegistrator<pureAppDeactivate>::Resort
PUBLIC	?Remove@?$CRegistrator@VpureAppDeactivate@@@@QAEXPAVpureAppDeactivate@@@Z ; CRegistrator<pureAppDeactivate>::Remove
PUBLIC	?pop_back@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEXXZ ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::pop_back
PUBLIC	?pop_back@?$vector@PAVIInputReceiver@@V?$xalloc@PAVIInputReceiver@@@@@stlp_std@@QAEXXZ ; stlp_std::vector<IInputReceiver *,xalloc<IInputReceiver *> >::pop_back
PUBLIC	??$__copy_ptrs@PAPAXPAPAX@priv@stlp_std@@YAPAPAXPAPAX00ABU__true_type@1@@Z ; stlp_std::priv::__copy_ptrs<void * *,void * *>
PUBLIC	?_M_erase@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@AAEPAPAXPAPAXABU__false_type@3@@Z ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::_M_erase
PUBLIC	?erase@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEPAPAXPAPAX@Z ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::erase
PUBLIC	?uncv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::uncv_ptr
PUBLIC	?to_storage_type_ptr@?$_CastTraits@PAXPAVIInputReceiver@@@priv@stlp_std@@SAPAPAXPAPAVIInputReceiver@@@Z ; stlp_std::priv::_CastTraits<void *,IInputReceiver *>::to_storage_type_ptr
PUBLIC	?erase@?$vector@PAVIInputReceiver@@V?$xalloc@PAVIInputReceiver@@@@@stlp_std@@QAEPAPAVIInputReceiver@@PAPAV3@@Z ; stlp_std::vector<IInputReceiver *,xalloc<IInputReceiver *> >::erase
PUBLIC	?size@?$vector@PAVIInputReceiver@@V?$xalloc@PAVIInputReceiver@@@@@stlp_std@@QBEIXZ ; stlp_std::vector<IInputReceiver *,xalloc<IInputReceiver *> >::size
PUBLIC	?size@?$xr_vector@PAVIInputReceiver@@V?$xalloc@PAVIInputReceiver@@@@@@QBEIXZ ; xr_vector<IInputReceiver *,xalloc<IInputReceiver *> >::size
PUBLIC	?to_value_type_ptr@?$_CastTraits@PAXPAVIInputReceiver@@@priv@stlp_std@@SAPAPAVIInputReceiver@@PAPAX@Z ; stlp_std::priv::_CastTraits<void *,IInputReceiver *>::to_value_type_ptr
PUBLIC	?begin@?$vector@PAVIInputReceiver@@V?$xalloc@PAVIInputReceiver@@@@@stlp_std@@QAEPAPAVIInputReceiver@@XZ ; stlp_std::vector<IInputReceiver *,xalloc<IInputReceiver *> >::begin
PUBLIC	??A?$xr_vector@PAVIInputReceiver@@V?$xalloc@PAVIInputReceiver@@@@@@QAEAAPAVIInputReceiver@@I@Z ; xr_vector<IInputReceiver *,xalloc<IInputReceiver *> >::operator[]
PUBLIC	??$__advance@PAPAVIInputReceiver@@I@stlp_std@@YAXAAPAPAVIInputReceiver@@IABUrandom_access_iterator_tag@0@@Z ; stlp_std::__advance<IInputReceiver * *,unsigned int>
PUBLIC	??$advance@PAPAVIInputReceiver@@I@stlp_std@@YAXAAPAPAVIInputReceiver@@I@Z ; stlp_std::advance<IInputReceiver * *,unsigned int>
PUBLIC	?empty@?$vector@PAVIInputReceiver@@V?$xalloc@PAVIInputReceiver@@@@@stlp_std@@QBE_NXZ ; stlp_std::vector<IInputReceiver *,xalloc<IInputReceiver *> >::empty
PUBLIC	?back@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEAAPAXXZ ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::back
PUBLIC	?cv_ref@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAAAPAXAAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ref
PUBLIC	?to_value_type_ref@?$_CastTraits@PAXPAVIInputReceiver@@@priv@stlp_std@@SAAAPAVIInputReceiver@@AAPAX@Z ; stlp_std::priv::_CastTraits<void *,IInputReceiver *>::to_value_type_ref
PUBLIC	?back@?$vector@PAVIInputReceiver@@V?$xalloc@PAVIInputReceiver@@@@@stlp_std@@QAEAAPAVIInputReceiver@@XZ ; stlp_std::vector<IInputReceiver *,xalloc<IInputReceiver *> >::back
PUBLIC	?_M_set@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@AAEXPAPAX00@Z ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::_M_set
PUBLIC	??$__fill_n@PAPAXIPAX@priv@stlp_std@@YAPAPAXPAPAXIABQAX@Z ; stlp_std::priv::__fill_n<void * *,unsigned int,void *>
PUBLIC	?_M_insert_overflow@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@AAEXPAPAXABQAXABU__true_type@3@I_N@Z ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::_M_insert_overflow
PUBLIC	?push_back@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEXABQAX@Z ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::push_back
PUBLIC	?uncv_cref@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAABQAXABQAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::uncv_cref
PUBLIC	?to_storage_type_cref@?$_CastTraits@PAXPAVIInputReceiver@@@priv@stlp_std@@SAABQAXABQAVIInputReceiver@@@Z ; stlp_std::priv::_CastTraits<void *,IInputReceiver *>::to_storage_type_cref
PUBLIC	?push_back@?$vector@PAVIInputReceiver@@V?$xalloc@PAVIInputReceiver@@@@@stlp_std@@QAEXABQAVIInputReceiver@@@Z ; stlp_std::vector<IInputReceiver *,xalloc<IInputReceiver *> >::push_back
PUBLIC	?max@?$numeric_limits@M@stlp_std@@SAMXZ		; stlp_std::numeric_limits<float>::max
PUBLIC	?pInput@@3PAVCInput@@A				; pInput
PUBLIC	?psMouseSens@@3MA				; psMouseSens
PUBLIC	?psMouseSensScale@@3MA				; psMouseSensScale
PUBLIC	?psMouseInvert@@3U?$_flags@I@@A			; psMouseInvert
PUBLIC	??_C@_0BJ@CPDBDIOG@Starting?5INPUT?5device?4?4?4?$AA@ ; `string'
PUBLIC	??_C@_07BFLDNPLJ@Input?3?5?$AA@			; `string'
PUBLIC	??_C@_0CM@BFPMLCCJ@?$CB?5INPUT?3?5Can?8t?5set?5coop?5level?4?5E@ ; `string'
PUBLIC	??_C@_0BK@GOKHJJOE@CInput?3?3CreateInputDevice?$AA@ ; `string'
PUBLIC	??_C@_0DB@FGAJOMBI@D?3?2CLEARSKY?2sources?2engine?2xrEng@ ; `string'
PUBLIC	??_C@_03BGBILOPL@_hr?$AA@			; `string'
PUBLIC	?b_altF4@@3HA					; b_altF4
PUBLIC	??_C@_0CP@PIIDBILA@?$CB?5cant?5convert?5dik_name?5for?5dik?$FL@ ; `string'
EXTRN	__imp__SendMessageA@16:PROC
EXTRN	__imp__WideCharToMultiByte@32:PROC
EXTRN	__imp_?set_on_dialog@xrDebug@@QAEXP6AX_N@Z@Z:PROC
EXTRN	_IID_IDirectInput8A:BYTE
EXTRN	_GUID_SysMouse:BYTE
EXTRN	_GUID_SysKeyboard:BYTE
EXTRN	_c_dfDIMouse2:BYTE
EXTRN	_c_dfDIKeyboard:BYTE
EXTRN	_DirectInput8Create@20:PROC
EXTRN	__imp_?Log@@YAXPBDI@Z:PROC
?pInput@@3PAVCInput@@A DD 01H DUP (?)			; pInput
?psMouseInvert@@3U?$_flags@I@@A DD 01H DUP (?)		; psMouseInvert
;	COMDAT ?ignore_always@?7??CreateInputDevice@CInput@@AAEJPAPAUIDirectInputDevice8A@@U_GUID@@PBU_DIDATAFORMAT@@II@Z@4_NA
_BSS	SEGMENT
?ignore_always@?7??CreateInputDevice@CInput@@AAEJPAPAUIDirectInputDevice8A@@U_GUID@@PBU_DIDATAFORMAT@@II@Z@4_NA DB 01H DUP (?) ; `CInput::CreateInputDevice'::`8'::ignore_always
?b_altF4@@3HA DD 01H DUP (?)				; b_altF4
;	COMDAT ??_C@_0CP@PIIDBILA@?$CB?5cant?5convert?5dik_name?5for?5dik?$FL@
CONST	SEGMENT
??_C@_0CP@PIIDBILA@?$CB?5cant?5convert?5dik_name?5for?5dik?$FL@ DB '! can'
	DB	't convert dik_name for dik[%d], prop=[%S]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03BGBILOPL@_hr?$AA@
CONST	SEGMENT
??_C@_03BGBILOPL@_hr?$AA@ DB '_hr', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@FGAJOMBI@D?3?2CLEARSKY?2sources?2engine?2xrEng@
CONST	SEGMENT
??_C@_0DB@FGAJOMBI@D?3?2CLEARSKY?2sources?2engine?2xrEng@ DB 'D:\CLEARSKY'
	DB	'\sources\engine\xrEngine\Xr_input.cpp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GOKHJJOE@CInput?3?3CreateInputDevice?$AA@
CONST	SEGMENT
??_C@_0BK@GOKHJJOE@CInput?3?3CreateInputDevice?$AA@ DB 'CInput::CreateInp'
	DB	'utDevice', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@BFPMLCCJ@?$CB?5INPUT?3?5Can?8t?5set?5coop?5level?4?5E@
CONST	SEGMENT
??_C@_0CM@BFPMLCCJ@?$CB?5INPUT?3?5Can?8t?5set?5coop?5level?4?5E@ DB '! IN'
	DB	'PUT: Can''t set coop level. Emulation???', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07BFLDNPLJ@Input?3?5?$AA@
CONST	SEGMENT
??_C@_07BFLDNPLJ@Input?3?5?$AA@ DB 'Input: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CPDBDIOG@Starting?5INPUT?5device?4?4?4?$AA@
CONST	SEGMENT
??_C@_0BJ@CPDBDIOG@Starting?5INPUT?5device?4?4?4?$AA@ DB 'Starting INPUT '
	DB	'device...', 00H				; `string'
_g_exclusive DB	01H
?psMouseSens@@3MA DD 03f800000r			; 1	; psMouseSens
	ORG $+1
?psMouseSensScale@@3MA DD 03f800000r		; 1	; psMouseSensScale
PUBLIC	__real@7f7fffff
;	COMDAT __real@7f7fffff
; File d:\clearsky\sources\sdk\include\stlport\stl\_limits.h
CONST	SEGMENT
__real@7f7fffff DD 07f7fffffr			; 3.40282e+038
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?max@?$numeric_limits@M@stlp_std@@SAMXZ
_TEXT	SEGMENT
?max@?$numeric_limits@M@stlp_std@@SAMXZ PROC		; stlp_std::numeric_limits<float>::max, COMDAT

; 466  :   static float (_STLP_CALL max) () _STLP_NOTHROW { _STLP_USING_VENDOR_CSTD return FLT_MAX; }

	movss	xmm0, DWORD PTR __real@7f7fffff
	ret	0
?max@?$numeric_limits@M@stlp_std@@SAMXZ ENDP		; stlp_std::numeric_limits<float>::max
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_iterator_base.h
_TEXT	ENDS
;	COMDAT ??$__advance@PAPAVIInputReceiver@@I@stlp_std@@YAXAAPAPAVIInputReceiver@@IABUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
??$__advance@PAPAVIInputReceiver@@I@stlp_std@@YAXAAPAPAVIInputReceiver@@IABUrandom_access_iterator_tag@0@@Z PROC ; stlp_std::__advance<IInputReceiver * *,unsigned int>, COMDAT
; ___i$ = eax
; ___n$ = ecx

; 522  :   __i += __n;

	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 523  : }

	ret	0
??$__advance@PAPAVIInputReceiver@@I@stlp_std@@YAXAAPAPAVIInputReceiver@@IABUrandom_access_iterator_tag@0@@Z ENDP ; stlp_std::__advance<IInputReceiver * *,unsigned int>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_algobase.h
_TEXT	ENDS
;	COMDAT ??$__fill_n@PAPAXIPAX@priv@stlp_std@@YAPAPAXPAPAXIABQAX@Z
_TEXT	SEGMENT
??$__fill_n@PAPAXIPAX@priv@stlp_std@@YAPAPAXPAPAXIABQAX@Z PROC ; stlp_std::priv::__fill_n<void * *,unsigned int,void *>, COMDAT
; ___first$ = eax
; ___n$ = ecx
; ___val$ = edx

; 403  :   _STLP_FIX_LITERAL_BUG(__first)
; 404  :   for ( ; __n > 0; --__n, ++__first)

	test	ecx, ecx
	jbe	SHORT $LN1@fill_n@18
	push	esi
$LL3@fill_n@18:

; 405  :     *__first = __val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	sub	ecx, 1
	add	eax, 4
	test	ecx, ecx
	ja	SHORT $LL3@fill_n@18
	pop	esi
$LN1@fill_n@18:

; 406  :   return __first;
; 407  : }

	ret	0
??$__fill_n@PAPAXIPAX@priv@stlp_std@@YAPAPAXPAPAXIABQAX@Z ENDP ; stlp_std::priv::__fill_n<void * *,unsigned int,void *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ?_M_set@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@AAEXPAPAX00@Z
_TEXT	SEGMENT
___e$ = 8						; size = 4
?_M_set@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@AAEXPAPAX00@Z PROC ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::_M_set, COMDAT
; _this$ = eax
; ___s$ = ecx
; ___f$ = edx

; 626  :     this->_M_start = __s;

	mov	DWORD PTR [eax], ecx

; 627  :     this->_M_finish = __f;
; 628  :     this->_M_end_of_storage._M_data = __e;

	mov	ecx, DWORD PTR ___e$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], ecx

; 629  :   }

	ret	4
?_M_set@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@AAEXPAPAX00@Z ENDP ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::_M_set
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ??$?0PAVIInputReceiver@@@?$xalloc@PAX@@QAE@ABV?$xalloc@PAVIInputReceiver@@@@@Z
_TEXT	SEGMENT
??$?0PAVIInputReceiver@@@?$xalloc@PAX@@QAE@ABV?$xalloc@PAVIInputReceiver@@@@@Z PROC ; xalloc<void *>::xalloc<void *><IInputReceiver *>, COMDAT
; _this$ = eax

; 79   : 	template<class _Other>							xalloc			(const xalloc<_Other>&)					{	}

	ret	0
??$?0PAVIInputReceiver@@@?$xalloc@PAX@@QAE@ABV?$xalloc@PAVIInputReceiver@@@@@Z ENDP ; xalloc<void *>::xalloc<void *><IInputReceiver *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_iterator_base.h
_TEXT	ENDS
;	COMDAT ??$advance@PAPAVIInputReceiver@@I@stlp_std@@YAXAAPAPAVIInputReceiver@@I@Z
_TEXT	SEGMENT
??$advance@PAPAVIInputReceiver@@I@stlp_std@@YAXAAPAPAVIInputReceiver@@I@Z PROC ; stlp_std::advance<IInputReceiver * *,unsigned int>, COMDAT
; ___i$ = eax
; ___n$ = ecx

; 527  :   __advance(__i, __n, _STLP_ITERATOR_CATEGORY(__i, _InputIterator));

	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 528  : }

	ret	0
??$advance@PAPAVIInputReceiver@@I@stlp_std@@YAXAAPAPAVIInputReceiver@@I@Z ENDP ; stlp_std::advance<IInputReceiver * *,unsigned int>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_tools.h
_TEXT	ENDS
;	COMDAT ?cv_ref@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAAAPAXAAPAX@Z
_TEXT	SEGMENT
?cv_ref@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAAAPAXAAPAX@Z PROC ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ref, COMDAT
; ___ref$ = eax

; 155  :   { return __ref; }

	ret	0
?cv_ref@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAAAPAXAAPAX@Z ENDP ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ref
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?uncv_cref@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAABQAXABQAX@Z
_TEXT	SEGMENT
?uncv_cref@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAABQAXABQAX@Z PROC ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::uncv_cref, COMDAT
; ___ref$ = eax

; 147  :   { return __ref; }

	ret	0
?uncv_cref@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAABQAXABQAX@Z ENDP ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::uncv_cref
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?uncv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z
_TEXT	SEGMENT
?uncv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z PROC ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::uncv_ptr, COMDAT
; ___ptr$ = eax

; 139  :   { return __ptr; }

	ret	0
?uncv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ENDP ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::uncv_ptr
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\pure.h
_TEXT	ENDS
;	COMDAT ?_REG_Compare@?$CRegistrator@VpureAppDeactivate@@@@CAHPBX0@Z
_TEXT	SEGMENT
_e1$ = 8						; size = 4
_e2$ = 12						; size = 4
?_REG_Compare@?$CRegistrator@VpureAppDeactivate@@@@CAHPBX0@Z PROC ; CRegistrator<pureAppDeactivate>::_REG_Compare, COMDAT

; 42   : 	_REG_INFO *p1 = (_REG_INFO *)e1;
; 43   : 	_REG_INFO *p2 = (_REG_INFO *)e2;
; 44   : 	return (p2->Prio - p1->Prio);

	mov	eax, DWORD PTR _e2$[esp-4]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _e1$[esp-4]
	sub	eax, DWORD PTR [ecx+4]

; 45   : }

	ret	0
?_REG_Compare@?$CRegistrator@VpureAppDeactivate@@@@CAHPBX0@Z ENDP ; CRegistrator<pureAppDeactivate>::_REG_Compare
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_REG_Compare@?$CRegistrator@VpureAppActivate@@@@CAHPBX0@Z
_TEXT	SEGMENT
_e1$ = 8						; size = 4
_e2$ = 12						; size = 4
?_REG_Compare@?$CRegistrator@VpureAppActivate@@@@CAHPBX0@Z PROC ; CRegistrator<pureAppActivate>::_REG_Compare, COMDAT

; 42   : 	_REG_INFO *p1 = (_REG_INFO *)e1;
; 43   : 	_REG_INFO *p2 = (_REG_INFO *)e2;
; 44   : 	return (p2->Prio - p1->Prio);

	mov	eax, DWORD PTR _e2$[esp-4]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _e1$[esp-4]
	sub	eax, DWORD PTR [ecx+4]

; 45   : }

	ret	0
?_REG_Compare@?$CRegistrator@VpureAppActivate@@@@CAHPBX0@Z ENDP ; CRegistrator<pureAppActivate>::_REG_Compare
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_tools.h
_TEXT	ENDS
;	COMDAT ?to_storage_type_cref@?$_CastTraits@PAXPAVIInputReceiver@@@priv@stlp_std@@SAABQAXABQAVIInputReceiver@@@Z
_TEXT	SEGMENT
?to_storage_type_cref@?$_CastTraits@PAXPAVIInputReceiver@@@priv@stlp_std@@SAABQAXABQAVIInputReceiver@@@Z PROC ; stlp_std::priv::_CastTraits<void *,IInputReceiver *>::to_storage_type_cref, COMDAT
; ___ref$ = eax

; 224  :   { return cv_traits::uncv_cref(__REINTERPRET_CAST(void_cv_type const&, __ref)); }

	ret	0
?to_storage_type_cref@?$_CastTraits@PAXPAVIInputReceiver@@@priv@stlp_std@@SAABQAXABQAVIInputReceiver@@@Z ENDP ; stlp_std::priv::_CastTraits<void *,IInputReceiver *>::to_storage_type_cref
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?to_storage_type_ptr@?$_CastTraits@PAXPAVIInputReceiver@@@priv@stlp_std@@SAPAPAXPAPAVIInputReceiver@@@Z
_TEXT	SEGMENT
?to_storage_type_ptr@?$_CastTraits@PAXPAVIInputReceiver@@@priv@stlp_std@@SAPAPAXPAPAVIInputReceiver@@@Z PROC ; stlp_std::priv::_CastTraits<void *,IInputReceiver *>::to_storage_type_ptr, COMDAT
; ___ptr$ = eax

; 218  :   { return cv_traits::uncv_ptr(__REINTERPRET_CAST(void_cv_type *, __ptr)); }

	ret	0
?to_storage_type_ptr@?$_CastTraits@PAXPAVIInputReceiver@@@priv@stlp_std@@SAPAPAXPAPAVIInputReceiver@@@Z ENDP ; stlp_std::priv::_CastTraits<void *,IInputReceiver *>::to_storage_type_ptr
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?to_value_type_ref@?$_CastTraits@PAXPAVIInputReceiver@@@priv@stlp_std@@SAAAPAVIInputReceiver@@AAPAX@Z
_TEXT	SEGMENT
?to_value_type_ref@?$_CastTraits@PAXPAVIInputReceiver@@@priv@stlp_std@@SAAAPAVIInputReceiver@@AAPAX@Z PROC ; stlp_std::priv::_CastTraits<void *,IInputReceiver *>::to_value_type_ref, COMDAT
; ___ref$ = eax

; 213  :   { return __REINTERPRET_CAST(value_type &, cv_traits::cv_ref(__ref)); }

	ret	0
?to_value_type_ref@?$_CastTraits@PAXPAVIInputReceiver@@@priv@stlp_std@@SAAAPAVIInputReceiver@@AAPAX@Z ENDP ; stlp_std::priv::_CastTraits<void *,IInputReceiver *>::to_value_type_ref
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ??0?$xalloc@PAVIInputReceiver@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@PAVIInputReceiver@@@@QAE@XZ PROC		; xalloc<IInputReceiver *>::xalloc<IInputReceiver *>, COMDAT
; _this$ = eax

; 77   : 													xalloc			()										{	}

	ret	0
??0?$xalloc@PAVIInputReceiver@@@@QAE@XZ ENDP		; xalloc<IInputReceiver *>::xalloc<IInputReceiver *>
_TEXT	ENDS
PUBLIC	?feedback@CInput@@QAEXGGM@Z			; CInput::feedback
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\xr_input.cpp
;	COMDAT ?feedback@CInput@@QAEXGGM@Z
_TEXT	SEGMENT
_s1$ = 8						; size = 2
_s2$ = 12						; size = 2
_time$ = 16						; size = 4
?feedback@CInput@@QAEXGGM@Z PROC			; CInput::feedback, COMDAT
; _this$ = ecx

; 558  : 	stop_vibration_time = RDEVICE.fTimeGlobal + time;

	movss	xmm0, DWORD PTR ?Device@@3VCRenderDevice@@A+32
	addss	xmm0, DWORD PTR _time$[esp-4]
	movss	DWORD PTR ?stop_vibration_time@@3MA, xmm0

; 559  : #ifndef _EDITOR
; 560  : //.	set_vibration (s1, s2);
; 561  : #endif
; 562  : }

	ret	12					; 0000000cH
?feedback@CInput@@QAEXGGM@Z ENDP			; CInput::feedback
_TEXT	ENDS
PUBLIC	?get_exclusive_mode@CInput@@QAE_NXZ		; CInput::get_exclusive_mode
; Function compile flags: /Ogtpy
;	COMDAT ?get_exclusive_mode@CInput@@QAE_NXZ
_TEXT	SEGMENT
?get_exclusive_mode@CInput@@QAE_NXZ PROC		; CInput::get_exclusive_mode, COMDAT
; _this$ = ecx

; 553  : 	return g_exclusive;

	mov	al, BYTE PTR _g_exclusive

; 554  : }

	ret	0
?get_exclusive_mode@CInput@@QAE_NXZ ENDP		; CInput::get_exclusive_mode
_TEXT	ENDS
PUBLIC	?acquire@CInput@@QAEXAB_N@Z			; CInput::acquire
; Function compile flags: /Ogtpy
;	COMDAT ?acquire@CInput@@QAEXAB_N@Z
_TEXT	SEGMENT
_exclusive$ = 8						; size = 4
?acquire@CInput@@QAEXAB_N@Z PROC			; CInput::acquire, COMDAT
; _this$ = ecx

; 525  : {

	push	esi
	push	edi

; 526  : 	pKeyboard->SetCooperativeLevel	(
; 527  : #ifdef INGAME_EDITOR
; 528  : 		Device.editor() ? Device.editor()->main_handle() : 
; 529  : #endif // #ifdef INGAME_EDITOR
; 530  : 		RDEVICE.m_hWnd,
; 531  : 		(exclusive ? DISCL_EXCLUSIVE : DISCL_NONEXCLUSIVE) | DISCL_FOREGROUND
; 532  : 	);

	mov	edi, DWORD PTR _exclusive$[esp+4]
	movzx	edx, BYTE PTR [edi]
	neg	dl
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [eax]
	sbb	edx, edx
	add	edx, 2
	or	edx, 4
	push	edx
	mov	edx, DWORD PTR ?Device@@3VCRenderDevice@@A+760
	push	edx
	push	eax
	mov	eax, DWORD PTR [ecx+52]
	call	eax

; 533  : 	pKeyboard->Acquire				();

	mov	eax, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+28]
	push	eax
	call	edx

; 534  : 
; 535  : 	pMouse->SetCooperativeLevel		(
; 536  : #ifdef INGAME_EDITOR
; 537  : 		Device.editor() ? Device.editor()->main_handle() :
; 538  : #endif // #ifdef INGAME_EDITOR
; 539  : 		RDEVICE.m_hWnd,
; 540  : 		(exclusive ? DISCL_EXCLUSIVE : DISCL_NONEXCLUSIVE) | DISCL_FOREGROUND | DISCL_NOWINKEY
; 541  : 	);

	movzx	edx, BYTE PTR [edi]
	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	neg	dl
	sbb	edx, edx
	add	edx, 2
	or	edx, 20					; 00000014H
	push	edx
	mov	edx, DWORD PTR ?Device@@3VCRenderDevice@@A+760
	push	edx
	push	eax
	mov	eax, DWORD PTR [ecx+52]
	call	eax

; 542  : 	pMouse->Acquire					();

	mov	esi, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+28]
	push	esi
	call	edx
	pop	edi
	pop	esi

; 543  : }

	ret	4
?acquire@CInput@@QAEXAB_N@Z ENDP			; CInput::acquire
_TEXT	ENDS
PUBLIC	?unacquire@CInput@@QAEXXZ			; CInput::unacquire
; Function compile flags: /Ogtpy
;	COMDAT ?unacquire@CInput@@QAEXXZ
_TEXT	SEGMENT
?unacquire@CInput@@QAEXXZ PROC				; CInput::unacquire, COMDAT
; _this$ = ecx

; 519  : {

	push	esi
	mov	esi, ecx

; 520  : 	pKeyboard->Unacquire			();

	mov	eax, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+32]
	push	eax
	call	edx

; 521  : 	pMouse->Unacquire				();

	mov	esi, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+32]
	push	esi
	call	ecx
	pop	esi

; 522  : }

	ret	0
?unacquire@CInput@@QAEXXZ ENDP				; CInput::unacquire
_TEXT	ENDS
PUBLIC	?iGetAsyncBtnState@CInput@@QAEHH@Z		; CInput::iGetAsyncBtnState
; Function compile flags: /Ogtpy
;	COMDAT ?iGetAsyncBtnState@CInput@@QAEHH@Z
_TEXT	SEGMENT
_btn$ = 8						; size = 4
?iGetAsyncBtnState@CInput@@QAEHH@Z PROC			; CInput::iGetAsyncBtnState, COMDAT
; _this$ = ecx

; 328  : 	return !!mouseState[btn];

	mov	edx, DWORD PTR _btn$[esp-4]
	xor	eax, eax
	cmp	DWORD PTR [ecx+edx*4+60], eax
	setne	al

; 329  : }

	ret	4
?iGetAsyncBtnState@CInput@@QAEHH@Z ENDP			; CInput::iGetAsyncBtnState
_TEXT	ENDS
PUBLIC	?iGetAsyncKeyState@CInput@@QAEHH@Z		; CInput::iGetAsyncKeyState
; Function compile flags: /Ogtpy
;	COMDAT ?iGetAsyncKeyState@CInput@@QAEHH@Z
_TEXT	SEGMENT
_dik$ = 8						; size = 4
?iGetAsyncKeyState@CInput@@QAEHH@Z PROC			; CInput::iGetAsyncKeyState, COMDAT
; _this$ = ecx

; 323  : 	return !!KBState[dik];

	mov	edx, DWORD PTR _dik$[esp-4]
	xor	eax, eax
	cmp	DWORD PTR [ecx+edx*4+72], eax
	setne	al

; 324  : }

	ret	4
?iGetAsyncKeyState@CInput@@QAEHH@Z ENDP			; CInput::iGetAsyncKeyState
_TEXT	ENDS
PUBLIC	?get_dik_name@CInput@@QAE_NHPADH@Z		; CInput::get_dik_name
; Function compile flags: /Ogtpy
;	COMDAT ?get_dik_name@CInput@@QAE_NHPADH@Z
_TEXT	SEGMENT
tv76 = -540						; size = 4
_keyname$ = -536					; size = 536
_dik$ = 8						; size = 4
_dest_str$ = 12						; size = 4
_dest_sz$ = 16						; size = 4
?get_dik_name@CInput@@QAE_NHPADH@Z PROC			; CInput::get_dik_name, COMDAT
; _this$ = ecx

; 298  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 540				; 0000021cH

; 299  : 	DIPROPSTRING keyname;
; 300  : 	keyname.diph.dwSize			= sizeof(DIPROPSTRING);
; 301  : 	keyname.diph.dwHeaderSize	= sizeof(DIPROPHEADER);
; 302  : 	keyname.diph.dwObj			= static_cast<DWORD>(dik);
; 303  : 	keyname.diph.dwHow			= DIPH_BYOFFSET;
; 304  : 	HRESULT hr = pKeyboard->GetProperty(DIPROP_KEYNAME, &keyname.diph);

	mov	eax, DWORD PTR [ecx+20]
	push	esi
	mov	esi, DWORD PTR _dik$[ebp]
	lea	edx, DWORD PTR _keyname$[esp+544]
	push	edx
	mov	DWORD PTR _keyname$[esp+548], 536	; 00000218H
	mov	DWORD PTR _keyname$[esp+552], 16	; 00000010H
	mov	DWORD PTR _keyname$[esp+556], esi
	mov	DWORD PTR _keyname$[esp+560], 1
	mov	ecx, DWORD PTR [eax]
	push	20					; 00000014H
	push	eax
	mov	eax, DWORD PTR [ecx+20]
	call	eax

; 305  : 	if(FAILED(hr))

	test	eax, eax

; 306  : 		return false;

	jl	SHORT $LN7@get_dik_na

; 307  : 
; 308  : 	const wchar_t* wct			= keyname.wsz;
; 309  : 	if(0==wcslen(wct))

	lea	eax, DWORD PTR _keyname$[esp+560]
	lea	edx, DWORD PTR [eax+2]
	npad	7
$LL6@get_dik_na:
	mov	cx, WORD PTR [eax]
	add	eax, 2
	test	cx, cx
	jne	SHORT $LL6@get_dik_na
	sub	eax, edx
	sar	eax, 1

; 310  : 		return					false;

	je	SHORT $LN7@get_dik_na

; 311  : 	
; 312  : 	int cnt						= WideCharToMultiByte(CP_ACP,0,keyname.wsz,-1,dest_str,dest_sz,NULL,NULL);

	mov	ecx, DWORD PTR _dest_sz$[ebp]
	mov	edx, DWORD PTR _dest_str$[ebp]
	push	0
	push	0
	push	ecx
	push	edx
	push	-1
	lea	eax, DWORD PTR _keyname$[esp+580]
	push	eax
	push	0
	push	0
	call	DWORD PTR __imp__WideCharToMultiByte@32

; 313  : 	if(cnt==-1)

	cmp	eax, -1
	jne	SHORT $LN1@get_dik_na

; 314  : 	{
; 315  : 		Msg("! cant convert dik_name for dik[%d], prop=[%S]", dik, keyname.wsz);

	lea	ecx, DWORD PTR _keyname$[esp+560]
	push	ecx
	push	esi
	push	OFFSET ??_C@_0CP@PIIDBILA@?$CB?5cant?5convert?5dik_name?5for?5dik?$FL@
	call	DWORD PTR __imp_?Msg@@YAXPBDZZ
	add	esp, 12					; 0000000cH
$LN7@get_dik_na:

; 316  : 		return					false;

	xor	al, al

; 319  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN1@get_dik_na:

; 317  : 	}
; 318  : 	return						(cnt!=-1);

	mov	al, 1

; 319  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?get_dik_name@CInput@@QAE_NHPADH@Z ENDP			; CInput::get_dik_name
_TEXT	ENDS
PUBLIC	?SetKBDAcquire@CInput@@QAEXH@Z			; CInput::SetKBDAcquire
; Function compile flags: /Ogtpy
;	COMDAT ?SetKBDAcquire@CInput@@QAEXH@Z
_TEXT	SEGMENT
_bAcquire$ = 8						; size = 4
?SetKBDAcquire@CInput@@QAEXH@Z PROC			; CInput::SetKBDAcquire, COMDAT
; _this$ = ecx

; 172  : 	if (pKeyboard)	bAcquire ? pKeyboard->Acquire()	: pKeyboard->Unacquire();

	cmp	DWORD PTR [ecx+20], 0
	je	SHORT $LN5@SetKBDAcqu
	mov	ecx, DWORD PTR [ecx+20]
	cmp	DWORD PTR _bAcquire$[esp-4], 0
	mov	DWORD PTR _bAcquire$[esp-4], ecx
	je	SHORT $LN4@SetKBDAcqu
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+28]
	jmp	ecx
$LN4@SetKBDAcqu:
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+32]
	jmp	eax
$LN5@SetKBDAcqu:

; 173  : }

	ret	4
?SetKBDAcquire@CInput@@QAEXH@Z ENDP			; CInput::SetKBDAcquire
_TEXT	ENDS
PUBLIC	?SetMouseAcquire@CInput@@QAEXH@Z		; CInput::SetMouseAcquire
; Function compile flags: /Ogtpy
;	COMDAT ?SetMouseAcquire@CInput@@QAEXH@Z
_TEXT	SEGMENT
_bAcquire$ = 8						; size = 4
?SetMouseAcquire@CInput@@QAEXH@Z PROC			; CInput::SetMouseAcquire, COMDAT
; _this$ = ecx

; 168  : 	if (pMouse)		bAcquire ? pMouse->Acquire() : pMouse->Unacquire();

	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $LN5@SetMouseAc
	mov	ecx, DWORD PTR [ecx+16]
	cmp	DWORD PTR _bAcquire$[esp-4], 0
	mov	DWORD PTR _bAcquire$[esp-4], ecx
	je	SHORT $LN4@SetMouseAc
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+28]
	jmp	ecx
$LN4@SetMouseAc:
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+32]
	jmp	eax
$LN5@SetMouseAc:

; 169  : }

	ret	4
?SetMouseAcquire@CInput@@QAEXH@Z ENDP			; CInput::SetMouseAcquire
_TEXT	ENDS
PUBLIC	?SetAllAcquire@CInput@@QAEXH@Z			; CInput::SetAllAcquire
; Function compile flags: /Ogtpy
;	COMDAT ?SetAllAcquire@CInput@@QAEXH@Z
_TEXT	SEGMENT
_bAcquire$ = 8						; size = 4
?SetAllAcquire@CInput@@QAEXH@Z PROC			; CInput::SetAllAcquire, COMDAT
; _this$ = ecx

; 161  : {

	push	esi
	mov	esi, ecx

; 162  : 	if (pMouse)		bAcquire ? pMouse->Acquire() 	: pMouse->Unacquire();

	cmp	DWORD PTR [esi+16], 0
	push	edi
	mov	edi, DWORD PTR _bAcquire$[esp+4]
	je	SHORT $LN6@SetAllAcqu
	test	edi, edi
	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	push	eax
	je	SHORT $LN5@SetAllAcqu
	mov	edx, DWORD PTR [ecx+28]
	jmp	SHORT $LN9@SetAllAcqu
$LN5@SetAllAcqu:
	mov	edx, DWORD PTR [ecx+32]
$LN9@SetAllAcqu:
	call	edx
$LN6@SetAllAcqu:

; 163  : 	if (pKeyboard)	bAcquire ? pKeyboard->Acquire()	: pKeyboard->Unacquire();

	cmp	DWORD PTR [esi+20], 0
	je	SHORT $LN8@SetAllAcqu
	test	edi, edi
	mov	esi, DWORD PTR [esi+20]
	push	esi
	je	SHORT $LN7@SetAllAcqu
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+28]
	call	ecx
	pop	edi
	pop	esi

; 164  : }

	ret	4
$LN7@SetAllAcqu:

; 163  : 	if (pKeyboard)	bAcquire ? pKeyboard->Acquire()	: pKeyboard->Unacquire();

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+32]
	call	eax
$LN8@SetAllAcqu:
	pop	edi
	pop	esi

; 164  : }

	ret	4
?SetAllAcquire@CInput@@QAEXH@Z ENDP			; CInput::SetAllAcquire
_TEXT	ENDS
PUBLIC	?CreateInputDevice@CInput@@AAEJPAPAUIDirectInputDevice8A@@U_GUID@@PBU_DIDATAFORMAT@@II@Z ; CInput::CreateInputDevice
; Function compile flags: /Ogtpy
;	COMDAT ?CreateInputDevice@CInput@@AAEJPAPAUIDirectInputDevice8A@@U_GUID@@PBU_DIDATAFORMAT@@II@Z
_TEXT	SEGMENT
_dipdw$ = -20						; size = 20
_device$ = 8						; size = 4
_guidDevice$ = 12					; size = 16
_pdidDataFormat$ = 28					; size = 4
_dwFlags$ = 32						; size = 4
_buf_size$ = 36						; size = 4
?CreateInputDevice@CInput@@AAEJPAPAUIDirectInputDevice8A@@U_GUID@@PBU_DIDATAFORMAT@@II@Z PROC ; CInput::CreateInputDevice, COMDAT
; _this$ = ecx

; 125  : 	// Obtain an interface to the input device
; 126  : //.	CHK_DX( pDI->CreateDeviceEx( guidDevice, IID_IDirectInputDevice8, (void**)device, NULL ) );
; 127  : 	CHK_DX( pDI->CreateDevice( guidDevice, /*IID_IDirectInputDevice8,*/ device, NULL ) );

	mov	eax, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [eax]
	sub	esp, 20					; 00000014H
	push	esi
	mov	esi, DWORD PTR _device$[esp+20]
	push	0
	push	esi
	lea	edx, DWORD PTR _guidDevice$[esp+28]
	push	edx
	push	eax
	mov	eax, DWORD PTR [ecx+12]
	call	eax

; 128  : 
; 129  : 	// Set the device data format. Note: a data format specifies which
; 130  : 	// controls on a device we are interested in, and how they should be
; 131  : 	// reported.
; 132  : 	CHK_DX((*device)->SetDataFormat( pdidDataFormat ) );

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR _pdidDataFormat$[esp+20]
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	mov	eax, DWORD PTR [ecx+44]
	call	eax

; 133  : 
; 134  : 	// Set the cooperativity level to let DirectInput know how this device
; 135  : 	// should interact with the system and with other DirectInput applications.
; 136  : #ifdef INGAME_EDITOR
; 137  : 	if (!Device.editor())
; 138  : #endif // #ifdef INGAME_EDITOR
; 139  : 	{
; 140  : 		HRESULT	_hr = (*device)->SetCooperativeLevel( RDEVICE.m_hWnd, dwFlags );

	mov	edx, DWORD PTR _dwFlags$[esp+20]
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax]
	push	edx
	mov	edx, DWORD PTR ?Device@@3VCRenderDevice@@A+760
	push	edx
	push	eax
	mov	eax, DWORD PTR [ecx+52]
	call	eax

; 141  : 		if (FAILED(_hr) && (_hr==E_NOTIMPL)) Msg("! INPUT: Can't set coop level. Emulation???");

	test	eax, eax
	jge	SHORT $LN4@CreateInpu
	cmp	eax, -2147467263			; 80004001H
	jne	SHORT $LN4@CreateInpu
	push	OFFSET ??_C@_0CM@BFPMLCCJ@?$CB?5INPUT?3?5Can?8t?5set?5coop?5level?4?5E@
	call	DWORD PTR __imp_?Msg@@YAXPBDZZ
	add	esp, 4
	jmp	SHORT $LN2@CreateInpu
$LN4@CreateInpu:

; 142  : 		else R_CHK(_hr);

	cmp	BYTE PTR ?ignore_always@?7??CreateInputDevice@CInput@@AAEJPAPAUIDirectInputDevice8A@@U_GUID@@PBU_DIDATAFORMAT@@II@Z@4_NA, 0
	jne	SHORT $LN2@CreateInpu
	test	eax, eax
	jge	SHORT $LN2@CreateInpu
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?7??CreateInputDevice@CInput@@AAEJPAPAUIDirectInputDevice8A@@U_GUID@@PBU_DIDATAFORMAT@@II@Z@4_NA
	push	OFFSET ??_C@_0BK@GOKHJJOE@CInput?3?3CreateInputDevice?$AA@
	push	142					; 0000008eH
	push	OFFSET ??_C@_0DB@FGAJOMBI@D?3?2CLEARSKY?2sources?2engine?2xrEng@
	push	OFFSET ??_C@_03BGBILOPL@_hr?$AA@
	push	eax
	call	DWORD PTR __imp_?error@xrDebug@@QAEXJPBD0H0AA_N@Z
$LN2@CreateInpu:

; 143  : 	}
; 144  : 
; 145  : 	// setup the buffer size for the keyboard data
; 146  : 	DIPROPDWORD				dipdw;
; 147  : 	dipdw.diph.dwSize		= sizeof(DIPROPDWORD);
; 148  : 	dipdw.diph.dwHeaderSize = sizeof(DIPROPHEADER);
; 149  : 	dipdw.diph.dwObj		= 0;
; 150  : 	dipdw.diph.dwHow		= DIPH_DEVICE;
; 151  : 	dipdw.dwData			= buf_size;

	mov	ecx, DWORD PTR _buf_size$[esp+20]

; 152  : 
; 153  : 	CHK_DX( (*device)->SetProperty( DIPROP_BUFFERSIZE, &dipdw.diph ) );

	mov	esi, DWORD PTR [esi]
	lea	eax, DWORD PTR _dipdw$[esp+24]
	push	eax
	mov	DWORD PTR _dipdw$[esp+44], ecx
	mov	DWORD PTR _dipdw$[esp+28], 20		; 00000014H
	mov	DWORD PTR _dipdw$[esp+32], 16		; 00000010H
	mov	DWORD PTR _dipdw$[esp+36], 0
	mov	DWORD PTR _dipdw$[esp+40], 0
	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [edx+24]
	push	1
	push	esi
	call	ecx

; 154  : 
; 155  : 	return S_OK;

	xor	eax, eax
	pop	esi

; 156  : }

	add	esp, 20					; 00000014H
	ret	32					; 00000020H
?CreateInputDevice@CInput@@AAEJPAPAUIDirectInputDevice8A@@U_GUID@@PBU_DIDATAFORMAT@@II@Z ENDP ; CInput::CreateInputDevice
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?on_error_dialog@@YAX_N@Z
_TEXT	SEGMENT
$T220688 = -1						; size = 1
_before$ = 8						; size = 1
?on_error_dialog@@YAX_N@Z PROC				; on_error_dialog, COMDAT

; 26   : {

	push	ecx

; 27   : #ifdef INGAME_EDITOR
; 28   : 	if (Device.editor())
; 29   : 		return;
; 30   : #endif // #ifdef INGAME_EDITOR
; 31   : 	if (!pInput || !g_exclusive)

	mov	ecx, DWORD PTR ?pInput@@3PAVCInput@@A	; pInput
	test	ecx, ecx
	je	SHORT $LN2@on_error_d
	cmp	BYTE PTR _g_exclusive, 0
	je	SHORT $LN2@on_error_d

; 32   : 		return;
; 33   : 
; 34   : 	if (before) {

	cmp	BYTE PTR _before$[esp], 0
	je	SHORT $LN1@on_error_d

; 35   : 		pInput->unacquire	();

	mov	eax, DWORD PTR [ecx+20]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+32]
	push	eax
	call	edx
	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+32]
	push	eax
	call	edx
	pop	esi

; 40   : }

	pop	ecx
	ret	0
$LN1@on_error_d:

; 36   : 		return;
; 37   : 	}
; 38   : 
; 39   : 	pInput->acquire			(true);

	lea	eax, DWORD PTR $T220688[esp+4]
	push	eax
	mov	BYTE PTR $T220688[esp+8], 1
	call	?acquire@CInput@@QAEXAB_N@Z		; CInput::acquire
$LN2@on_error_d:

; 40   : }

	pop	ecx
	ret	0
?on_error_dialog@@YAX_N@Z ENDP				; on_error_dialog
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_algobase.h
;	COMDAT ??$__copy_ptrs@PAPAXPAPAX@priv@stlp_std@@YAPAPAXPAPAX00ABU__true_type@1@@Z
_TEXT	SEGMENT
??$__copy_ptrs@PAPAXPAPAX@priv@stlp_std@@YAPAPAXPAPAX00ABU__true_type@1@@Z PROC ; stlp_std::priv::__copy_ptrs<void * *,void * *>, COMDAT
; ___first$ = edx
; ___last$ = ecx
; ___result$ = eax

; 255  :   // we know they all pointers, so this cast is OK
; 256  :   //  return (_OutputIter)__copy_trivial(&(*__first), &(*__last), &(*__result));
; 257  :   return (_OutputIter)__copy_trivial(__first, __last, __result);

	sub	ecx, edx
	push	esi
	mov	esi, ecx
	je	SHORT $LN6@copy_ptrs@30
	push	esi
	push	edx
	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	add	eax, esi
$LN6@copy_ptrs@30:
	pop	esi

; 258  : }

	ret	0
??$__copy_ptrs@PAPAXPAPAX@priv@stlp_std@@YAPAPAXPAPAX00ABU__true_type@1@@Z ENDP ; stlp_std::priv::__copy_ptrs<void * *,void * *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ?_M_erase@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@AAEPAPAXPAPAXABU__false_type@3@@Z
_TEXT	SEGMENT
?_M_erase@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@AAEPAPAXPAPAXABU__false_type@3@@Z PROC ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::_M_erase, COMDAT
; _this$ = eax
; ___pos$ = edi

; 548  :   iterator _M_erase(iterator __pos, const __false_type& /*_Movable*/) {

	push	esi
	mov	esi, eax

; 549  :     if (__pos + 1 != end())

	mov	eax, DWORD PTR [esi+4]
	lea	ecx, DWORD PTR [edi+4]
	cmp	ecx, eax
	je	SHORT $LN10@M_erase@20

; 550  :       _STLP_PRIV __copy_ptrs(__pos + 1, this->_M_finish, __pos, _TrivialCopy());

	sub	eax, ecx
	je	SHORT $LN10@M_erase@20
	push	eax
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
$LN10@M_erase@20:

; 551  :     --this->_M_finish;

	add	DWORD PTR [esi+4], -4			; fffffffcH
	mov	esi, DWORD PTR [esi+4]

; 552  :     _STLP_STD::_Destroy(this->_M_finish);

	push	esi
	call	??$_Destroy@PAX@stlp_std@@YAXPAPAX@Z	; stlp_std::_Destroy<void *>
	add	esp, 4

; 553  :     return __pos;

	mov	eax, edi
	pop	esi

; 554  :   }

	ret	0
?_M_erase@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@AAEPAPAXPAPAXABU__false_type@3@@Z ENDP ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::_M_erase
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_tools.h
_TEXT	ENDS
;	COMDAT ?to_value_type_ptr@?$_CastTraits@PAXPAVIInputReceiver@@@priv@stlp_std@@SAPAPAVIInputReceiver@@PAPAX@Z
_TEXT	SEGMENT
?to_value_type_ptr@?$_CastTraits@PAXPAVIInputReceiver@@@priv@stlp_std@@SAPAPAVIInputReceiver@@PAPAX@Z PROC ; stlp_std::priv::_CastTraits<void *,IInputReceiver *>::to_value_type_ptr, COMDAT
; ___ptr$ = eax

; 207  :   { return __REINTERPRET_CAST(value_type *, cv_traits::cv_ptr(__ptr)); }

	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 4
	ret	0
?to_value_type_ptr@?$_CastTraits@PAXPAVIInputReceiver@@@priv@stlp_std@@SAPAPAVIInputReceiver@@PAPAX@Z ENDP ; stlp_std::priv::_CastTraits<void *,IInputReceiver *>::to_value_type_ptr
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVIInputReceiver@@V?$xalloc@PAVIInputReceiver@@@@@stlp_std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVIInputReceiver@@V?$xalloc@PAVIInputReceiver@@@@@stlp_std@@QBEIXZ PROC ; stlp_std::vector<IInputReceiver *,xalloc<IInputReceiver *> >::size, COMDAT
; _this$ = ecx

; 89   :   size_type size() const        { return _M_impl.size(); }

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	ret	0
?size@?$vector@PAVIInputReceiver@@V?$xalloc@PAVIInputReceiver@@@@@stlp_std@@QBEIXZ ENDP ; stlp_std::vector<IInputReceiver *,xalloc<IInputReceiver *> >::size
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ?erase@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEPAPAXPAPAX@Z
_TEXT	SEGMENT
?erase@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEPAPAXPAPAX@Z PROC ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::erase, COMDAT
; _this$ = eax
; ___pos$ = edi

; 586  :   iterator erase(iterator __pos) {

	push	esi
	mov	esi, eax

; 587  :     return _M_erase(__pos, _Movable());

	mov	eax, DWORD PTR [esi+4]
	lea	ecx, DWORD PTR [edi+4]
	cmp	ecx, eax
	je	SHORT $LN12@erase@25
	sub	eax, ecx
	je	SHORT $LN12@erase@25
	push	eax
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
$LN12@erase@25:
	add	DWORD PTR [esi+4], -4			; fffffffcH
	mov	esi, DWORD PTR [esi+4]
	push	esi
	call	??$_Destroy@PAX@stlp_std@@YAXPAPAX@Z	; stlp_std::_Destroy<void *>
	add	esp, 4
	mov	eax, edi
	pop	esi

; 588  :   }

	ret	0
?erase@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEPAPAXPAPAX@Z ENDP ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?pop_back@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEXXZ PROC ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::pop_back, COMDAT
; _this$ = eax

; 532  :     --this->_M_finish;

	add	DWORD PTR [eax+4], -4			; fffffffcH
	mov	eax, DWORD PTR [eax+4]

; 533  :     _STLP_STD::_Destroy(this->_M_finish);

	push	eax
	call	??$_Destroy@PAX@stlp_std@@YAXPAPAX@Z	; stlp_std::_Destroy<void *>
	pop	ecx

; 534  :   }

	ret	0
?pop_back@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEXXZ ENDP ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::pop_back
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?back@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEAAPAXXZ
_TEXT	SEGMENT
?back@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEAAPAXXZ PROC ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::back, COMDAT
; _this$ = eax

; 195  :   reference back()              { return *(end() - 1); }

	mov	eax, DWORD PTR [eax+4]
	sub	eax, 4
	ret	0
?back@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEAAPAXXZ ENDP ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::back
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ?erase@?$vector@PAVIInputReceiver@@V?$xalloc@PAVIInputReceiver@@@@@stlp_std@@QAEPAPAVIInputReceiver@@PAPAV3@@Z
_TEXT	SEGMENT
?erase@?$vector@PAVIInputReceiver@@V?$xalloc@PAVIInputReceiver@@@@@stlp_std@@QAEPAPAVIInputReceiver@@PAPAV3@@Z PROC ; stlp_std::vector<IInputReceiver *,xalloc<IInputReceiver *> >::erase, COMDAT
; _this$ = eax
; ___pos$ = edi

; 206  :   {return cast_traits::to_value_type_ptr(_M_impl.erase(cast_traits::to_storage_type_ptr(__pos)));}

	push	esi
	mov	esi, eax
	mov	eax, DWORD PTR [esi+4]
	lea	ecx, DWORD PTR [edi+4]
	cmp	ecx, eax
	je	SHORT $LN18@erase@26
	sub	eax, ecx
	je	SHORT $LN18@erase@26
	push	eax
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
$LN18@erase@26:
	add	DWORD PTR [esi+4], -4			; fffffffcH
	mov	esi, DWORD PTR [esi+4]
	push	esi
	call	??$_Destroy@PAX@stlp_std@@YAXPAPAX@Z	; stlp_std::_Destroy<void *>
	push	edi
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 8
	pop	esi
	ret	0
?erase@?$vector@PAVIInputReceiver@@V?$xalloc@PAVIInputReceiver@@@@@stlp_std@@QAEPAPAVIInputReceiver@@PAPAV3@@Z ENDP ; stlp_std::vector<IInputReceiver *,xalloc<IInputReceiver *> >::erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?pop_back@?$vector@PAVIInputReceiver@@V?$xalloc@PAVIInputReceiver@@@@@stlp_std@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$vector@PAVIInputReceiver@@V?$xalloc@PAVIInputReceiver@@@@@stlp_std@@QAEXXZ PROC ; stlp_std::vector<IInputReceiver *,xalloc<IInputReceiver *> >::pop_back, COMDAT
; _this$ = eax

; 204  :   void pop_back() {_M_impl.pop_back();}

	add	DWORD PTR [eax+4], -4			; fffffffcH
	mov	eax, DWORD PTR [eax+4]
	push	eax
	call	??$_Destroy@PAX@stlp_std@@YAXPAPAX@Z	; stlp_std::_Destroy<void *>
	pop	ecx
	ret	0
?pop_back@?$vector@PAVIInputReceiver@@V?$xalloc@PAVIInputReceiver@@@@@stlp_std@@QAEXXZ ENDP ; stlp_std::vector<IInputReceiver *,xalloc<IInputReceiver *> >::pop_back
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?back@?$vector@PAVIInputReceiver@@V?$xalloc@PAVIInputReceiver@@@@@stlp_std@@QAEAAPAVIInputReceiver@@XZ
_TEXT	SEGMENT
?back@?$vector@PAVIInputReceiver@@V?$xalloc@PAVIInputReceiver@@@@@stlp_std@@QAEAAPAVIInputReceiver@@XZ PROC ; stlp_std::vector<IInputReceiver *,xalloc<IInputReceiver *> >::back, COMDAT
; _this$ = eax

; 100  :   reference back()              { return cast_traits::to_value_type_ref(_M_impl.back()); }

	mov	eax, DWORD PTR [eax+4]
	sub	eax, 4
	ret	0
?back@?$vector@PAVIInputReceiver@@V?$xalloc@PAVIInputReceiver@@@@@stlp_std@@QAEAAPAVIInputReceiver@@XZ ENDP ; stlp_std::vector<IInputReceiver *,xalloc<IInputReceiver *> >::back
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?empty@?$vector@PAVIInputReceiver@@V?$xalloc@PAVIInputReceiver@@@@@stlp_std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@PAVIInputReceiver@@V?$xalloc@PAVIInputReceiver@@@@@stlp_std@@QBE_NXZ PROC ; stlp_std::vector<IInputReceiver *,xalloc<IInputReceiver *> >::empty, COMDAT
; _this$ = ecx

; 93   :   bool empty() const            { return _M_impl.empty(); }

	jmp	?empty@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QBE_NXZ ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::empty
?empty@?$vector@PAVIInputReceiver@@V?$xalloc@PAVIInputReceiver@@@@@stlp_std@@QBE_NXZ ENDP ; stlp_std::vector<IInputReceiver *,xalloc<IInputReceiver *> >::empty
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@PAVIInputReceiver@@V?$xalloc@PAVIInputReceiver@@@@@stlp_std@@QAEPAPAVIInputReceiver@@XZ
_TEXT	SEGMENT
?begin@?$vector@PAVIInputReceiver@@V?$xalloc@PAVIInputReceiver@@@@@stlp_std@@QAEPAPAVIInputReceiver@@XZ PROC ; stlp_std::vector<IInputReceiver *,xalloc<IInputReceiver *> >::begin, COMDAT
; _this$ = eax

; 79   :   iterator begin()             { return cast_traits::to_value_type_ptr(_M_impl.begin()); }

	mov	eax, DWORD PTR [eax]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 4
	ret	0
?begin@?$vector@PAVIInputReceiver@@V?$xalloc@PAVIInputReceiver@@@@@stlp_std@@QAEPAPAVIInputReceiver@@XZ ENDP ; stlp_std::vector<IInputReceiver *,xalloc<IInputReceiver *> >::begin
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ??A?$xr_vector@PAVIInputReceiver@@V?$xalloc@PAVIInputReceiver@@@@@@QAEAAPAVIInputReceiver@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$xr_vector@PAVIInputReceiver@@V?$xalloc@PAVIInputReceiver@@@@@@QAEAAPAVIInputReceiver@@I@Z PROC ; xr_vector<IInputReceiver *,xalloc<IInputReceiver *> >::operator[], COMDAT
; _this$ = eax

; 139  : 	reference operator[]		(size_type _Pos)					{ {VERIFY2(_Pos<size(),make_string("index is out of range: index requested[%d], size of container[%d]", _Pos, size()).c_str());} return (*(begin() + _Pos)); }

	mov	eax, DWORD PTR [eax]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	mov	ecx, DWORD PTR __Pos$[esp]
	add	esp, 4
	lea	eax, DWORD PTR [eax+ecx*4]
	ret	4
??A?$xr_vector@PAVIInputReceiver@@V?$xalloc@PAVIInputReceiver@@@@@@QAEAAPAVIInputReceiver@@I@Z ENDP ; xr_vector<IInputReceiver *,xalloc<IInputReceiver *> >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$xr_vector@PAVIInputReceiver@@V?$xalloc@PAVIInputReceiver@@@@@@QBEIXZ
_TEXT	SEGMENT
?size@?$xr_vector@PAVIInputReceiver@@V?$xalloc@PAVIInputReceiver@@@@@@QBEIXZ PROC ; xr_vector<IInputReceiver *,xalloc<IInputReceiver *> >::size, COMDAT
; _this$ = ecx

; 126  : 	u32		size				() const							{ return (u32)inherited::size();} 

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	ret	0
?size@?$xr_vector@PAVIInputReceiver@@V?$xalloc@PAVIInputReceiver@@@@@@QBEIXZ ENDP ; xr_vector<IInputReceiver *,xalloc<IInputReceiver *> >::size
_TEXT	ENDS
PUBLIC	?exclusive_mode@CInput@@QAEXAB_N@Z		; CInput::exclusive_mode
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\xr_input.cpp
;	COMDAT ?exclusive_mode@CInput@@QAEXAB_N@Z
_TEXT	SEGMENT
_exclusive$ = 8						; size = 4
?exclusive_mode@CInput@@QAEXAB_N@Z PROC			; CInput::exclusive_mode, COMDAT
; _this$ = ecx

; 546  : {

	push	esi
	push	edi

; 547  : 	g_exclusive						= exclusive;

	mov	edi, DWORD PTR _exclusive$[esp+4]
	mov	al, BYTE PTR [edi]
	mov	esi, ecx
	mov	BYTE PTR _g_exclusive, al

; 548  : 	unacquire						();

	mov	eax, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+32]
	push	eax
	call	edx
	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+32]
	push	eax
	call	edx

; 549  : 	acquire							(exclusive);

	push	edi
	mov	ecx, esi
	call	?acquire@CInput@@QAEXAB_N@Z		; CInput::acquire
	pop	edi
	pop	esi

; 550  : }

	ret	4
?exclusive_mode@CInput@@QAEXAB_N@Z ENDP			; CInput::exclusive_mode
_TEXT	ENDS
PUBLIC	?CurrentIR@CInput@@QAEPAVIInputReceiver@@XZ	; CInput::CurrentIR
; Function compile flags: /Ogtpy
;	COMDAT ?CurrentIR@CInput@@QAEPAVIInputReceiver@@XZ
_TEXT	SEGMENT
?CurrentIR@CInput@@QAEPAVIInputReceiver@@XZ PROC	; CInput::CurrentIR, COMDAT
; _this$ = ecx

; 512  : 	if(cbStack.size())

	mov	eax, DWORD PTR [ecx+1100]
	sub	eax, DWORD PTR [ecx+1096]
	test	eax, -4					; fffffffcH
	je	SHORT $LN2@CurrentIR

; 513  : 		return cbStack.back();

	mov	ecx, DWORD PTR [ecx+1100]
	mov	eax, DWORD PTR [ecx-4]

; 516  : }

	ret	0
$LN2@CurrentIR:

; 514  : 	else
; 515  : 		return NULL;

	xor	eax, eax

; 516  : }

	ret	0
?CurrentIR@CInput@@QAEPAVIInputReceiver@@XZ ENDP	; CInput::CurrentIR
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?OnAppDeactivate@CInput@@UAEXXZ
_TEXT	SEGMENT
?OnAppDeactivate@CInput@@UAEXXZ PROC			; CInput::OnAppDeactivate, COMDAT
; _this$ = ecx

; 489  : {

	push	esi
	mov	esi, ecx

; 490  : 	if (CurrentIR())

	mov	eax, DWORD PTR [esi+1092]
	sub	eax, DWORD PTR [esi+1088]
	test	eax, -4					; fffffffcH
	je	SHORT $LN1@OnAppDeact
	mov	ecx, DWORD PTR [esi+1092]
	cmp	DWORD PTR [ecx-4], 0
	je	SHORT $LN1@OnAppDeact

; 491  : 		CurrentIR()->IR_OnDeactivate();

	mov	edx, ecx
	sub	edx, DWORD PTR [esi+1088]
	test	edx, -4					; fffffffcH
	je	SHORT $LN25@OnAppDeact
	mov	eax, ecx
	mov	ecx, DWORD PTR [eax-4]
	jmp	SHORT $LN24@OnAppDeact
$LN25@OnAppDeact:
	xor	ecx, ecx
$LN24@OnAppDeact:
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	call	eax
$LN1@OnAppDeact:

; 492  : 
; 493  : 	SetAllAcquire	( false );

	cmp	DWORD PTR [esi+8], 0
	je	SHORT $LN49@OnAppDeact
	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+32]
	push	eax
	call	edx
$LN49@OnAppDeact:
	cmp	DWORD PTR [esi+12], 0
	je	SHORT $LN51@OnAppDeact
	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+32]
	push	eax
	call	edx
$LN51@OnAppDeact:

; 494  : 	ZeroMemory		( mouseState,	sizeof(mouseState) );

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	edx, DWORD PTR [ecx+12]
	push	12					; 0000000cH
	push	0
	lea	eax, DWORD PTR [esi+52]
	push	eax
	call	edx

; 495  : 	ZeroMemory		( KBState,		sizeof(KBState) );

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	edx, DWORD PTR [ecx+12]
	push	1024					; 00000400H
	push	0
	lea	eax, DWORD PTR [esi+64]
	push	eax
	call	edx

; 496  : 	ZeroMemory		( timeStamp,	sizeof(timeStamp) );

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	edx, DWORD PTR [ecx+12]
	push	12					; 0000000cH
	push	0
	lea	eax, DWORD PTR [esi+16]
	push	eax
	call	edx

; 497  : 	ZeroMemory		( timeSave,		sizeof(timeStamp) );

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	edx, DWORD PTR [ecx+12]
	push	12					; 0000000cH
	push	0
	lea	eax, DWORD PTR [esi+28]
	push	eax
	call	edx

; 498  : 	ZeroMemory		( offs,			sizeof(offs) );

	mov	eax, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ecx, DWORD PTR [eax+12]
	push	12					; 0000000cH
	push	0
	add	esi, 40					; 00000028H
	push	esi
	call	ecx
	pop	esi

; 499  : }

	ret	0
?OnAppDeactivate@CInput@@UAEXXZ ENDP			; CInput::OnAppDeactivate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?OnAppActivate@CInput@@UAEXXZ
_TEXT	SEGMENT
?OnAppActivate@CInput@@UAEXXZ PROC			; CInput::OnAppActivate, COMDAT
; _this$ = ecx

; 476  : {

	push	esi
	mov	esi, ecx

; 477  : 	if (CurrentIR())

	mov	eax, DWORD PTR [esi+1096]
	sub	eax, DWORD PTR [esi+1092]
	test	eax, -4					; fffffffcH
	je	SHORT $LN1@OnAppActiv
	mov	ecx, DWORD PTR [esi+1096]
	cmp	DWORD PTR [ecx-4], 0
	je	SHORT $LN1@OnAppActiv

; 478  : 		CurrentIR()->IR_OnActivate();

	mov	edx, ecx
	sub	edx, DWORD PTR [esi+1092]
	test	edx, -4					; fffffffcH
	je	SHORT $LN25@OnAppActiv
	mov	eax, ecx
	mov	ecx, DWORD PTR [eax-4]
	jmp	SHORT $LN24@OnAppActiv
$LN25@OnAppActiv:
	xor	ecx, ecx
$LN24@OnAppActiv:
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	call	eax
$LN1@OnAppActiv:

; 479  : 
; 480  : 	SetAllAcquire	( true );

	cmp	DWORD PTR [esi+12], 0
	je	SHORT $LN49@OnAppActiv
	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+28]
	push	eax
	call	edx
$LN49@OnAppActiv:
	cmp	DWORD PTR [esi+16], 0
	je	SHORT $LN51@OnAppActiv
	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+28]
	push	eax
	call	edx
$LN51@OnAppActiv:

; 481  : 	ZeroMemory		( mouseState,	sizeof(mouseState) );

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	edx, DWORD PTR [ecx+12]
	push	12					; 0000000cH
	push	0
	lea	eax, DWORD PTR [esi+56]
	push	eax
	call	edx

; 482  : 	ZeroMemory		( KBState,		sizeof(KBState) );

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	edx, DWORD PTR [ecx+12]
	push	1024					; 00000400H
	push	0
	lea	eax, DWORD PTR [esi+68]
	push	eax
	call	edx

; 483  : 	ZeroMemory		( timeStamp,	sizeof(timeStamp) );

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	edx, DWORD PTR [ecx+12]
	push	12					; 0000000cH
	push	0
	lea	eax, DWORD PTR [esi+20]
	push	eax
	call	edx

; 484  : 	ZeroMemory		( timeSave,		sizeof(timeStamp) );

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	edx, DWORD PTR [ecx+12]
	push	12					; 0000000cH
	push	0
	lea	eax, DWORD PTR [esi+32]
	push	eax
	call	edx

; 485  : 	ZeroMemory		( offs,			sizeof(offs) );

	mov	eax, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ecx, DWORD PTR [eax+12]
	push	12					; 0000000cH
	push	0
	add	esi, 44					; 0000002cH
	push	esi
	call	ecx
	pop	esi

; 486  : }

	ret	0
?OnAppActivate@CInput@@UAEXXZ ENDP			; CInput::OnAppActivate
_TEXT	ENDS
PUBLIC	?iRelease@CInput@@QAEXPAVIInputReceiver@@@Z	; CInput::iRelease
; Function compile flags: /Ogtpy
;	COMDAT ?iRelease@CInput@@QAEXPAVIInputReceiver@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?iRelease@CInput@@QAEXPAVIInputReceiver@@@Z PROC	; CInput::iRelease, COMDAT
; _this$ = ecx

; 456  : {

	push	ebx

; 457  : 	if (p == cbStack.back())

	mov	ebx, DWORD PTR _p$[esp]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+1100]
	cmp	ebx, DWORD PTR [eax-4]
	jne	SHORT $LN6@iRelease

; 458  : 	{
; 459  : 		cbStack.back()->IR_OnDeactivate();

	mov	ecx, DWORD PTR [eax-4]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	call	edx

; 460  : 		cbStack.pop_back();

	add	DWORD PTR [esi+1100], -4		; fffffffcH
	mov	eax, DWORD PTR [esi+1100]
	push	eax
	call	??$_Destroy@PAX@stlp_std@@YAXPAPAX@Z	; stlp_std::_Destroy<void *>

; 461  : 		IInputReceiver * ir = cbStack.back();

	mov	eax, DWORD PTR [esi+1100]
	mov	ecx, DWORD PTR [eax-4]

; 462  : 		ir->IR_OnActivate();

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	add	esp, 4
	call	eax
	pop	esi
	pop	ebx

; 470  : 				break;
; 471  : 			}
; 472  : 	}
; 473  : }

	ret	4
$LN6@iRelease:
	push	edi

; 463  : 	}else{// we are not topmost receiver, so remove the nearest one
; 464  : 		u32 cnt = cbStack.size();

	mov	edi, eax
	sub	edi, DWORD PTR [esi+1096]
	sar	edi, 2

; 465  : 		for(;cnt>0;--cnt)

	je	SHORT $LN108@iRelease
	npad	11
$LL4@iRelease:

; 466  : 			if( cbStack[cnt-1] == p ){

	mov	eax, DWORD PTR [esi+1096]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	lea	eax, DWORD PTR [eax+edi*4-4]
	add	esp, 4
	cmp	DWORD PTR [eax], ebx
	je	SHORT $LN106@iRelease

; 465  : 		for(;cnt>0;--cnt)

	sub	edi, 1
	jne	SHORT $LL4@iRelease
	pop	edi
	pop	esi
	pop	ebx

; 470  : 				break;
; 471  : 			}
; 472  : 	}
; 473  : }

	ret	4
$LN106@iRelease:

; 467  : 				xr_vector<IInputReceiver*>::iterator it = cbStack.begin();

	mov	eax, DWORD PTR [esi+1096]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr

; 468  : 				std::advance	(it,cnt-1);

	lea	edi, DWORD PTR [eax+edi*4-4]

; 469  : 				cbStack.erase	(it);

	mov	eax, DWORD PTR [esi+1100]
	lea	ecx, DWORD PTR [edi+4]
	add	esp, 4
	cmp	ecx, eax
	je	SHORT $LN95@iRelease
	sub	eax, ecx
	je	SHORT $LN95@iRelease
	push	eax
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
$LN95@iRelease:
	add	DWORD PTR [esi+1100], -4		; fffffffcH
	mov	esi, DWORD PTR [esi+1100]
	push	esi
	call	??$_Destroy@PAX@stlp_std@@YAXPAPAX@Z	; stlp_std::_Destroy<void *>
	push	edi
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 8
$LN108@iRelease:
	pop	edi
	pop	esi
	pop	ebx

; 470  : 				break;
; 471  : 			}
; 472  : 	}
; 473  : }

	ret	4
?iRelease@CInput@@QAEXPAVIInputReceiver@@@Z ENDP	; CInput::iRelease
_TEXT	ENDS
PUBLIC	?MouseUpdate@CInput@@AAEXXZ			; CInput::MouseUpdate
; Function compile flags: /Ogtpy
;	COMDAT ?MouseUpdate@CInput@@AAEXXZ
_TEXT	SEGMENT
_dwElements$ = -1300					; size = 4
_i$117779 = -1296					; size = 4
_mouse_prev$ = -1292					; size = 12
_od$ = -1280						; size = 1280
?MouseUpdate@CInput@@AAEXXZ PROC			; CInput::MouseUpdate, COMDAT
; _this$ = ecx

; 332  : {

	sub	esp, 1300				; 00000514H
	push	ebx
	push	esi

; 333  : 	HRESULT hr;
; 334  : 	DWORD dwElements	= MOUSEBUFFERSIZE;
; 335  : 	DIDEVICEOBJECTDATA	od[MOUSEBUFFERSIZE];
; 336  : 
; 337  : 	VERIFY(pMouse);
; 338  : 
; 339  : 	hr = pMouse->GetDeviceData( sizeof(DIDEVICEOBJECTDATA), &od[0], &dwElements, 0 );

	xor	ebx, ebx
	push	ebx
	lea	edx, DWORD PTR _dwElements$[esp+1312]
	push	edx
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+16]
	lea	edx, DWORD PTR _od$[esp+1316]
	push	edx
	mov	DWORD PTR _dwElements$[esp+1320], 64	; 00000040H
	mov	ecx, DWORD PTR [eax]
	push	20					; 00000014H
	push	eax
	mov	eax, DWORD PTR [ecx+40]
	call	eax

; 340  : 	if (( hr == DIERR_INPUTLOST )||( hr == DIERR_NOTACQUIRED )){

	cmp	eax, -2147024866			; 8007001eH
	je	SHORT $LN46@MouseUpdat
	cmp	eax, -2147024884			; 8007000cH
	jne	SHORT $LN44@MouseUpdat
$LN46@MouseUpdat:

; 341  : 		hr = pMouse->Acquire();

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+28]
	push	eax
	call	edx

; 342  : 		if ( hr != S_OK ) return;

	test	eax, eax
	jne	$LN1@MouseUpdat

; 343  : 		hr = pMouse->GetDeviceData( sizeof(DIDEVICEOBJECTDATA), &od[0], &dwElements, 0 );

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	push	ebx
	lea	edx, DWORD PTR _dwElements$[esp+1312]
	push	edx
	lea	edx, DWORD PTR _od$[esp+1316]
	push	edx
	push	20					; 00000014H
	push	eax
	mov	eax, DWORD PTR [ecx+40]
	call	eax

; 344  : 		if ( hr != S_OK ) return;

	test	eax, eax
	jne	$LN1@MouseUpdat
$LN44@MouseUpdat:

; 345  : 	};
; 346  : 
; 347  : 	if(Device.dwPrecacheFrame)

	cmp	DWORD PTR ?Device@@3VCRenderDevice@@A+12, ebx
	jne	$LN1@MouseUpdat

; 353  : 	mouse_prev[1]		= mouseState[1];
; 354  : 	mouse_prev[2]		= mouseState[2];
; 355  : 
; 356  : 	offs[0] = offs[1] = offs[2] = 0;
; 357  : 	for (u32 i = 0; i < dwElements; i++){

	cmp	DWORD PTR _dwElements$[esp+1308], ebx
	mov	ecx, DWORD PTR [esi+60]
	mov	edx, DWORD PTR [esi+64]
	mov	eax, DWORD PTR [esi+68]
	push	ebp
	push	edi
	mov	DWORD PTR _mouse_prev$[esp+1316], ecx
	mov	DWORD PTR _mouse_prev$[esp+1320], edx
	mov	DWORD PTR _mouse_prev$[esp+1324], eax
	mov	DWORD PTR [esi+56], ebx
	mov	DWORD PTR [esi+52], ebx
	mov	DWORD PTR [esi+48], ebx
	mov	DWORD PTR _i$117779[esp+1316], ebx
	mov	ebp, 1
	jbe	$LN40@MouseUpdat

; 348  : 		return;
; 349  : 
; 350  : 	BOOL				mouse_prev[COUNT_MOUSE_BUTTONS];
; 351  : 
; 352  : 	mouse_prev[0]		= mouseState[0];

	lea	edi, DWORD PTR _od$[esp+1320]
$LL42@MouseUpdat:

; 358  : 		switch (od[i].dwOfs){

	mov	eax, DWORD PTR [edi-4]
	cmp	eax, 19					; 00000013H
	ja	$LN41@MouseUpdat
	movzx	ecx, BYTE PTR $LN285@MouseUpdat[eax]
	jmp	DWORD PTR $LN305@MouseUpdat[ecx*4]
$LN37@MouseUpdat:

; 359  : 		case DIMOFS_X:	offs[0]	+= od[i].dwData; timeStamp[0] = od[i].dwTimeStamp;	break;

	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edi+4]
	add	DWORD PTR [esi+48], edx
	mov	DWORD PTR [esi+24], eax
	jmp	$LN41@MouseUpdat
$LN36@MouseUpdat:

; 360  : 		case DIMOFS_Y:	offs[1]	+= od[i].dwData; timeStamp[1] = od[i].dwTimeStamp;	break;

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [edi+4]
	add	DWORD PTR [esi+52], ecx
	mov	DWORD PTR [esi+28], edx
	jmp	$LN41@MouseUpdat
$LN35@MouseUpdat:

; 361  : 		case DIMOFS_Z:	offs[2]	+= od[i].dwData; timeStamp[2] = od[i].dwTimeStamp;	break;

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [edi+4]
	add	DWORD PTR [esi+56], eax
	mov	DWORD PTR [esi+32], ecx
	jmp	$LN41@MouseUpdat
$LN34@MouseUpdat:

; 362  : 		case DIMOFS_BUTTON0:
; 363  : 			if ( od[i].dwData & 0x80 )	

	test	BYTE PTR [edi], 128			; 00000080H
	je	SHORT $LN288@MouseUpdat

; 364  : 			{ mouseState[0] = TRUE;				cbStack.back()->IR_OnMousePress(0);		}

	mov	edx, DWORD PTR [esi+1100]
	mov	DWORD PTR [esi+60], ebp
	mov	ecx, DWORD PTR [edx-4]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+8]
	push	ebx
	call	edx

; 365  : 			if ( !(od[i].dwData & 0x80))

	test	BYTE PTR [edi], 128			; 00000080H
	jne	$LN41@MouseUpdat
$LN288@MouseUpdat:

; 366  : 			{ mouseState[0] = FALSE;			cbStack.back()->IR_OnMouseRelease(0);	}

	mov	eax, DWORD PTR [esi+1100]
	mov	DWORD PTR [esi+60], ebx
	mov	ecx, DWORD PTR [eax-4]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+12]
	push	ebx

; 367  : 			break;

	jmp	$LN289@MouseUpdat
$LN31@MouseUpdat:

; 368  : 		case DIMOFS_BUTTON1:
; 369  : 			if ( od[i].dwData & 0x80 )	

	test	BYTE PTR [edi], 128			; 00000080H
	je	SHORT $LN291@MouseUpdat

; 370  : 			{ mouseState[1] = TRUE;				cbStack.back()->IR_OnMousePress(1);		}

	mov	ecx, DWORD PTR [esi+1100]
	mov	DWORD PTR [esi+64], ebp
	mov	ecx, DWORD PTR [ecx-4]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	push	ebp
	call	eax

; 371  : 			if ( !(od[i].dwData & 0x80))

	test	BYTE PTR [edi], 128			; 00000080H
	jne	$LN41@MouseUpdat
$LN291@MouseUpdat:

; 372  : 			{ mouseState[1] = FALSE;			cbStack.back()->IR_OnMouseRelease(1);	}

	mov	ecx, DWORD PTR [esi+1100]
	mov	DWORD PTR [esi+64], ebx
	mov	ecx, DWORD PTR [ecx-4]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+12]
	push	ebp

; 373  : 			break;

	jmp	$LN289@MouseUpdat
$LN28@MouseUpdat:

; 374  : 		case DIMOFS_BUTTON2:
; 375  : 			if ( od[i].dwData & 0x80 )	

	test	BYTE PTR [edi], 128			; 00000080H
	je	SHORT $LN293@MouseUpdat

; 376  : 			{ mouseState[2] = TRUE;				cbStack.back()->IR_OnMousePress(2);		}

	mov	ecx, DWORD PTR [esi+1100]
	mov	DWORD PTR [esi+68], ebp
	mov	ecx, DWORD PTR [ecx-4]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	push	2
	call	eax

; 377  : 			if ( !(od[i].dwData & 0x80))

	test	BYTE PTR [edi], 128			; 00000080H
	jne	$LN41@MouseUpdat
$LN293@MouseUpdat:

; 378  : 			{ mouseState[2] = FALSE;			cbStack.back()->IR_OnMouseRelease(2);	}

	mov	ecx, DWORD PTR [esi+1100]
	mov	DWORD PTR [esi+68], ebx
	mov	ecx, DWORD PTR [ecx-4]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+12]
	push	2

; 379  : 			break;

	jmp	$LN289@MouseUpdat
$LN25@MouseUpdat:

; 380  : 		case DIMOFS_BUTTON3:
; 381  : 			if ( od[i].dwData & 0x80 )	

	test	BYTE PTR [edi], 128			; 00000080H
	je	SHORT $LN295@MouseUpdat

; 382  : 			{ mouseState[2] = TRUE;				cbStack.back()->IR_OnKeyboardPress(0xED + 103);		}

	mov	ecx, DWORD PTR [esi+1100]
	mov	DWORD PTR [esi+68], ebp
	mov	ecx, DWORD PTR [ecx-4]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+32]
	push	340					; 00000154H
	call	eax

; 383  : 			if ( !(od[i].dwData & 0x80))

	test	BYTE PTR [edi], 128			; 00000080H
	jne	$LN41@MouseUpdat
$LN295@MouseUpdat:

; 384  : 			{ mouseState[2] = FALSE;			cbStack.back()->IR_OnKeyboardRelease(0xED + 103);	}

	push	340					; 00000154H

; 385  : 			break;

	jmp	$LN296@MouseUpdat
$LN22@MouseUpdat:

; 386  : 		case DIMOFS_BUTTON4:
; 387  : 			if ( od[i].dwData & 0x80 )	

	test	BYTE PTR [edi], 128			; 00000080H
	je	SHORT $LN298@MouseUpdat

; 388  : 			{ mouseState[2] = TRUE;				cbStack.back()->IR_OnKeyboardPress(0xED + 104);		}

	mov	ecx, DWORD PTR [esi+1100]
	mov	DWORD PTR [esi+68], ebp
	mov	ecx, DWORD PTR [ecx-4]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+32]
	push	341					; 00000155H
	call	eax

; 389  : 			if ( !(od[i].dwData & 0x80))

	test	BYTE PTR [edi], 128			; 00000080H
	jne	$LN41@MouseUpdat
$LN298@MouseUpdat:

; 390  : 			{ mouseState[2] = FALSE;			cbStack.back()->IR_OnKeyboardRelease(0xED + 104);	}

	push	341					; 00000155H

; 391  : 			break;

	jmp	SHORT $LN296@MouseUpdat
$LN19@MouseUpdat:

; 392  : 		case DIMOFS_BUTTON5:
; 393  : 			if ( od[i].dwData & 0x80 )	

	test	BYTE PTR [edi], 128			; 00000080H
	je	SHORT $LN300@MouseUpdat

; 394  : 			{ mouseState[2] = TRUE;				cbStack.back()->IR_OnKeyboardPress(0xED + 105);		}

	mov	ecx, DWORD PTR [esi+1100]
	mov	DWORD PTR [esi+68], ebp
	mov	ecx, DWORD PTR [ecx-4]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+32]
	push	342					; 00000156H
	call	eax

; 395  : 			if ( !(od[i].dwData & 0x80))

	test	BYTE PTR [edi], 128			; 00000080H
	jne	SHORT $LN41@MouseUpdat
$LN300@MouseUpdat:

; 396  : 			{ mouseState[2] = FALSE;			cbStack.back()->IR_OnKeyboardRelease(0xED + 105);	}

	push	342					; 00000156H

; 397  : 			break;

	jmp	SHORT $LN296@MouseUpdat
$LN16@MouseUpdat:

; 398  : 		case DIMOFS_BUTTON6:
; 399  : 			if ( od[i].dwData & 0x80 )	

	test	BYTE PTR [edi], 128			; 00000080H
	je	SHORT $LN302@MouseUpdat

; 400  : 			{ mouseState[2] = TRUE;				cbStack.back()->IR_OnKeyboardPress(0xED + 106);		}

	mov	ecx, DWORD PTR [esi+1100]
	mov	DWORD PTR [esi+68], ebp
	mov	ecx, DWORD PTR [ecx-4]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+32]
	push	343					; 00000157H
	call	eax

; 401  : 			if ( !(od[i].dwData & 0x80))

	test	BYTE PTR [edi], 128			; 00000080H
	jne	SHORT $LN41@MouseUpdat
$LN302@MouseUpdat:

; 402  : 			{ mouseState[2] = FALSE;			cbStack.back()->IR_OnKeyboardRelease(0xED + 106);	}

	push	343					; 00000157H

; 403  : 			break;

	jmp	SHORT $LN296@MouseUpdat
$LN13@MouseUpdat:

; 404  : 		case DIMOFS_BUTTON7:
; 405  : 			if ( od[i].dwData & 0x80 )	

	test	BYTE PTR [edi], 128			; 00000080H
	je	SHORT $LN304@MouseUpdat

; 406  : 			{ mouseState[2] = TRUE;				cbStack.back()->IR_OnKeyboardPress(0xED + 107);		}

	mov	ecx, DWORD PTR [esi+1100]
	mov	DWORD PTR [esi+68], ebp
	mov	ecx, DWORD PTR [ecx-4]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+32]
	push	344					; 00000158H
	call	eax

; 407  : 			if ( !(od[i].dwData & 0x80))

	test	BYTE PTR [edi], 128			; 00000080H
	jne	SHORT $LN41@MouseUpdat
$LN304@MouseUpdat:

; 408  : 			{ mouseState[2] = FALSE;			cbStack.back()->IR_OnKeyboardRelease(0xED + 107);	}

	push	344					; 00000158H
$LN296@MouseUpdat:
	mov	ecx, DWORD PTR [esi+1100]
	mov	DWORD PTR [esi+68], ebx
	mov	ecx, DWORD PTR [ecx-4]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+36]
$LN289@MouseUpdat:
	call	eax
$LN41@MouseUpdat:

; 353  : 	mouse_prev[1]		= mouseState[1];
; 354  : 	mouse_prev[2]		= mouseState[2];
; 355  : 
; 356  : 	offs[0] = offs[1] = offs[2] = 0;
; 357  : 	for (u32 i = 0; i < dwElements; i++){

	mov	eax, DWORD PTR _i$117779[esp+1316]
	add	eax, ebp
	add	edi, 20					; 00000014H
	cmp	eax, DWORD PTR _dwElements$[esp+1316]
	mov	DWORD PTR _i$117779[esp+1316], eax
	jb	$LL42@MouseUpdat
$LN40@MouseUpdat:

; 409  : 			break;
; 410  : 		}
; 411  : 	}
; 412  : 
; 413  : 	if (mouseState[0] && mouse_prev[0])

	cmp	DWORD PTR [esi+60], ebx
	je	SHORT $LN10@MouseUpdat
	cmp	DWORD PTR _mouse_prev$[esp+1316], ebx
	je	SHORT $LN10@MouseUpdat

; 414  : 	{
; 415  : 		cbStack.back()->IR_OnMouseHold(0);

	mov	ecx, DWORD PTR [esi+1100]
	mov	ecx, DWORD PTR [ecx-4]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	push	ebx
	call	eax
$LN10@MouseUpdat:

; 416  : 	}
; 417  : 
; 418  : 	if (mouseState[1] && mouse_prev[1])		

	cmp	DWORD PTR [esi+64], ebx
	je	SHORT $LN9@MouseUpdat
	cmp	DWORD PTR _mouse_prev$[esp+1320], ebx
	je	SHORT $LN9@MouseUpdat

; 419  : 	{
; 420  : 		cbStack.back()->IR_OnMouseHold(1);

	mov	ecx, DWORD PTR [esi+1100]
	mov	ecx, DWORD PTR [ecx-4]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	push	ebp
	call	eax
$LN9@MouseUpdat:

; 421  : 	}
; 422  : 
; 423  : 	if (mouseState[2] && mouse_prev[2])		

	cmp	DWORD PTR [esi+68], ebx
	je	SHORT $LN8@MouseUpdat
	cmp	DWORD PTR _mouse_prev$[esp+1324], ebx
	je	SHORT $LN8@MouseUpdat

; 424  : 	{
; 425  : 		cbStack.back()->IR_OnMouseHold(2);

	mov	ecx, DWORD PTR [esi+1100]
	mov	ecx, DWORD PTR [ecx-4]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	push	2
	call	eax
$LN8@MouseUpdat:

; 426  : 	}
; 427  : 	if ( dwElements ){

	cmp	DWORD PTR _dwElements$[esp+1316], ebx
	je	SHORT $LN7@MouseUpdat

; 428  : 		if (offs[0] || offs[1]) cbStack.back()->IR_OnMouseMove	( offs[0], offs[1] );

	mov	eax, DWORD PTR [esi+48]
	cmp	eax, ebx
	jne	SHORT $LN5@MouseUpdat
	cmp	DWORD PTR [esi+52], ebx
	je	SHORT $LN6@MouseUpdat
$LN5@MouseUpdat:
	mov	ecx, DWORD PTR [esi+1100]
	mov	edi, DWORD PTR [esi+52]
	mov	ecx, DWORD PTR [ecx-4]
	mov	edx, DWORD PTR [ecx]
	push	edi
	push	eax
	mov	eax, DWORD PTR [edx+24]
	call	eax
$LN6@MouseUpdat:

; 429  : 		if (offs[2])			cbStack.back()->IR_OnMouseWheel	( offs[2] );

	mov	eax, DWORD PTR [esi+56]
	cmp	eax, ebx
	je	SHORT $LN286@MouseUpdat
	mov	ecx, DWORD PTR [esi+1100]
	mov	ecx, DWORD PTR [ecx-4]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+20]
	call	eax
	pop	edi
	pop	ebp
	pop	esi
	pop	ebx

; 433  : 	}
; 434  : }

	add	esp, 1300				; 00000514H
	ret	0
$LN7@MouseUpdat:

; 430  : 	} else {
; 431  : 		if (timeStamp[1] && ((dwCurTime-timeStamp[1])>=mouse_property.mouse_dt))	cbStack.back()->IR_OnMouseStop(DIMOFS_Y, timeStamp[1] = 0);

	mov	eax, DWORD PTR [esi+28]
	cmp	eax, ebx
	je	SHORT $LN2@MouseUpdat
	mov	ecx, DWORD PTR [esi+2992]
	sub	ecx, eax
	cmp	ecx, DWORD PTR [esi+2048]
	jb	SHORT $LN2@MouseUpdat
	mov	edx, DWORD PTR [esi+1100]
	mov	DWORD PTR [esi+28], ebx
	mov	ecx, DWORD PTR [edx-4]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+28]
	push	ebx
	push	4
	call	edx
$LN2@MouseUpdat:

; 432  : 		if (timeStamp[0] && ((dwCurTime-timeStamp[0])>=mouse_property.mouse_dt))	cbStack.back()->IR_OnMouseStop(DIMOFS_X, timeStamp[0] = 0);

	mov	eax, DWORD PTR [esi+24]
	cmp	eax, ebx
	je	SHORT $LN286@MouseUpdat
	mov	ecx, DWORD PTR [esi+2992]
	sub	ecx, eax
	cmp	ecx, DWORD PTR [esi+2048]
	jb	SHORT $LN286@MouseUpdat
	mov	edx, DWORD PTR [esi+1100]
	mov	DWORD PTR [esi+24], ebx
	mov	ecx, DWORD PTR [edx-4]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+28]
	push	ebx
	push	ebx
	call	edx
$LN286@MouseUpdat:
	pop	edi
	pop	ebp
$LN1@MouseUpdat:
	pop	esi
	pop	ebx

; 433  : 	}
; 434  : }

	add	esp, 1300				; 00000514H
	ret	0
	npad	2
$LN305@MouseUpdat:
	DD	$LN37@MouseUpdat
	DD	$LN36@MouseUpdat
	DD	$LN35@MouseUpdat
	DD	$LN34@MouseUpdat
	DD	$LN31@MouseUpdat
	DD	$LN28@MouseUpdat
	DD	$LN25@MouseUpdat
	DD	$LN22@MouseUpdat
	DD	$LN19@MouseUpdat
	DD	$LN16@MouseUpdat
	DD	$LN13@MouseUpdat
	DD	$LN41@MouseUpdat
$LN285@MouseUpdat:
	DB	0
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	1
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	2
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	3
	DB	4
	DB	5
	DB	6
	DB	7
	DB	8
	DB	9
	DB	10					; 0000000aH
?MouseUpdate@CInput@@AAEXXZ ENDP			; CInput::MouseUpdate
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
;	COMDAT ??0?$vector@PAVIInputReceiver@@V?$xalloc@PAVIInputReceiver@@@@@stlp_std@@QAE@ABV?$xalloc@PAVIInputReceiver@@@@@Z
_TEXT	SEGMENT
??0?$vector@PAVIInputReceiver@@V?$xalloc@PAVIInputReceiver@@@@@stlp_std@@QAE@ABV?$xalloc@PAVIInputReceiver@@@@@Z PROC ; stlp_std::vector<IInputReceiver *,xalloc<IInputReceiver *> >::vector<IInputReceiver *,xalloc<IInputReceiver *> >, COMDAT
; _this$ = eax

; 106  :   explicit vector(const allocator_type& __a = allocator_type())

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$vector@PAVIInputReceiver@@V?$xalloc@PAVIInputReceiver@@@@@stlp_std@@QAE@ABV?$xalloc@PAVIInputReceiver@@@@@Z ENDP ; stlp_std::vector<IInputReceiver *,xalloc<IInputReceiver *> >::vector<IInputReceiver *,xalloc<IInputReceiver *> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\pure.h
_TEXT	ENDS
;	COMDAT ?Resort@?$CRegistrator@VpureAppDeactivate@@@@QAEXXZ
_TEXT	SEGMENT
?Resort@?$CRegistrator@VpureAppDeactivate@@@@QAEXXZ PROC ; CRegistrator<pureAppDeactivate>::Resort, COMDAT
; _this$ = esi

; 96   : 		qsort	(&*R.begin(),R.size(),sizeof(_REG_INFO),_REG_Compare);

	push	OFFSET ?_REG_Compare@?$CRegistrator@VpureAppDeactivate@@@@CAHPBX0@Z ; CRegistrator<pureAppDeactivate>::_REG_Compare
	push	12					; 0000000cH
	mov	ecx, esi
	call	?size@?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QBEIXZ ; xr_vector<_REG_INFO,xalloc<_REG_INFO> >::size
	push	eax
	mov	ecx, esi
	call	?begin@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@stlp_std@@QAEPAU_REG_INFO@@XZ ; stlp_std::vector<_REG_INFO,xalloc<_REG_INFO> >::begin
	push	eax
	call	DWORD PTR __imp__qsort
	add	esp, 16					; 00000010H

; 97   : 		while	((R.size()) && (R[R.size()-1].Prio==REG_PRIORITY_INVALID)) R.pop_back();

	mov	ecx, esi
	call	?size@?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QBEIXZ ; xr_vector<_REG_INFO,xalloc<_REG_INFO> >::size
	test	eax, eax
	je	SHORT $LN2@Resort@7
	npad	5
$LL3@Resort@7:
	mov	ecx, esi
	call	?size@?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QBEIXZ ; xr_vector<_REG_INFO,xalloc<_REG_INFO> >::size
	sub	eax, 1
	push	eax
	mov	ecx, esi
	call	??A?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QAEAAU_REG_INFO@@I@Z ; xr_vector<_REG_INFO,xalloc<_REG_INFO> >::operator[]
	cmp	DWORD PTR [eax+4], -1
	jne	SHORT $LN2@Resort@7
	mov	ecx, esi
	call	?pop_back@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@stlp_std@@QAEXXZ ; stlp_std::vector<_REG_INFO,xalloc<_REG_INFO> >::pop_back
	mov	ecx, esi
	call	?size@?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QBEIXZ ; xr_vector<_REG_INFO,xalloc<_REG_INFO> >::size
	test	eax, eax
	jne	SHORT $LL3@Resort@7
$LN2@Resort@7:

; 98   : 		if (R.empty())		R.clear		();

	mov	ecx, esi
	call	?empty@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@stlp_std@@QBE_NXZ ; stlp_std::vector<_REG_INFO,xalloc<_REG_INFO> >::empty
	test	al, al
	je	SHORT $LN78@Resort@7
	mov	ecx, esi
	call	?clear@?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QAEXXZ ; xr_vector<_REG_INFO,xalloc<_REG_INFO> >::clear
$LN78@Resort@7:

; 99   : 		changed				= false;

	and	DWORD PTR [esi+12], -3			; fffffffdH

; 100  : 	};

	ret	0
?Resort@?$CRegistrator@VpureAppDeactivate@@@@QAEXXZ ENDP ; CRegistrator<pureAppDeactivate>::Resort
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Resort@?$CRegistrator@VpureAppActivate@@@@QAEXXZ
_TEXT	SEGMENT
?Resort@?$CRegistrator@VpureAppActivate@@@@QAEXXZ PROC	; CRegistrator<pureAppActivate>::Resort, COMDAT
; _this$ = esi

; 96   : 		qsort	(&*R.begin(),R.size(),sizeof(_REG_INFO),_REG_Compare);

	push	OFFSET ?_REG_Compare@?$CRegistrator@VpureAppActivate@@@@CAHPBX0@Z ; CRegistrator<pureAppActivate>::_REG_Compare
	push	12					; 0000000cH
	mov	ecx, esi
	call	?size@?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QBEIXZ ; xr_vector<_REG_INFO,xalloc<_REG_INFO> >::size
	push	eax
	mov	ecx, esi
	call	?begin@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@stlp_std@@QAEPAU_REG_INFO@@XZ ; stlp_std::vector<_REG_INFO,xalloc<_REG_INFO> >::begin
	push	eax
	call	DWORD PTR __imp__qsort
	add	esp, 16					; 00000010H

; 97   : 		while	((R.size()) && (R[R.size()-1].Prio==REG_PRIORITY_INVALID)) R.pop_back();

	mov	ecx, esi
	call	?size@?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QBEIXZ ; xr_vector<_REG_INFO,xalloc<_REG_INFO> >::size
	test	eax, eax
	je	SHORT $LN2@Resort@8
	npad	5
$LL3@Resort@8:
	mov	ecx, esi
	call	?size@?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QBEIXZ ; xr_vector<_REG_INFO,xalloc<_REG_INFO> >::size
	sub	eax, 1
	push	eax
	mov	ecx, esi
	call	??A?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QAEAAU_REG_INFO@@I@Z ; xr_vector<_REG_INFO,xalloc<_REG_INFO> >::operator[]
	cmp	DWORD PTR [eax+4], -1
	jne	SHORT $LN2@Resort@8
	mov	ecx, esi
	call	?pop_back@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@stlp_std@@QAEXXZ ; stlp_std::vector<_REG_INFO,xalloc<_REG_INFO> >::pop_back
	mov	ecx, esi
	call	?size@?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QBEIXZ ; xr_vector<_REG_INFO,xalloc<_REG_INFO> >::size
	test	eax, eax
	jne	SHORT $LL3@Resort@8
$LN2@Resort@8:

; 98   : 		if (R.empty())		R.clear		();

	mov	ecx, esi
	call	?empty@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@stlp_std@@QBE_NXZ ; stlp_std::vector<_REG_INFO,xalloc<_REG_INFO> >::empty
	test	al, al
	je	SHORT $LN78@Resort@8
	mov	ecx, esi
	call	?clear@?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QAEXXZ ; xr_vector<_REG_INFO,xalloc<_REG_INFO> >::clear
$LN78@Resort@8:

; 99   : 		changed				= false;

	and	DWORD PTR [esi+12], -3			; fffffffdH

; 100  : 	};

	ret	0
?Resort@?$CRegistrator@VpureAppActivate@@@@QAEXXZ ENDP	; CRegistrator<pureAppActivate>::Resort
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Remove@?$CRegistrator@VpureAppDeactivate@@@@QAEXPAVpureAppDeactivate@@@Z
_TEXT	SEGMENT
?Remove@?$CRegistrator@VpureAppDeactivate@@@@QAEXPAVpureAppDeactivate@@@Z PROC ; CRegistrator<pureAppDeactivate>::Remove, COMDAT
; _this$ = eax
; _obj$ = ebx

; 73   : 	{

	push	esi
	mov	esi, eax
	push	edi

; 74   : 		for (u32 i=0; i<R.size(); i++) {

	mov	ecx, esi
	xor	edi, edi
	call	?size@?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QBEIXZ ; xr_vector<_REG_INFO,xalloc<_REG_INFO> >::size
	test	eax, eax
	jbe	SHORT $LN4@Remove@5
$LL6@Remove@5:

; 75   : 			if (R[i].Object==obj) R[i].Prio = REG_PRIORITY_INVALID;

	push	edi
	mov	ecx, esi
	call	??A?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QAEAAU_REG_INFO@@I@Z ; xr_vector<_REG_INFO,xalloc<_REG_INFO> >::operator[]
	cmp	DWORD PTR [eax], ebx
	jne	SHORT $LN5@Remove@5
	push	edi
	mov	ecx, esi
	call	??A?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QAEAAU_REG_INFO@@I@Z ; xr_vector<_REG_INFO,xalloc<_REG_INFO> >::operator[]
	mov	DWORD PTR [eax+4], -1
$LN5@Remove@5:
	mov	ecx, esi
	add	edi, 1
	call	?size@?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QBEIXZ ; xr_vector<_REG_INFO,xalloc<_REG_INFO> >::size
	cmp	edi, eax
	jb	SHORT $LL6@Remove@5
$LN4@Remove@5:

; 76   : 		}
; 77   : 		if(in_process)		changed=true;

	mov	eax, DWORD PTR [esi+12]
	test	al, 1
	je	SHORT $LN2@Remove@5
	or	eax, 2
	pop	edi
	mov	DWORD PTR [esi+12], eax
	pop	esi

; 79   : 	};

	ret	0
$LN2@Remove@5:

; 78   : 		else Resort			( );

	call	?Resort@?$CRegistrator@VpureAppDeactivate@@@@QAEXXZ ; CRegistrator<pureAppDeactivate>::Resort
	pop	edi
	pop	esi

; 79   : 	};

	ret	0
?Remove@?$CRegistrator@VpureAppDeactivate@@@@QAEXPAVpureAppDeactivate@@@Z ENDP ; CRegistrator<pureAppDeactivate>::Remove
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Remove@?$CRegistrator@VpureAppActivate@@@@QAEXPAVpureAppActivate@@@Z
_TEXT	SEGMENT
?Remove@?$CRegistrator@VpureAppActivate@@@@QAEXPAVpureAppActivate@@@Z PROC ; CRegistrator<pureAppActivate>::Remove, COMDAT
; _this$ = eax
; _obj$ = ebx

; 73   : 	{

	push	esi
	mov	esi, eax
	push	edi

; 74   : 		for (u32 i=0; i<R.size(); i++) {

	mov	ecx, esi
	xor	edi, edi
	call	?size@?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QBEIXZ ; xr_vector<_REG_INFO,xalloc<_REG_INFO> >::size
	test	eax, eax
	jbe	SHORT $LN4@Remove@6
$LL6@Remove@6:

; 75   : 			if (R[i].Object==obj) R[i].Prio = REG_PRIORITY_INVALID;

	push	edi
	mov	ecx, esi
	call	??A?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QAEAAU_REG_INFO@@I@Z ; xr_vector<_REG_INFO,xalloc<_REG_INFO> >::operator[]
	cmp	DWORD PTR [eax], ebx
	jne	SHORT $LN5@Remove@6
	push	edi
	mov	ecx, esi
	call	??A?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QAEAAU_REG_INFO@@I@Z ; xr_vector<_REG_INFO,xalloc<_REG_INFO> >::operator[]
	mov	DWORD PTR [eax+4], -1
$LN5@Remove@6:
	mov	ecx, esi
	add	edi, 1
	call	?size@?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QBEIXZ ; xr_vector<_REG_INFO,xalloc<_REG_INFO> >::size
	cmp	edi, eax
	jb	SHORT $LL6@Remove@6
$LN4@Remove@6:

; 76   : 		}
; 77   : 		if(in_process)		changed=true;

	mov	eax, DWORD PTR [esi+12]
	test	al, 1
	je	SHORT $LN2@Remove@6
	or	eax, 2
	pop	edi
	mov	DWORD PTR [esi+12], eax
	pop	esi

; 79   : 	};

	ret	0
$LN2@Remove@6:

; 78   : 		else Resort			( );

	call	?Resort@?$CRegistrator@VpureAppActivate@@@@QAEXXZ ; CRegistrator<pureAppActivate>::Resort
	pop	edi
	pop	esi

; 79   : 	};

	ret	0
?Remove@?$CRegistrator@VpureAppActivate@@@@QAEXPAVpureAppActivate@@@Z ENDP ; CRegistrator<pureAppActivate>::Remove
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.c
;	COMDAT ?_M_insert_overflow@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@AAEXPAPAXABQAXABU__true_type@3@I_N@Z
_TEXT	SEGMENT
___old_size$ = -8					; size = 4
tv266 = -4						; size = 4
___pos$ = 8						; size = 4
___fill_len$ = 12					; size = 4
___atend$ = 16						; size = 1
?_M_insert_overflow@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@AAEXPAPAXABQAXABU__true_type@3@I_N@Z PROC ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::_M_insert_overflow, COMDAT
; _this$ = edi
; ___x$ = eax

; 109  :                                              size_type __fill_len, bool __atend ) {

	sub	esp, 8
	push	ebx
	mov	ebx, eax

; 110  :   const size_type __old_size = size();

	mov	eax, DWORD PTR [edi+4]
	sub	eax, DWORD PTR [edi]
	push	ebp
	push	esi

; 111  :   size_type __len = __old_size + (max)(__old_size, __fill_len);

	lea	ecx, DWORD PTR ___fill_len$[esp+16]
	push	ecx
	lea	edx, DWORD PTR ___old_size$[esp+24]
	sar	eax, 2
	push	edx
	mov	DWORD PTR ___old_size$[esp+28], eax
	call	??$max@I@stlp_std@@YAABIABI0@Z		; stlp_std::max<unsigned int>
	mov	eax, DWORD PTR [eax]
	add	eax, DWORD PTR ___old_size$[esp+28]

; 112  : 
; 113  :   pointer __new_start = this->_M_end_of_storage.allocate(__len, __len);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	add	eax, eax
	add	eax, eax
	add	esp, 8
	push	eax
	mov	DWORD PTR tv266[esp+24], eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 114  :   pointer __new_finish = __STATIC_CAST(pointer, _STLP_PRIV __copy_trivial(this->_M_start, __pos, __new_start));

	mov	esi, DWORD PTR ___pos$[esp+16]
	mov	ebp, eax
	mov	eax, DWORD PTR [edi]
	sub	esi, eax
	je	SHORT $LN22@M_insert_o@23
	push	esi
	push	eax
	push	ebp
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	add	eax, esi
	jmp	SHORT $LN23@M_insert_o@23
$LN22@M_insert_o@23:
	mov	eax, ebp
$LN23@M_insert_o@23:

; 115  :   // handle insertion
; 116  :   __new_finish = _STLP_PRIV __fill_n(__new_finish, __fill_len, __x);

	mov	ecx, DWORD PTR ___fill_len$[esp+16]
	test	ecx, ecx
	jbe	SHORT $LN24@M_insert_o@23
$LL26@M_insert_o@23:
	mov	edx, DWORD PTR [ebx]
	mov	DWORD PTR [eax], edx
	sub	ecx, 1
	add	eax, 4
	test	ecx, ecx
	ja	SHORT $LL26@M_insert_o@23
$LN24@M_insert_o@23:

; 117  :   if (!__atend)

	cmp	BYTE PTR ___atend$[esp+16], 0
	mov	esi, eax
	jne	SHORT $LN31@M_insert_o@23

; 118  :     __new_finish = __STATIC_CAST(pointer, _STLP_PRIV __copy_trivial(__pos, this->_M_finish, __new_finish)); // copy remainder

	mov	ebx, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR ___pos$[esp+16]
	sub	ebx, ecx
	je	SHORT $LN31@M_insert_o@23
	push	ebx
	push	ecx
	push	eax
	call	DWORD PTR __imp__memmove
	mov	esi, eax
	add	esp, 12					; 0000000cH
	add	esi, ebx
$LN31@M_insert_o@23:

; 119  :   _M_clear();

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN63@M_insert_o@23
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN63@M_insert_o@23:

; 120  :   _M_set(__new_start, __new_finish, __new_start + __len);

	mov	eax, DWORD PTR tv266[esp+20]
	mov	DWORD PTR [edi+4], esi

; 121  : }

	pop	esi
	add	eax, ebp
	mov	DWORD PTR [edi], ebp
	pop	ebp
	mov	DWORD PTR [edi+8], eax
	pop	ebx
	add	esp, 8
	ret	12					; 0000000cH
?_M_insert_overflow@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@AAEXPAPAXABQAXABU__true_type@3@I_N@Z ENDP ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::_M_insert_overflow
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ?push_back@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEXABQAX@Z
_TEXT	SEGMENT
?push_back@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEXABQAX@Z PROC ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::push_back, COMDAT
; _this$ = ecx
; ___x$ = eax

; 360  :   void push_back(const _Tp& __x) {

	push	edi
	mov	edi, ecx

; 361  : #endif /*!_STLP_DONT_SUP_DFLT_PARAM && !_STLP_NO_ANACHRONISMS*/
; 362  :     if (this->_M_finish != this->_M_end_of_storage._M_data) {

	mov	ecx, DWORD PTR [edi+4]
	cmp	ecx, DWORD PTR [edi+8]
	je	SHORT $LN2@push_back@32

; 363  :       _Copy_Construct(this->_M_finish, __x);

	push	eax
	push	ecx
	call	??$_Copy_Construct@PAX@stlp_std@@YAXPAPAXABQAX@Z ; stlp_std::_Copy_Construct<void *>
	add	esp, 8

; 364  :       ++this->_M_finish;

	add	DWORD PTR [edi+4], 4
	pop	edi

; 368  :   }

	ret	0
$LN2@push_back@32:

; 365  :     }
; 366  :     else
; 367  :       _M_insert_overflow(this->_M_finish, __x, _TrivialCopy(), 1UL, true);

	push	1
	push	1
	push	ecx
	call	?_M_insert_overflow@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@AAEXPAPAXABQAXABU__true_type@3@I_N@Z ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::_M_insert_overflow
	pop	edi

; 368  :   }

	ret	0
?push_back@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEXABQAX@Z ENDP ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::push_back
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@PAVIInputReceiver@@V?$xalloc@PAVIInputReceiver@@@@@stlp_std@@QAEXABQAVIInputReceiver@@@Z
_TEXT	SEGMENT
?push_back@?$vector@PAVIInputReceiver@@V?$xalloc@PAVIInputReceiver@@@@@stlp_std@@QAEXABQAVIInputReceiver@@@Z PROC ; stlp_std::vector<IInputReceiver *,xalloc<IInputReceiver *> >::push_back, COMDAT
; _this$ = ecx
; ___x$ = eax

; 171  :   { _M_impl.push_back(cast_traits::to_storage_type_cref(__x)); }

	push	edi
	mov	edi, ecx
	mov	ecx, DWORD PTR [edi+4]
	cmp	ecx, DWORD PTR [edi+8]
	je	SHORT $LN8@push_back@33
	push	eax
	push	ecx
	call	??$_Copy_Construct@PAX@stlp_std@@YAXPAPAXABQAX@Z ; stlp_std::_Copy_Construct<void *>
	add	esp, 8
	add	DWORD PTR [edi+4], 4
	pop	edi
	ret	0
$LN8@push_back@33:
	push	1
	push	1
	push	ecx
	call	?_M_insert_overflow@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@AAEXPAPAXABQAXABU__true_type@3@I_N@Z ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::_M_insert_overflow
	pop	edi
	ret	0
?push_back@?$vector@PAVIInputReceiver@@V?$xalloc@PAVIInputReceiver@@@@@stlp_std@@QAEXABQAVIInputReceiver@@@Z ENDP ; stlp_std::vector<IInputReceiver *,xalloc<IInputReceiver *> >::push_back
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ??0?$xr_vector@PAVIInputReceiver@@V?$xalloc@PAVIInputReceiver@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@PAVIInputReceiver@@V?$xalloc@PAVIInputReceiver@@@@@@QAE@XZ PROC ; xr_vector<IInputReceiver *,xalloc<IInputReceiver *> >::xr_vector<IInputReceiver *,xalloc<IInputReceiver *> >, COMDAT
; _this$ = eax

; 123  : 			xr_vector			()									: inherited	()					{}

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$xr_vector@PAVIInputReceiver@@V?$xalloc@PAVIInputReceiver@@@@@@QAE@XZ ENDP ; xr_vector<IInputReceiver *,xalloc<IInputReceiver *> >::xr_vector<IInputReceiver *,xalloc<IInputReceiver *> >
_TEXT	ENDS
PUBLIC	??1CInput@@QAE@XZ				; CInput::~CInput
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\xr_input.cpp
;	COMDAT ??1CInput@@QAE@XZ
_TEXT	SEGMENT
??1CInput@@QAE@XZ PROC					; CInput::~CInput, COMDAT
; _this$ = ecx

; 96   : {

	push	ebx
	push	esi
	mov	esi, ecx
	push	edi
	lea	edi, DWORD PTR [esi+4]
	lea	ebx, DWORD PTR [esi+8]

; 97   : #ifdef ENGINE_BUILD
; 98   : 	Device.seqFrame.Remove			(this);

	push	esi
	mov	ecx, OFFSET ?Device@@3VCRenderDevice@@A+728
	mov	DWORD PTR [esi], OFFSET ??_7CInput@@6BpureFrame@@@
	mov	DWORD PTR [edi], OFFSET ??_7CInput@@6BpureAppActivate@@@
	mov	DWORD PTR [ebx], OFFSET ??_7CInput@@6BpureAppDeactivate@@@
	call	?Remove@?$CRegistrator@VpureFrame@@@@QAEXPAVpureFrame@@@Z ; CRegistrator<pureFrame>::Remove

; 99   : 	Device.seqAppDeactivate.Remove	(this);

	mov	eax, OFFSET ?Device@@3VCRenderDevice@@A+680
	call	?Remove@?$CRegistrator@VpureAppDeactivate@@@@QAEXPAVpureAppDeactivate@@@Z ; CRegistrator<pureAppDeactivate>::Remove

; 100  : 	Device.seqAppActivate.Remove	(this);

	mov	ebx, edi
	mov	eax, OFFSET ?Device@@3VCRenderDevice@@A+664
	call	?Remove@?$CRegistrator@VpureAppActivate@@@@QAEXPAVpureAppActivate@@@Z ; CRegistrator<pureAppActivate>::Remove

; 101  : #endif
; 102  : 	//_______________________
; 103  : 
; 104  : 	// Unacquire and release the device's interfaces
; 105  : 	if( pMouse ){

	mov	eax, DWORD PTR [esi+16]
	xor	edi, edi
	cmp	eax, edi
	je	SHORT $LN5@CInput

; 106  : 		pMouse->Unacquire();

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+32]
	push	eax
	call	edx

; 107  : 		_RELEASE	(pMouse);

	mov	eax, DWORD PTR [esi+16]
	cmp	eax, edi
	je	SHORT $LN5@CInput
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	push	eax
	call	edx
	mov	DWORD PTR [esi+16], edi
$LN5@CInput:

; 108  : 	}
; 109  : 
; 110  : 	if( pKeyboard ){

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, edi
	je	SHORT $LN3@CInput

; 111  : 		pKeyboard->Unacquire();

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+32]
	push	eax
	call	edx

; 112  : 		_RELEASE	(pKeyboard);

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, edi
	je	SHORT $LN3@CInput
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	push	eax
	call	edx
	mov	DWORD PTR [esi+20], edi
$LN3@CInput:

; 113  : 	}
; 114  : 
; 115  : 	_SHOW_REF	("Input: ",pDI);

	mov	eax, DWORD PTR [esi+12]
	cmp	eax, edi
	je	SHORT $LN2@CInput
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	push	eax
	call	edx
	push	eax
	push	OFFSET ??_C@_07BFLDNPLJ@Input?3?5?$AA@
	call	DWORD PTR __imp_?Log@@YAXPBDI@Z
	add	esp, 8
$LN2@CInput:

; 116  : 	_RELEASE	(pDI);

	mov	eax, DWORD PTR [esi+12]
	cmp	eax, edi
	je	SHORT $LN1@CInput
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	push	eax
	call	edx
	mov	DWORD PTR [esi+12], edi
$LN1@CInput:

; 117  : }

	mov	esi, DWORD PTR [esi+1096]
	cmp	esi, edi
	je	SHORT $LN50@CInput
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN50@CInput:
	pop	edi
	pop	esi
	pop	ebx
	ret	0
??1CInput@@QAE@XZ ENDP					; CInput::~CInput
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\pure.h
;	COMDAT ?Add@?$CRegistrator@VpureAppDeactivate@@@@QAEXPAVpureAppDeactivate@@HI@Z
_TEXT	SEGMENT
_I$ = -12						; size = 12
?Add@?$CRegistrator@VpureAppDeactivate@@@@QAEXPAVpureAppDeactivate@@HI@Z PROC ; CRegistrator<pureAppDeactivate>::Add, COMDAT
; _this$ = edx
; _obj$ = eax
; _priority$ = ecx

; 57   : 	{

	sub	esp, 12					; 0000000cH
	push	esi
	mov	esi, edx

; 58   : #ifdef DEBUG
; 59   : 		VERIFY	(priority!=REG_PRIORITY_INVALID);
; 60   : 		VERIFY	(obj);
; 61   : 		for		(u32 i=0; i<R.size(); i++) VERIFY( !((R[i].Prio!=REG_PRIORITY_INVALID)&&(R[i].Object==(void*)obj))   );
; 62   : #endif
; 63   : 		_REG_INFO			I;
; 64   : 		I.Object			=obj;
; 65   : 		I.Prio				=priority;
; 66   : 		I.Flags				=flags;
; 67   : 		R.push_back			(I);

	lea	edx, DWORD PTR _I$[esp+16]
	mov	DWORD PTR _I$[esp+20], ecx
	push	edx
	mov	ecx, esi
	mov	DWORD PTR _I$[esp+20], eax
	mov	DWORD PTR _I$[esp+28], 0
	call	?push_back@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@stlp_std@@QAEXABU_REG_INFO@@@Z ; stlp_std::vector<_REG_INFO,xalloc<_REG_INFO> >::push_back

; 68   : 		
; 69   : 		if(in_process)		changed=true;

	mov	eax, DWORD PTR [esi+12]
	test	al, 1
	je	SHORT $LN2@Add@6
	or	eax, 2
	mov	DWORD PTR [esi+12], eax
	pop	esi

; 71   : 	};

	add	esp, 12					; 0000000cH
	ret	0
$LN2@Add@6:

; 70   : 		else Resort			( );

	call	?Resort@?$CRegistrator@VpureAppDeactivate@@@@QAEXXZ ; CRegistrator<pureAppDeactivate>::Resort
	pop	esi

; 71   : 	};

	add	esp, 12					; 0000000cH
	ret	0
?Add@?$CRegistrator@VpureAppDeactivate@@@@QAEXPAVpureAppDeactivate@@HI@Z ENDP ; CRegistrator<pureAppDeactivate>::Add
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Add@?$CRegistrator@VpureAppActivate@@@@QAEXPAVpureAppActivate@@HI@Z
_TEXT	SEGMENT
_I$ = -12						; size = 12
?Add@?$CRegistrator@VpureAppActivate@@@@QAEXPAVpureAppActivate@@HI@Z PROC ; CRegistrator<pureAppActivate>::Add, COMDAT
; _this$ = ecx
; _obj$ = eax

; 57   : 	{

	sub	esp, 12					; 0000000cH
	push	esi
	mov	esi, ecx

; 58   : #ifdef DEBUG
; 59   : 		VERIFY	(priority!=REG_PRIORITY_INVALID);
; 60   : 		VERIFY	(obj);
; 61   : 		for		(u32 i=0; i<R.size(); i++) VERIFY( !((R[i].Prio!=REG_PRIORITY_INVALID)&&(R[i].Object==(void*)obj))   );
; 62   : #endif
; 63   : 		_REG_INFO			I;
; 64   : 		I.Object			=obj;
; 65   : 		I.Prio				=priority;
; 66   : 		I.Flags				=flags;
; 67   : 		R.push_back			(I);

	lea	ecx, DWORD PTR _I$[esp+16]
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR _I$[esp+20], eax
	mov	DWORD PTR _I$[esp+24], 572662306	; 22222222H
	mov	DWORD PTR _I$[esp+28], 0
	call	?push_back@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@stlp_std@@QAEXABU_REG_INFO@@@Z ; stlp_std::vector<_REG_INFO,xalloc<_REG_INFO> >::push_back

; 68   : 		
; 69   : 		if(in_process)		changed=true;

	mov	eax, DWORD PTR [esi+12]
	test	al, 1
	je	SHORT $LN2@Add@7
	or	eax, 2
	mov	DWORD PTR [esi+12], eax
	pop	esi

; 71   : 	};

	add	esp, 12					; 0000000cH
	ret	0
$LN2@Add@7:

; 70   : 		else Resort			( );

	call	?Resort@?$CRegistrator@VpureAppActivate@@@@QAEXXZ ; CRegistrator<pureAppActivate>::Resort
	pop	esi

; 71   : 	};

	add	esp, 12					; 0000000cH
	ret	0
?Add@?$CRegistrator@VpureAppActivate@@@@QAEXPAVpureAppActivate@@HI@Z ENDP ; CRegistrator<pureAppActivate>::Add
PUBLIC	?KeyUpdate@CInput@@AAEXXZ			; CInput::KeyUpdate
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\xr_input.cpp
;	COMDAT ?KeyUpdate@CInput@@AAEXXZ
_TEXT	SEGMENT
_b_alt_tab$ = -1285					; size = 1
_dwElements$ = -1284					; size = 4
_od$ = -1280						; size = 1280
?KeyUpdate@CInput@@AAEXXZ PROC				; CInput::KeyUpdate, COMDAT
; _this$ = ecx

; 177  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 1288				; 00000508H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	ebp, ecx

; 178  : 	if(b_altF4)					return;

	cmp	DWORD PTR ?b_altF4@@3HA, 0		; b_altF4
	jne	$LN1@KeyUpdate

; 179  : 
; 180  : 	HRESULT						hr;
; 181  : 	DWORD dwElements			= KEYBOARDBUFFERSIZE;
; 182  : 	DIDEVICEOBJECTDATA			od[KEYBOARDBUFFERSIZE];
; 183  : 	DWORD key					= 0;
; 184  : 
; 185  : 	VERIFY(pKeyboard);
; 186  : 
; 187  : 	hr = pKeyboard->GetDeviceData( sizeof(DIDEVICEOBJECTDATA), &od[0], &dwElements, 0 );

	mov	eax, DWORD PTR [ebp+20]
	push	0
	lea	edx, DWORD PTR _dwElements$[esp+1308]
	push	edx
	lea	edx, DWORD PTR _od$[esp+1312]
	push	edx
	mov	DWORD PTR _dwElements$[esp+1316], 64	; 00000040H
	mov	ecx, DWORD PTR [eax]
	push	20					; 00000014H
	push	eax
	mov	eax, DWORD PTR [ecx+40]
	call	eax

; 188  : 	if (( hr == DIERR_INPUTLOST )||( hr == DIERR_NOTACQUIRED ))

	cmp	eax, -2147024866			; 8007001eH
	je	SHORT $LN26@KeyUpdate
	cmp	eax, -2147024884			; 8007000cH
	jne	SHORT $LN24@KeyUpdate
$LN26@KeyUpdate:

; 189  : 	{
; 190  : 		hr = pKeyboard->Acquire();

	mov	eax, DWORD PTR [ebp+20]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+28]
	push	eax
	call	edx

; 191  : 		if ( hr != S_OK ) 

	test	eax, eax
	jne	$LN1@KeyUpdate

; 192  : 			return;
; 193  : 
; 194  : 		hr = pKeyboard->GetDeviceData( sizeof(DIDEVICEOBJECTDATA), &od[0], &dwElements, 0 );

	mov	eax, DWORD PTR [ebp+20]
	mov	ecx, DWORD PTR [eax]
	push	0
	lea	edx, DWORD PTR _dwElements$[esp+1308]
	push	edx
	lea	edx, DWORD PTR _od$[esp+1312]
	push	edx
	push	20					; 00000014H
	push	eax
	mov	eax, DWORD PTR [ecx+40]
	call	eax

; 195  : 		if ( hr != S_OK ) 

	test	eax, eax
	jne	$LN1@KeyUpdate
$LN24@KeyUpdate:

; 200  : 	for (u32 idx = 0; idx < dwElements; idx++)

	xor	edi, edi
	xor	dl, dl
	cmp	DWORD PTR _dwElements$[esp+1304], edi
	jbe	SHORT $LN21@KeyUpdate

; 196  : 			return;
; 197  : 	}
; 198  : 
; 199  : 	bool b_dik_pause_was_pressed = false;

	lea	eax, DWORD PTR _od$[esp+1308]
$LL23@KeyUpdate:

; 201  : 	{
; 202  : 		if(od[idx].dwOfs==DIK_PAUSE)

	mov	ecx, DWORD PTR [eax-4]
	cmp	ecx, 197				; 000000c5H
	jne	SHORT $LN18@KeyUpdate

; 203  : 		{
; 204  : 			if( od[idx].dwData & 0x80 )

	mov	esi, DWORD PTR [eax]
	and	esi, 128				; 00000080H
	je	SHORT $LN19@KeyUpdate

; 205  : 				b_dik_pause_was_pressed = true;

	mov	dl, 1

; 206  : 		
; 207  : 			if(b_dik_pause_was_pressed && !(od[idx].dwData & 0x80) )

	jmp	SHORT $LN74@KeyUpdate
$LN19@KeyUpdate:
	test	dl, dl
	je	SHORT $LN18@KeyUpdate
$LN74@KeyUpdate:
	test	esi, esi
	jne	SHORT $LN18@KeyUpdate

; 208  : 			{
; 209  : 				od[idx].uAppData = 666;

	mov	DWORD PTR [eax+12], 666			; 0000029aH

; 210  : 				continue; //skip one-frame pause key on-off switch

	jmp	SHORT $LN22@KeyUpdate
$LN18@KeyUpdate:

; 211  : 			}
; 212  : 		}
; 213  : 		KBState[od[idx].dwOfs]		= od[idx].dwData & 0x80;

	mov	esi, DWORD PTR [eax]
	and	esi, 128				; 00000080H
	mov	DWORD PTR [ebp+ecx*4+72], esi
$LN22@KeyUpdate:
	add	edi, 1
	add	eax, 20					; 00000014H
	cmp	edi, DWORD PTR _dwElements$[esp+1304]
	jb	SHORT $LL23@KeyUpdate
$LN21@KeyUpdate:

; 214  : 	}
; 215  : 
; 216  : #ifndef _EDITOR
; 217  : 	bool b_alt_tab				= false;
; 218  : 
; 219  : 	if(!b_altF4 && KBState[DIK_F4] && (KBState[DIK_RMENU] || KBState[DIK_LMENU]) )

	cmp	DWORD PTR ?b_altF4@@3HA, 0		; b_altF4
	mov	BYTE PTR _b_alt_tab$[esp+1304], 0
	jne	$LN1@KeyUpdate
	cmp	DWORD PTR [ebp+320], 0
	je	SHORT $LN75@KeyUpdate
	cmp	DWORD PTR [ebp+808], 0
	jne	SHORT $LN16@KeyUpdate
	cmp	DWORD PTR [ebp+296], 0
	je	SHORT $LN75@KeyUpdate
$LN16@KeyUpdate:

; 220  : 	{
; 221  : 		b_altF4				= TRUE;
; 222  : 		Engine.Event.Defer	("KERNEL:disconnect");

	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0BC@DMJJJMJK@KERNEL?3disconnect?$AA@
	mov	ecx, OFFSET ?Engine@@3VCEngine@@A+36
	mov	DWORD PTR ?b_altF4@@3HA, 1		; b_altF4
	call	?Defer@CEventAPI@@QAEXPBD_K1@Z		; CEventAPI::Defer

; 223  : 		Engine.Event.Defer	("KERNEL:quit");

	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0M@BKEEDDOA@KERNEL?3quit?$AA@
	mov	ecx, OFFSET ?Engine@@3VCEngine@@A+36
	call	?Defer@CEventAPI@@QAEXPBD_K1@Z		; CEventAPI::Defer

; 224  : 	}
; 225  : 
; 226  : 
; 227  : #endif
; 228  : 	if(b_altF4)					return;

	cmp	DWORD PTR ?b_altF4@@3HA, 0		; b_altF4
	jne	$LN1@KeyUpdate
$LN75@KeyUpdate:

; 229  : 
; 230  : 	if(Device.dwPrecacheFrame==0)

	cmp	DWORD PTR ?Device@@3VCRenderDevice@@A+12, 0
	jne	$LN1@KeyUpdate

; 231  : 	{
; 232  : 
; 233  : 		for (u32 i = 0; i < dwElements; i++)

	xor	ebx, ebx
	cmp	DWORD PTR _dwElements$[esp+1304], ebx
	jbe	SHORT $LN11@KeyUpdate
	lea	edi, DWORD PTR _od$[esp+1304]
	npad	3
$LL13@KeyUpdate:

; 234  : 		{
; 235  : 			if(od[i].uAppData == 666) //ignored action

	cmp	DWORD PTR [edi+16], 666			; 0000029aH
	je	SHORT $LN12@KeyUpdate

; 236  : 				continue;
; 237  : 
; 238  : 			key					= od[i].dwOfs;
; 239  : 			if(od[i].dwData & 0x80)

	test	BYTE PTR [edi+4], 128			; 00000080H

; 240  : 				cbStack.back()->IR_OnKeyboardPress	( key );

	mov	ecx, DWORD PTR [ebp+1100]
	mov	esi, DWORD PTR [edi]
	mov	ecx, DWORD PTR [ecx-4]
	mov	edx, DWORD PTR [ecx]
	push	esi
	je	SHORT $LN9@KeyUpdate
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 241  : 			else

	jmp	SHORT $LN12@KeyUpdate
$LN9@KeyUpdate:

; 242  : 			{
; 243  : 				cbStack.back()->IR_OnKeyboardRelease	( key );

	mov	eax, DWORD PTR [edx+36]
	call	eax

; 244  : 	#ifndef _EDITOR
; 245  : 				if(key==DIK_TAB  && (iGetAsyncKeyState(DIK_RMENU) || iGetAsyncKeyState(DIK_LMENU)) )

	cmp	esi, 15					; 0000000fH
	jne	SHORT $LN12@KeyUpdate
	cmp	DWORD PTR [ebp+808], 0
	jne	SHORT $LN6@KeyUpdate
	cmp	DWORD PTR [ebp+296], 0
	je	SHORT $LN12@KeyUpdate
$LN6@KeyUpdate:

; 246  : 					b_alt_tab = true;

	mov	BYTE PTR _b_alt_tab$[esp+1304], 1
$LN12@KeyUpdate:

; 231  : 	{
; 232  : 
; 233  : 		for (u32 i = 0; i < dwElements; i++)

	add	ebx, 1
	add	edi, 20					; 00000014H
	cmp	ebx, DWORD PTR _dwElements$[esp+1304]
	jb	SHORT $LL13@KeyUpdate
$LN11@KeyUpdate:

; 247  : 	#endif
; 248  : 			}
; 249  : 		}
; 250  : 
; 251  : 		for ( i = 0; i < COUNT_KB_BUTTONS; i++ )

	xor	esi, esi
	lea	edi, DWORD PTR [ebp+72]
$LL5@KeyUpdate:

; 252  : 			if (KBState[i]) 

	cmp	DWORD PTR [edi], 0
	je	SHORT $LN4@KeyUpdate

; 253  : 				cbStack.back()->IR_OnKeyboardHold( i );

	mov	ecx, DWORD PTR [ebp+1100]
	mov	ecx, DWORD PTR [ecx-4]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+40]
	push	esi
	call	eax
$LN4@KeyUpdate:
	add	esi, 1
	add	edi, 4
	cmp	esi, 256				; 00000100H
	jb	SHORT $LL5@KeyUpdate

; 254  : 	}
; 255  : 
; 256  : #ifndef _EDITOR
; 257  : 	if(b_alt_tab)

	cmp	BYTE PTR _b_alt_tab$[esp+1304], 0
	je	SHORT $LN1@KeyUpdate

; 258  : 		SendMessage(Device.m_hWnd, WM_SYSCOMMAND, SC_MINIMIZE, 0);

	mov	ecx, DWORD PTR ?Device@@3VCRenderDevice@@A+760
	push	0
	push	61472					; 0000f020H
	push	274					; 00000112H
	push	ecx
	call	DWORD PTR __imp__SendMessageA@16
$LN1@KeyUpdate:

; 259  : #endif
; 260  : /*
; 261  : #ifndef _EDITOR
; 262  : //update xinput if exist
; 263  :     for( DWORD iUserIndex=0; iUserIndex<DXUT_MAX_CONTROLLERS; iUserIndex++ )
; 264  : 	{
; 265  :         DXUTGetGamepadState( iUserIndex, &g_GamePads[iUserIndex], true, false );
; 266  : 
; 267  :         if( !g_GamePads[iUserIndex].bConnected )
; 268  :             continue; // unplugged?
; 269  : 
; 270  : 		bool new_b, old_b;
; 271  : 		new_b = !!(g_GamePads[iUserIndex].wPressedButtons & XINPUT_GAMEPAD_A);
; 272  : 		old_b = !!(g_GamePads[iUserIndex].wLastButtons & XINPUT_GAMEPAD_A);
; 273  : 
; 274  : 		if(new_b != old_b)
; 275  : 		{
; 276  : 			if(old_b)
; 277  : 				cbStack.back()->IR_OnMousePress(0);
; 278  : 			else
; 279  : 				cbStack.back()->IR_OnMouseRelease(0);
; 280  : 		}
; 281  : 		int dx,dy;
; 282  : 		dx = iFloor(g_GamePads[iUserIndex].fThumbRX*6);
; 283  : 		dy = iFloor(g_GamePads[iUserIndex].fThumbRY*6);
; 284  : 		if(dx || dy)
; 285  : 			cbStack.back()->IR_OnMouseMove	( dx, dy );
; 286  : 	}
; 287  : 
; 288  : 	if(Device.fTimeGlobal > stop_vibration_time)
; 289  : 	{
; 290  : 		stop_vibration_time		= flt_max;
; 291  : 		set_vibration			(0, 0);
; 292  : 	}
; 293  : //xinput
; 294  : #endif
; 295  : */
; 296  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?KeyUpdate@CInput@@AAEXXZ ENDP				; CInput::KeyUpdate
; Function compile flags: /Ogtpy
;	COMDAT ?OnFrame@CInput@@UAGXXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?OnFrame@CInput@@UAGXXZ PROC				; CInput::OnFrame, COMDAT

; 503  : 	RDEVICE.Statistic->Input.Begin			();

	mov	eax, DWORD PTR __imp_?g_bEnableStatGather@@3HA
	push	esi
	mov	esi, DWORD PTR ?Device@@3VCRenderDevice@@A+920
	push	edi
	xor	edi, edi
	add	esi, 2552				; 000009f8H
	cmp	DWORD PTR [eax], edi
	je	SHORT $LN9@OnFrame@9
	add	DWORD PTR [esi+68], 1
	cmp	DWORD PTR [esi+24], edi
	jne	SHORT $LN9@OnFrame@9
	call	DWORD PTR __imp_?QPC@CPU@@YA_KXZ
	sub	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [esi+40], edi
	sbb	edx, DWORD PTR [esi+20]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], edx
	mov	DWORD PTR [esi+44], edi
	mov	DWORD PTR [esi+48], edi
	mov	DWORD PTR [esi+52], edi
$LN9@OnFrame@9:

; 504  : 	dwCurTime		= RDEVICE.TimerAsync_MMT	();

	mov	ecx, OFFSET ?Device@@3VCRenderDevice@@A+800
	call	DWORD PTR __imp_?GetElapsed_ms@CTimer@@QBEIXZ
	add	eax, DWORD PTR ?Device@@3VCRenderDevice@@A+500
	mov	esi, DWORD PTR _this$[esp+4]

; 505  : 	if (pKeyboard)	KeyUpdate				();

	cmp	DWORD PTR [esi+20], edi
	mov	DWORD PTR [esi+2992], eax
	je	SHORT $LN2@OnFrame@9
	mov	ecx, esi
	call	?KeyUpdate@CInput@@AAEXXZ		; CInput::KeyUpdate
$LN2@OnFrame@9:

; 506  : 	if (pMouse)		MouseUpdate				();

	cmp	DWORD PTR [esi+16], edi
	je	SHORT $LN1@OnFrame@9
	mov	ecx, esi
	call	?MouseUpdate@CInput@@AAEXXZ		; CInput::MouseUpdate
$LN1@OnFrame@9:

; 507  : 	RDEVICE.Statistic->Input.End			();

	mov	esi, DWORD PTR ?Device@@3VCRenderDevice@@A+920
	mov	ecx, DWORD PTR __imp_?g_bEnableStatGather@@3HA
	add	esi, 2552				; 000009f8H
	cmp	DWORD PTR [ecx], edi
	je	SHORT $LN17@OnFrame@9
	mov	ecx, esi
	call	DWORD PTR __imp_?GetElapsed_ticks@CTimer@@QBE_KXZ
	add	DWORD PTR [esi+56], eax
	adc	DWORD PTR [esi+60], edx
$LN17@OnFrame@9:
	pop	edi
	pop	esi

; 508  : }

	ret	4
?OnFrame@CInput@@UAGXXZ ENDP				; CInput::OnFrame
_TEXT	ENDS
PUBLIC	?iCapture@CInput@@QAEXPAVIInputReceiver@@@Z	; CInput::iCapture
; Function compile flags: /Ogtpy
;	COMDAT ?iCapture@CInput@@QAEXPAVIInputReceiver@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?iCapture@CInput@@QAEXPAVIInputReceiver@@@Z PROC	; CInput::iCapture, COMDAT
; _this$ = ecx

; 438  : {

	push	esi
	mov	esi, ecx

; 439  : 	VERIFY(p);
; 440  : 	if (pMouse) 	MouseUpdate();

	cmp	DWORD PTR [esi+16], 0
	push	edi
	je	SHORT $LN3@iCapture
	call	?MouseUpdate@CInput@@AAEXXZ		; CInput::MouseUpdate
$LN3@iCapture:

; 441  :     if (pKeyboard) 	KeyUpdate();

	cmp	DWORD PTR [esi+20], 0
	je	SHORT $LN2@iCapture
	mov	ecx, esi
	call	?KeyUpdate@CInput@@AAEXXZ		; CInput::KeyUpdate
$LN2@iCapture:

; 442  : 
; 443  :     // change focus
; 444  : 	if (!cbStack.empty())

	lea	edi, DWORD PTR [esi+1096]
	mov	ecx, edi
	call	?empty@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@QBE_NXZ ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::empty
	test	al, al
	jne	SHORT $LN1@iCapture

; 445  : 		cbStack.back()->IR_OnDeactivate();

	mov	eax, DWORD PTR [esi+1100]
	mov	ecx, DWORD PTR [eax-4]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	call	eax
$LN1@iCapture:

; 446  : 	cbStack.push_back(p);

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, DWORD PTR [edi+8]
	je	SHORT $LN30@iCapture
	lea	ecx, DWORD PTR _p$[esp+4]
	push	ecx
	push	eax
	call	??$_Copy_Construct@PAX@stlp_std@@YAXPAPAXABQAX@Z ; stlp_std::_Copy_Construct<void *>
	add	esp, 8
	add	DWORD PTR [edi+4], 4
	jmp	SHORT $LN29@iCapture
$LN30@iCapture:
	push	1
	push	1
	push	eax
	lea	eax, DWORD PTR _p$[esp+16]
	call	?_M_insert_overflow@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@AAEXPAPAXABQAXABU__true_type@3@I_N@Z ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::_M_insert_overflow
$LN29@iCapture:

; 447  : 	cbStack.back()->IR_OnActivate();

	mov	edx, DWORD PTR [esi+1100]
	mov	ecx, DWORD PTR [edx-4]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+4]
	call	edx

; 448  : 
; 449  : 	// prepare for _new_ controller
; 450  : 	ZeroMemory			( timeStamp,	sizeof(timeStamp) );

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	edx, DWORD PTR [ecx+12]
	push	12					; 0000000cH
	push	0
	lea	eax, DWORD PTR [esi+24]
	push	eax
	call	edx

; 451  : 	ZeroMemory			( timeSave,		sizeof(timeStamp) );

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	edx, DWORD PTR [ecx+12]
	push	12					; 0000000cH
	push	0
	lea	eax, DWORD PTR [esi+36]
	push	eax
	call	edx

; 452  : 	ZeroMemory			( offs,			sizeof(offs) );

	mov	eax, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ecx, DWORD PTR [eax+12]
	push	12					; 0000000cH
	push	0
	add	esi, 48					; 00000030H
	push	esi
	call	ecx

; 453  : }

	pop	edi
	pop	esi
	ret	4
?iCapture@CInput@@QAEXPAVIInputReceiver@@@Z ENDP	; CInput::iCapture
_TEXT	ENDS
PUBLIC	??0CInput@@QAE@HH@Z				; CInput::CInput
; Function compile flags: /Ogtpy
;	COMDAT ??0CInput@@QAE@HH@Z
_TEXT	SEGMENT
_I$538223 = -12						; size = 12
_I$538214 = -12						; size = 12
_bExclusive$ = 8					; size = 4
_deviceForInit$ = 12					; size = 4
??0CInput@@QAE@HH@Z PROC				; CInput::CInput, COMDAT
; _this$ = ecx

; 43   : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi

; 44   : 	g_exclusive							= !!bExclusive;

	mov	esi, DWORD PTR _bExclusive$[esp+20]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [edi+4], OFFSET ??_7pureAppActivate@@6B@
	mov	DWORD PTR [edi+8], OFFSET ??_7pureAppDeactivate@@6B@
	xor	eax, eax
	lea	ebp, DWORD PTR [edi+4]
	mov	DWORD PTR [edi], OFFSET ??_7CInput@@6BpureFrame@@@
	mov	DWORD PTR [ebp], OFFSET ??_7CInput@@6BpureAppActivate@@@
	mov	DWORD PTR [edi+8], OFFSET ??_7CInput@@6BpureAppDeactivate@@@
	mov	DWORD PTR [edi+1096], eax
	mov	DWORD PTR [edi+1100], eax
	cmp	esi, eax
	mov	DWORD PTR [edi+1104], eax
	setne	al

; 45   : 
; 46   : 	Log("Starting INPUT device...");

	push	OFFSET ??_C@_0BJ@CPDBDIOG@Starting?5INPUT?5device?4?4?4?$AA@
	mov	BYTE PTR _g_exclusive, al
	call	DWORD PTR __imp_?Log@@YAXPBD@Z
	add	esp, 4

; 47   : 
; 48   : 	pDI 								=	NULL;
; 49   : 	pMouse								=	NULL;
; 50   : 	pKeyboard							=	NULL;
; 51   : 
; 52   : 	//=====================Mouse
; 53   : 	mouse_property.mouse_dt				=	25;
; 54   : 
; 55   : 	ZeroMemory							( mouseState,	sizeof(mouseState) );

	push	12					; 0000000cH
	lea	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR [ebx], 0
	mov	DWORD PTR [edi+16], 0
	mov	DWORD PTR [edi+20], 0
	mov	DWORD PTR [edi+2048], 25		; 00000019H
	mov	edx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	eax, DWORD PTR [edx+12]
	push	0
	lea	ecx, DWORD PTR [edi+60]
	push	ecx
	call	eax

; 56   : 	ZeroMemory							( KBState,		sizeof(KBState) );

	mov	edx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	eax, DWORD PTR [edx+12]
	push	1024					; 00000400H
	push	0
	lea	ecx, DWORD PTR [edi+72]
	push	ecx
	call	eax

; 57   : 	ZeroMemory							( timeStamp,	sizeof(timeStamp) );

	mov	edx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	eax, DWORD PTR [edx+12]
	push	12					; 0000000cH
	push	0
	lea	ecx, DWORD PTR [edi+24]
	push	ecx
	call	eax

; 58   : 	ZeroMemory							( timeSave,		sizeof(timeStamp) );

	mov	edx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	eax, DWORD PTR [edx+12]
	push	12					; 0000000cH
	push	0
	lea	ecx, DWORD PTR [edi+36]
	push	ecx
	call	eax

; 59   : 	ZeroMemory							( offs,			sizeof(offs) );

	mov	edx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	eax, DWORD PTR [edx+12]
	push	12					; 0000000cH
	push	0
	lea	ecx, DWORD PTR [edi+48]
	push	ecx
	call	eax

; 60   : 
; 61   : 	//===================== Dummy pack
; 62   : 	iCapture	(&dummyController);

	push	OFFSET ?dummyController@@3VIInputReceiver@@A ; dummyController
	mov	ecx, edi
	call	?iCapture@CInput@@QAEXPAVIInputReceiver@@@Z ; CInput::iCapture

; 63   : 
; 64   : 	if (!pDI) CHK_DX(DirectInput8Create( GetModuleHandle(NULL), DIRECTINPUT_VERSION, IID_IDirectInput8, (void**)&pDI, NULL ));

	cmp	DWORD PTR [ebx], 0
	jne	SHORT $LN3@CInput@2
	push	0
	push	ebx
	push	OFFSET _IID_IDirectInput8A
	push	2048					; 00000800H
	push	0
	call	DWORD PTR __imp__GetModuleHandleA@4
	push	eax
	call	_DirectInput8Create@20
$LN3@CInput@2:

; 65   : 
; 66   : //.	u32 kb_input_flags = ((bExclusive)?DISCL_EXCLUSIVE:DISCL_NONEXCLUSIVE) | DISCL_FOREGROUND;
; 67   : 	u32 kb_input_flags = ((bExclusive)?DISCL_EXCLUSIVE:DISCL_NONEXCLUSIVE) | DISCL_FOREGROUND;
; 68   : 	
; 69   : //.	u32 mouse_input_flags = ((bExclusive)?DISCL_EXCLUSIVE:DISCL_NONEXCLUSIVE) | DISCL_FOREGROUND | DISCL_NOWINKEY,
; 70   : 	u32 mouse_input_flags = ((bExclusive)?DISCL_EXCLUSIVE:DISCL_NONEXCLUSIVE) | DISCL_FOREGROUND | DISCL_NOWINKEY;

	neg	esi
	sbb	esi, esi
	add	esi, 2
	mov	ebx, esi
	or	ebx, 20					; 00000014H

; 71   : 
; 72   : 	// KEYBOARD
; 73   : 	if (deviceForInit & keyboard_device_key)

	test	BYTE PTR _deviceForInit$[esp+24], 2
	je	SHORT $LN2@CInput@2

; 74   : 		CHK_DX(CreateInputDevice(
; 75   : 		&pKeyboard, 	GUID_SysKeyboard, 	&c_dfDIKeyboard,
; 76   : 		kb_input_flags,
; 77   : 		KEYBOARDBUFFERSIZE ));

	mov	ecx, DWORD PTR _GUID_SysKeyboard
	mov	edx, DWORD PTR _GUID_SysKeyboard+4
	push	64					; 00000040H
	or	esi, 4
	push	esi
	push	OFFSET _c_dfDIKeyboard
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _GUID_SysKeyboard+8
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR _GUID_SysKeyboard+12
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], edx
	lea	eax, DWORD PTR [edi+20]
	push	eax
	mov	ecx, edi
	call	?CreateInputDevice@CInput@@AAEJPAPAUIDirectInputDevice8A@@U_GUID@@PBU_DIDATAFORMAT@@II@Z ; CInput::CreateInputDevice
$LN2@CInput@2:

; 78   : 
; 79   : 	// MOUSE
; 80   : 	if (deviceForInit & mouse_device_key)

	test	BYTE PTR _deviceForInit$[esp+24], 1
	je	SHORT $LN1@CInput@2

; 81   : 		CHK_DX(CreateInputDevice(
; 82   : 		&pMouse,		GUID_SysMouse,		&c_dfDIMouse2,
; 83   : 		mouse_input_flags,
; 84   : 		MOUSEBUFFERSIZE ));

	mov	ecx, DWORD PTR _GUID_SysMouse
	mov	edx, DWORD PTR _GUID_SysMouse+4
	push	64					; 00000040H
	push	ebx
	push	OFFSET _c_dfDIMouse2
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _GUID_SysMouse+8
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR _GUID_SysMouse+12
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], edx
	lea	eax, DWORD PTR [edi+16]
	push	eax
	mov	ecx, edi
	call	?CreateInputDevice@CInput@@AAEJPAPAUIDirectInputDevice8A@@U_GUID@@PBU_DIDATAFORMAT@@II@Z ; CInput::CreateInputDevice
$LN1@CInput@2:

; 85   : 
; 86   : 	Debug.set_on_dialog				(&on_error_dialog);

	mov	eax, DWORD PTR __imp_?Debug@@3VxrDebug@@A

; 87   : 
; 88   : #ifdef ENGINE_BUILD
; 89   : 	Device.seqAppActivate.Add		(this);

	lea	ecx, DWORD PTR _I$538214[esp+28]
	push	ecx
	mov	ecx, OFFSET ?Device@@3VCRenderDevice@@A+664
	mov	DWORD PTR [eax+4], OFFSET ?on_error_dialog@@YAX_N@Z ; on_error_dialog
	mov	DWORD PTR _I$538214[esp+32], ebp
	mov	DWORD PTR _I$538214[esp+36], 572662306	; 22222222H
	mov	DWORD PTR _I$538214[esp+40], 0
	call	?push_back@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@stlp_std@@QAEXABU_REG_INFO@@@Z ; stlp_std::vector<_REG_INFO,xalloc<_REG_INFO> >::push_back
	test	BYTE PTR ?Device@@3VCRenderDevice@@A+676, 1
	je	SHORT $LN35@CInput@2
	or	DWORD PTR ?Device@@3VCRenderDevice@@A+676, 2
	jmp	SHORT $LN34@CInput@2
$LN35@CInput@2:
	mov	esi, OFFSET ?Device@@3VCRenderDevice@@A+664
	call	?Resort@?$CRegistrator@VpureAppActivate@@@@QAEXXZ ; CRegistrator<pureAppActivate>::Resort
$LN34@CInput@2:

; 90   : 	Device.seqAppDeactivate.Add		(this, REG_PRIORITY_HIGH);

	lea	edx, DWORD PTR _I$538223[esp+28]
	lea	eax, DWORD PTR [edi+8]
	push	edx
	mov	ecx, OFFSET ?Device@@3VCRenderDevice@@A+680
	mov	DWORD PTR _I$538223[esp+32], eax
	mov	DWORD PTR _I$538223[esp+36], 858993459	; 33333333H
	mov	DWORD PTR _I$538223[esp+40], 0
	call	?push_back@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@stlp_std@@QAEXABU_REG_INFO@@@Z ; stlp_std::vector<_REG_INFO,xalloc<_REG_INFO> >::push_back
	test	BYTE PTR ?Device@@3VCRenderDevice@@A+692, 1
	je	SHORT $LN43@CInput@2
	or	DWORD PTR ?Device@@3VCRenderDevice@@A+692, 2
	jmp	SHORT $LN42@CInput@2
$LN43@CInput@2:
	mov	esi, OFFSET ?Device@@3VCRenderDevice@@A+680
	call	?Resort@?$CRegistrator@VpureAppDeactivate@@@@QAEXXZ ; CRegistrator<pureAppDeactivate>::Resort
$LN42@CInput@2:

; 91   : 	Device.seqFrame.Add				(this, REG_PRIORITY_HIGH);

	push	0
	push	858993459				; 33333333H
	push	edi
	mov	ecx, OFFSET ?Device@@3VCRenderDevice@@A+728
	call	?Add@?$CRegistrator@VpureFrame@@@@QAEXPAVpureFrame@@HI@Z ; CRegistrator<pureFrame>::Add

; 92   : #endif
; 93   : }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	8
??0CInput@@QAE@HH@Z ENDP				; CInput::CInput
PUBLIC	?dummyController@@3VIInputReceiver@@A		; dummyController
?dummyController@@3VIInputReceiver@@A DD FLAT:??_7IInputReceiver@@6B@ ; dummyController
PUBLIC	?stop_vibration_time@@3MA			; stop_vibration_time
?stop_vibration_time@@3MA DD 07f7fffffr		; 3.40282e+038 ; stop_vibration_time
END

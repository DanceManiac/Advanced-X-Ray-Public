; AutoExp.Dat - templates for automatically expanding data
; Copyright(c) Microsoft Corporation. All Rights Reserved.
;---------------------------------------------------------------
;
; While debugging, Data Tips and items in the Watch and Variable
; windows are automatically expanded to show their most important
; elements. The expansion follows the format given by the rules
; in this file. You can add rules for your types or change the
; predefined rules.
;
; For good examples, read the rules in this file.
;
; To find what the debugger considers the type of a variable to
; be, add it to the Watch window and look at the Type column.
;
; An AutoExpand rule is a line with the name of a type, an equals 
; sign, and text with replaceable parts in angle brackets. The 
; part in angle brackets names a member of the type and an 
; optional Watch format specifier.
;
; AutoExpand rules use the following syntax. The equals sign (=), 
; angle brackets (<>), and comma are taken literally. Square
; brackets ([]) indicate optional items.
;
; type=[text]<member[,format]>...
;
; type      Name of the type (may be followed by <*> for template
;           types such as the ATL types listed below).
;
; text      Any text.Usually the name of the member to display, 
;           or a shorthand name for the member.
;
; member    Name of a member to display.
;
; format    Watch format specifier. One of the following:
;
;   Letter  Description                 Sample         Display
;   ------  --------------------------  ------------   -------------
;   d,i     Signed decimal integer      0xF000F065,d   -268373915
;   u       Unsigned decimal integer    0x0065,u       101
;   o       Unsigned octal integer      0xF065,o       0170145
;   x,X     Hexadecimal integer         61541,X        0X0000F065
;   l,h     long or short prefix for    00406042,hx    0x0c22
;             d, i, u, o, x, X
;   f       Signed floating-point       3./2.,f        1.500000
;   e       Signed scientific-notation  3./2.,e        1.500000e+000
;   g       Shorter of e and f          3./2.,g        1.5
;   c       Single character            0x0065,c       'e'
;   s       Zero-terminated string      pVar,s         "Hello world"
;   su      Unicode string              pVar,su        "Hello world"
;
; For details of other format specifiers see Help under:
; "format specifiers/watch variable"
;
; The special format <,t> specifies the name of the most-derived 
; type of the object. This is especially useful with pointers or
; references to a base class.
;
; If there is no rule for a class, the base classes are checked for
; a matching rule.
;
; There are some special entries allowed in the AutoExpand section:
; $BUILTIN is used to display more complex types that need to do more
; than just show a member variable or two.
; $ADDIN allows external DLLs to be added to display even more complex
; types via the EE Add-in API. The first argument is the DLL name, the
; second argument is the name of the export from the DLL to use. For 
; further information on this API see the sample called EEAddIn.
;
; WARNING: if hexadecimal mode is on in the watch window, all numbers here are
; evaluated in hex, e.g. 42 becomes 0x42

[AutoExpand]

; from xrCore.h
shared_str =<p_->value>

; from windef.h
tagPOINT =x=<x> y=<y>
tagRECT =top=<top> bottom=<bottom> left=<left> right=<right>

; from winuser.h
tagMSG =msg=<message,x> wp=<wParam,x> lp=<lParam,x>

; intrinsics
__m64 =<m64_i64,x>
__m128=$BUILTIN(M128)
__m128i=$BUILTIN(M128I)
__m128d=$BUILTIN(M128D)

; from afxwin.h
CDC =hDC=<m_hDC> attrib=<m_hAttribDC>
CPaintDC =<,t> hWnd=<m_hWnd>
CPoint =x=<x> y=<y>
CRect =top=<top> bottom=<bottom> left=<left> right=<right>
CSize =cx=<cx> cy=<cy>
CWnd =<,t> hWnd=<m_hWnd>
CWinApp =<,t> <m_pszAppName,s>
CWinThread =<,t> h=<m_hThread> proc=<m_pfnThreadProc>

; from afxcoll.h
CPtrList =cnt=<m_nCount>

; from afxstat_.h
CProcessLocalObject =<,t>
CThreadLocalObject =<,t>

; from afx.h
CArchiveException =cause=<m_cause>
CFile =hFile=<m_hFile> name=<m_strFileName.m_pchData,s>
CFileException =cause=<m_cause> OS Error=m_lOsError
CMemFile =pos=<m_nPosition> size=<m_nFileSize>
CObject =<,t>
CRuntimeClass =<m_lpszClassName,s>
CStdioFile =FILE*=<m_pStream> name=<m_strFilename.m_pchData,s>
CTimeSpan =time=<m_time>
CTime =time=<m_time>

; from afxcoll.h
CByteArray =count=<m_nCount>
CStringList =count=<m_nCount>
; same for all CXXXArray classes
; same for CXXXList
; same for CMapXXToXX

; various string classes from MFC & ATL

_com_error=<m_hresult,hr>
_bstr_t=<m_Data->m_wstr,su> (<m_Data->m_RefCount,u>)
_com_ptr_t<*>=<m_pInterface>
_LARGE_INTEGER=<QuadPart>
_ULARGE_INTEGER=<QuadPart>
ATL::CComPtr<*>=<p>

ATL::CComQIPtr<*>=<p>

tagVARIANT=$BUILTIN(VARIANT)
VARIANT=$BUILTIN(VARIANT)
_GUID=$BUILTIN(GUID)

; see EEAddIn sample for how to use these
;_SYSTEMTIME=$ADDIN(EEAddIn.dll,AddIn_SystemTime)
;_FILETIME=$ADDIN(EEAddIn.dll,AddIn_FileTime)

std::binder1st<*>= op=<op> value=<value>
std::binder2nd<*>= op=<op> value=<value>
std::less<*>=lessthan
std::greater<*>=greaterthan
_D3DVECTOR=<x,g>, <y,g>, <z,g>
D3DXPLANE=<a,g>, <b,g>, <c,g>, <d,g>
D3DXVECTOR4=<x,g>, <y,g>, <z,g>, <w,g>
D3DXVECTOR2=<x,g>, <y,g>
_D3DBOX=<Left,u>, <Top,u>, <Right,u>, <Bottom,u>, <Front,u>, <Back,u>
_D3DRECT=<x1,u>, <y1,u>, <x2,u>, <y2,u>
D3DXQUATERNION=<x,g>, <y,g>, <z,g>, <w,g>
D3DXCOLOR=<r,g>, <g,g>, <b,g>, <a,g>

[Visualizer]
; This section contains visualizers for STL and ATL containers
; DO NOT MODIFY

;------------------------------------------------------------------------------
;-- lua visualizers
;------------------------------------------------------------------------------
lua_State {
	preview (
		#(
			"thread top=", [$c.top-$c.base, i]
		)
	)

	children (
		#(
			[raw members]: [$c,!],
			stack size: [$c.top-$c.base, i],
			globals: [$c.l_gt],
			registry: [$c.l_G->l_registry],

			#array (
				expr: $e.ci->func,
				size: $e.ci->func->tt != 0,
			): #( call: $e ),

			#array (
				expr: $c.base[$i],
				size: $c.top - $c.base,
				base: 1
			)
		)
	)
	
}

Node {
	preview (
		#( $c.i_key.tvk, " = ", $c.i_val )
	)
	children (
		#(
			key: $c.i_key.tvk,
			val: $c.i_val,
			#if( $c.i_key.nk.next != 0 ) (
				#( next: $c.i_key.nk.next )
			)
		)
	)
}

lua_TValue {
	children (
		#switch($c.tt)
		#case 2 (							; LUA_TLIGHTUSERDATA
			ptr: #((const char*)($c.value.p))
		)
		#case 5 ( 							; LUA_TTABLE
			#(
				[raw]: [$c,!],
				array size: $c.value.gc->h.sizearray,
				#array (
					expr: $e.value.gc->h.metatable,
					size: $e.value.gc->h.metatable != 0,
				): #( metatable: $e ),
				
				#array (
					expr: $c.value.gc->h.array[$i],
					size: $c.value.gc->h.sizearray,
					base: 1
				),
				#array (
					expr: #( $c.value.gc->h.node[$i], 2 ),
					size: (1<<$c.value.gc->h.lsizenode),
					base: 1
				): #( hash part: $e )
			)	
		)
		#case 6 (							; LUA_TFUNCTION
			#if ($c.value.gc->cl.c.isC) (
				#(
					env: $c.value.gc->cl.c.env,
					#array (
						expr: $e.value.gc->cl.c.upvalue[$i],
						size: $e.value.gc->cl.c.nupvalues,
					): #( upvalues: $e )
				)
			) #else (
				#($c.value.gc->cl.l)
			)
			
		)
		#case 7 (							; LUA_TUSERDATA
			#(
				#array (
					expr: $e.value.gc->u.uv.metatable,
					size: $e.value.gc->u.uv.metatable != 0,
				): #( metatable: $e ),
				env: $c.value.gc->u.uv.env,
				ptr: #((const char*)((&$c.value.gc->u)+1)),
				size: $c.value.gc->u.uv.len
			)
		)
		#case 8 ( #($c.value.gc->th) )		; LUA_TTHREAD
		
	)

	preview (
		#switch($c.tt)
		#case 0 ( "nil" )					; LUA_TNIL
		#case 1 (
			#if ($c.value.b == 0) (
				"false"
			) #else (
				"true"
			)
		)
		#case 2 (							; LUA_TLIGHTUSERDATA
		  #($c.value.p, " lightuserdata") )
		#case 3 (							; LUA_TNUMBER
		  #("number=", $c.value.n) )
		#case 4 (							; LUA_TSTRING
		  #( $c.value.gc->ts) )
		#case 5 ( 	; LUA_TTABLE
			#( "table" )
		)
		
		#case 6 ( #($c.value.gc->cl) )		; LUA_TFUNCTION
		#case 7 ( #($c.value.gc->u) )		; LUA_TUSERDATA
		#case 8 ( #($c.value.gc->th) )		; LUA_TTHREAD
		#default ( "empty" )
		)
	)
}

Udata {
	preview (
		#( "userdata size=", $c.uv.len, " ptr=", #((void*)((&$c)+1)) )
	)
}

CClosure {
	preview (
		$c.f
	)
}
LClosure {
	preview (
		"Lua function"
	)
}

Closure {
	preview (
		#if ($c.c.isC) ( #($c.c) )
		#else ( #($c.value.gc->cl.l) )
	)
}

Table {
	children (
			#(
				[raw]: [$c,!],
				[array size]: $c.sizearray,
				#array (
					expr: $e.metatable,
					size: $e.metatable != 0,
				): #( metatable: $e ),
				
				#array (
					expr: $c.array[$i],
					size: $c.sizearray,
					base: 1
				),
				#array (
					expr: #( $c.node[$i], 2 ),
					size: (1<<$c.lsizenode),
					base: 1
				): #( key: $e )
			)	
	)

	preview (
		#( "table" )
	)
}

TString {
	preview (
		#( (const char *) (&($c.tsv)+1) )
	)
}


;------------------------------------------------------------------------------
; This is the description of STLport data structures in Visual Studio debugger
; language. Those descriptions has been tested with Visual C++ 2005 Express
; Edition, you are welcome to report successful usage with any other Visual
; Studio version.
; Those descriptions has been tested with STLport 5.2.0 but it should also work
; with 5.1 release.
; How to use: Copy/Paste this file content in the autoexp.dat file you will find
; in your Visual Studio install, for instance
; C:\Program Files\Microsoft Visual Studio 8\Common7\Packages\Debugger, in the
; [Visualizer] section.
; TODO: Enhance debug iterator visualization to report end iterators.
; TODO: Add visualization for rope.
; TODO: Fix bitset visualization.
;------------------------------------------------------------------------------
;------------------------------------------------------------------------------
; stlport::basic_string
;------------------------------------------------------------------------------
xr_string|stlp_std::basic_string<char,*>|stlpx_std::basic_string<char,*>|stlpmtx_std::basic_string<char,*>|stlpxmtx_std::basic_string<char,*>|stlpd_std::priv::_NonDbg_str<char,*>|stlpdx_std::priv::_NonDbg_str<char,*>|stlpdmtx_std::priv::_NonDbg_str<char,*>|stlpdxmtx_std::priv::_NonDbg_str<char,*>{
    preview
    (
        #if (($c._M_end_of_storage._M_data) == ($c._M_buffers._M_static_buf + $c._DEFAULT_SIZE))
        (
            [$c._M_Buffers._M_static_buf, s]
        )
        #else
        (
            [$c._M_Buffers._M_dynamic_buf, s]
        )
    )

    stringview
    (
        #if (($c._M_end_of_storage._M_data) == ($c._M_buffers._M_static_buf + $c._DEFAULT_SIZE))
        (
            [$c._M_Buffers._M_static_buf, s]
        )
        #else
        (
            [$c._M_Buffers._M_dynamic_buf, s]
        )
    )

    children
    (
        #(
            [raw view]: [$c,!],
            buffer: #if (($c._M_end_of_storage._M_data) == ($c._M_buffers._M_static_buf + $c._DEFAULT_SIZE))
                    (
                        [(unsigned int)$c._M_Buffers._M_static_buf, x]
                    )
                    #else
                    (
                        [(unsigned int)$c._M_Buffers._M_dynamic_buf, x]
                    ),
            length: #if (($c._M_end_of_storage._M_data) == ($c._M_buffers._M_static_buf + $c._DEFAULT_SIZE))
                    (
                        [$c._M_finish - $c._M_buffers._M_static_buf]
                    )
                    #else
                    (
                        [$c._M_finish - $c._M_buffers._M_dynamic_buf]
                    ),
            capacity: #if (($c._M_end_of_storage._M_data) == ($c._M_buffers._M_static_buf + $c._DEFAULT_SIZE))
                      (
                          [$c._M_end_of_storage._M_data - $c._M_buffers._M_static_buf]
                      )
                      #else
                      (
                          [$c._M_end_of_storage._M_data - $c._M_buffers._M_dynamic_buf]
                      ),
            #if (($c._M_end_of_storage._M_data) == ($c._M_buffers._M_static_buf + $c._DEFAULT_SIZE))
            (
                #array
                (
                                        expr: $c._M_buffers._M_static_buf[$i],
                                        size: $c._M_finish - $c._M_buffers._M_static_buf
                                )
            )
            #else
            (
                #array
                (
                                        expr: $c._M_buffers._M_dynamic_buf[$i],
                                        size: $c._M_finish - $c._M_buffers._M_dynamic_buf
                                )
            )
        )
    )
}

stlp_std::basic_string<unsigned short,*>|stlp_std::basic_string<wchar_t,*>|stlpx_std::basic_string<unsigned short,*>|stlpx_std::basic_string<wchar_t,*>|stlpmtx_std::basic_string<unsigned short,*>|stlpmtx_std::basic_string<wchar_t,*>|stlpxmtx_std::basic_string<unsigned short,*>|stlpxmtx_std::basic_string<wchar_t,*>|stlpd_std::priv::_NonDbg_str<unsigned short,*>|stlpd_std::priv::_NonDbg_str<wchar_t,*>|stlpdx_std::priv::_NonDbg_str<unsigned short,*>|stlpdx_std::priv::_NonDbg_str<wchar_t,*>|stlpdmtx_std::priv::_NonDbg_str<unsigned short,*>|stlpdmtx_std::priv::_NonDbg_str<wchar_t,*>|stlpdxmtx_std::priv::_NonDbg_str<unsigned short,*>|stlpdxmtx_std::priv::_NonDbg_str<wchar_t,*>{
    preview
    (
        #if (($c._M_end_of_storage._M_data) == ($c._M_buffers._M_static_buf + $c._DEFAULT_SIZE))
        (
            [$c._M_Buffers._M_static_buf, su]
        )
        #else
        (
            [$c._M_Buffers._M_dynamic_buf, su]
        )
    )

    stringview
    (
        #if (($c._M_end_of_storage._M_data) == ($c._M_buffers._M_static_buf + $c._DEFAULT_SIZE))
        (
            [$c._M_Buffers._M_static_buf,su]
        )
        #else
        (
            [$c._M_Buffers._M_dynamic_buf,su]
        )
    )

    children
    (
        #(
            [raw view]: [$c,!],
            buffer: #if (($c._M_end_of_storage._M_data) == ($c._M_buffers._M_static_buf + $c._DEFAULT_SIZE))
                    (
                        [(unsigned int)$c._M_Buffers._M_static_buf, x]
                    )
                    #else
                    (
                        [(unsigned int)$c._M_Buffers._M_dynamic_buf, x]
                    ),
            length: #if (($c._M_end_of_storage._M_data) == ($c._M_buffers._M_static_buf + $c._DEFAULT_SIZE))
                    (
                        [$c._M_finish - $c._M_buffers._M_static_buf]
                    )
                    #else
                    (
                        [$c._M_finish - $c._M_buffers._M_dynamic_buf]
                    ),
            capacity: #if (($c._M_end_of_storage._M_data) == ($c._M_buffers._M_static_buf + $c._DEFAULT_SIZE))
                      (
                          [$c._M_end_of_storage._M_data - $c._M_buffers._M_static_buf]
                      )
                      #else
                      (
                          [$c._M_end_of_storage._M_data - $c._M_buffers._M_dynamic_buf]
                      ),
            #if (($c._M_end_of_storage._M_data) == ($c._M_buffers._M_static_buf + $c._DEFAULT_SIZE))
            (
                #array
                (
                                        expr: $c._M_buffers._M_static_buf[$i],
                                        size: $c._M_finish - $c._M_buffers._M_static_buf
                                )
            )
            #else
            (
                #array
                (
                                        expr: $c._M_buffers._M_dynamic_buf[$i],
                                        size: $c._M_finish - $c._M_buffers._M_dynamic_buf
                                )
            )
        )
    )
}

stlpd_std::basic_string<*>|stlpdx_std::basic_string<*>|stlpdmtx_std::basic_string<*>|stlpdxmtx_std::basic_string<*>{
    preview
    (
                $c._M_non_dbg_impl
        )

    stringview
    (
                $c._M_non_dbg_impl
    )

    children
    (
        #(
            [raw view]: [$c,!],
            string: $c._M_non_dbg_impl
         )
    )
}

;------------------------------------------------------------------------------
; stlport::vector
;------------------------------------------------------------------------------
xr_vector<bool,*>|stlp_std::vector<bool,*>|stlpx_std::vector<bool,*>|stlpmtx_std::vector<bool,*>|stlpxmtx_std::vector<bool,*>|stlpd_std::priv::_NonDbg_vector<bool,*>|stlpdx_std::priv::_NonDbg_vector<bool,*>|stlpdmtx_std::priv::_NonDbg_vector<bool,*>|stlpdxmtx_std::priv::_NonDbg_vector<bool,*>{
    preview
    (
        #(
                        "[",
                        ($c._M_finish._M_p - $c._M_start._M_p) * sizeof(unsigned int) * 8 + $c._M_finish._M_offset,
                        "](",
                        #array
                        (
                                expr : ($c._M_start._M_p[$i / (sizeof(unsigned int) * 8)] >> ($i % (sizeof(unsigned int) * 8))),
                                size : (($c._M_finish._M_p - $c._M_start._M_p) * sizeof(unsigned int) * 8 + $c._M_finish._M_offset)
                        )  : (bool)($e & 1),
                        ")"
                )
        )
        children
        (
                #(
                        [raw view]: [$c,!],
                        buffer : [(unsigned int)$c._M_start._M_p, x],
                        size : (($c._M_finish._M_p - $c._M_start._M_p) * sizeof(unsigned int) * 8 + $c._M_finish._M_offset),
                        #array
                        (
                                expr : ($c._M_start._M_p[$i / (sizeof(unsigned int) * 8)] >> ($i % (sizeof(unsigned int) * 8))),
                                size : (($c._M_finish._M_p - $c._M_start._M_p) * sizeof(unsigned int) * 8 + $c._M_finish._M_offset)
                        )  : (bool)($e & 1)
                )
        )
}

stlp_std::priv::_Bit_iter<*>|stlpx_std::priv::_Bit_iter<*>|stlpmtx_std::priv::_Bit_iter<*>|stlpxmtx_std::priv::_Bit_iter<*>|stlpd_std::priv::_Bit_iter<*>|stlpdx_std::priv::_Bit_iter<*>|stlpdmtx_std::priv::::_Bit_iter<*>|stlpdxmtx_std::priv::_Bit_iter<*>{
        preview
        (
                #(
                        (bool) (((*$c._M_p) >> $c._M_offset) & 1)
                )
        )
        children
        (
                #(
                        [raw view]: [$c,!],
                        value : (bool) (((*$c._M_p) >> $c._M_offset) & 1)
                )
        )
}

xr_vector<*>|stlp_std::vector<*>|stlpx_std::vector<*>|stlpmtx_std::vector<*>|stlpxmtx_std::vector<*>|stlpd_std::priv::_NonDbg_vector<*>|stlpdx_std::priv::_NonDbg_vector<*>|stlpdmtx_std::priv::_NonDbg_vector<*>|stlpdxmtx_std::priv::_NonDbg_vector<*>{
    preview
    (
        #(
            "[",
            $c._M_finish - $c._M_start,
            "/",
            $c._M_end_of_storage._M_data - $c._M_start,
            "](",
            #array
            (
                expr :  ($c._M_start)[$i],
                size :  $c._M_finish - $c._M_start
            ),
            ")"
        )
    )
    children
    (
        #(
            [raw view]: [$c,!],
            size : $c._M_finish - $c._M_start,
            capacity : $c._M_end_of_storage._M_data - $c._M_start,
            #array
            (
                expr :  ($c._M_start)[$i],
                size :  $c._M_finish - $c._M_start
            )
        )
    )
}

stlpd_std::vector<*>|stlpdx_std::vector<*>|stlpdmtx_std::vector<*>|stlpdxmtx_std::vector<*>{
    preview
    (
                $c._M_non_dbg_impl
    )
    children
    (
        #(
            [raw view] : [$c,!],
            vector : $c._M_non_dbg_impl
         )
    )
}

;------------------------------------------------------------------------------
; buffer_vector
;------------------------------------------------------------------------------

buffer_vector<*>{
    preview
    (
        #(
            "[",
            $c.m_end - $c.m_begin,
            "/",
            $c.m_max_end - $c.m_begin,
            "](",
            #array
            (
                expr :  ($c.m_begin)[$i],
                size :  $c.m_end - $c.m_begin
            ),
            ")"
        )
    )
    children
    (
        #(
            [raw view]: [$c,!],
            size : $c.m_end - $c.m_begin,
            capacity : $c.m_max_end - $c.m_begin,
            #array
            (
                expr :  ($c.m_begin)[$i],
                size :  $c.m_end - $c.m_begin
            )
        )
    )
}


;------------------------------------------------------------------------------
; stlport::deque
;------------------------------------------------------------------------------
xr_deque<*>|stlp_std::deque<*,*>|stlpx_std::deque<*,*>|stlpmtx_std::deque<*,*>|stlpxmtx_std::deque<*,*>|stlpd_std::priv::_NonDbg_deque<*,*>|stlpdx_std::priv::_NonDbg_deque<*,*>|stlpdmtx_std::priv::_NonDbg_deque<*,*>|stlpdxmtx_std::priv::_NonDbg_deque<*,*>{
    preview
    (
                #if (((unsigned int)($c._M_start._M_cur + 1) - ((unsigned int)$c._M_start._M_cur)) < _MAX_BYTES)
                (
                        #(
                                "[",
                                (($c._M_finish._M_node - $c._M_start._M_node + 1) * (_MAX_BYTES / sizeof($T1))) - ($c._M_start._M_cur - $c._M_start._M_first) - ($c._M_finish._M_last - $c._M_finish._M_cur),
                                "/",
                                ($c._M_finish._M_node - $c._M_start._M_node + 1) * (_MAX_BYTES / sizeof($T1)) - 1,
                                "](",
                                #array
                                (
                                        expr : *(*($c._M_start._M_node + (($i + ($c._M_start._M_cur - $c._M_start._M_first)) / (_MAX_BYTES / sizeof($T1)))) + (($i + ($c._M_start._M_cur - $c._M_start._M_first)) % (_MAX_BYTES / sizeof($T1)))),
                                        size : (($c._M_finish._M_node - $c._M_start._M_node + 1) * (_MAX_BYTES / sizeof($T1))) - ($c._M_start._M_cur - $c._M_start._M_first) - ($c._M_finish._M_last - $c._M_finish._M_cur)
                                ),
                                ")"
                        )
                )
                #else
                (
                        #(
                                "[",
                                $c._M_finish._M_node - $c._M_start._M_node,
                                "/",
                                $c._M_finish._M_node - $c._M_start._M_node,
                                "](",
                                #array
                                (
                                        expr : **($c._M_start._M_node + $i),
                                        size : $c._M_finish._M_node - $c._M_start._M_node
                                ),
                                ")"
                        )
                )
    )
    children
    (
                #if (((unsigned int)($c._M_start._M_cur + 1) - ((unsigned int)$c._M_start._M_cur)) < _MAX_BYTES)
                (
                        #(
                                [raw view]: [$c,!],
                                size : (($c._M_finish._M_node - $c._M_start._M_node + 1) * (_MAX_BYTES / sizeof($T1))) - ($c._M_start._M_cur - $c._M_start._M_first) - ($c._M_finish._M_last - $c._M_finish._M_cur),
                                capacity : ($c._M_finish._M_node - $c._M_start._M_node + 1) * (_MAX_BYTES / sizeof($T1)) - 1,
                                front free space : $c._M_start._M_cur - $c._M_start._M_first,
                                back free space : $c._M_finish._M_last - $c._M_finish._M_cur - 1,
                                #array
                                (
                                        expr : *(*($c._M_start._M_node + (($i + ($c._M_start._M_cur - $c._M_start._M_first)) / (_MAX_BYTES / sizeof($T1)))) + (($i + ($c._M_start._M_cur - $c._M_start._M_first)) % (_MAX_BYTES / sizeof($T1)))),
                                        size : (($c._M_finish._M_node - $c._M_start._M_node + 1) * (_MAX_BYTES / sizeof($T1))) - ($c._M_start._M_cur - $c._M_start._M_first) - ($c._M_finish._M_last - $c._M_finish._M_cur)
                                )
                        )
                )
                #else
                (
                        #(
                                [raw view] : [$c,!],
                                size : $c._M_finish._M_node - $c._M_start._M_node,
                                capacity : $c._M_finish._M_node - $c._M_start._M_node,
                                front free space : $c._M_start._M_cur - $c._M_start._M_first,
                                back free space : $c._M_finish._M_last - $c._M_finish._M_cur - 1,
                                #array
                                (
                                        expr : **($c._M_start._M_node + $i),
                                        size : $c._M_finish._M_node - $c._M_start._M_node
                                )
                        )
                )
    )
}

stlp_std::priv::_Deque_iterator<*>|stlpx_std::priv::_Deque_iterator<*>|stlpmtx_std::priv::_Deque_iterator<*>|stlpxmtx_std::priv::_Deque_iterator<*>|stlpd_std::priv::_Deque_iterator<*>|stlpdx_std::priv::_Deque_iterator<*>|stlpdmtx_std::priv::_Deque_iterator<*>|stlpdxmtx_std::priv::_Deque_iterator<*>{
        preview
        (
                *($c._M_cur)
        )
    children
    (
        #(
            [raw view] : [$c, !],
            ptr : [(unsigned int)($c._M_cur), x],
            value : *($c._M_cur)
        )
    )
}

stlpd_std::deque<*>|stlpdx_std::deque<*>|stlpdmtx_std::deque<*>|stlpdxmtx_std::deque<*>{
    preview
    (
                $c._M_non_dbg_impl
        )
    children
    (
        #(
            [raw view] : [$c,!],
            deque : $c._M_non_dbg_impl
        )
    )
}

;------------------------------------------------------------------------------
; stlport::list
;------------------------------------------------------------------------------
xr_list<*>|stlp_std::list<*,*>|stlpx_std::list<*,*>|stlpmtx_std::list<*,*>|stlpxmtx_std::list<*,*>|stlpd_std::priv::_NonDbg_list<*,*>|stlpdx_std::priv::_NonDbg_list<*,*>|stlpdmtx_std::priv::_NonDbg_list<*,*>|stlpdxmtx_std::priv::_NonDbg_list<*,*>{
    preview
    (
                #(
                        "(",
                        #list
                        (
                                head : $c._M_node._M_data._M_next,
                                skip : &($c._M_node._M_data),
                                next : _M_next,
                        ): #( *($T1*)(&($e) + 1)),
                        ")"
                )
    )
    children
    (
        #(
            [raw view]: [$c,!],
            #list
            (
                head : $c._M_node._M_data._M_next,
                                skip : &($c._M_node._M_data),
                next : _M_next,
            ): #( *($T1*)(&($e) + 1))
        )
    )
}

stlp_std::priv::_List_iterator<*,*>|stlpx_std::priv::_List_iterator<*,*>|stlpmtx_std::priv::_List_iterator<*,*>|stlpxmtx_std::priv::_List_iterator<*,*>|stlpd_std::priv::_List_iterator<*,*>|stlpdx_std::priv::_List_iterator<*,*>|stlpdmtx_std::priv::_List_iterator<*,*>|stlpdxmtx_std::priv::_List_iterator<*,*>{
    preview
    (
        #(*($T1 *)($c._M_node + 1))
    )
    children
    (
        #(
            [raw view] : [$c, !],
            ptr : [(unsigned int)($c._M_node + 1), x],
            value : *($T1 *)($c._M_node + 1)
        )
    )
}

stlpd_std::list<*,*>|stlpdx_std::list<*,*>|stlpdmtx_std::list<*,*>|stlpdxmtx_std::list<*,*>{
    preview
    (
                $c._M_non_dbg_impl
    )
    children
    (
        #(
            [raw view] : [$c,!],
            list : $c._M_non_dbg_impl
        )
    )
}

;------------------------------------------------------------------------------
; stlport::slist
;------------------------------------------------------------------------------
stlp_std::slist<*,*>|stlpx_std::slist<*,*>|stlpmtx_std::slist<*,*>|stlpxmtx_std::slist<*,*>|stlpd_std::priv::_NonDbg_slist<*,*>|stlpdx_std::priv::_NonDbg_slist<*,*>|stlpdmtx_std::priv::_NonDbg_slist<*,*>|stlpdxmtx_std::priv::_NonDbg_slist<*,*>{
    preview
    (
                #(
                        "(",
                        #list
                        (
                                head : $c._M_head._M_data._M_next,
                                skip : &($c._M_head._M_data),
                                next : _M_next,
                        ): #( *($T1*)(&($e) + 1)),
                        ")"
                )
    )
    children
    (
        #(
            [raw view]: [$c,!],
            #list
            (
                head : $c._M_head._M_data._M_next,
                                skip : &($c._M_head._M_data),
                next : _M_next,
            ): #( *($T1*)(&($e) + 1))
        )
    )
}

stlp_std::priv::_Slist_iterator<*,*>|stlpx_std::priv::_Slist_iterator<*,*>|stlpmtx_std::priv::_Slist_iterator<*,*>|stlpxmtx_std::priv::_Slist_iterator<*,*>|stlpd_std::priv::_Slist_iterator<*,*>|stlpdx_std::priv::_Slist_iterator<*,*>|stlpdmtx_std::priv::_Slist_iterator<*,*>|stlpdxmtx_std::priv::_Slist_iterator<*,*>{
    preview
    (
        #(*($T1 *)($c._M_node + 1))
    )
    children
    (
        #(
            [raw view] : [$c,!],
            ptr : [(unsigned int)($c._M_node + 1), x],
            value : *($T1 *)($c._M_node + 1)
        )
    )
}

stlpd_std::slist<*,*>|stlpdx_std::slist<*,*>|stlpdmtx_std::slist<*,*>|stlpdxmtx_std::slist<*,*>{
    preview
    (
                $c._M_non_dbg_impl
    )
    children
    (
        #(
            [raw view] : [$c,!],
            [slist] : $c._M_non_dbg_impl
        )
    )
}

;------------------------------------------------------------------------------
; stlport::pair
;------------------------------------------------------------------------------
stlp_std::pair<*,*>|stlpx_std::pair<*,*>|stlpmtx_std::pair<*,*>|stlpxmtx_std::pair<*,*>|stlpd_std::pair<*,*>|stlpdx_std::pair<*,*>|stlpdmtx_std::pair<*,*>|stlpdxmtx_std::pair<*,*>{
    preview
    (
        #(
            "(",
            $c.first,
            ", ",
            $c.second,
            ")"
        )
    )
}

;------------------------------------------------------------------------------
; stlport::map, stlport::multimap, stlport::set, stlport::multiset
;------------------------------------------------------------------------------
xr_map<*>|xr_multimap<*>|xr_set<*>|xr_multiset<*>|stlp_std::map<*>|stlpx_std::map<*>|stlpmtx_std::map<*>|stlpxmtx_std::map<*>|stlp_std::multimap<*>|stlpx_std::multimap<*>|stlpmtx_std::multimap<*>|stlpxmtx_std::multimap<*>|stlp_std::set<*>|stlpx_std::set<*>|stlpmtx_std::set<*>|stlpxmtx_std::set<*>|stlp_std::multiset<*>|stlpx_std::multiset<*>|stlpmtx_std::multiset<*>|stlpxmtx_std::multiset<*>{
    preview
    (
                #(
                        "[",
                        $c._M_t._M_node_count,
                        "](",
                        $c._M_t,
                        ")"
                )
    )
    children
    (
        #(
            [raw view]: [$c,!],
            size: [$c._M_t._M_node_count],
            tree: $c._M_t
        )
    )
}

stlpd_std::map<*>|stlpdx_std::map<*>|stlpdmtx_std::map<*>|stlpdxmtx_std::map<*>|stlpd_std::multimap<*>|stlpdx_std::multimap<*>|stlpdmtx_std::multimap<*>|stlpdxmtx_std::multimap<*>|stlpd_std::set<*>|stlpdx_std::set<*>|stlpdmtx_std::set<*>|stlpdxmtx_std::set<*>|stlpd_std::multiset<*>|stlpdx_std::multiset<*>|stlpdmtx_std::multiset<*>|stlpdxmtx_std::multiset<*>{
    preview
    (
                #(
                        "[",
                        $c._M_t._M_non_dbg_impl._M_node_count,
                        "](",
                        $c._M_t._M_non_dbg_impl,
                        ")"
                )
    )
    children
    (
        #(
            [raw view]: [$c,!],
            size: $c._M_t._M_non_dbg_impl._M_node_count,
            tree: $c._M_t._M_non_dbg_impl
        )
    )
}

stlp_std::priv::_Rb_tree<*,*,*,*,*>|stlpx_std::priv::_Rb_tree<*,*,*,*,*>|stlpmtx_std::priv::_Rb_tree<*,*,*,*,*>|stlpxmtx_std::priv::_Rb_tree<*,*,*,*,*>|stlpd_std::priv::_NonDbg_Rb_tree<*,*,*,*,*>|stlpdx_std::priv::_NonDbg_Rb_tree<*,*,*,*,*>|stlpdmtx_std::priv::_NonDbg_Rb_tree<*,*,*,*,*>|stlpdxmtx_std::priv::_NonDbg_Rb_tree<*,*,*,*,*>{
    preview
    (
                #tree
                (
                        head : $c._M_header._M_data._M_parent,
                        skip : &($c._M_header._M_data),
                        size : $c._M_node_count,
                        left : _M_left,
                        right : _M_right
                ): #(*($T3 *)(&($e) + 1))
    )
    children
    (
        #(
            [raw view]: [$c,!],
            #tree
            (
                head : $c._M_header._M_data._M_parent,
                                skip : &($c._M_header._M_data),
                                size : $c._M_node_count,
                left : _M_left,
                right : _M_right
            ) : #(*($T3 *)(&($e) + 1))
        )
    )
}

stlp_std::priv::_Rb_tree_iterator<*,*>|stlpx_std::priv::_Rb_tree_iterator<*,*>|stlpmtx_std::priv::_Rb_tree_iterator<*,*>|stlpxmtx_std::priv::_Rb_tree_iterator<*,*>|stlpd_std::priv::_Rb_tree_iterator<*,*>|stlpdx_std::priv::_Rb_tree_iterator<*,*>|stlpdmtx_std::priv::_Rb_tree_iterator<*,*>|stlpdxmtx_std::priv::_Rb_tree_iterator<*,*>{
    preview
    (
        [*($T1*)($c._M_node + 1)]
    )
    children
    (
        #(
            [raw view]: [$c,!],
            value: [*($T1*)($c._M_node + 1)],
            ptr: [(unsigned int)($c._M_node + 1), x]
        )
    )
}

;------------------------------------------------------------------------------
; stlport::hash_map, stlport::hash_multimap, stlport::hash_set, stlport::hash_multiset
; stlport::unordered_map, stlport::unordered_multimap, stlport::unordered_set, stlport::unordered_multiset
;------------------------------------------------------------------------------
xr_hash_map<*>|stlp_std::hash_map<*>|stlpx_std::hash_map<*>|stlpmtx_std::hash_map<*>|stlpxmtx_std::hash_map<*>|stlp_std::hash_multimap<*>|stlpx_std::hash_multimap<*>|stlpmtx_std::hash_multimap<*>|stlpxmtx_std::hash_multimap<*>|stlp_std::hash_set<*>|stlpx_std::hash_set<*>|stlpmtx_std::hash_set<*>|stlpxmtx_std::hash_set<*>|stlp_std::hash_multiset<*>|stlpx_std::hash_multiset<*>|stlpmtx_std::hash_multiset<*>|stlpxmtx_std::hash_multiset<*>|stlp_std::tr1::unordered_map<*>|stlpx_std::tr1::unordered_map<*>|stlpmtx_std::tr1::unordered_map<*>|stlpxmtx_std::tr1::unordered_map<*>|stlp_std::tr1::unordered_multimap<*>|stlpx_std::tr1::unordered_multimap<*>|stlpmtx_std::tr1::unordered_multimap<*>|stlpxmtx_std::tr1::unordered_multimap<*>|stlp_std::tr1::unordered_set<*>|stlpx_std::tr1::unordered_set<*>|stlpmtx_std::tr1::unordered_set<*>|stlpxmtx_std::tr1::unordered_set<*>|stlp_std::tr1::unordered_multiset<*>|stlpx_std::tr1::unordered_multiset<*>|stlpmtx_std::tr1::unordered_multiset<*>|stlpxmtx_std::tr1::unordered_multiset<*>{
    preview
    (
                #(
                        "[",
                        $c._M_ht._M_num_elements,
                        "]",
                        $c._M_ht
                )
    )
    children
    (
        #(
            [raw view]: [$c,!],
            hashtable: $c._M_ht
        )
    )
}

stlpd_std::hash_map<*>|stlpdx_std::hash_map<*>|stlpdmtx_std::hash_map<*>|stlpdxmtx_std::hash_map<*>|stlpd_std::hash_multimap<*>|stlpdx_std::hash_multimap<*>|stlpdmtx_std::hash_multimap<*>|stlpdxmtx_std::hash_multimap<*>|stlpd_std::hash_set<*>|stlpdx_std::hash_set<*>|stlpdmtx_std::hash_set<*>|stlpdxmtx_std::hash_set<*>|stlpd_std::hash_multiset<*>|stlpdx_std::hash_multiset<*>|stlpdmtx_std::hash_multiset<*>|stlpdxmtx_std::hash_multiset<*>|stlpd_std::tr1::unordered_map<*>|stlpdx_std::tr1::unordered_map<*>|stlpdmtx_std::tr1::unordered_map<*>|stlpdxmtx_std::tr1::unordered_map<*>|stlpd_std::tr1::unordered_multimap<*>|stlpdx_std::tr1::unordered_multimap<*>|stlpdmtx_std::tr1::unordered_multimap<*>|stlpdxmtx_std::tr1::unordered_multimap<*>|stlpd_std::tr1::unordered_set<*>|stlpdx_std::tr1::unordered_set<*>|stlpdmtx_std::tr1::unordered_set<*>|stlpdxmtx_std::tr1::unordered_set<*>|stlpd_std::tr1::unordered_multiset<*>|stlpdx_std::tr1::unordered_multiset<*>|stlpdmtx_std::tr1::unordered_multiset<*>|stlpdxmtx_std::tr1::unordered_multiset<*>{
    preview
    (
                #(
                        "[",
                        $c._M_ht._M_non_dbg_impl._M_num_elements,
                        "]",
                        $c._M_ht._M_non_dbg_impl
                )
    )
    children
    (
        #(
            [raw view]: [$c,!],
            hashtable: $c._M_ht._M_non_dbg_impl
        )
    )
}

stlp_std::hashtable<*,*>|stlpx_std::hashtable<*,*>|stlpmtx_std::hashtable<*,*>|stlpxmtx_std::hashtable<*,*>|stlpd_std::priv::_NonDbg_hashtable<*,*>|stlpdx_std::priv::_NonDbg_hashtable<*,*>|stlpdmtx_std::priv::_NonDbg_hashtable<*,*>|stlpdxmtx_std::priv::_NonDbg_hashtable<*,*>{
    preview
    (
                $c._M_elems
    )
    children
    (
        #(
            [raw view]: [$c,!],
            size : $c._M_num_elements,
            load factor : (float)$c._M_num_elements / ($c._M_buckets._M_finish - $c._M_buckets._M_start),
            max load factor: $c._M_max_load_factor,
            buckets : $c._M_buckets,
            elements : $c._M_elems
        )
    )
}

;------------------------------------------------------------------------------
; stlport::queue, stlport::priority_queue, stlport::stack
;------------------------------------------------------------------------------
xr_queue<*>|xr_priority_queue<*>|xr_stack<*>|stlp_std::queue<*>|stlpx_std::queue<*>|stlpmtx_std::queue<*>|stlpxmtx_std::queue<*>|stlpd_std::queue<*>|stlpdx_std::queue<*>|stlpdmtx_std::queue<*>|stlpdxmtx_std::queue<*>|stlp_std::priority_queue<*>|stlpx_std::priority_queue<*>|stlpmtx_std::priority_queue<*>|stlpxmtx_std::priority_queue<*>|stlpd_std::priority_queue<*>|stlpdx_std::priority_queue<*>|stlpdmtx_std::priority_queue<*>|stlpdxmtx_std::priority_queue<*>|stlp_std::stack<*>|stlpx_std::stack<*>|stlpmtx_std::stack<*>|stlpxmtx_std::stack<*>|stlpd_std::stack<*>|stlpdx_std::stack<*>|stlpdmtx_std::stack<*>|stlpdxmtx_std::stack<*>{
        preview
        (
                $c.c
        )
        children
        (
                #(
                        [raw view] : [$c,!],
                        container : $c.c
                )
        )
}

;------------------------------------------------------------------------------
; stlport debug iterator
;------------------------------------------------------------------------------
stlp_std::priv::_DBG_iter<*>|stlpx_std::priv::_DBG_iter<*>|stlpmtx_std::priv::_DBG_iter<*>|stlpxmtx_std::priv::_DBG_iter<*>|stlpd_std::priv::_DBG_iter<*>|stlpdx_std::priv::_DBG_iter<*>|stlpdmtx_std::priv::_DBG_iter<*>|stlpdxmtx_std::priv::_DBG_iter<*>{
        preview
        (
                #if($c._M_owner != 0)
                (
                        $c._M_iterator
                )
                #else
                (
                        "undefined"
                )
        )
        children
        (
                #(
                        #if($c._M_owner != 0)
                        (
                                #(
                                        [raw view] : [$c,!],
                                        [iterator] : $c._M_iterator,
                                        [valid] : [true]
                                )
                        )
                        #else
                        (
                                #(
                                        [raw view] : [$c,!],
                                        [valid] : [false]
                                )
                        )
                )
        )
}

;------------------------------------------------------------------------------
; stlport::bitset
; TODO: Fix it, it doesn't work as expected even when adding an enum to the bitset
; class to get access to the bitset static size rather than using $T1.
;------------------------------------------------------------------------------
stdp_std::bitset<*,*>|stdpx_std::bitset<*,*>|stdpmtx_std::bitset<*,*>|stdpxmtx_std::bitset<*,*>|stdpd_std::bitset<*>|stdpdx_std::bitset<*>|stdpdmtx_std::bitset<*>|stdpdxmtx_std::bitset<*>{
        preview
        (
                #(
                "[",
                        $T1,
                "](",
                #array
                (
                        expr : ($c._M_w[$i / (sizeof(unsigned long) * 8)] >> ($i % (sizeof(unsigned long) * 8))),
                        size : $T1
                ) : [($e & 1),d],
                ")"
                )
        )
        children
        (
                #array
                (
                        expr :  ($c._M_w[$i / (sizeof(unsigned long) * 8)] >> ($i % (sizeof(unsigned long) * 8))),
                        size :  $T1
                ) : (bool)($e & 1)
        )
}

stdp_std::bitset<*>::reference|stdpx_std::bitset<*>::reference|stdpmtx_std::bitset<*>::reference|stdpxmtx_std::bitset<*>::reference|stdpd_std::bitset<*>::reference|stdpdx_std::bitset<*>::reference|stdpdmtx_std::bitset<*>::reference|stdpdxmtx_std::bitset<*>{
    preview
    (
                #(
                        "bitset[", $c._M_bpos, "] = ",
                        (bool)(*($c._M_wp) >> $c._M_bpos) & 1)
                )
    )
}

;------------------------------------------------------------------------------
; stlport::auto_ptr
;------------------------------------------------------------------------------
stlp_std::auto_ptr<*>|stlpx_std::auto_ptr<*>|stlpmtx_std::auto_ptr<*>|stlpxmtx_std::auto_ptr<*>|stlpd_std::auto_ptr<*>|stlpdx_std::auto_ptr<*>|stlpdmtx_std::auto_ptr<*>|stlpdxmtx_std::auto_ptr<*>{
    preview
    (
        #if(($c._M_p) != 0)
        (
            [*($T1 *)$c._M_p]
        )
        #else
        (
            "null"
        )
    )
    children
    (
        #if(($c._M_p) != 0)
        (
            #(
                [raw view]: [$c,!],
                ptr: [(unsigned int)$c._M_p, x],
                value: [*($T1 *)$c._M_p]
            )
        )
        #else
        (
            #(
                [raw view]: [$c,!]
            )
        )
    )
}

;------------------------------------------------------------------------------
;  stlport::complex
;------------------------------------------------------------------------------
stlp_std::complex<*>|stlpx_std::complex<*>|stlpmtx_std::complex<*>|stlpxmtx_std::complex<*>|stlpd_std::complex<*>|stlpdx_std::complex<*>|stlpdmtx_std::complex<*>|stlpdxmtx_std::complex<*>{
        children
        (
                #(
                        real: $e._M_re,
                        imaginary: $e._M_im
                )
        )
        preview
        (
                #if($e._M_im != 0)
                (
                        #if ($e._M_re != 0)
                        (                                                                       ; Real and Imaginary components
                                #if ($e._M_im >= 0)
                                (
                                        #($e._M_re,"+i*", $e._M_im)
                                )
                                #else
                                (
                                        #($e._M_re,"-i*", -$e._M_im)
                                )
                        )
                        #else
                        (                                                                       ; Purely imaginary
                                #if ($e._M_im >= 0.0)
                                (
                                        #("i*", $e._M_im)
                                )
                                #else
                                (
                                        #("-i*", -$e._M_im)
                                )
                        )
                )
                #else
                (                                                                               ; Purely real
                        $e._M_re
                )
        )
}

;------------------------------------------------------------------------------
;  stlport::valarray
;------------------------------------------------------------------------------

stlp_std::valarray<*>|stlpx_std::valarray<*>|stlpmtx_std::valarray<*>|stlpxmtx_std::valarray<*>|stlpd_std::valarray<*>|stlpdx_std::valarray<*>|stlpdmtx_std::valarray<*>|stlpdxmtx_std::valarray<*>{
    preview
    (
                #(
                        "[",
            $c._M_size ,
            "](",
            #array
            (
                                expr :  ($c._M_first)[$i],
                                size :  $c._M_size
                        ),
                        ")"
                )
        )

        children
        (
                #array
                (
                        expr :  ($c._M_first)[$i],
                        size :  $c._M_size
                )
        )
}

stlp_std::slice|stlpx_std::slice|stlpmtx_std::slice|stlpxmtx_std::slice|stlpd_std::slice|stlpdx_std::slice|stlpdmtx_std::slice|stlpdxmtx_std::slice{
        preview
        (
                #(
                        "start = ",
                        $c._M_start,
                        ", size = ",
                        $c._M_length,
                        ", stride = ",
                        $c._M_stride
                )
        )
        children
        (
                #(
                        [raw view] : [$c,!],
                        start : $c._M_start,
                        size : $c._M_length,
                        stride : $c._M_stride
                )
        )
}

stlp_std::gslice|stlpx_std::gslice|stlpmtx_std::gslice|stlpxmtx_std::gslice|stlpd_std::gslice|stlpdx_std::gslice|stlpdmtx_std::gslice|stlpdxmtx_std::gslice{
        preview
        (
                #(
                        "start = ",
                        $c._M_start,
                        ", sizes = ",
                        $c._M_lengths,
                        ", strides = ",
                        $c._M_strides
                )
        )
        children
        (
                #(
                        [raw view] : [$c,!],
                        start : $c._M_start,
                        sizes : $c._M_lengths,
                        strides : $c._M_strides
                )
        )
}


ATL::CStringT<char,*>|CSimpleStringT<char,*>|ATL::CSimpleStringT<char,*>{
	preview([$c.m_pszData,s])
        stringview([$c.m_pszData,sb])
}

ATL::CStringT<wchar_t,*>|CSimpleStringT<wchar_t,*>|ATL::CSimpleStringT<wchar_t,*>|ATL::CStringT<unsigned short,*>|CSimpleStringT<unsigned short,*>|ATL::CSimpleStringT<unsigned short,*>{
	preview([$c.m_pszData,su])
        stringview([$c.m_pszData,sub])
}

ATL::CComBSTR{
	preview([$c.m_str,su])
        stringview([$c.m_str,sub])
}


;------------------------------------------------------------------------------
;  std::vector<bool,*> specialization
;------------------------------------------------------------------------------

std::vector<bool,*>{
	children
	(
		#array
		(
			expr : ($c._Myvec._Myfirst[$i / _VBITS] >> ($i % _VBITS)), 
			size : ($c._Mysize)
		)  : (bool)($e & 1)
	)
		
    preview
    ( 
            #( 
				"[", 
				$e._Mysize , 
				"](", 
				#array
				(
					expr : ($c._Myvec._Myfirst[$i / _VBITS] >> ($i % _VBITS)), 
					size : ($c._Mysize)
				)  : (bool)($e & 1), ")")
	)		
}

std::vector<bool,*>::iterator|std::vector<bool,*>::const_iterator|std::_Vb_iterator<*>|std::_Vb_const_iterator<*>{
	preview
	(
		#( 
			(bool) (((*$e._Myptr) >> $e._Myoff) & 1)   
		)
	)
	
	children
	(
		#( 
			ptr: (bool) (((*$e._Myptr) >> $e._Myoff) & 1)   
		)
	)

	
}


;------------------------------------------------------------------------------
;  std::vector
;------------------------------------------------------------------------------
std::vector<*>{
	children
	(
	    #array
	    (
			expr :	($c._Myfirst)[$i],  
			size :	$c._Mylast-$c._Myfirst
		)
	)
	
    preview
    ( 
        #( 
			"[", 
            $e._Mylast - $e._Myfirst , 
            "](", 
            
            #array
            (
				expr : 	($c._Myfirst)[$i],  
				size : 	$c._Mylast-$c._Myfirst
			), 
			")"
		)
	)
	

}

std::_Vector_iterator<*>|std::_Vector_const_iterator<*>{
	preview 
	(
		#(*$e._Myptr)
	)
	
	children
	(
		#(ptr: *$e._Myptr)
	)
}



;------------------------------------------------------------------------------
;  std::string/basic_string
;------------------------------------------------------------------------------

std::basic_string<char,*>{
	preview
	( 
		#if(($e._Myres) < ($e._BUF_SIZE))
		(
			[$e._Bx._Buf,s]
		)
		#else
		(
			[$e._Bx._Ptr,s]
		)
	)
	
	stringview
	(
		#if(($e._Myres) < ($e._BUF_SIZE))
		(
			[$e._Bx._Buf,sb]
		)
		#else
		(
			[$e._Bx._Ptr,sb]
		)
	)
	
	children
	(
		#if(($e._Myres) < ($e._BUF_SIZE))
		(
			#([actual members]: [$e,!] , #array( expr: $e._Bx._Buf[$i], size: $e._Mysize))
		)
		#else
		(
			#([actual members]: [$e,!],  #array( expr: $e._Bx._Ptr[$i], size: $e._Mysize))
		)	
	)	

}

std::basic_string<unsigned short,*>|std::basic_string<wchar_t,*>{
	preview
	( 
		#if(($e._Myres) < ($e._BUF_SIZE)) ( [$e._Bx._Buf,su] )
		#else ( [$e._Bx._Ptr,su] )
	)
	
	stringview
	( 
		#if(($e._Myres) < ($e._BUF_SIZE)) ( [$e._Bx._Buf,sub] )
		#else ( [$e._Bx._Ptr,sub] )
	)
	
	children
	(
		#if(($e._Myres) < ($e._BUF_SIZE))
		(
			#([actual members]: [$e,!] , #array( expr: $e._Bx._Buf[$i], size: $e._Mysize))
		)
		#else
		(
			#([actual members]: [$e,!],  #array( expr: $e._Bx._Ptr[$i], size: $e._Mysize))
		)	
	)	
}

std::basic_string<*>::iterator|std::basic_string<*>::const_iterator|std::_String_iterator<*>|std::_String_const_iterator<*>{
	preview
	( 
		#( $e._Myptr ) 
	)

	children
	( 
		#( ptr: $e._Myptr ) 
	)
}

std::pair<*>{
	preview
	(
		#( 
			"(", 
			$e.first, 
			",", 
			$e.second , 
			")"
		)
	)
}

;------------------------------------------------------------------------------
;  std::auto_ptr
;------------------------------------------------------------------------------

std::auto_ptr<*>{
	preview
	( 
		#(	"auto_ptr ",
			(*(($T1 *)$c._Myptr))
		 )
	)
	children
	( 
		#( 
			ptr: (*(($T1 *)$c._Myptr)) 
		)
	)
}

;------------------------------------------------------------------------------
;  std::map
;------------------------------------------------------------------------------

std::map<*>{
	children
	(
		#tree
		(
			head : $c._Myhead->_Parent, 
		    skip : $c._Myhead, 
		    size : $c._Mysize, 
		    left : _Left, 
		    right : _Right
		) : $e._Myval
	)
		     
	preview
	(
		#(
			"[", 
			$e._Mysize, 
			"](", 

			#tree
			(
				head : $c._Myhead->_Parent, 
				skip : $c._Myhead, 
				size : $c._Mysize, 
				left : _Left, 
				right : _Right
			) : $e._Myval,
			
			")"
		)
	)		     
}

;------------------------------------------------------------------------------
;  std::multi_map
;------------------------------------------------------------------------------

std::multimap<*>{
	children
	(
		#tree
		(
			head : $c._Myhead->_Parent, 
		    skip : $c._Myhead, 
		    size : $c._Mysize, 
		    left : _Left, 
		    right : _Right
		) : $e._Myval
	)
		     
	preview
	(
		#(
			"[", 
			$e._Mysize, 
			"](", 
			
			#tree
			(	
				head : $c._Myhead->_Parent, 
				skip : $c._Myhead, 
				size : $c._Mysize, 
				left : _Left, 
				right : _Right
			) : $e._Myval,
			
			")"
		)
	)		     
}


;------------------------------------------------------------------------------
;  std::list
;------------------------------------------------------------------------------

std::list<*>{

	children
	(
		#list
		(
			head : $c._Myhead->_Next, 
		    size : $c._Mysize, 
		    next : _Next
		) : $e._Myval
	)
		          
	preview
	(
		#(
			"[", 
			$e._Mysize, 
			"](", 
		  
			#list
			(
				head : $c._Myhead->_Next, 
				size : $c._Mysize, 
				next : _Next
			) : $e._Myval,
		 
			")"
		)
	)			      
}

std::list<*>::iterator|std::list<*>::const_iterator|std::list<*>::_Iterator<1>|std::list<*>::_Const_iterator<1>{
	preview
	(
		#($e._Ptr->_Myval)
	)
	
	children
	(
		#(ptr: $e._Ptr->_Myval)
	)

}


;------------------------------------------------------------------------------
;  std::bitset  <bitset>
;------------------------------------------------------------------------------

std::bitset<*>{       
	preview
	(
		#(
		"[",
			$c.digits,
		"](",
		#array
		(	
			expr : 	($c._Array[$i / $c._Bitsperword] >> ($i % $c._Bitsperword)),  
			size : 	$c.digits
		) : [($e & 1),d],
		")"
		)
	)
	children
	(
		#array
		(	
			expr : 	($c._Array[$i / $c._Bitsperword] >> ($i % $c._Bitsperword)),  
			size : 	$c.digits
		) : (bool)($e & 1))
}

std::bitset<*>::reference{
    preview
    (
		#(
			"bitset[", $e._Mypos, "] = ", 
			(bool)(($e._Pbitset->_Array[$i / _Bitsperword] >> ($e._Mypos % _Bitsperword)) & 1) 
		)
    )
}

;------------------------------------------------------------------------------
;  std::deque
;------------------------------------------------------------------------------

std::deque<*>{
	children
	(
		#array
		(
			expr : $c._Map[ (($i + $c._Myoff) / $c._EEN_DS) % $c._Mapsize][($i + $c._Myoff) % $c._EEN_DS],  
			size : $c._Mysize
		)
	)

	preview
	(
		#(
			"[", 
			$e._Mysize, 
			"](", 
		  
			#array
			(
				expr : $c._Map[ (($i + $c._Myoff) / $c._EEN_DS) % $c._Mapsize][($i + $c._Myoff) % $c._EEN_DS],  
				size : $c._Mysize
			),
		 
			")"
		)
	)		       
}

std::deque<*,*>::iterator|std::_Deque_iterator<*,*,*>|std::_Deque_const_iterator<*,*,*>{
   preview
   (
	   #if( $e._Myoff >= ((std::deque<$T1,$T2 > *)$c._Mycont)->_Myoff + ((std::deque<$T1,$T2 > *)$c._Mycont)->_Mysize)
	   (
	   		#("<end>")
	   )
	   #else(
			#(
				"deque[", 
				$e._Myoff - ((std::deque<$T1,$T2 > *)$c._Mycont)->_Myoff, 
				"] = ",
				((std::deque<$T1,$T2 > *)$c._Mycont)->_Map[ (($c._Myoff) / ((std::deque<$T1,$T2 > *)$c._Mycont)->_EEN_DS) % ((std::deque<$T1,$T2 > *)$c._Mycont)->_Mapsize][$c._Myoff % ((std::deque<$T1,$T2 > *)$c._Mycont)->_EEN_DS] 
			)
		)
	)
	children
	(
	   #if( ((std::deque<$T1,$T2 > *)$c._Mycont)->_Myoff + ((std::deque<$T1,$T2 > *)$c._Mycont)->_Mysize > $e._Myoff) 
	   (
			#(
				ptr: ((std::deque<$T1,$T2 > *)$c._Mycont)->_Map[ ($c._Myoff / ((std::deque<$T1,$T2 > *)$c._Mycont)->_EEN_DS) % ((std::deque<$T1,$T2 > *)$c._Mycont)->_Mapsize][$c._Myoff % ((std::deque<$T1,$T2 > *)$c._Mycont)->_EEN_DS] 
			)
		)
	)
}

;------------------------------------------------------------------------------
;  std::queue
;------------------------------------------------------------------------------

std::queue<*>{
	children
	(
		#array
		(
			expr : $c.c._Map[ (($i + $c.c._Myoff) / $c.c._EEN_DS) % $c.c._Mapsize][($i + $c.c._Myoff) % $c.c._EEN_DS],  
			size : $c.c._Mysize
		)
	)
		   
 preview
	(
		#(
			"[", 
			$e.c._Mysize, 
			"](", 
		  
			#array
			(
				expr : $c.c._Map[ (($i + $c.c._Myoff) / $c.c._EEN_DS) % $c.c._Mapsize][($i + $c.c._Myoff) % $c.c._EEN_DS],  
				size : $c.c._Mysize
			),
		 
			")"
		)
	)			   
}


;------------------------------------------------------------------------------
;  std::priority_queue
;------------------------------------------------------------------------------

std::priority_queue<*>{
	preview
	( 
		$e.c 
	)
}

;------------------------------------------------------------------------------
;  std::set
;------------------------------------------------------------------------------

std::set<*>{
    preview
    ( 
		#( 
			"[", 
            $e._Mysize , 
            "](", 
            
            #tree
            (
				head : $c._Myhead->_Parent, 
				skip : $c._Myhead, 
				left : _Left, 
				right : _Right,
				size  : $c._Mysize
			) : $e._Myval, 
			
			")"
		)
	)
			   
	children
	(
		#tree
		(
			head : $c._Myhead->_Parent, 
			skip : $c._Myhead, 
			left : _Left, 
			right : _Right,
			size  : $c._Mysize
		) : $e._Myval
	)
}

;------------------------------------------------------------------------------
;  std::multi_set
;------------------------------------------------------------------------------

std::multiset<*>{
    preview
    (
		#( 
			"[", 
            $e._Mysize , 
            "](", 
            
            #tree
            (
				head : $c._Myhead->_Parent, 
				skip : $c._Myhead, 
				left : _Left, 
				right : _Right,
				size  : $c._Mysize
			) : $e._Myval, 
			
			")"
		)
	)
			   
	children
	(
		#tree
		(
			head : $c._Myhead->_Parent, 
			skip : $c._Myhead, 
			left : _Left, 
			right : _Right,
			size  : $c._Mysize
		) : $e._Myval
	)
}


;------------------------------------------------------------------------------
;  std::_Tree (shared my map/multimap/set/multiset)
;------------------------------------------------------------------------------

std::_Tree<*>::iterator|std::_Tree<*>::const_iterator{
	preview
	(
		#($e._Ptr->_Myval)
	)
	
	children
	(
		#(ptr: $e._Ptr->_Myval)
	)

	
}


;------------------------------------------------------------------------------
;  std::stack
;------------------------------------------------------------------------------

std::stack<*>{
	children
	(
		#array
		(
			expr : $c.c._Map[ (($i + $c.c._Myoff) / $c.c._EEN_DS) % $c.c._Mapsize][($i + $c.c._Myoff) % $c.c._EEN_DS],  
			size : $c.c._Mysize
		)
	)
           
    preview
    (
		#( 
			"[", 
            $e.c._Mysize , 
            "](", 
            
            #array
            (
				expr : $c.c._Map[ (($i + $c.c._Myoff) / $c.c._EEN_DS) % $c.c._Mapsize][($i + $c.c._Myoff) % $c.c._EEN_DS],  
				size : $c.c._Mysize
			), 
			
			")"
		)
	)           
}

;------------------------------------------------------------------------------
;  stdext::hash_map
;  stdext::hash_multimap
;  stdext::hash_set
;  stdext::hash_multiset
;------------------------------------------------------------------------------

stdext::hash_map<*>|stdext::hash_multimap<*>|stdext::hash_set<*>|stdext::hash_multiset<*>{
	
	preview
	(
		#(
			"[", 
			$e._List._Mysize, 
			"](", 
		 
			#list
			(
				head : $c._List._Myhead->_Next, 
          	    size : $c._List._Mysize,
				next : _Next
			) : $e._Myval,
			
			")"
		)
	)	

	children
	(
    
		#list
		(
			head : $c._List._Myhead->_Next, 
			size : $c._List._Mysize, 
			next : _Next
		) : $e._Myval
	)
}

;------------------------------------------------------------------------------
;  std::complex
;------------------------------------------------------------------------------

std::complex<*>{
	children
	(
		#(
			real: $e._Val[0],
			imaginary: $e._Val[1]
		)
	)
	preview
	(
		#if($e._Val[1] != 0)
		(										
			#if ($e._Val[0] != 0)				
			(									; Real and Imaginary components 
				#if ($e._Val[1] >= 0)
				(
					#($e._Val[0],"+i*", $e._Val[1])
				)
				#else
				(
					#($e._Val[0],"-i*", -$e._Val[1])							  
				)
			)
			#else
			(									; Purely imaginary
				#if ($e._Val[1] >= 0.0)
				(
					#("i*", $e._Val[1])
				)
				#else
				(
					#("-i*", -$e._Val[1])						
				)
			)
		)
		#else
		(										; Purely real
			$e._Val[0]		
		)
	)
}

;------------------------------------------------------------------------------
;  std::valarray
;------------------------------------------------------------------------------

std::valarray<*>{
    preview
    ( 
		#( 
			"[", 
            $e._Mysize , 
            "](", 
            
            #array
            (
				expr : 	($c._Myptr)[$i],  
				size : 	$c._Mysize
			), 
			
			")"
		)
	)
	
	children
	(
		#array
		(
			expr :	($c._Myptr)[$i],  
			size :	$c._Mysize
		)
	)
}

;------------------------------------------------------------------------------
;  PROPVARIANT
;------------------------------------------------------------------------------

; Visualizers for VT_VECTOR C arrays
tagCAC|tagCAUB|tagCAI|tagCAUI|tagCAL|tagCAUL|tagCAFLT|tagCADBL|tagCACY|tagCADATE|tagCABSTR|tagCABSTRBLOB|tagCABOOL|tagCASCODE|tagCAPROPVARIANT|tagCAH|tagCAUH|tagCALPSTR|tagCALPWSTR|tagCAFILETIME|tagCACLIPDATA|tagCACLSID{
	preview(
		#( 
			"[", 
            $e.cElems , 
            "](", 
            
            #array
            (
				expr : 	($c.pElems)[$i],  
				size : 	$c.cElems
			), 			
			")"
		)
	)

	children
	(
		#array
		(
			expr :	($c.pElems)[$i],  
			size :	$c.cElems
		)
	)	
	
}

; Visualizers for SAFE ARRAY
tagSAFEARRAY|SAFEARRAY{
	preview(		
			#if ($c.fFeatures & 0x0080)		; FADF_HAVEVARTYPE 
			(
				;
				;	Switch on the variant type field - which is stored 4 bytes
				;	before the beginning of the SAFEARRAY type
				;
				#switch( ((unsigned *)&($c))[-1] )						
					#case 0x2							; VT_I2 | VT_ARRAY
					(
						#(
							"safearray of I2 = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((signed short *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)	
					
					#case 0x3							; VT_I4 | VT_ARRAY
					(
						#(
							"safearray of I4 = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((signed int *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)	
					
					#case 0x4							; VT_R4 | VT_ARRAY
					(
						#(
							"safearray of R4 = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((float *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)	
					
					#case 0x5							; VT_R8 | VT_ARRAY
					(
						#(
							"safearray of R8 = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((double *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)	
					
					#case 0x6							; VT_CY | VT_ARRAY
					(
						#(
							"safearray of CY = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((CY *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)
					
					#case 0x7							; VT_DATE | VT_ARRAY
					(
						#(
							"safearray of DATE = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((DATE *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)		
					
					#case 0x8							; VT_BSTR | VT_ARRAY
					(
						#(
							"safearray of BSTR = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((wchar_t **)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)	

					#case 0xa							; VT_ERROR | VT_ARRAY
					(
						#(
							"safearray of ERROR = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((long *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)
					
					#case 0xb							; VT_BOOL | VT_ARRAY
					(
						#(
							"safearray of BOOL = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((short *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)		
					
					#case 0xc							; VT_VARIANT | VT_ARRAY
					(
						#(
							"safearray of VARIANT = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((tagVARIANT *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)	
					
					#case 0x10							; VT_I1 | VT_ARRAY
					(
						#(
							"safearray of I1 = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((signed char *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)		
					
					#case 0x11							; VT_UI1 | VT_ARRAY
					(
						#(
							"safearray of UI1 = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((unsigned char *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)		
					
					#case 0x12							; VT_UI2 | VT_ARRAY
					(
						#(
							"safearray of UI2 = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((unsigned short *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)	
					
					#case 0x13							; VT_UI4 | VT_ARRAY
					(
						#(
							"safearray of UI4 = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((unsigned int *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)	
					
					#case 0x14							; VT_I8 | VT_ARRAY
					(
						#(
							"safearray of I8 = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((signed __int64 *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)	
					
					#case 0x15							; VT_UI8 | VT_ARRAY
					(
						#(
							"safearray of UI8 = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((unsigned __int64 *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)	
					
					#case 0x16							; VT_INT | VT_ARRAY
					(
						#(
							"safearray of INT = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((int *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)																																																																																
					
					#case 0x17							; VT_UINT | VT_ARRAY
					(
						#(
							"safearray of UINT = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((unsigned *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)	
					
					#case 0x1e							; VT_LPSTR | VT_ARRAY
					(
						#(
							"safearray of LPSTR = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((char **)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)	

					#case 0x1f							; VT_LPWSTR | VT_ARRAY
					(
						#(
							"safearray of LPWSTR = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((wchar_t **)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)	
					
					#case 0x40							; VT_FILETIME | VT_ARRAY
					(
						#(
							"safearray of FILETIME = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((FILETIME *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)	
					
					#case 0x47							; VT_CLIPDATA | VT_ARRAY
					(
						#(
							"safearray of CLIPDATA = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((CLIPDATA *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)	
					
					#case 0x48							; VT_CLSID | VT_ARRAY
					(
						#(
							"safearray of CLSID = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((CLSID *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)																															
			)
			#elif ($c.fFeatures & 0x0100)		; FADF_BSTR 
			(
				#("safearray of BSTR = ",#array(expr: $c.rgsabound[$i].cElements, size: $c.cDims) : #("[",$e,"]"), "(", #array(expr: ((wchar_t * *)$c.pvData)[$i], size: $c.rgsabound[$r].cElements, rank: $c.cDims, base: $c.rgsabound[$r].lLbound ), ")")
			)
			#elif ($c.fFeatures & 0x0200)		; FADF_UNKNOWN
			(
				#("safearray of IUnknown* = ",#array(expr: $c.rgsabound[$i].cElements, size: $c.cDims) : #("[",$e,"]"), "(", #array(expr: ((IUnknown *)$c.pvData)[$i], size: $c.rgsabound[$r].cElements, rank: $c.cDims, base: $c.rgsabound[$r].lLbound ), ")")
			)	
			#elif ($c.fFeatures & 0x0400)		; FADF_DISPATCH
			(
				#("safearray of IDispatch* = ",#array(expr: $c.rgsabound[$i].cElements, size: $c.cDims) : #("[",$e,"]"), "(", #array(expr: ((IDispatch*)$c.pvData)[$i], size: $c.rgsabound[$r].cElements, rank: $c.cDims, base: $c.rgsabound[$r].lLbound ), ")")
			)
			#elif ($c.fFeatures & 0x0800)		; FADF_VARIANT
			(
				#("safearray of VARIANT = ",#array(expr: $c.rgsabound[$i].cElements, size: $c.cDims) : #("[",$e,"]"), "(", #array(expr: ((tagVARIANT *)$c.pvData)[$i], size: $c.rgsabound[$r].cElements, rank: $c.cDims, base: $c.rgsabound[$r].lLbound ), ")")
			)
	)
	children(
		#(									;[actual members]: [$c,!],
			#if ($c.fFeatures & 0x0080)		; FADF_HAVEVARTYPE 
			(
				#switch( ((unsigned *)&($c))[-1] )	; for some reason the VT field is before the SAFEARRAY struct
					#case 2							; VT_I2|VT_ARRAY
					( 
						#array(
								expr: ((signed short *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound 
							  )
					)				
					
					#case 3							; VT_I4|VT_ARRAY
					( 
						#array(
								expr: ((signed int   *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound 
							   )
					)		
							
					#case 4							; VT_R4|VT_ARRAY
					( 
						#array(
								expr: ((float *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements,
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound 
							   )
					)		
							
					#case 5							; VT_R8|VT_ARRAY
					( 
						#array(
								expr: ((double  *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound 
							  )
					)		
							
					#case 0x10						; VT_I1|VT_ARRAY
					( 
						#array(
								expr: ((signed char *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound 
							   )
					)	
								
					#case 0x11						; VT_UI1|VT_ARRAY
					( 
						#array(
								expr: ((unsigned char *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound 
							  )
					)		
							
					#case 0x12						; VT_UI2|VT_ARRAY
					( 
						#array(
								expr: ((unsigned short *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound 
							   )
					)		
							
					#case 0x13						; VT_UI4|VT_ARRAY
					( 
						#array(
								expr: ((unsigned int *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							   )	
					)
								
					#case 0x14						; VT_I8|VT_ARRAY
					( 
						#array(
								expr: ((signed __int64 *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							   )				
					)							 
					#case 0x15						; VT_UI8|VT_ARRAY
					( 
						#array(
								expr: ((unsigned __int64 *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							  )				
					)
					
					#case 0x1e						; VT_LPSTR|VT_ARRAY
					( 
						#array(
								expr: ((char * *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							  )			
					)
					
					#case 0x1f						; VT_LPWSTR|VT_ARRAY
					( 
						#array(
								expr: ((wchar_t **)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							  )		
					)
					
					#case 0xc						; VT_VARIANT|VT_ARRAY
					( 
						#array(
								expr: ((tagVARIANT *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							  )			
					
					)
					
					#case 0xb						; VT_BOOL|VT_ARRAY
					(					
						#array(
								expr: ((short *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							  )			
					)
					
					#case 0xa						; VT_ERROR|VT_ARRAY
					( 
						#array(
								expr: ((long *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							  )			
					)
					
					#case 6							; VT_CY|VT_ARRAY
					( 
						#array(
								expr: ((CY *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							  )				
					)
					
					#case 7							; VT_DATE|VT_ARRAY
					( 
						#array(
								expr: ((DATE *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							  )			
					)
					
					#case 0x40						; VT_FILETIME|VT_ARRAY
					( 
						#array(
								expr: ((FILETIME *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							  )		
					)
					
					#case 0x48						; VT_CLSID|VT_ARRAY
					( 
						#array(
								expr: ((CLSID *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							  )			
					)
					
					#case 0x47						; VT_CF|VT_ARRAY
					( 
						#array(
								expr: ((CLIPDATA *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							  )				
					)
					
					#case 8							; VT_BSTR|VT_ARRAY
					( 
						#array(
								expr: ((wchar_t * *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							  )			
					)
					
					#case 0x16						; VT_INT|VT_ARRAY
					( 
						#array(
								expr: ((int *)$c.pvData)[$i],
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							  )				
					)
					
					#case 0x17						; VT_UINT|VT_ARRAY		
					( 
						#array(
								expr: ((unsigned int*)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							  )	
					)			
					
					#default
					(
						#([actual members]: [$e,!])
					)
					#except
					(
						#([actual members]: [$e,!])
					)
			)
			#elif ($c.fFeatures & 0x0100)		; FADF_BSTR 
			(
				#array(expr: ((wchar_t * *)$c.pvData)[$i], size: $c.rgsabound[$r].cElements, rank: $c.cDims, base: $c.rgsabound[$r].lLbound )	
			)
			#elif ($c.fFeatures & 0x0200)		; FADF_UNKNOWN
			(
				#array(expr: ((IUnknown *)$c.pvData)[$i], size: $c.rgsabound[$r].cElements, rank: $c.cDims, base: $c.rgsabound[$r].lLbound )	
			)	
			#elif ($c.fFeatures & 0x0400)		; FADF_DISPATCH
			(
				#array(expr: ((IDispatch *)$c.pvData)[$i], size: $c.rgsabound[$r].cElements, rank: $c.cDims, base: $c.rgsabound[$r].lLbound )	
			)
			#elif ($c.fFeatures & 0x0800)		; FADF_VARIANT
			(
				#array(expr: ((tagVARIANT *)$c.pvData)[$i], size: $c.rgsabound[$r].cElements, rank: $c.cDims, base: $c.rgsabound[$r].lLbound )	
			)
		)
	)
}

tagPROPVARIANT|tagVARIANT|PROPVARIANT|VARIANT{
	preview(
			#switch ($e.vt)
				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				;;      Base Types                                          ;;
				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				#case 0 ( #("Empty") )										; VT_EMPTY
				#case 1 ( #("NULL") )										; VT_NULL
				#case 2 ( #("I2 = ", $e.iVal) )								; VT_I2
				#case 3 ( #("I4 = ", $e.lVal) )								; VT_I4
				#case 4 ( #("R4 = ", $e.fltVal) )							; VT_R4
				#case 5 ( #("R8 = ", $e.dblVal) )							; VT_R8
				#case 6 ( #("CY = ", $e.cyVal) )							; VT_CY
				#case 7 ( #("DATE =  ", $e.date) )							; VT_DATE
				#case 8 ( #("BSTR = ", $e.bstrVal) )						; VT_BSTR
				#case 9 ( #("DISPATCH =  ", $e.pdispVal) )					; VT_DISPATCH
				#case 10 ( #("ERROR =  ", $e.scode) )						; VT_ERROR
				#case 0xB ( #("BOOL =  ", $e.boolVal) )						; VT_BOOL
				#case 0xC ( #("VARIANT ") )									; VT_VARIANT
				#case 0xD ( #("UNKNOWN =  ", $e.punkVal) )					; VT_UNKOWN
				#case 0xE ( #("DECIMAL = ", $e.hVal) )						; VT_DECIMAL
				#case 0x10 ( #("I1 =  ", $e.cVal) )							; VT_I1
				#case 0x11 ( #("UI1 =  ", $e.bVal) )							; VT_UI1
				#case 0x12 ( #("UI2 =  ", $e.uiVal) )							; VT_UI2
				#case 0x13 ( #("UI4 =  ", $e.ulVal) )							; VT_UI4
				#case 0x14 ( #("I8 =  ", $e.hVal) )							; VT_I8
				#case 0x15 ( #("UI8 =  ", $e.uhVal) )							; VT_UI8
				#case 0x16 ( #("INT =  ", $e.intVal) )						; VT_INT
				#case 0x17 ( #("UINT = ", $e.uintVal) )						; VT_UINT
				#case 0x18 ( #("VOID ") )										; VT_VOID
				#case 0x19 ( #("HRESULT ") )									; VT_HRESULT
				#case 0x1A ( #("PTR ") )										; VT_PTR
				#case 0x1B ( #("SAFEARRAY ") )								; VT_SAFEARRAY
				#case 0x1C ( #("CARRAY ") )									; VT_CARRAY
				#case 0x1D ( #("USERDEFINED ") )								; VT_USERDEFINED
				#case 0x1E ( #("LPSTR =  ", $e.pszVal) )						; VT_LPSTR
				#case 0x1F ( #("LPWSTR =  ", $e.pwszVal) )					; VT_LPWSTR
				#case 0x24 ( #("RECORD  ") )									; VT_RECORD
				#case 0x26 ( #("UINT_PTR ") )									; VT_UINT_PTR
				#case 0x40 ( #("FILETIME =  ", $e.filetime) )					; VT_FILETIME
				#case 0x42 ( #("STREAM =  ", $e.pStream) )					; VT_STREAM
				#case 0x43 ( #("STORAGE = ", $e.pStorage) )					; VT_STORAGE
				#case 0x44 ( #("STREAMED_OBJECT =  ", $e.pStream) )			; VT_STREAMED_OBJECT
				#case 0x45 ( #("STORED_OBJECT =  ", $e.pStorage) )			; VT_STORED_OBJECT
				#case 0x46 ( #("BLOB_OBJECT = ", $e.blob ) )					; VT_BLOB_OBJECT
				#case 0x47 ( #("CF =  ", $e.pclipdata) )						; VT_CF
				#case 0x48 ( #("CLSID = ", $e.puuid) )						; VT_CLSID
				#case 0x49 ( #("VERSIONED_STREAM = ", $e.pVersionedStream) )	; VT_VERSIONED_STREAM
				
				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				;;   Vector types                                           ;;
				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				#case 0x1002 ( #("vector of I2 = ", $e.cai) )					; VT_I2|VT_VECTOR
				#case 0x1003 ( #("vector of I4 = ", $e.cal) )					; VT_I4|VT_VECTOR
				#case 0x1004 ( #("vector of R4 = ", $e.caflt) )				; VT_R4|VT_VECTOR
				#case 0x1005 ( #("vector of R8 = ", $e.cadbl) )				; VT_R8|VT_VECTOR
				#case 0x1010 ( #("vector of I1 =  ", $e.cac) )				; VT_I1|VT_VECTOR
				#case 0x1011 ( #("vector of UI1 =  ", $e.caub) )				; VT_UI1|VT_VECTOR
				#case 0x1012 ( #("vector of UI2 =  ", $e.caui) )				; VT_UI2|VT_VECTOR
				#case 0x1013 ( #("vector of UI4 =  ", $e.caul) )				; VT_UI4|VT_VECTOR
				#case 0x1014 ( #("vector of I8 =  ", $e.cah) )				; VT_I8|VT_VECTOR
				#case 0x1015 ( #("vector of UI8 =  ", $e.cauh) )				; VT_UI8|VT_VECTOR
				#case 0x101E ( #("vector of LPSTR =  ", $e.calpstr) )			; VT_LPSTR|VT_VECTOR
				#case 0x101F ( #("vector of LPWSTR =  ", $e.calpwstr) )		; VT_LPWSTR|VT_VECTOR
				#case 0x100C ( #("vector of VARIANT ", $e.capropvar) )		; VT_VARIANT|VT_VECTOR
				#case 0x100B ( #("vector of BOOL =  ", $e.cabool) )		    ; VT_BOOL|VT_VECTOR
				#case 0x100A ( #("vector of ERROR =  ", $e.cascode) )			; VT_ERROR|VT_VECTOR
				#case 0x1006 ( #("vector of CY = ", $e.cacy) )				; VT_CY|VT_VECTOR
				#case 0x1007 ( #("vector of DATE =  ", $e.cadate) )			; VT_DATE|VT_VECTOR
				#case 0x1040 ( #("vector of FILETIME =  ", $e.cafiletime) )	; VT_FILETIME|VT_VECTOR
				#case 0x1048 ( #("vector of CLSID = ", $e.cauuid) )			; VT_CLSID|VT_VECTOR
				#case 0x1047 ( #("vector of CF =  ", $e.caclipdata) )			; VT_CF|VT_VECTOR
				#case 0x1008 ( #("vector of BSTR = ", $e.cabstr) )			; VT_BSTR|VT_VECTOR
		
				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				;;   Byref Types                                            ;;
				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				#case 0x4016 ( #("byref of INT =  ", $e.pintVal) )				; VT_INT|VT_BYREF
				#case 0x4017 ( #("byref of UINT = ", $e.puintVal) )				; VT_UINT|VT_BYREF
				#case 0x4002 ( #("byref of I2 = ", $e.piVal) )					; VT_I2|VT_BYREF
				#case 0x4003 ( #("byref of I4 = ", $e.plVal) )					; VT_I4|VT_BYREF
				#case 0x4004 ( #("byref of R4 = ", $e.pfltVal) )					; VT_R4|VT_BYREF
				#case 0x4005 ( #("byref of R8 = ", $e.pdblVal) )					; VT_R8|VT_BYREF
				#case 0x4010 ( #("byref of I1 =  ", $e.pcVal) )					; VT_I1|VT_BYREF
				#case 0x4011 ( #("byref of UI1 =  ", $e.pbVal) )					; VT_UI1|VT_BYREF
				#case 0x4012 ( #("byref of UI2 =  ", $e.puiVal) )				; VT_UI2|VT_BYREF
				#case 0x4013 ( #("byref of UI4 =  ", $e.pulVal) )				; VT_UI4|VT_BYREF
				#case 0x400C ( #("byref of VARIANT ", $e.pvarVal) )				; VT_VARIANT|VT_BYREF
				#case 0x400B ( #("byref of BOOL =  ", $e.pboolVal) )				; VT_BOOL|VT_BYREF
				#case 0x400A ( #("byref of ERROR =  ", $e.pscode) )				; VT_ERROR|VT_BYREF
				#case 0x4006 ( #("byref of CY = ", $e.pcyVal) )					; VT_CY|VT_BYREF
				#case 0x4007 ( #("byref of DATE =  ", $e.pdate) )				; VT_DATE|VT_BYREF
				#case 0x4008 ( #("byref of BSTR = ", $e.pbstrVal) )				; VT_BSTR|VT_BYREF
				#case 0x400E ( #("byref of DECIMAL = ", $e.pdecVal) )			; VT_DECIMAL|VT_BYREF
				#case 0x400D ( #("byref of UNKNOWN =  ", $e.ppunkVal) )			; VT_UNKOWN|VT_BYREF
				#case 0x4009 ( #("byref of DISPATCH =  ", $e.ppdispVal) )		; VT_DISPATCH|VT_BYREF
				#case 0x6000 ( #("byref of ARRAY =  ", $e.pparray) )				; VT_ARRAY|VT_BYREF
							
				#default 
				( 
					#if ($e.vt & 0x2000)
					(
						$e.parray
					)
					#else
					(
						#("Unknown vt type = ", $e.vt) 
					)
				)
	)
	
	
	children(
			#(vt: $e.vt, 
			#switch ($e.vt)
				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				;;      Base Types                                          ;;
				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				#case 0x2 ( #(I2  : $e.iVal) )								; VT_I2
				#case 0x3 ( #(I4  : $e.lVal) )								; VT_I4
				#case 0x4 ( #(R4  : $e.fltVal) )								; VT_R4
				#case 0x5 ( #(R8  : $e.dblVal) )								; VT_R8
				#case 0x6 ( #(CY  : $e.cyVal) )								; VT_CY
				#case 0x7 ( #(DATE   : $e.date) )								; VT_DATE
				#case 0x8 ( #(BSTR  : $e.bstrVal) )							; VT_BSTR
				#case 0x9 ( #(DISPATCH   : $e.pdispVal) )						; VT_DISPATCH
				#case 0xA ( #(ERROR   : $e.scode) )							; VT_ERROR
				#case 0xB ( #(BOOL   : $e.boolVal) )							; VT_BOOL
				#case 0xD ( #(UNKNOWN   : $e.punkVal) )						; VT_UNKOWN
				#case 0xE ( #(DECIMAL  : $e.hVal) )							; VT_DECIMAL
				#case 0x10 ( #(I1   : $e.cVal) )								; VT_I1
				#case 0x11 ( #(UI1   : $e.bVal) )								; VT_UI1
				#case 0x12 ( #(UI2   : $e.uiVal) )							; VT_UI2
				#case 0x13 ( #(UI4   : $e.ulVal) )							; VT_UI4
				#case 0x14 ( #(I8   : $e.hVal) )								; VT_I8
				#case 0x15 ( #(UI8   : $e.uhVal) )							; VT_UI8
				#case 0x16 ( #(INT   : $e.intVal) )							; VT_INT
				#case 0x17 ( #(UINT  : $e.uintVal) )							; VT_UINT
				#case 0x1E ( #(LPSTR   : $e.pszVal) )							; VT_LPSTR
				#case 0x1F ( #(LPWSTR   : $e.pwszVal) )						; VT_LPWSTR
				#case 0x40 ( #(FILETIME   : $e.filetime) )					; VT_FILETIME
				#case 0x42 ( #(STREAM   : $e.pStream) )						; VT_STREAM
				#case 0x43 ( #(STORAGE  : $e.pStorage) )						; VT_STORAGE
				#case 0x44 ( #(STREAMED_OBJECT   : $e.pStream) )				; VT_STREAMED_OBJECT
				#case 0x45 ( #(STORED_OBJECT   : $e.pStorage) )				; VT_STORED_OBJECT
				#case 0x46 ( #(BLOB_OBJECT  : $e.blob ) )						; VT_BLOB_OBJECT
				#case 0x47 ( #(CF   : $e.pclipdata) )							; VT_CF
				#case 0x48 ( #(CLSID  : $e.puuid) )							; VT_CLSID
				#case 0x49 ( #(VERSIONED_STREAM  : $e.pVersionedStream) )		; VT_VERSIONED_STREAM
				
				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				;;   Vector types                                           ;;
				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				#case 0x1002 ( #(vector of I2  : $e.cai) )					; VT_I2|VT_VECTOR
				#case 0x1003 ( #(vector of I4  : $e.cal) )					; VT_I4|VT_VECTOR
				#case 0x1004 ( #(vector of R4  : $e.caflt) )					; VT_R4|VT_VECTOR
				#case 0x1005 ( #(vector of R8  : $e.cadbl) )					; VT_R8|VT_VECTOR
				#case 0x1010 ( #(vector of I1   : $e.cac) )					; VT_I1|VT_VECTOR
				#case 0x1011 ( #(vector of UI1   : $e.caub) )					; VT_UI1|VT_VECTOR
				#case 0x1012 ( #(vector of UI2   : $e.caui) )					; VT_UI2|VT_VECTOR
				#case 0x1013 ( #(vector of UI4   : $e.caul) )					; VT_UI4|VT_VECTOR
				#case 0x1014 ( #(vector of I8   : $e.cah) )					; VT_I8|VT_VECTOR
				#case 0x1015 ( #(vector of UI8   : $e.cauh) )					; VT_UI8|VT_VECTOR
				#case 0x101E ( #(vector of LPSTR   : $e.calpstr) )			; VT_LPSTR|VT_VECTOR
				#case 0x101F ( #(vector of LPWSTR   : $e.calpwstr) )			; VT_LPWSTR|VT_VECTOR
				#case 0x100C ( #(vector of VARIANT : $e.capropvar) )			; VT_VARIANT|VT_VECTOR
				#case 0x100B ( #(vector of BOOL   : $e.cabool) )				; VT_BOOL|VT_VECTOR
				#case 0x100A ( #(vector of ERROR   : $e.cascode) )			; VT_ERROR|VT_VECTOR
				#case 0x1006 ( #(vector of CY  : $e.cacy) )					; VT_CY|VT_VECTOR
				#case 0x1007 ( #(vector of DATE   : $e.cadate) )				; VT_DATE|VT_VECTOR
				#case 0x1040 ( #(vector of FILETIME   : $e.cafiletime) )		; VT_FILETIME|VT_VECTOR
				#case 0x1048 ( #(vector of CLSID  : $e.cauuid) )				; VT_CLSID|VT_VECTOR
				#case 0x1047 ( #(vector of CF   : $e.caclipdata) )			; VT_CF|VT_VECTOR
				#case 0x1008 ( #(vector of BSTR  : $e.cabstr) )				; VT_BSTR|VT_VECTOR

				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				;;   Byref Types                                            ;;
				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				#case 0x4016 ( #(byref of INT   : $e.pintVal) )				; VT_INT|VT_BYREF
				#case 0x4017 ( #(byref of UINT  : $e.puintVal) )				; VT_UINT|VT_BYREF
				#case 0x4002 ( #(byref of I2  : $e.piVal) )					; VT_I2|VT_BYREF
				#case 0x4003 ( #(byref of I4  : $e.plVal) )					; VT_I4|VT_BYREF
				#case 0x4004 ( #(byref of R4  : $e.pfltVal) )				; VT_R4|VT_BYREF
				#case 0x4005 ( #(byref of R8  : $e.pdblVal) )				; VT_R8|VT_BYREF
				#case 0x4010 ( #(byref of I1   : $e.pcVal) )					; VT_I1|VT_BYREF
				#case 0x4011 ( #(byref of UI1   : $e.pbVal) )				; VT_UI1|VT_BYREF
				#case 0x4012 ( #(byref of UI2   : $e.puiVal) )				; VT_UI2|VT_BYREF
				#case 0x4013 ( #(byref of UI4   : $e.pulVal) )				; VT_UI4|VT_BYREF
				#case 0x400C ( #(byref of VARIANT : $e.pvarVal) )			; VT_VARIANT|VT_BYREF
				#case 0x400B ( #(byref of BOOL   : $e.pboolVal) )			; VT_BOOL|VT_BYREF
				#case 0x400A ( #(byref of ERROR   : $e.pscode) )				; VT_ERROR|VT_BYREF
				#case 0x4006 ( #(byref of CY  : $e.pcyVal) )					; VT_CY|VT_BYREF
				#case 0x4007 ( #(byref of DATE   : $e.pdate) )				; VT_DATE|VT_BYREF
				#case 0x4008 ( #(byref of BSTR  : $e.pbstrVal) )				; VT_BSTR|VT_BYREF
				#case 0x400E ( #(byref of DECIMAL  : $e.pdecVal) )			; VT_DECIMAL|VT_BYREF
				#case 0x400D ( #(byref of UNKNOWN   : $e.ppunkVal) )			; VT_UNKOWN|VT_BYREF
				#case 0x4009 ( #(byref of DISPATCH   : $e.ppdispVal) )		; VT_DISPATCH|VT_BYREF
				#case 0x6000 ( #(byref of ARRAY   : $e.pparray) )			; VT_ARRAY|VT_BYREF
				
				; the following are either empty or invalid vt values for a variant
				; #case 0 ( #(Empty :) )										; VT_EMPTY
				; #case 0x1 ( #(NULL :) )										; VT_NULL
				; #case 0xC ( #(VARIANT :) )									; VT_VARIANT
				; #case 0x18 ( #(VOID :) )										; VT_VOID
				; #case 0x19 ( #(HRESULT :) )									; VT_HRESULT
				; #case 0x1A ( #(PTR :) )										; VT_PTR
				; #case 0x1B ( #(SAFEARRAY :) )									; VT_SAFEARRAY
				; #case 0x1C ( #(CARRAY :) )									; VT_CARRAY
				; #case 0x1D ( #(USERDEFINED :) )								; VT_USERDEFINED
				; #case 0x24 ( #(RECORD  :) )									; VT_RECORD
				; #case 0x26 ( #(UINT_PTR :) )									; VT_UINT_PTR
							
				#default 
				( 
					#if ($e.vt & 0x2000 )
					(
						#(safearray: $e.parray)
					)
					#else
					(
						#(
							[raw members]: [$e,!]	; unformatted data members
						)
					)
				)							
				#except 
				( 
					#(
						[raw members]: [$e,!]	; unformatted data members
					)
				)							
	))
}

; This section lets you define your own errors for the HRESULT display.
; You need to list the error code in unsigned decimal, followed by the message.
; Changes will take effect the next time you redisplay the variable.
[hresult]
;1234=my custom error code

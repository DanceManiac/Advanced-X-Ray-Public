; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	D:\CLEARSKY\sources\engine\xrEngine\Text_Console.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	?OnFrame@CTextConsole@@UAGXXZ			; CTextConsole::OnFrame
PUBLIC	?Destroy@CTextConsole@@UAEXXZ			; CTextConsole::Destroy
PUBLIC	?Initialize@CTextConsole@@UAEXXZ		; CTextConsole::Initialize
PUBLIC	?OnRender@CTextConsole@@UAEXXZ			; CTextConsole::OnRender
PUBLIC	?size@?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@stlp_std@@QBEIXZ ; stlp_std::vector<shared_str,xalloc<shared_str> >::size
PUBLIC	?size@?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@QBEIXZ ; xr_vector<shared_str,xalloc<shared_str> >::size
PUBLIC	??A?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@QAEAAVshared_str@@I@Z ; xr_vector<shared_str,xalloc<shared_str> >::operator[]
PUBLIC	?g_svTextConsoleUpdateRate@@3HA			; g_svTextConsoleUpdateRate
PUBLIC	??_C@_0N@CGFICJJI@TEXT_CONSOLE?$AA@		; `string'
PUBLIC	??_C@_0BC@BMDLCHKK@XRAY?5Text?5Console?$AA@	; `string'
PUBLIC	??_C@_0BP@HKPBKOBO@CTextConsole?3?3CreateConsoleWnd?$AA@ ; `string'
PUBLIC	??_C@_0DF@OECDJJNH@D?3?2CLEARSKY?2sources?2engine?2xrEng@ ; `string'
PUBLIC	??_C@_0CF@PAHJGOGD@Unable?5to?5Create?5TextConsole?5Win@ ; `string'
PUBLIC	??_C@_0O@IKOHBJCM@m_hConsoleWnd?$AA@		; `string'
PUBLIC	??_C@_0BF@HJFDKALO@TEXT_CONSOLE_LOG_WND?$AA@	; `string'
PUBLIC	??_C@_0BG@EOFDKDIP@XRAY?5Text?5Console?5Log?$AA@ ; `string'
PUBLIC	??_C@_0BL@GHENLCPO@CTextConsole?3?3CreateLogWnd?$AA@ ; `string'
PUBLIC	??_C@_09NCJAFLKN@m_hLogWnd?$AA@			; `string'
PUBLIC	??_C@_0CF@OIMKOGBP@Unable?5to?5Create?5Font?5for?5Log?5Wi@ ; `string'
PUBLIC	??_C@_0O@HLJICJAP@m_hLogWndFont?$AA@		; `string'
PUBLIC	??_C@_0CB@MFCOLKCK@Unable?5to?5Get?5DC?5for?5Log?5Window?$CB@ ; `string'
PUBLIC	??_C@_0N@KFPNLOGC@m_hDC_LogWnd?$AA@		; `string'
PUBLIC	??_C@_0CP@LCJDBKMI@Unable?5to?5Create?5Compatible?5DC?5f@ ; `string'
PUBLIC	??_C@_0BI@NIEDJCGI@m_hDC_LogWnd_BackBuffer?$AA@	; `string'
PUBLIC	??_C@_0DD@IHPCHKOI@Unable?5to?5Create?5Compatible?5Bitm@ ; `string'
PUBLIC	??_C@_08EFIBLJBG@m_hBB_BM?$AA@			; `string'
PUBLIC	??_C@_01OHGJGJJP@?$FL?$AA@			; `string'
PUBLIC	??_C@_01LBDDMOBJ@?$FN?$AA@			; `string'
PUBLIC	??_C@_0BG@DJBAGMOM@CTextConsole?3?3DrawLog?$AA@	; `string'
PUBLIC	??_C@_0BI@LPKBDJAC@TextOut?$CI?4?4?$CJ?5return?5NULL?$AA@ ; `string'
EXTRN	__imp__CreateCompatibleBitmap@12:PROC
EXTRN	__imp__CreateCompatibleDC@4:PROC
EXTRN	__imp__CreateFontIndirectA@4:PROC
EXTRN	__imp__SetBkColor@8:PROC
EXTRN	__imp__GetDC@4:PROC
EXTRN	__imp__BitBlt@36:PROC
EXTRN	__imp__BeginPaint@8:PROC
EXTRN	__imp__EndPaint@8:PROC
EXTRN	__imp__SetTextColor@8:PROC
EXTRN	__imp__GetTextMetricsA@8:PROC
EXTRN	__imp__TextOutA@20:PROC
EXTRN	__imp__FillRect@12:PROC
EXTRN	__imp_?LogFile@@3PAV?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@A:DWORD
EXTRN	__imp__InvalidateRect@12:PROC
EXTRN	__imp__SetCursor@4:PROC
EXTRN	__imp__GetStockObject@4:PROC
EXTRN	__imp__RegisterClassA@4:PROC
EXTRN	__imp__CreateWindowExA@48:PROC
EXTRN	__imp__GetClientRect@8:PROC
EXTRN	__imp__SetRect@20:PROC
EXTRN	__imp__LoadCursorA@8:PROC
EXTRN	__imp__DeleteObject@4:PROC
EXTRN	__imp__SelectObject@8:PROC
EXTRN	__imp__ReleaseDC@8:PROC
;	COMDAT ?ignore_always@?3??CreateConsoleWnd@CTextConsole@@AAEXXZ@4_NA
_BSS	SEGMENT
?ignore_always@?3??CreateConsoleWnd@CTextConsole@@AAEXXZ@4_NA DB 01H DUP (?) ; `CTextConsole::CreateConsoleWnd'::`4'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?3??CreateLogWnd@CTextConsole@@AAEXXZ@4_NA
_BSS	SEGMENT
?ignore_always@?3??CreateLogWnd@CTextConsole@@AAEXXZ@4_NA DB 01H DUP (?) ; `CTextConsole::CreateLogWnd'::`4'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?7??CreateLogWnd@CTextConsole@@AAEXXZ@4_NA
_BSS	SEGMENT
?ignore_always@?7??CreateLogWnd@CTextConsole@@AAEXXZ@4_NA DB 01H DUP (?) ; `CTextConsole::CreateLogWnd'::`8'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?M@??CreateLogWnd@CTextConsole@@AAEXXZ@4_NA
_BSS	SEGMENT
?ignore_always@?M@??CreateLogWnd@CTextConsole@@AAEXXZ@4_NA DB 01H DUP (?) ; `CTextConsole::CreateLogWnd'::`12'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?BA@??CreateLogWnd@CTextConsole@@AAEXXZ@4_NA
_BSS	SEGMENT
?ignore_always@?BA@??CreateLogWnd@CTextConsole@@AAEXXZ@4_NA DB 01H DUP (?) ; `CTextConsole::CreateLogWnd'::`16'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?BE@??CreateLogWnd@CTextConsole@@AAEXXZ@4_NA
_BSS	SEGMENT
?ignore_always@?BE@??CreateLogWnd@CTextConsole@@AAEXXZ@4_NA DB 01H DUP (?) ; `CTextConsole::CreateLogWnd'::`20'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?P@??DrawLog@CTextConsole@@AAEXPAUHDC__@@PAUtagRECT@@@Z@4_NA
_BSS	SEGMENT
?ignore_always@?P@??DrawLog@CTextConsole@@AAEXPAUHDC__@@PAUtagRECT@@@Z@4_NA DB 01H DUP (?) ; `CTextConsole::DrawLog'::`15'::ignore_always
;	COMDAT ??_C@_0BI@LPKBDJAC@TextOut?$CI?4?4?$CJ?5return?5NULL?$AA@
CONST	SEGMENT
??_C@_0BI@LPKBDJAC@TextOut?$CI?4?4?$CJ?5return?5NULL?$AA@ DB 'TextOut(..)'
	DB	' return NULL', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DJBAGMOM@CTextConsole?3?3DrawLog?$AA@
CONST	SEGMENT
??_C@_0BG@DJBAGMOM@CTextConsole?3?3DrawLog?$AA@ DB 'CTextConsole::DrawLog'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_01LBDDMOBJ@?$FN?$AA@
CONST	SEGMENT
??_C@_01LBDDMOBJ@?$FN?$AA@ DB ']', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01OHGJGJJP@?$FL?$AA@
CONST	SEGMENT
??_C@_01OHGJGJJP@?$FL?$AA@ DB '[', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08EFIBLJBG@m_hBB_BM?$AA@
CONST	SEGMENT
??_C@_08EFIBLJBG@m_hBB_BM?$AA@ DB 'm_hBB_BM', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@IHPCHKOI@Unable?5to?5Create?5Compatible?5Bitm@
CONST	SEGMENT
??_C@_0DD@IHPCHKOI@Unable?5to?5Create?5Compatible?5Bitm@ DB 'Unable to Cr'
	DB	'eate Compatible Bitmap for Log Window!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@NIEDJCGI@m_hDC_LogWnd_BackBuffer?$AA@
CONST	SEGMENT
??_C@_0BI@NIEDJCGI@m_hDC_LogWnd_BackBuffer?$AA@ DB 'm_hDC_LogWnd_BackBuff'
	DB	'er', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@LCJDBKMI@Unable?5to?5Create?5Compatible?5DC?5f@
CONST	SEGMENT
??_C@_0CP@LCJDBKMI@Unable?5to?5Create?5Compatible?5DC?5f@ DB 'Unable to C'
	DB	'reate Compatible DC for Log Window!', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KFPNLOGC@m_hDC_LogWnd?$AA@
CONST	SEGMENT
??_C@_0N@KFPNLOGC@m_hDC_LogWnd?$AA@ DB 'm_hDC_LogWnd', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@MFCOLKCK@Unable?5to?5Get?5DC?5for?5Log?5Window?$CB@
CONST	SEGMENT
??_C@_0CB@MFCOLKCK@Unable?5to?5Get?5DC?5for?5Log?5Window?$CB@ DB 'Unable '
	DB	'to Get DC for Log Window!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HLJICJAP@m_hLogWndFont?$AA@
CONST	SEGMENT
??_C@_0O@HLJICJAP@m_hLogWndFont?$AA@ DB 'm_hLogWndFont', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@OIMKOGBP@Unable?5to?5Create?5Font?5for?5Log?5Wi@
CONST	SEGMENT
??_C@_0CF@OIMKOGBP@Unable?5to?5Create?5Font?5for?5Log?5Wi@ DB 'Unable to '
	DB	'Create Font for Log Window', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09NCJAFLKN@m_hLogWnd?$AA@
CONST	SEGMENT
??_C@_09NCJAFLKN@m_hLogWnd?$AA@ DB 'm_hLogWnd', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GHENLCPO@CTextConsole?3?3CreateLogWnd?$AA@
CONST	SEGMENT
??_C@_0BL@GHENLCPO@CTextConsole?3?3CreateLogWnd?$AA@ DB 'CTextConsole::Cr'
	DB	'eateLogWnd', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@EOFDKDIP@XRAY?5Text?5Console?5Log?$AA@
CONST	SEGMENT
??_C@_0BG@EOFDKDIP@XRAY?5Text?5Console?5Log?$AA@ DB 'XRAY Text Console Lo'
	DB	'g', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HJFDKALO@TEXT_CONSOLE_LOG_WND?$AA@
CONST	SEGMENT
??_C@_0BF@HJFDKALO@TEXT_CONSOLE_LOG_WND?$AA@ DB 'TEXT_CONSOLE_LOG_WND', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IKOHBJCM@m_hConsoleWnd?$AA@
CONST	SEGMENT
??_C@_0O@IKOHBJCM@m_hConsoleWnd?$AA@ DB 'm_hConsoleWnd', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@PAHJGOGD@Unable?5to?5Create?5TextConsole?5Win@
CONST	SEGMENT
??_C@_0CF@PAHJGOGD@Unable?5to?5Create?5TextConsole?5Win@ DB 'Unable to Cr'
	DB	'eate TextConsole Window!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@OECDJJNH@D?3?2CLEARSKY?2sources?2engine?2xrEng@
CONST	SEGMENT
??_C@_0DF@OECDJJNH@D?3?2CLEARSKY?2sources?2engine?2xrEng@ DB 'D:\CLEARSKY'
	DB	'\sources\engine\xrEngine\Text_Console.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@HKPBKOBO@CTextConsole?3?3CreateConsoleWnd?$AA@
CONST	SEGMENT
??_C@_0BP@HKPBKOBO@CTextConsole?3?3CreateConsoleWnd?$AA@ DB 'CTextConsole'
	DB	'::CreateConsoleWnd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BMDLCHKK@XRAY?5Text?5Console?$AA@
CONST	SEGMENT
??_C@_0BC@BMDLCHKK@XRAY?5Text?5Console?$AA@ DB 'XRAY Text Console', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CGFICJJI@TEXT_CONSOLE?$AA@
CONST	SEGMENT
??_C@_0N@CGFICJJI@TEXT_CONSOLE?$AA@ DB 'TEXT_CONSOLE', 00H ; `string'
?g_svTextConsoleUpdateRate@@3HA DD 01H			; g_svTextConsoleUpdateRate
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\text_console.cpp
;	COMDAT ?OnRender@CTextConsole@@UAEXXZ
_TEXT	SEGMENT
?OnRender@CTextConsole@@UAEXXZ PROC			; CTextConsole::OnRender, COMDAT
; _this$ = ecx

; 190  : void CTextConsole::OnRender() {} //disable ÑConsole::OnRender()

	ret	0
?OnRender@CTextConsole@@UAEXXZ ENDP			; CTextConsole::OnRender
_TEXT	ENDS
PUBLIC	?CreateConsoleWnd@CTextConsole@@AAEXXZ		; CTextConsole::CreateConsoleWnd
; Function compile flags: /Ogtpy
;	COMDAT ?CreateConsoleWnd@CTextConsole@@AAEXXZ
_TEXT	SEGMENT
_lY$ = -80						; size = 4
_lX$ = -76						; size = 4
_cRc$ = -72						; size = 16
_rc$ = -56						; size = 16
_wndClass$ = -40					; size = 40
?CreateConsoleWnd@CTextConsole@@AAEXXZ PROC		; CTextConsole::CreateConsoleWnd, COMDAT
; _this$ = ecx

; 32   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 80					; 00000050H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	ebp, ecx

; 33   : 	HINSTANCE hInstance = (HINSTANCE)GetModuleHandle(0);

	push	0
	call	DWORD PTR __imp__GetModuleHandleA@4

; 34   : 	//----------------------------------
; 35   : 	RECT cRc;
; 36   : 	GetClientRect(*m_pMainWnd, &cRc);

	mov	ecx, DWORD PTR [ebp+204]
	mov	edx, DWORD PTR [ecx]
	mov	ebx, eax
	lea	eax, DWORD PTR _cRc$[esp+96]
	push	eax
	push	edx
	call	DWORD PTR __imp__GetClientRect@8

; 37   : 	INT lX = cRc.left;

	mov	eax, DWORD PTR _cRc$[esp+96]

; 38   : 	INT lY = cRc.top;
; 39   : 	INT lWidth = cRc.right - cRc.left;

	mov	esi, DWORD PTR _cRc$[esp+104]
	mov	ecx, DWORD PTR _cRc$[esp+100]

; 40   : 	INT lHeight = cRc.bottom - cRc.top;

	mov	edi, DWORD PTR _cRc$[esp+108]
	mov	DWORD PTR _lX$[esp+96], eax
	sub	esi, eax

; 41   : 	//----------------------------------
; 42   : 	const char*	wndclass ="TEXT_CONSOLE";
; 43   : 
; 44   : 	// Register the windows class
; 45   : 	WNDCLASS wndClass = { 0, TextConsole_WndProc, 0, 0, hInstance,

	xor	eax, eax

; 46   : 		NULL,
; 47   : 		LoadCursor( hInstance, IDC_ARROW ),

	push	32512					; 00007f00H
	push	ebx
	mov	DWORD PTR _lY$[esp+104], ecx
	sub	edi, ecx
	mov	DWORD PTR _wndClass$[esp+104], eax
	mov	DWORD PTR _wndClass$[esp+108], OFFSET ?TextConsole_WndProc@@YGJPAUHWND__@@IIJ@Z ; TextConsole_WndProc
	mov	DWORD PTR _wndClass$[esp+112], eax
	mov	DWORD PTR _wndClass$[esp+116], eax
	mov	DWORD PTR _wndClass$[esp+120], ebx
	mov	DWORD PTR _wndClass$[esp+124], eax
	call	DWORD PTR __imp__LoadCursorA@8

; 48   : 		GetStockBrush(GRAY_BRUSH),

	push	2
	mov	DWORD PTR _wndClass$[esp+124], eax
	call	DWORD PTR __imp__GetStockObject@4
	mov	DWORD PTR _wndClass$[esp+124], eax

; 49   : 		NULL, wndclass };
; 50   : 	RegisterClass( &wndClass );

	lea	eax, DWORD PTR _wndClass$[esp+96]
	push	eax
	mov	DWORD PTR _wndClass$[esp+132], 0
	mov	DWORD PTR _wndClass$[esp+136], OFFSET ??_C@_0N@CGFICJJI@TEXT_CONSOLE?$AA@
	call	DWORD PTR __imp__RegisterClassA@4

; 51   : 
; 52   : 	// Set the window's initial style
; 53   : 	u32 dwWindowStyle = WS_OVERLAPPED | WS_CHILD | WS_VISIBLE;// | WS_CLIPSIBLINGS;// | WS_CLIPCHILDREN;
; 54   : 
; 55   : 	// Set the window's initial width
; 56   : 	RECT rc;
; 57   : 	SetRect			( &rc, lX, lY, lWidth, lHeight );

	mov	ecx, DWORD PTR _lY$[esp+96]
	mov	edx, DWORD PTR _lX$[esp+96]
	push	edi
	push	esi
	push	ecx
	push	edx
	lea	eax, DWORD PTR _rc$[esp+112]
	push	eax
	call	DWORD PTR __imp__SetRect@20

; 58   : //	AdjustWindowRect( &rc, dwWindowStyle, FALSE );
; 59   : 
; 60   : 	// Create the render window
; 61   : 	m_hConsoleWnd = CreateWindow( wndclass, "XRAY Text Console", dwWindowStyle,
; 62   : 		lX, lY,
; 63   : 		lWidth, lHeight, *m_pMainWnd,
; 64   : 		0, hInstance, 0L );

	mov	ecx, DWORD PTR [ebp+204]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _lY$[esp+96]
	mov	ecx, DWORD PTR _lX$[esp+96]
	push	0
	push	ebx
	push	0
	push	edx
	push	edi
	push	esi
	push	eax
	push	ecx
	push	1342177280				; 50000000H
	push	OFFSET ??_C@_0BC@BMDLCHKK@XRAY?5Text?5Console?$AA@
	push	OFFSET ??_C@_0N@CGFICJJI@TEXT_CONSOLE?$AA@
	push	0
	call	DWORD PTR __imp__CreateWindowExA@48
	mov	DWORD PTR [ebp+208], eax

; 65   : 	//---------------------------------------------------------------------------
; 66   : 	R_ASSERT2(m_hConsoleWnd, "Unable to Create TextConsole Window!");

	cmp	BYTE PTR ?ignore_always@?3??CreateConsoleWnd@CTextConsole@@AAEXXZ@4_NA, 0
	jne	SHORT $LN3@CreateCons
	test	eax, eax
	jne	SHORT $LN3@CreateCons
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?3??CreateConsoleWnd@CTextConsole@@AAEXXZ@4_NA
	push	OFFSET ??_C@_0BP@HKPBKOBO@CTextConsole?3?3CreateConsoleWnd?$AA@
	push	66					; 00000042H
	push	OFFSET ??_C@_0DF@OECDJJNH@D?3?2CLEARSKY?2sources?2engine?2xrEng@
	push	OFFSET ??_C@_0CF@PAHJGOGD@Unable?5to?5Create?5TextConsole?5Win@
	push	OFFSET ??_C@_0O@IKOHBJCM@m_hConsoleWnd?$AA@
	call	DWORD PTR __imp_?fail@xrDebug@@QAEXPBD00H0AA_N@Z
$LN3@CreateCons:

; 67   : };

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CreateConsoleWnd@CTextConsole@@AAEXXZ ENDP		; CTextConsole::CreateConsoleWnd
_TEXT	ENDS
PUBLIC	?get_selected_mode@line_edit_control@text_editor@@QBE_NXZ ; text_editor::line_edit_control::get_selected_mode
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\line_edit_control.h
;	COMDAT ?get_selected_mode@line_edit_control@text_editor@@QBE_NXZ
_TEXT	SEGMENT
?get_selected_mode@line_edit_control@text_editor@@QBE_NXZ PROC ; text_editor::line_edit_control::get_selected_mode, COMDAT
; _this$ = ecx

; 86   : 		bool		get_selected_mode	() const			{ return !m_unselected_mode; }

	xor	eax, eax
	cmp	BYTE PTR [ecx+1106], al
	sete	al
	ret	0
?get_selected_mode@line_edit_control@text_editor@@QBE_NXZ ENDP ; text_editor::line_edit_control::get_selected_mode
_TEXT	ENDS
PUBLIC	?set_selected_mode@line_edit_control@text_editor@@QAEX_N@Z ; text_editor::line_edit_control::set_selected_mode
; Function compile flags: /Ogtpy
;	COMDAT ?set_selected_mode@line_edit_control@text_editor@@QAEX_N@Z
_TEXT	SEGMENT
_status$ = 8						; size = 1
?set_selected_mode@line_edit_control@text_editor@@QAEX_N@Z PROC ; text_editor::line_edit_control::set_selected_mode, COMDAT
; _this$ = ecx

; 85   : 		void		set_selected_mode	( bool status )		{ m_unselected_mode = !status; }

	cmp	BYTE PTR _status$[esp-4], 0
	sete	al
	mov	BYTE PTR [ecx+1106], al
	ret	4
?set_selected_mode@line_edit_control@text_editor@@QAEX_N@Z ENDP ; text_editor::line_edit_control::set_selected_mode
_TEXT	ENDS
PUBLIC	?str_after_mark@line_edit_control@text_editor@@QBEPBDXZ ; text_editor::line_edit_control::str_after_mark
; Function compile flags: /Ogtpy
;	COMDAT ?str_after_mark@line_edit_control@text_editor@@QBEPBDXZ
_TEXT	SEGMENT
?str_after_mark@line_edit_control@text_editor@@QBEPBDXZ PROC ; text_editor::line_edit_control::str_after_mark, COMDAT
; _this$ = ecx

; 82   : 	IC	LPCSTR		str_after_mark		()	const	{ return m_buf3; }

	mov	eax, DWORD PTR [ecx+1048]
	ret	0
?str_after_mark@line_edit_control@text_editor@@QBEPBDXZ ENDP ; text_editor::line_edit_control::str_after_mark
_TEXT	ENDS
PUBLIC	?str_mark@line_edit_control@text_editor@@QBEPBDXZ ; text_editor::line_edit_control::str_mark
; Function compile flags: /Ogtpy
;	COMDAT ?str_mark@line_edit_control@text_editor@@QBEPBDXZ
_TEXT	SEGMENT
?str_mark@line_edit_control@text_editor@@QBEPBDXZ PROC	; text_editor::line_edit_control::str_mark, COMDAT
; _this$ = ecx

; 81   : 	IC	LPCSTR		str_mark			()	const	{ return m_buf2; }

	mov	eax, DWORD PTR [ecx+1044]
	ret	0
?str_mark@line_edit_control@text_editor@@QBEPBDXZ ENDP	; text_editor::line_edit_control::str_mark
_TEXT	ENDS
PUBLIC	?str_before_mark@line_edit_control@text_editor@@QBEPBDXZ ; text_editor::line_edit_control::str_before_mark
; Function compile flags: /Ogtpy
;	COMDAT ?str_before_mark@line_edit_control@text_editor@@QBEPBDXZ
_TEXT	SEGMENT
?str_before_mark@line_edit_control@text_editor@@QBEPBDXZ PROC ; text_editor::line_edit_control::str_before_mark, COMDAT
; _this$ = ecx

; 80   : 	IC	LPCSTR		str_before_mark		()	const	{ return m_buf1; }

	mov	eax, DWORD PTR [ecx+1040]
	ret	0
?str_before_mark@line_edit_control@text_editor@@QBEPBDXZ ENDP ; text_editor::line_edit_control::str_before_mark
_TEXT	ENDS
PUBLIC	?str_before_cursor@line_edit_control@text_editor@@QBEPBDXZ ; text_editor::line_edit_control::str_before_cursor
; Function compile flags: /Ogtpy
;	COMDAT ?str_before_cursor@line_edit_control@text_editor@@QBEPBDXZ
_TEXT	SEGMENT
?str_before_cursor@line_edit_control@text_editor@@QBEPBDXZ PROC ; text_editor::line_edit_control::str_before_cursor, COMDAT
; _this$ = ecx

; 79   : 	IC	LPCSTR		str_before_cursor	()	const	{ return m_buf0; }

	mov	eax, DWORD PTR [ecx+1036]
	ret	0
?str_before_cursor@line_edit_control@text_editor@@QBEPBDXZ ENDP ; text_editor::line_edit_control::str_before_cursor
_TEXT	ENDS
PUBLIC	?str_edit@line_edit_control@text_editor@@QBEPBDXZ ; text_editor::line_edit_control::str_edit
; Function compile flags: /Ogtpy
;	COMDAT ?str_edit@line_edit_control@text_editor@@QBEPBDXZ
_TEXT	SEGMENT
?str_edit@line_edit_control@text_editor@@QBEPBDXZ PROC	; text_editor::line_edit_control::str_edit, COMDAT
; _this$ = ecx

; 78   : 	IC	LPCSTR		str_edit			()	const	{ return m_edit_str; }

	mov	eax, DWORD PTR [ecx+1024]
	ret	0
?str_edit@line_edit_control@text_editor@@QBEPBDXZ ENDP	; text_editor::line_edit_control::str_edit
_TEXT	ENDS
PUBLIC	?need_update@line_edit_control@text_editor@@QBE_NXZ ; text_editor::line_edit_control::need_update
; Function compile flags: /Ogtpy
;	COMDAT ?need_update@line_edit_control@text_editor@@QBE_NXZ
_TEXT	SEGMENT
?need_update@line_edit_control@text_editor@@QBE_NXZ PROC ; text_editor::line_edit_control::need_update, COMDAT
; _this$ = ecx

; 76   : 	IC	bool		need_update			()	const	{ return m_need_update; }

	mov	al, BYTE PTR [ecx+1105]
	ret	0
?need_update@line_edit_control@text_editor@@QBE_NXZ ENDP ; text_editor::line_edit_control::need_update
_TEXT	ENDS
PUBLIC	?cursor_view@line_edit_control@text_editor@@QBE_NXZ ; text_editor::line_edit_control::cursor_view
; Function compile flags: /Ogtpy
;	COMDAT ?cursor_view@line_edit_control@text_editor@@QBE_NXZ
_TEXT	SEGMENT
?cursor_view@line_edit_control@text_editor@@QBE_NXZ PROC ; text_editor::line_edit_control::cursor_view, COMDAT
; _this$ = ecx

; 75   : 	IC	bool		cursor_view			()	const	{ return m_cursor_view; }

	mov	al, BYTE PTR [ecx+1104]
	ret	0
?cursor_view@line_edit_control@text_editor@@QBE_NXZ ENDP ; text_editor::line_edit_control::cursor_view
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
;	COMDAT ?size@?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@stlp_std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@stlp_std@@QBEIXZ PROC ; stlp_std::vector<shared_str,xalloc<shared_str> >::size, COMDAT
; _this$ = ecx

; 89   :   size_type size() const        { return _M_impl.size(); }

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	ret	0
?size@?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@stlp_std@@QBEIXZ ENDP ; stlp_std::vector<shared_str,xalloc<shared_str> >::size
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ?size@?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@QBEIXZ
_TEXT	SEGMENT
?size@?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@QBEIXZ PROC ; xr_vector<shared_str,xalloc<shared_str> >::size, COMDAT
; _this$ = ecx

; 126  : 	u32		size				() const							{ return (u32)inherited::size();} 

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	ret	0
?size@?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@QBEIXZ ENDP ; xr_vector<shared_str,xalloc<shared_str> >::size
_TEXT	ENDS
PUBLIC	?set_key_state@line_edit_control@text_editor@@QAEXW4key_state@2@_N@Z ; text_editor::line_edit_control::set_key_state
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\line_edit_control.h
;	COMDAT ?set_key_state@line_edit_control@text_editor@@QAEXW4key_state@2@_N@Z
_TEXT	SEGMENT
_mask$ = 8						; size = 4
_value$ = 12						; size = 1
?set_key_state@line_edit_control@text_editor@@QAEXW4key_state@2@_N@Z PROC ; text_editor::line_edit_control::set_key_state, COMDAT
; _this$ = ecx

; 73   : 	IC	void		set_key_state		( key_state mask, bool value )		{ m_key_state.set( mask, value ); }

	movzx	eax, BYTE PTR _value$[esp-4]
	mov	DWORD PTR _value$[esp-4], eax
	add	ecx, 1096				; 00000448H
	jmp	?set@?$_flags@I@@QAEAAU1@IH@Z		; _flags<unsigned int>::set
?set_key_state@line_edit_control@text_editor@@QAEXW4key_state@2@_N@Z ENDP ; text_editor::line_edit_control::set_key_state
_TEXT	ENDS
PUBLIC	?get_key_state@line_edit_control@text_editor@@QBE_NW4key_state@2@@Z ; text_editor::line_edit_control::get_key_state
; Function compile flags: /Ogtpy
;	COMDAT ?get_key_state@line_edit_control@text_editor@@QBE_NW4key_state@2@@Z
_TEXT	SEGMENT
_mask$ = 8						; size = 4
?get_key_state@line_edit_control@text_editor@@QBE_NW4key_state@2@@Z PROC ; text_editor::line_edit_control::get_key_state, COMDAT
; _this$ = ecx

; 72   : 	IC	bool		get_key_state		( key_state mask ) const			{ return (mask)? !!(m_key_state.test( mask ) ) : true; }

	mov	eax, DWORD PTR _mask$[esp-4]
	test	eax, eax
	je	SHORT $LN3@get_key_st
	push	eax
	add	ecx, 1096				; 00000448H
	call	?test@?$_flags@I@@QBEHI@Z		; _flags<unsigned int>::test
	neg	eax
	sbb	eax, eax
	neg	eax
	ret	4
$LN3@get_key_st:
	mov	eax, 1
	ret	4
?get_key_state@line_edit_control@text_editor@@QBE_NW4key_state@2@@Z ENDP ; text_editor::line_edit_control::get_key_state
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
;	COMDAT ??A?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@QAEAAVshared_str@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@QAEAAVshared_str@@I@Z PROC ; xr_vector<shared_str,xalloc<shared_str> >::operator[], COMDAT
; _this$ = ecx

; 139  : 	reference operator[]		(size_type _Pos)					{ {VERIFY2(_Pos<size(),make_string("index is out of range: index requested[%d], size of container[%d]", _Pos, size()).c_str());} return (*(begin() + _Pos)); }

	call	?begin@?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@stlp_std@@QAEPAVshared_str@@XZ ; stlp_std::vector<shared_str,xalloc<shared_str> >::begin
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]
	ret	4
??A?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@QAEAAVshared_str@@I@Z ENDP ; xr_vector<shared_str,xalloc<shared_str> >::operator[]
_TEXT	ENDS
PUBLIC	__real@3ea3d70a
PUBLIC	?DrawLog@CTextConsole@@AAEXPAUHDC__@@PAUtagRECT@@@Z ; CTextConsole::DrawLog
;	COMDAT __real@3ea3d70a
; File d:\clearsky\sources\engine\xrcore\fixedvector.h
CONST	SEGMENT
__real@3ea3d70a DD 03ea3d70ar			; 0.32
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\text_console.cpp
CONST	ENDS
;	COMDAT ?DrawLog@CTextConsole@@AAEXPAUHDC__@@PAUtagRECT@@@Z
_TEXT	SEGMENT
_tm$ = -124						; size = 56
_q$ = -68						; size = 16
_q2$ = -52						; size = 16
_wRC$ = -36						; size = 16
_Width$ = -20						; size = 4
tv975 = -16						; size = 4
_y_top_max$ = -12					; size = 4
_s_edt$ = -8						; size = 4
_this$ = -4						; size = 4
tv803 = 8						; size = 4
_ypos$ = 8						; size = 4
_cur_len$ = 8						; size = 4
_hDC$ = 8						; size = 4
_ls$121469 = 12						; size = 4
_cur0_len$ = 12						; size = 4
_s_cur$ = 12						; size = 4
_pRect$ = 12						; size = 4
?DrawLog@CTextConsole@@AAEXPAUHDC__@@PAUtagRECT@@@Z PROC ; CTextConsole::DrawLog, COMDAT
; _this$ = ecx

; 225  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	push	ebx
	push	esi

; 226  : 	TEXTMETRIC tm;
; 227  : 	GetTextMetrics(hDC, &tm);

	mov	esi, DWORD PTR _hDC$[ebp]
	push	edi
	lea	eax, DWORD PTR _tm$[ebp]
	push	eax
	mov	edi, ecx
	push	esi
	mov	DWORD PTR _this$[ebp], edi
	call	DWORD PTR __imp__GetTextMetricsA@8

; 228  : 
; 229  : 	RECT wRC = *pRect;

	mov	ebx, DWORD PTR _pRect$[ebp]
	mov	edx, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [ebx+8]
	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR _wRC$[ebp+4], edx

; 230  : 	GetClientRect(m_hLogWnd, &wRC);

	lea	edx, DWORD PTR _wRC$[ebp]
	mov	DWORD PTR _wRC$[ebp+8], eax
	mov	eax, DWORD PTR [edi+212]
	mov	DWORD PTR _wRC$[ebp], ecx
	mov	ecx, DWORD PTR [ebx+12]
	push	edx
	push	eax
	mov	DWORD PTR _wRC$[ebp+12], ecx
	call	DWORD PTR __imp__GetClientRect@8

; 231  : 	FillRect(hDC, &wRC, m_hBackGroundBrush);

	mov	ecx, DWORD PTR [edi+232]
	push	ecx
	lea	edx, DWORD PTR _wRC$[ebp]
	push	edx
	push	esi
	call	DWORD PTR __imp__FillRect@12

; 232  : 
; 233  : 	int Width = wRC.right - wRC.left;

	mov	eax, DWORD PTR _wRC$[ebp+8]
	sub	eax, DWORD PTR _wRC$[ebp]

; 234  : 	int Height = wRC.bottom - wRC.top;

	mov	edi, DWORD PTR _wRC$[ebp+12]
	sub	edi, DWORD PTR _wRC$[ebp+4]

; 235  : 	wRC = *pRect;

	mov	edx, DWORD PTR [ebx+8]
	mov	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR _Width$[ebp], eax
	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR _wRC$[ebp], eax
	mov	eax, DWORD PTR [ebx+12]
	mov	DWORD PTR _wRC$[ebp+8], edx

; 236  : 	int y_top_max = (int)(0.32f * Height);
; 237  : 
; 238  : 	//---------------------------------------------------------------------------------
; 239  : 	LPCSTR s_edt = ec().str_edit();

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR _wRC$[ebp+4], ecx
	mov	DWORD PTR _wRC$[ebp+12], eax
	mov	eax, DWORD PTR [edx+200]
	cvtsi2ss xmm0, edi
	mulss	xmm0, DWORD PTR __real@3ea3d70a
	cvttss2si ecx, xmm0
	mov	DWORD PTR _y_top_max$[ebp], ecx
	mov	ecx, DWORD PTR [eax+1028]

; 240  : 	LPCSTR s_cur = ec().str_before_cursor();

	mov	eax, DWORD PTR [eax+1040]
	mov	DWORD PTR _s_edt$[ebp], ecx
	mov	DWORD PTR _s_cur$[ebp], eax

; 241  : 
; 242  : 	u32 cur_len = xr_strlen( s_cur ) + xr_strlen( ch_cursor ) + 1;

	lea	ecx, DWORD PTR [eax+1]
$LL245@DrawLog:
	mov	dl, BYTE PTR [eax]
	add	eax, 1
	test	dl, dl
	jne	SHORT $LL245@DrawLog
	sub	eax, ecx
	add	eax, 2
	mov	DWORD PTR _cur_len$[ebp], eax

; 243  : 	PSTR buf = (PSTR)_alloca( cur_len * sizeof(char) );

	call	__alloca_probe_16

; 244  : 	xr_strcpy( buf, cur_len, s_cur );

	mov	eax, DWORD PTR _cur_len$[ebp]
	mov	edx, DWORD PTR _s_cur$[ebp]
	mov	ebx, esp
	push	eax
	push	edx
	push	eax
	push	ebx
	call	DWORD PTR __imp__strncpy_s

; 245  : 	xr_strcat( buf, cur_len, ch_cursor );

	mov	eax, ebx
	add	esp, 16					; 00000010H
	lea	ecx, DWORD PTR [eax+1]
$LL246@DrawLog:
	mov	dl, BYTE PTR [eax]
	add	eax, 1
	test	dl, dl
	jne	SHORT $LL246@DrawLog
	sub	eax, ecx
	mov	ecx, DWORD PTR _cur_len$[ebp]
	add	eax, ebx
	lea	ecx, DWORD PTR [ebx+ecx-1]
	cmp	eax, ecx
	ja	SHORT $LN40@DrawLog
	mov	edx, OFFSET ??_C@_01IDAFKMJL@_?$AA@
	sub	edx, eax
	mov	DWORD PTR tv975[ebp], edx
$LL38@DrawLog:
	cmp	eax, ecx
	je	SHORT $LN36@DrawLog
	mov	dl, BYTE PTR [edx+eax]
	mov	BYTE PTR [eax], dl
	mov	edx, DWORD PTR tv975[ebp]
	add	eax, 1
	cmp	BYTE PTR [edx+eax], 0
	jne	SHORT $LL38@DrawLog
$LN36@DrawLog:
	mov	BYTE PTR [eax], 0
$LN40@DrawLog:

; 246  : 	buf[cur_len-1] = 0;
; 247  : 
; 248  : 	u32 cur0_len = xr_strlen( s_cur );

	mov	eax, DWORD PTR _s_cur$[ebp]
	mov	BYTE PTR [ecx], 0
	lea	ecx, DWORD PTR [eax+1]
$LL247@DrawLog:
	mov	dl, BYTE PTR [eax]
	add	eax, 1
	test	dl, dl
	jne	SHORT $LL247@DrawLog

; 249  : 
; 250  : 	int xb = 25;
; 251  : 	
; 252  : 	SetTextColor( hDC, RGB(255, 255, 255) );

	push	16777215				; 00ffffffH
	sub	eax, ecx
	push	esi
	mov	DWORD PTR _cur0_len$[ebp], eax
	call	DWORD PTR __imp__SetTextColor@8

; 253  : 	TextOut( hDC, xb, Height-tm.tmHeight-1, buf, cur_len-1 );

	mov	eax, DWORD PTR _cur_len$[ebp]
	add	eax, -1
	push	eax
	mov	ecx, edi
	sub	ecx, DWORD PTR _tm$[ebp]
	push	ebx
	sub	ecx, 1
	push	ecx
	push	25					; 00000019H
	push	esi
	call	DWORD PTR __imp__TextOutA@20

; 254  : 	buf[ cur0_len ] = 0;

	mov	edx, DWORD PTR _cur0_len$[ebp]

; 255  : 	
; 256  : 	SetTextColor(hDC, RGB(0, 0, 0));

	push	0
	push	esi
	mov	BYTE PTR [edx+ebx], 0
	call	DWORD PTR __imp__SetTextColor@8

; 257  : 	TextOut( hDC, xb, Height-tm.tmHeight-1, buf, cur0_len );

	mov	eax, DWORD PTR _cur0_len$[ebp]
	push	eax
	mov	ecx, edi
	sub	ecx, DWORD PTR _tm$[ebp]
	push	ebx
	sub	ecx, 1
	push	ecx
	push	25					; 00000019H
	push	esi
	call	DWORD PTR __imp__TextOutA@20

; 258  : 
; 259  : 
; 260  : 	SetTextColor( hDC, RGB(255, 255, 255) );

	mov	ebx, DWORD PTR __imp__SetTextColor@8
	push	16777215				; 00ffffffH
	push	esi
	call	ebx

; 261  : 	TextOut( hDC, 0, Height-tm.tmHeight-3, ioc_prompt, xr_strlen(ioc_prompt) ); // ">>> "

	push	4
	mov	edx, edi
	sub	edx, DWORD PTR _tm$[ebp]
	push	OFFSET ??_C@_04IMEJGNKP@?$DO?$DO?$DO?5?$AA@
	sub	edx, 3
	push	edx
	push	0
	push	esi
	call	DWORD PTR __imp__TextOutA@20

; 262  : 
; 263  : 	SetTextColor( hDC, (COLORREF)bgr2rgb(get_mark_color( mark11 )) );

	push	6933965					; 0069cdcdH
	push	esi
	call	ebx

; 264  : 	TextOut( hDC, xb, Height-tm.tmHeight-3, s_edt, xr_strlen(s_edt) );

	mov	eax, DWORD PTR _s_edt$[ebp]
	lea	ecx, DWORD PTR [eax+1]
$LL248@DrawLog:
	mov	dl, BYTE PTR [eax]
	add	eax, 1
	test	dl, dl
	jne	SHORT $LL248@DrawLog
	sub	eax, ecx
	push	eax
	mov	eax, DWORD PTR _s_edt$[ebp]
	mov	ecx, edi
	sub	ecx, DWORD PTR _tm$[ebp]
	push	eax
	sub	ecx, 3
	push	ecx
	push	25					; 00000019H
	push	esi
	call	DWORD PTR __imp__TextOutA@20

; 265  : 
; 266  : 	SetTextColor( hDC, RGB(205, 205, 225) );

	push	14798285				; 00e1cdcdH
	push	esi
	call	ebx

; 267  : 	u32 log_line = LogFile->size()-1;

	mov	edx, DWORD PTR __imp_?LogFile@@3PAV?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@A
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax+4]
	sub	edx, DWORD PTR [eax]

; 268  : 	string16 q, q2;
; 269  : 	itoa( log_line, q, 10 );

	push	10					; 0000000aH
	lea	ecx, DWORD PTR _q$[ebp]
	sar	edx, 2
	push	ecx
	sub	edx, 1
	push	edx
	call	DWORD PTR __imp__itoa

; 270  : 	xr_strcpy( q2, sizeof(q2), "[" );

	push	16					; 00000010H
	push	OFFSET ??_C@_01OHGJGJJP@?$FL?$AA@
	lea	eax, DWORD PTR _q2$[ebp]
	push	16					; 00000010H
	push	eax
	call	DWORD PTR __imp__strncpy_s

; 271  : 	xr_strcat( q2, sizeof(q2), q );

	lea	eax, DWORD PTR _q2$[ebp]
	add	esp, 28					; 0000001cH
	lea	ecx, DWORD PTR [eax+1]
	npad	7
$LL249@DrawLog:
	mov	dl, BYTE PTR [eax]
	add	eax, 1
	test	dl, dl
	jne	SHORT $LL249@DrawLog
	sub	eax, ecx
	lea	eax, DWORD PTR _q2$[ebp+eax]
	lea	ecx, DWORD PTR _q2$[ebp+15]
	cmp	eax, ecx
	ja	SHORT $LN144@DrawLog
	cmp	BYTE PTR _q$[ebp], dl
	je	SHORT $LN140@DrawLog
	lea	ecx, DWORD PTR _q$[ebp]
	sub	ecx, eax
$LL142@DrawLog:
	lea	edx, DWORD PTR _q2$[ebp+15]
	cmp	eax, edx
	je	SHORT $LN140@DrawLog
	mov	dl, BYTE PTR [ecx+eax]
	mov	BYTE PTR [eax], dl
	add	eax, 1
	cmp	BYTE PTR [ecx+eax], 0
	jne	SHORT $LL142@DrawLog
$LN140@DrawLog:
	mov	BYTE PTR [eax], 0
$LN144@DrawLog:

; 272  : 	xr_strcat( q2, sizeof(q2), "]" );

	lea	eax, DWORD PTR _q2$[ebp]
	lea	edx, DWORD PTR [eax+1]
	npad	2
$LL250@DrawLog:
	mov	cl, BYTE PTR [eax]
	add	eax, 1
	test	cl, cl
	jne	SHORT $LL250@DrawLog
	sub	eax, edx
	lea	eax, DWORD PTR _q2$[ebp+eax]
	lea	ecx, DWORD PTR _q2$[ebp+15]
	cmp	eax, ecx
	ja	SHORT $LN152@DrawLog
	mov	ecx, OFFSET ??_C@_01LBDDMOBJ@?$FN?$AA@
	sub	ecx, eax
	npad	3
$LL150@DrawLog:
	lea	edx, DWORD PTR _q2$[ebp+15]
	cmp	eax, edx
	je	SHORT $LN148@DrawLog
	mov	dl, BYTE PTR [ecx+eax]
	mov	BYTE PTR [eax], dl
	add	eax, 1
	cmp	BYTE PTR [ecx+eax], 0
	jne	SHORT $LL150@DrawLog
$LN148@DrawLog:
	mov	BYTE PTR [eax], 0
$LN152@DrawLog:

; 273  : 	u32 qn = xr_strlen( q2 );

	lea	eax, DWORD PTR _q2$[ebp]
	lea	ecx, DWORD PTR [eax+1]
	npad	2
$LL251@DrawLog:
	mov	dl, BYTE PTR [eax]
	add	eax, 1
	test	dl, dl
	jne	SHORT $LL251@DrawLog

; 274  : 
; 275  : 	TextOut( hDC, Width - 8 * qn, Height-tm.tmHeight-tm.tmHeight, q2, qn );

	mov	edx, DWORD PTR _tm$[ebp]
	sub	eax, ecx
	push	eax
	add	eax, eax
	lea	ecx, DWORD PTR _q2$[ebp]
	push	ecx
	lea	ecx, DWORD PTR [edx+edx]
	add	eax, eax
	add	eax, eax
	mov	edx, edi
	sub	edx, ecx
	mov	ecx, eax
	mov	eax, DWORD PTR _Width$[ebp]
	push	edx
	sub	eax, ecx
	push	eax
	push	esi
	call	DWORD PTR __imp__TextOutA@20

; 276  : 
; 277  : 	int ypos = Height - tm.tmHeight - tm.tmHeight;

	mov	edx, DWORD PTR _tm$[ebp]

; 278  : 	for( int i = LogFile->size()-1-scroll_delta; i >= 0; --i ) 

	mov	ecx, DWORD PTR __imp_?LogFile@@3PAV?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@A
	lea	eax, DWORD PTR [edx+edx]
	mov	edx, DWORD PTR _this$[ebp]
	sub	edi, eax
	mov	eax, DWORD PTR [ecx]
	mov	ebx, edi
	mov	edi, DWORD PTR [eax+4]
	sub	edi, DWORD PTR [eax]
	sar	edi, 2
	sub	edi, DWORD PTR [edx+12]
	sub	edi, 1
	js	$LN238@DrawLog
$LN15@DrawLog:

; 279  : 	{
; 280  : 		ypos -= tm.tmHeight;

	sub	ebx, DWORD PTR _tm$[ebp]

; 281  : 		if ( ypos < y_top_max )

	cmp	ebx, DWORD PTR _y_top_max$[ebp]
	mov	DWORD PTR _ypos$[ebp], ebx
	jl	$LN238@DrawLog

; 282  : 		{
; 283  : 			break;
; 284  : 		}
; 285  : 		LPCSTR ls = ((*LogFile)[i]).c_str();

	mov	eax, DWORD PTR __imp_?LogFile@@3PAV?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@A
	mov	ecx, DWORD PTR [eax]
	call	?begin@?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@stlp_std@@QAEPAVshared_str@@XZ ; stlp_std::vector<shared_str,xalloc<shared_str> >::begin
	lea	eax, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	$LN14@DrawLog
	add	eax, 16					; 00000010H
	mov	DWORD PTR _ls$121469[ebp], eax

; 286  : 
; 287  : 		if ( !ls )

	je	$LN14@DrawLog

; 288  : 		{
; 289  : 			continue;
; 290  : 		}
; 291  : 		Console_mark cm = (Console_mark)ls[0];

	movsx	ebx, BYTE PTR [eax]

; 292  : 		COLORREF     c2 = (COLORREF)bgr2rgb( get_mark_color( cm ) );

	mov	ecx, DWORD PTR _this$[ebp]
	push	ebx
	call	?get_mark_color@CConsole@@IAEIW4Console_mark@1@@Z ; CConsole::get_mark_color

; 293  : 		SetTextColor( hDC, c2 );

	mov	ecx, eax
	movzx	edx, al
	shr	ecx, 16					; 00000010H
	and	ecx, 255				; 000000ffH
	shl	edx, 16					; 00000010H
	or	ecx, edx
	and	eax, 65280				; 0000ff00H
	or	ecx, eax
	push	ecx
	push	esi
	call	DWORD PTR __imp__SetTextColor@8

; 294  : 		u8 b = (is_mark( cm ))? 2 : 0;

	mov	ecx, DWORD PTR _this$[ebp]
	push	ebx
	call	?is_mark@CConsole@@IAE_NW4Console_mark@1@@Z ; CConsole::is_mark
	neg	al
	sbb	eax, eax
	and	eax, 2

; 295  : 		LPCSTR pOut = ls + b;

	add	eax, DWORD PTR _ls$121469[ebp]
	mov	ecx, eax

; 296  : 
; 297  : 		BOOL res = TextOut( hDC, 10, ypos, pOut, xr_strlen(pOut) );

	lea	edx, DWORD PTR [eax+1]
$LL252@DrawLog:
	mov	bl, BYTE PTR [eax]
	add	eax, 1
	test	bl, bl
	jne	SHORT $LL252@DrawLog
	sub	eax, edx
	push	eax
	mov	eax, DWORD PTR _ypos$[ebp]
	push	ecx
	push	eax
	push	10					; 0000000aH
	push	esi
	call	DWORD PTR __imp__TextOutA@20

; 298  : 		if ( !res )

	test	eax, eax
	jne	SHORT $LN7@DrawLog

; 299  : 		{
; 300  : 			R_ASSERT2( 0, "TextOut(..) return NULL" );

	cmp	BYTE PTR ?ignore_always@?P@??DrawLog@CTextConsole@@AAEXPAUHDC__@@PAUtagRECT@@@Z@4_NA, al
	jne	SHORT $LN7@DrawLog
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?P@??DrawLog@CTextConsole@@AAEXPAUHDC__@@PAUtagRECT@@@Z@4_NA
	push	OFFSET ??_C@_0BG@DJBAGMOM@CTextConsole?3?3DrawLog?$AA@
	push	300					; 0000012cH
	push	OFFSET ??_C@_0DF@OECDJJNH@D?3?2CLEARSKY?2sources?2engine?2xrEng@
	push	OFFSET ??_C@_0BI@LPKBDJAC@TextOut?$CI?4?4?$CJ?5return?5NULL?$AA@
	push	OFFSET ??_C@_01GBGANLPD@0?$AA@
	call	DWORD PTR __imp_?fail@xrDebug@@QAEXPBD00H0AA_N@Z
$LN7@DrawLog:
	mov	ebx, DWORD PTR _ypos$[ebp]
$LN14@DrawLog:

; 278  : 	for( int i = LogFile->size()-1-scroll_delta; i >= 0; --i ) 

	sub	edi, 1
	jns	$LN15@DrawLog
$LN238@DrawLog:

; 301  : 		}
; 302  : 	}
; 303  : 
; 304  : 	if ( g_pGameLevel && ( Device.dwTimeGlobal - m_last_time > 500 ) )

	cmp	DWORD PTR ?g_pGameLevel@@3PAVIGame_Level@@A, 0 ; g_pGameLevel
	je	SHORT $LN5@DrawLog
	mov	eax, DWORD PTR ?Device@@3VCRenderDevice@@A+40
	mov	edi, DWORD PTR _this$[ebp]
	mov	ecx, eax
	sub	ecx, DWORD PTR [edi+260]
	cmp	ecx, 500				; 000001f4H
	jbe	SHORT $LN5@DrawLog

; 305  : 	{
; 306  : 		m_last_time = Device.dwTimeGlobal;

	mov	DWORD PTR [edi+260], eax

; 307  : 
; 308  : 		m_server_info.ResetData();

	add	edi, 264				; 00000108H
	mov	ecx, edi
	call	?clear@?$svector@USItem_ServerInfo@CServerInfo@@$0P@@@QAEXXZ ; svector<CServerInfo::SItem_ServerInfo,15>::clear

; 309  : 		g_pGameLevel->GetLevelInfo( &m_server_info );

	mov	ecx, DWORD PTR ?g_pGameLevel@@3PAVIGame_Level@@A ; g_pGameLevel
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+12]
	push	edi
	call	eax
$LN5@DrawLog:

; 310  : 	}
; 311  : 
; 312  : 	ypos = 5;
; 313  : 	for ( u32 i = 0; i < m_server_info.Size(); ++i )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 264				; 00000108H
	mov	edi, 5
	xor	ebx, ebx
	mov	DWORD PTR tv803[ebp], ecx
	call	?size@?$svector@USItem_ServerInfo@CServerInfo@@$0P@@@QBEIXZ ; svector<CServerInfo::SItem_ServerInfo,15>::size
	test	eax, eax
	jbe	SHORT $LN239@DrawLog
	npad	3
$LL4@DrawLog:

; 314  : 	{
; 315  : 		SetTextColor( hDC, m_server_info[i].color );

	mov	ecx, DWORD PTR tv803[ebp]
	push	ebx
	call	??A?$svector@USItem_ServerInfo@CServerInfo@@$0P@@@QAEAAUSItem_ServerInfo@CServerInfo@@I@Z ; svector<CServerInfo::SItem_ServerInfo,15>::operator[]
	mov	ecx, DWORD PTR [eax+128]
	push	ecx
	push	esi
	call	DWORD PTR __imp__SetTextColor@8

; 316  : 		TextOut( hDC, 10, ypos, m_server_info[i].name, xr_strlen(m_server_info[i].name) );

	mov	ecx, DWORD PTR tv803[ebp]
	push	ebx
	call	??A?$svector@USItem_ServerInfo@CServerInfo@@$0P@@@QAEAAUSItem_ServerInfo@CServerInfo@@I@Z ; svector<CServerInfo::SItem_ServerInfo,15>::operator[]
	lea	ecx, DWORD PTR [eax+1]
$LL253@DrawLog:
	mov	dl, BYTE PTR [eax]
	add	eax, 1
	test	dl, dl
	jne	SHORT $LL253@DrawLog
	sub	eax, ecx
	mov	ecx, DWORD PTR tv803[ebp]
	push	eax
	push	ebx
	call	??A?$svector@USItem_ServerInfo@CServerInfo@@$0P@@@QAEAAUSItem_ServerInfo@CServerInfo@@I@Z ; svector<CServerInfo::SItem_ServerInfo,15>::operator[]
	push	eax
	push	edi
	push	10					; 0000000aH
	push	esi
	call	DWORD PTR __imp__TextOutA@20

; 317  : 
; 318  : 		ypos += tm.tmHeight;

	add	edi, DWORD PTR _tm$[ebp]

; 319  : 		if ( ypos > y_top_max )

	cmp	edi, DWORD PTR _y_top_max$[ebp]
	jg	SHORT $LN239@DrawLog
	mov	ecx, DWORD PTR tv803[ebp]
	add	ebx, 1
	call	?size@?$svector@USItem_ServerInfo@CServerInfo@@$0P@@@QBEIXZ ; svector<CServerInfo::SItem_ServerInfo,15>::size
	cmp	ebx, eax
	jb	SHORT $LL4@DrawLog
$LN239@DrawLog:

; 320  : 		{
; 321  : 			break;
; 322  : 		}
; 323  : 	}
; 324  : }

	lea	esp, DWORD PTR [ebp-136]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?DrawLog@CTextConsole@@AAEXPAUHDC__@@PAUtagRECT@@@Z ENDP ; CTextConsole::DrawLog
_TEXT	ENDS
PUBLIC	?OnPaint@CTextConsole@@QAEXXZ			; CTextConsole::OnPaint
; Function compile flags: /Ogtpy
;	COMDAT ?OnPaint@CTextConsole@@QAEXXZ
_TEXT	SEGMENT
_wRC$ = -80						; size = 16
_ps$ = -64						; size = 64
?OnPaint@CTextConsole@@QAEXXZ PROC			; CTextConsole::OnPaint, COMDAT
; _this$ = ecx

; 193  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	esi, ecx

; 194  : 	RECT wRC;
; 195  : 	PAINTSTRUCT ps;
; 196  : 	BeginPaint( m_hLogWnd, &ps );

	mov	ecx, DWORD PTR [esi+212]
	lea	eax, DWORD PTR _ps$[esp+96]
	push	eax
	push	ecx
	call	DWORD PTR __imp__BeginPaint@8

; 197  : 
; 198  : 	if ( /*m_bNeedUpdate*/ Device.dwFrame % 2 )

	test	BYTE PTR ?Device@@3VCRenderDevice@@A+24, 1
	je	SHORT $LN2@OnPaint

; 199  : 	{
; 200  : //		m_dwLastUpdateTime = Device.dwTimeGlobal;
; 201  : //		m_bNeedUpdate = false;
; 202  : 		
; 203  : 		GetClientRect( m_hLogWnd, &wRC );

	mov	eax, DWORD PTR [esi+212]
	lea	edx, DWORD PTR _wRC$[esp+96]
	push	edx
	push	eax
	call	DWORD PTR __imp__GetClientRect@8

; 204  : 		DrawLog( m_hDC_LogWnd_BackBuffer, &wRC );

	mov	edx, DWORD PTR [esi+240]
	lea	ecx, DWORD PTR _wRC$[esp+96]
	push	ecx
	push	edx
	mov	ecx, esi
	call	?DrawLog@CTextConsole@@AAEXPAUHDC__@@PAUtagRECT@@@Z ; CTextConsole::DrawLog

; 205  : 	}
; 206  : 	else

	mov	edi, DWORD PTR _wRC$[esp+108]
	mov	edx, DWORD PTR _wRC$[esp+104]
	mov	ecx, DWORD PTR _wRC$[esp+100]
	mov	eax, DWORD PTR _wRC$[esp+96]
	jmp	SHORT $LN1@OnPaint
$LN2@OnPaint:

; 207  : 	{
; 208  : 		wRC = ps.rcPaint;

	mov	eax, DWORD PTR _ps$[esp+104]
	mov	ecx, DWORD PTR _ps$[esp+108]
	mov	edx, DWORD PTR _ps$[esp+112]
	mov	edi, DWORD PTR _ps$[esp+116]
	mov	DWORD PTR _wRC$[esp+96], eax
	mov	DWORD PTR _wRC$[esp+100], ecx
	mov	DWORD PTR _wRC$[esp+104], edx
	mov	DWORD PTR _wRC$[esp+108], edi
$LN1@OnPaint:

; 209  : 	}
; 210  : 	
; 211  : 	
; 212  : 	BitBlt(	m_hDC_LogWnd,
; 213  : 			wRC.left, wRC.top,
; 214  : 			wRC.right - wRC.left, wRC.bottom - wRC.top,
; 215  : 			m_hDC_LogWnd_BackBuffer,
; 216  : 			wRC.left, wRC.top,
; 217  : 			SRCCOPY); //(FullUpdate) ? SRCCOPY : NOTSRCCOPY);

	mov	ebx, DWORD PTR [esi+240]
	push	13369376				; 00cc0020H
	push	ecx
	push	eax
	push	ebx
	sub	edi, ecx
	push	edi
	sub	edx, eax
	push	edx
	push	ecx
	push	eax
	mov	eax, DWORD PTR [esi+236]
	push	eax
	call	DWORD PTR __imp__BitBlt@36

; 218  : /*
; 219  : 	Msg ("URect - %d:%d - %d:%d", ps.rcPaint.left, ps.rcPaint.top, ps.rcPaint.right, ps.rcPaint.bottom);
; 220  : */
; 221  : 	EndPaint( m_hLogWnd, &ps );

	mov	edx, DWORD PTR [esi+212]
	lea	ecx, DWORD PTR _ps$[esp+96]
	push	ecx
	push	edx
	call	DWORD PTR __imp__EndPaint@8

; 222  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnPaint@CTextConsole@@QAEXXZ ENDP			; CTextConsole::OnPaint
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@CTextConsole@@UAEXXZ
_TEXT	SEGMENT
?Destroy@CTextConsole@@UAEXXZ PROC			; CTextConsole::Destroy, COMDAT
; _this$ = ecx

; 171  : {

	push	esi
	mov	esi, ecx

; 172  : 	inherited::Destroy();	

	lea	eax, DWORD PTR [esi+16]
	push	edi
	push	eax
	call	??$xr_delete@VCGameFont@@@@YAXAAPAVCGameFont@@@Z ; xr_delete<CGameFont>
	lea	ecx, DWORD PTR [esi+20]
	push	ecx
	call	??$xr_delete@VCGameFont@@@@YAXAAPAVCGameFont@@@Z ; xr_delete<CGameFont>
	add	esp, 8
	lea	ecx, DWORD PTR [esi+176]
	call	?clear@?$_Rb_tree@PBDUstr_pred@CConsole@@U?$pair@QBDPAVIConsole_Command@@@stlp_std@@U?$_Select1st@U?$pair@QBDPAVIConsole_Command@@@stlp_std@@@priv@4@U?$_MapTraitsT@U?$pair@QBDPAVIConsole_Command@@@stlp_std@@@64@V?$xalloc@U?$pair@PBDPAVIConsole_Command@@@stlp_std@@@@@priv@stlp_std@@QAEXXZ ; stlp_std::priv::_Rb_tree<char const *,CConsole::str_pred,stlp_std::pair<char const * const,IConsole_Command *>,stlp_std::priv::_Select1st<stlp_std::pair<char const * const,IConsole_Command *> >,stlp_std::priv::_MapTraitsT<stlp_std::pair<char const * const,IConsole_Command *> >,xalloc<stlp_std::pair<char const *,IConsole_Command *> > >::clear

; 173  : 
; 174  : 	SelectObject( m_hDC_LogWnd_BackBuffer, m_hPrevFont );

	mov	edx, DWORD PTR [esi+228]
	mov	eax, DWORD PTR [esi+240]
	mov	edi, DWORD PTR __imp__SelectObject@8
	push	edx
	push	eax
	call	edi

; 175  : 	SelectObject( m_hDC_LogWnd_BackBuffer, m_hOld_BM );

	mov	ecx, DWORD PTR [esi+248]
	mov	edx, DWORD PTR [esi+240]
	push	ecx
	push	edx
	call	edi

; 176  : 
; 177  : 	if ( m_hBB_BM )           DeleteObject( m_hBB_BM );

	mov	eax, DWORD PTR [esi+244]
	test	eax, eax
	mov	edi, DWORD PTR __imp__DeleteObject@4
	je	SHORT $LN5@Destroy@4
	push	eax
	call	edi
$LN5@Destroy@4:

; 178  : 	if ( m_hOld_BM )          DeleteObject( m_hOld_BM );

	mov	eax, DWORD PTR [esi+248]
	test	eax, eax
	je	SHORT $LN4@Destroy@4
	push	eax
	call	edi
$LN4@Destroy@4:

; 179  : 	if ( m_hLogWndFont )      DeleteObject( m_hLogWndFont );

	mov	eax, DWORD PTR [esi+224]
	test	eax, eax
	je	SHORT $LN3@Destroy@4
	push	eax
	call	edi
$LN3@Destroy@4:

; 180  : 	if ( m_hPrevFont )        DeleteObject( m_hPrevFont );

	mov	eax, DWORD PTR [esi+228]
	test	eax, eax
	je	SHORT $LN2@Destroy@4
	push	eax
	call	edi
$LN2@Destroy@4:

; 181  : 	if ( m_hBackGroundBrush ) DeleteObject( m_hBackGroundBrush );

	mov	eax, DWORD PTR [esi+232]
	test	eax, eax
	je	SHORT $LN1@Destroy@4
	push	eax
	call	edi
$LN1@Destroy@4:

; 182  : 
; 183  : 	ReleaseDC( m_hLogWnd, m_hDC_LogWnd_BackBuffer );

	mov	eax, DWORD PTR [esi+240]
	mov	ecx, DWORD PTR [esi+212]
	mov	edi, DWORD PTR __imp__ReleaseDC@8
	push	eax
	push	ecx
	call	edi

; 184  : 	ReleaseDC( m_hLogWnd, m_hDC_LogWnd );

	mov	edx, DWORD PTR [esi+236]
	mov	eax, DWORD PTR [esi+212]
	push	edx
	push	eax
	call	edi

; 185  : 
; 186  : 	DestroyWindow( m_hLogWnd );

	mov	ecx, DWORD PTR [esi+212]
	mov	edi, DWORD PTR __imp__DestroyWindow@4
	push	ecx
	call	edi

; 187  : 	DestroyWindow( m_hConsoleWnd );

	mov	edx, DWORD PTR [esi+208]
	push	edx
	call	edi
	pop	edi
	pop	esi

; 188  : }

	ret	0
?Destroy@CTextConsole@@UAEXXZ ENDP			; CTextConsole::Destroy
_TEXT	ENDS
PUBLIC	?CreateLogWnd@CTextConsole@@AAEXXZ		; CTextConsole::CreateLogWnd
; Function compile flags: /Ogtpy
;	COMDAT ?CreateLogWnd@CTextConsole@@AAEXXZ
_TEXT	SEGMENT
_lY$ = -140						; size = 4
_lX$ = -136						; size = 4
_cRc$ = -132						; size = 16
_wndClass$ = -116					; size = 40
_lf$ = -76						; size = 60
_rc$ = -16						; size = 16
?CreateLogWnd@CTextConsole@@AAEXXZ PROC			; CTextConsole::CreateLogWnd, COMDAT
; _this$ = ecx

; 71   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 144				; 00000090H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 72   : 	HINSTANCE hInstance = (HINSTANCE)GetModuleHandle(0);

	push	0
	mov	esi, ecx
	call	DWORD PTR __imp__GetModuleHandleA@4

; 73   : 	//----------------------------------
; 74   : 	RECT cRc;
; 75   : 	GetClientRect(m_hConsoleWnd, &cRc);

	mov	ecx, DWORD PTR [esi+208]
	mov	ebx, eax
	lea	eax, DWORD PTR _cRc$[esp+160]
	push	eax
	push	ecx
	call	DWORD PTR __imp__GetClientRect@8

; 76   : 	INT lX = cRc.left;

	mov	eax, DWORD PTR _cRc$[esp+160]

; 77   : 	INT lY = cRc.top;
; 78   : 	INT lWidth = cRc.right - cRc.left;

	mov	edi, DWORD PTR _cRc$[esp+168]
	mov	ecx, DWORD PTR _cRc$[esp+164]

; 79   : 	INT lHeight = cRc.bottom - cRc.top;

	mov	ebp, DWORD PTR _cRc$[esp+172]
	mov	DWORD PTR _lX$[esp+160], eax
	sub	edi, eax

; 80   : 	//----------------------------------
; 81   : 	const char*	wndclass ="TEXT_CONSOLE_LOG_WND";
; 82   : 
; 83   : 	// Register the windows class
; 84   : 	WNDCLASS wndClass = { 0, TextConsole_LogWndProc, 0, 0, hInstance,

	xor	eax, eax

; 85   : 		NULL,
; 86   : 		LoadCursor( NULL, IDC_ARROW ),

	push	32512					; 00007f00H
	push	eax
	mov	DWORD PTR _lY$[esp+168], ecx
	sub	ebp, ecx
	mov	DWORD PTR _wndClass$[esp+168], eax
	mov	DWORD PTR _wndClass$[esp+172], OFFSET ?TextConsole_LogWndProc@@YGJPAUHWND__@@IIJ@Z ; TextConsole_LogWndProc
	mov	DWORD PTR _wndClass$[esp+176], eax
	mov	DWORD PTR _wndClass$[esp+180], eax
	mov	DWORD PTR _wndClass$[esp+184], ebx
	mov	DWORD PTR _wndClass$[esp+188], eax
	call	DWORD PTR __imp__LoadCursorA@8

; 87   : 		GetStockBrush(BLACK_BRUSH),

	push	4
	mov	DWORD PTR _wndClass$[esp+188], eax
	call	DWORD PTR __imp__GetStockObject@4

; 88   : 		NULL, wndclass };
; 89   : 	RegisterClass( &wndClass );

	lea	edx, DWORD PTR _wndClass$[esp+160]
	push	edx
	mov	DWORD PTR _wndClass$[esp+192], eax
	mov	DWORD PTR _wndClass$[esp+196], 0
	mov	DWORD PTR _wndClass$[esp+200], OFFSET ??_C@_0BF@HJFDKALO@TEXT_CONSOLE_LOG_WND?$AA@
	call	DWORD PTR __imp__RegisterClassA@4

; 90   : 
; 91   : 	// Set the window's initial style
; 92   : 	u32 dwWindowStyle = WS_OVERLAPPED | WS_CHILD | WS_VISIBLE;// | WS_CLIPSIBLINGS;
; 93   : //	u32 dwWindowStyleEx = WS_EX_CLIENTEDGE;
; 94   : 
; 95   : 	// Set the window's initial width
; 96   : 	RECT rc;
; 97   : 	SetRect			( &rc, lX, lY, lWidth, lHeight );

	mov	eax, DWORD PTR _lY$[esp+160]
	mov	ecx, DWORD PTR _lX$[esp+160]
	push	ebp
	push	edi
	push	eax
	push	ecx
	lea	edx, DWORD PTR _rc$[esp+176]
	push	edx
	call	DWORD PTR __imp__SetRect@20

; 98   : //	AdjustWindowRect( &rc, dwWindowStyle, FALSE );
; 99   : 
; 100  : 	// Create the render window
; 101  : 	m_hLogWnd = CreateWindow(wndclass, "XRAY Text Console Log", dwWindowStyle,
; 102  : 		lX, lY,
; 103  : 		lWidth, lHeight, m_hConsoleWnd,
; 104  : 		0, hInstance, 0L );

	mov	eax, DWORD PTR [esi+208]
	mov	ecx, DWORD PTR _lY$[esp+160]
	mov	edx, DWORD PTR _lX$[esp+160]
	push	0
	push	ebx
	push	0
	push	eax
	push	ebp
	push	edi
	push	ecx
	push	edx
	push	1342177280				; 50000000H
	push	OFFSET ??_C@_0BG@EOFDKDIP@XRAY?5Text?5Console?5Log?$AA@
	push	OFFSET ??_C@_0BF@HJFDKALO@TEXT_CONSOLE_LOG_WND?$AA@
	push	0
	call	DWORD PTR __imp__CreateWindowExA@48

; 105  : 	//---------------------------------------------------------------------------
; 106  : 	R_ASSERT2(m_hLogWnd, "Unable to Create TextConsole Window!");

	mov	edi, DWORD PTR __imp_?fail@xrDebug@@QAEXPBD00H0AA_N@Z
	mov	DWORD PTR [esi+212], eax
	cmp	BYTE PTR ?ignore_always@?3??CreateLogWnd@CTextConsole@@AAEXXZ@4_NA, 0
	jne	SHORT $LN23@CreateLogW@2
	xor	ebx, ebx
	cmp	eax, ebx
	jne	SHORT $LN19@CreateLogW@2
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?3??CreateLogWnd@CTextConsole@@AAEXXZ@4_NA
	push	OFFSET ??_C@_0BL@GHENLCPO@CTextConsole?3?3CreateLogWnd?$AA@
	push	106					; 0000006aH
	push	OFFSET ??_C@_0DF@OECDJJNH@D?3?2CLEARSKY?2sources?2engine?2xrEng@
	push	OFFSET ??_C@_0CF@PAHJGOGD@Unable?5to?5Create?5TextConsole?5Win@
	push	OFFSET ??_C@_09NCJAFLKN@m_hLogWnd?$AA@
	call	edi
	jmp	SHORT $LN19@CreateLogW@2
$LN23@CreateLogW@2:
	xor	ebx, ebx
$LN19@CreateLogW@2:

; 107  : 	//---------------------------------------------------------------------------
; 108  : 	ShowWindow(m_hLogWnd, SW_SHOW); 

	mov	eax, DWORD PTR [esi+212]
	push	5
	push	eax
	call	DWORD PTR __imp__ShowWindow@8

; 109  : 	UpdateWindow(m_hLogWnd);

	mov	ecx, DWORD PTR [esi+212]
	push	ecx
	call	DWORD PTR __imp__UpdateWindow@4

; 110  : 	//-----------------------------------------------
; 111  : 	LOGFONT lf; 
; 112  : 	lf.lfHeight = -12; 
; 113  : 	lf.lfWidth = 0;
; 114  : 	lf.lfEscapement = 0; 
; 115  : 	lf.lfOrientation = 0; 
; 116  : 	lf.lfWeight = FW_NORMAL;
; 117  : 	lf.lfItalic = 0; 
; 118  : 	lf.lfUnderline = 0; 
; 119  : 	lf.lfStrikeOut = 0; 
; 120  : 	lf.lfCharSet = DEFAULT_CHARSET;

	mov	al, 1

; 121  : 	lf.lfOutPrecision = OUT_STRING_PRECIS;
; 122  : 	lf.lfClipPrecision = CLIP_STROKE_PRECIS;	
; 123  : 	lf.lfQuality = DRAFT_QUALITY;
; 124  : 	lf.lfPitchAndFamily = VARIABLE_PITCH | FF_SWISS;
; 125  : 	xr_sprintf(lf.lfFaceName,sizeof(lf.lfFaceName),"");

	lea	edx, DWORD PTR _lf$[esp+188]
	mov	BYTE PTR _lf$[esp+183], al
	mov	BYTE PTR _lf$[esp+184], al
	mov	BYTE PTR _lf$[esp+186], al
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	edx
	mov	eax, 32					; 00000020H
	mov	DWORD PTR _lf$[esp+168], -12		; fffffff4H
	mov	DWORD PTR _lf$[esp+172], ebx
	mov	DWORD PTR _lf$[esp+176], ebx
	mov	DWORD PTR _lf$[esp+180], ebx
	mov	DWORD PTR _lf$[esp+184], 400		; 00000190H
	mov	BYTE PTR _lf$[esp+188], 0
	mov	BYTE PTR _lf$[esp+189], 0
	mov	BYTE PTR _lf$[esp+190], 0
	mov	BYTE PTR _lf$[esp+193], 2
	mov	BYTE PTR _lf$[esp+195], 34		; 00000022H
	call	?xr_sprintf@@YAHPADIPBDZZ		; xr_sprintf
	add	esp, 8

; 126  : 
; 127  : 	m_hLogWndFont = CreateFontIndirect(&lf);

	lea	eax, DWORD PTR _lf$[esp+160]
	push	eax
	call	DWORD PTR __imp__CreateFontIndirectA@4
	mov	DWORD PTR [esi+224], eax

; 128  : 	R_ASSERT2(m_hLogWndFont, "Unable to Create Font for Log Window");

	cmp	BYTE PTR ?ignore_always@?7??CreateLogWnd@CTextConsole@@AAEXXZ@4_NA, 0
	jne	SHORT $LN15@CreateLogW@2
	cmp	eax, ebx
	jne	SHORT $LN15@CreateLogW@2
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?7??CreateLogWnd@CTextConsole@@AAEXXZ@4_NA
	push	OFFSET ??_C@_0BL@GHENLCPO@CTextConsole?3?3CreateLogWnd?$AA@
	push	128					; 00000080H
	push	OFFSET ??_C@_0DF@OECDJJNH@D?3?2CLEARSKY?2sources?2engine?2xrEng@
	push	OFFSET ??_C@_0CF@OIMKOGBP@Unable?5to?5Create?5Font?5for?5Log?5Wi@
	push	OFFSET ??_C@_0O@HLJICJAP@m_hLogWndFont?$AA@
	call	edi
$LN15@CreateLogW@2:

; 129  : 	//------------------------------------------------
; 130  : 	m_hDC_LogWnd = GetDC(m_hLogWnd);

	mov	ecx, DWORD PTR [esi+212]
	push	ecx
	call	DWORD PTR __imp__GetDC@4
	mov	DWORD PTR [esi+236], eax

; 131  : 	R_ASSERT2(m_hDC_LogWnd, "Unable to Get DC for Log Window!");

	cmp	BYTE PTR ?ignore_always@?M@??CreateLogWnd@CTextConsole@@AAEXXZ@4_NA, 0
	jne	SHORT $LN11@CreateLogW@2
	cmp	eax, ebx
	jne	SHORT $LN11@CreateLogW@2
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?M@??CreateLogWnd@CTextConsole@@AAEXXZ@4_NA
	push	OFFSET ??_C@_0BL@GHENLCPO@CTextConsole?3?3CreateLogWnd?$AA@
	push	131					; 00000083H
	push	OFFSET ??_C@_0DF@OECDJJNH@D?3?2CLEARSKY?2sources?2engine?2xrEng@
	push	OFFSET ??_C@_0CB@MFCOLKCK@Unable?5to?5Get?5DC?5for?5Log?5Window?$CB@
	push	OFFSET ??_C@_0N@KFPNLOGC@m_hDC_LogWnd?$AA@
	call	edi
$LN11@CreateLogW@2:

; 132  : 	//------------------------------------------------
; 133  : 	m_hDC_LogWnd_BackBuffer = CreateCompatibleDC(m_hDC_LogWnd);

	mov	edx, DWORD PTR [esi+236]
	push	edx
	call	DWORD PTR __imp__CreateCompatibleDC@4
	mov	DWORD PTR [esi+240], eax

; 134  : 	R_ASSERT2(m_hDC_LogWnd_BackBuffer, "Unable to Create Compatible DC for Log Window!");

	cmp	BYTE PTR ?ignore_always@?BA@??CreateLogWnd@CTextConsole@@AAEXXZ@4_NA, 0
	jne	SHORT $LN7@CreateLogW@2
	cmp	eax, ebx
	jne	SHORT $LN7@CreateLogW@2
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?BA@??CreateLogWnd@CTextConsole@@AAEXXZ@4_NA
	push	OFFSET ??_C@_0BL@GHENLCPO@CTextConsole?3?3CreateLogWnd?$AA@
	push	134					; 00000086H
	push	OFFSET ??_C@_0DF@OECDJJNH@D?3?2CLEARSKY?2sources?2engine?2xrEng@
	push	OFFSET ??_C@_0CP@LCJDBKMI@Unable?5to?5Create?5Compatible?5DC?5f@
	push	OFFSET ??_C@_0BI@NIEDJCGI@m_hDC_LogWnd_BackBuffer?$AA@
	call	edi
$LN7@CreateLogW@2:

; 135  : 	//------------------------------------------------
; 136  : 	GetClientRect(m_hLogWnd, &cRc);

	mov	ecx, DWORD PTR [esi+212]
	lea	eax, DWORD PTR _cRc$[esp+160]
	push	eax
	push	ecx
	call	DWORD PTR __imp__GetClientRect@8

; 137  : 	lWidth = cRc.right - cRc.left;
; 138  : 	lHeight = cRc.bottom - cRc.top;

	mov	ecx, DWORD PTR _cRc$[esp+172]
	mov	eax, DWORD PTR _cRc$[esp+168]
	sub	ecx, DWORD PTR _cRc$[esp+164]
	sub	eax, DWORD PTR _cRc$[esp+160]

; 139  : 	//----------------------------------
; 140  : 	m_hBB_BM = CreateCompatibleBitmap(m_hDC_LogWnd, lWidth, lHeight);

	mov	edx, DWORD PTR [esi+236]
	push	ecx
	push	eax
	push	edx
	call	DWORD PTR __imp__CreateCompatibleBitmap@12
	mov	DWORD PTR [esi+244], eax

; 141  : 	R_ASSERT2(m_hBB_BM, "Unable to Create Compatible Bitmap for Log Window!");

	cmp	BYTE PTR ?ignore_always@?BE@??CreateLogWnd@CTextConsole@@AAEXXZ@4_NA, 0
	jne	SHORT $LN3@CreateLogW@2
	cmp	eax, ebx
	jne	SHORT $LN3@CreateLogW@2
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?BE@??CreateLogWnd@CTextConsole@@AAEXXZ@4_NA
	push	OFFSET ??_C@_0BL@GHENLCPO@CTextConsole?3?3CreateLogWnd?$AA@
	push	141					; 0000008dH
	push	OFFSET ??_C@_0DF@OECDJJNH@D?3?2CLEARSKY?2sources?2engine?2xrEng@
	push	OFFSET ??_C@_0DD@IHPCHKOI@Unable?5to?5Create?5Compatible?5Bitm@
	push	OFFSET ??_C@_08EFIBLJBG@m_hBB_BM?$AA@
	call	edi
$LN3@CreateLogW@2:

; 142  : 	//------------------------------------------------
; 143  : 	m_hOld_BM = (HBITMAP)SelectObject(m_hDC_LogWnd_BackBuffer, m_hBB_BM);

	mov	eax, DWORD PTR [esi+244]
	mov	ecx, DWORD PTR [esi+240]
	mov	edi, DWORD PTR __imp__SelectObject@8
	push	eax
	push	ecx
	call	edi

; 144  : 	//------------------------------------------------
; 145  : 	m_hPrevFont = (HFONT)SelectObject(m_hDC_LogWnd_BackBuffer, m_hLogWndFont);

	mov	edx, DWORD PTR [esi+224]
	mov	DWORD PTR [esi+248], eax
	mov	eax, DWORD PTR [esi+240]
	push	edx
	push	eax
	call	edi

; 146  : 	//------------------------------------------------
; 147  : 	SetTextColor(m_hDC_LogWnd_BackBuffer, RGB(255, 255, 255));

	mov	ecx, DWORD PTR [esi+240]
	push	16777215				; 00ffffffH
	push	ecx
	mov	DWORD PTR [esi+228], eax
	call	DWORD PTR __imp__SetTextColor@8

; 148  : 	SetBkColor(m_hDC_LogWnd_BackBuffer, RGB(1, 1, 1));

	mov	edx, DWORD PTR [esi+240]
	push	65793					; 00010101H
	push	edx
	call	DWORD PTR __imp__SetBkColor@8

; 149  : 	//------------------------------------------------
; 150  : 	m_hBackGroundBrush = GetStockBrush(BLACK_BRUSH);

	push	4
	call	DWORD PTR __imp__GetStockObject@4

; 151  : }

	pop	edi
	mov	DWORD PTR [esi+232], eax
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CreateLogWnd@CTextConsole@@AAEXXZ ENDP			; CTextConsole::CreateLogWnd
_TEXT	ENDS
PUBLIC	??1CTextConsole@@UAE@XZ				; CTextConsole::~CTextConsole
; Function compile flags: /Ogtpy
;	COMDAT ??1CTextConsole@@UAE@XZ
_TEXT	SEGMENT
??1CTextConsole@@UAE@XZ PROC				; CTextConsole::~CTextConsole, COMDAT
; _this$ = ecx

; 25   : {

	mov	DWORD PTR [ecx], OFFSET ??_7CTextConsole@@6BpureRender@@@
	mov	DWORD PTR [ecx+4], OFFSET ??_7CTextConsole@@6BpureFrame@@@
	mov	DWORD PTR [ecx+8], OFFSET ??_7CTextConsole@@6BpureScreenResolutionChanged@@@

; 26   : 	m_pMainWnd = NULL;

	mov	DWORD PTR [ecx+204], 0

; 27   : }

	jmp	??1CConsole@@UAE@XZ			; CConsole::~CConsole
??1CTextConsole@@UAE@XZ ENDP				; CTextConsole::~CTextConsole
; Function compile flags: /Ogtpy
;	COMDAT ?OnFrame@CTextConsole@@UAGXXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?OnFrame@CTextConsole@@UAGXXZ PROC			; CTextConsole::OnFrame, COMDAT

; 333  : {

	push	esi

; 334  : 	inherited::OnFrame();

	mov	esi, DWORD PTR _this$[esp]
	mov	ecx, DWORD PTR [esi+196]
	add	ecx, 4
	call	?on_frame@line_edit_control@text_editor@@QAEXXZ ; text_editor::line_edit_control::on_frame
	mov	ecx, DWORD PTR ?Device@@3VCRenderDevice@@A+24
	mov	eax, -858993459				; cccccccdH
	mul	ecx
	shr	edx, 3
	lea	eax, DWORD PTR [edx+edx*4]
	add	eax, eax
	sub	ecx, eax
	jne	SHORT $LN3@OnFrame@6
	lea	ecx, DWORD PTR [esi-4]
	call	?update_tips@CConsole@@IAEXXZ		; CConsole::update_tips
$LN3@OnFrame@6:

; 335  : /*	if ( !m_bNeedUpdate && m_dwLastUpdateTime + 1000/g_svTextConsoleUpdateRate > Device.dwTimeGlobal )
; 336  : 	{
; 337  : 		return;
; 338  : 	}
; 339  : */	InvalidateRect( m_hConsoleWnd, NULL, FALSE );

	mov	ecx, DWORD PTR [esi+204]
	push	0
	push	0
	push	ecx
	call	DWORD PTR __imp__InvalidateRect@12

; 340  : 	SetCursor( LoadCursor( NULL, IDC_ARROW ) );	

	push	32512					; 00007f00H
	push	0
	call	DWORD PTR __imp__LoadCursorA@8
	pop	esi
	mov	DWORD PTR _this$[esp-4], eax
	jmp	DWORD PTR __imp__SetCursor@4
?OnFrame@CTextConsole@@UAGXXZ ENDP			; CTextConsole::OnFrame
PUBLIC	??0CTextConsole@@QAE@XZ				; CTextConsole::CTextConsole
; Function compile flags: /Ogtpy
;	COMDAT ??0CTextConsole@@QAE@XZ
_TEXT	SEGMENT
??0CTextConsole@@QAE@XZ PROC				; CTextConsole::CTextConsole, COMDAT
; _this$ = ecx

; 10   : {

	push	esi
	mov	esi, ecx
	call	??0CConsole@@QAE@XZ			; CConsole::CConsole
	lea	ecx, DWORD PTR [esi+264]
	mov	DWORD PTR [esi], OFFSET ??_7CTextConsole@@6BpureRender@@@
	mov	DWORD PTR [esi+4], OFFSET ??_7CTextConsole@@6BpureFrame@@@
	mov	DWORD PTR [esi+8], OFFSET ??_7CTextConsole@@6BpureScreenResolutionChanged@@@
	call	??0?$svector@USItem_ServerInfo@CServerInfo@@$0P@@@QAE@XZ ; svector<CServerInfo::SItem_ServerInfo,15>::svector<CServerInfo::SItem_ServerInfo,15>

; 11   : 	m_pMainWnd    = NULL;

	xor	eax, eax
	mov	DWORD PTR [esi+204], eax

; 12   : 	m_hConsoleWnd = NULL;

	mov	DWORD PTR [esi+208], eax

; 13   : 	m_hLogWnd     = NULL;

	mov	DWORD PTR [esi+212], eax

; 14   : 	m_hLogWndFont = NULL;

	mov	DWORD PTR [esi+224], eax

; 15   : 
; 16   : 	m_bScrollLog  = true;
; 17   : 	m_dwStartLine = 0;

	mov	DWORD PTR [esi+220], eax

; 18   : 
; 19   : 	m_bNeedUpdate      = false;

	mov	BYTE PTR [esi+252], al
	mov	BYTE PTR [esi+216], 1

; 20   : 	m_dwLastUpdateTime = Device.dwTimeGlobal;

	mov	eax, DWORD PTR ?Device@@3VCRenderDevice@@A+40
	mov	DWORD PTR [esi+256], eax

; 21   : 	m_last_time        = Device.dwTimeGlobal;

	mov	ecx, DWORD PTR ?Device@@3VCRenderDevice@@A+40
	mov	DWORD PTR [esi+260], ecx

; 22   : }

	mov	eax, esi
	pop	esi
	ret	0
??0CTextConsole@@QAE@XZ ENDP				; CTextConsole::CTextConsole
; Function compile flags: /Ogtpy
;	COMDAT ?Initialize@CTextConsole@@UAEXXZ
_TEXT	SEGMENT
?Initialize@CTextConsole@@UAEXXZ PROC			; CTextConsole::Initialize, COMDAT
; _this$ = ecx

; 154  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	ecx
	push	esi
	mov	esi, ecx

; 155  : 	inherited::Initialize();

	call	?Initialize@CConsole@@UAEXXZ		; CConsole::Initialize

; 156  : 	
; 157  : 	m_pMainWnd         = &Device.m_hWnd;

	mov	DWORD PTR [esi+204], OFFSET ?Device@@3VCRenderDevice@@A+760

; 158  : 	m_dwLastUpdateTime = Device.dwTimeGlobal;

	mov	eax, DWORD PTR ?Device@@3VCRenderDevice@@A+40
	mov	DWORD PTR [esi+256], eax

; 159  : 	m_last_time        = Device.dwTimeGlobal;

	mov	ecx, DWORD PTR ?Device@@3VCRenderDevice@@A+40
	mov	DWORD PTR [esi+260], ecx

; 160  : 
; 161  : 	CreateConsoleWnd();

	mov	ecx, esi
	call	?CreateConsoleWnd@CTextConsole@@AAEXXZ	; CTextConsole::CreateConsoleWnd

; 162  : 	CreateLogWnd();

	mov	ecx, esi
	call	?CreateLogWnd@CTextConsole@@AAEXXZ	; CTextConsole::CreateLogWnd

; 163  : 
; 164  : 	ShowWindow( m_hConsoleWnd, SW_SHOW );

	mov	edx, DWORD PTR [esi+208]
	push	5
	push	edx
	call	DWORD PTR __imp__ShowWindow@8

; 165  : 	UpdateWindow( m_hConsoleWnd );	

	mov	eax, DWORD PTR [esi+208]
	push	eax
	call	DWORD PTR __imp__UpdateWindow@4

; 166  : 
; 167  : 	m_server_info.ResetData();

	lea	ecx, DWORD PTR [esi+264]
	call	?clear@?$svector@USItem_ServerInfo@CServerInfo@@$0P@@@QAEXXZ ; svector<CServerInfo::SItem_ServerInfo,15>::clear

; 168  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?Initialize@CTextConsole@@UAEXXZ ENDP			; CTextConsole::Initialize
END

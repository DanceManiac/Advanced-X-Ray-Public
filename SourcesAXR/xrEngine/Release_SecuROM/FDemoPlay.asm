; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	D:\CLEARSKY\sources\engine\xrEngine\FDemoPlay.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	?ProcessCam@CDemoPlay@@UAEHAAUSCamEffectorInfo@@@Z ; CDemoPlay::ProcessCam
PUBLIC	??_ECDemoPlay@@UAEPAXI@Z			; CDemoPlay::`vector deleting destructor'
PUBLIC	??_R4CDemoPlay@@6B@				; CDemoPlay::`RTTI Complete Object Locator'
PUBLIC	??_R3CDemoPlay@@8				; CDemoPlay::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CDemoPlay@@8				; CDemoPlay::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CDemoPlay@@8			; CDemoPlay::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCDemoPlay@@@8				; CDemoPlay `RTTI Type Descriptor'
PUBLIC	_modff
PUBLIC	??$_Copy_Construct@M@stlp_std@@YAXPAMABM@Z	; stlp_std::_Copy_Construct<float>
PUBLIC	?push_back@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@QAEXABM@Z ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::push_back
PUBLIC	?push_back@?$vector@MV?$xalloc@M@@@stlp_std@@QAEXABM@Z ; stlp_std::vector<float,xalloc<float> >::push_back
PUBLIC	?empty@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QBE_NXZ ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::empty
PUBLIC	?empty@?$vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@stlp_std@@QBE_NXZ ; stlp_std::vector<_matrix<float>,xalloc<_matrix<float> > >::empty
PUBLIC	??A?$xr_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@@QAEAAU?$_matrix@M@@I@Z ; xr_vector<_matrix<float>,xalloc<_matrix<float> > >::operator[]
PUBLIC	??0?$_Vector_base@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAE@IABV?$xalloc@U?$_matrix@M@@@@@Z ; stlp_std::priv::_Vector_base<_matrix<float>,xalloc<_matrix<float> > >::_Vector_base<_matrix<float>,xalloc<_matrix<float> > >
PUBLIC	?get_allocator@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QBE?AV?$xalloc@U?$_matrix@M@@@@XZ ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::get_allocator
PUBLIC	?begin@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QBEPBU?$_matrix@M@@XZ ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::begin
PUBLIC	?end@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QBEPBU?$_matrix@M@@XZ ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::end
PUBLIC	??0?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAE@ABV012@@Z ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >
PUBLIC	??0?$vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@stlp_std@@QAE@ABV01@@Z ; stlp_std::vector<_matrix<float>,xalloc<_matrix<float> > >::vector<_matrix<float>,xalloc<_matrix<float> > >
PUBLIC	??0?$xr_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@@QAE@ABV0@@Z ; xr_vector<_matrix<float>,xalloc<_matrix<float> > >::xr_vector<_matrix<float>,xalloc<_matrix<float> > >
PUBLIC	?capacity@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QBEIXZ ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::capacity
PUBLIC	?_Answer@?$_BothPtrType@PBU?$_matrix@M@@PAU1@@stlp_std@@SA?AU__true_type@2@XZ ; stlp_std::_BothPtrType<_matrix<float> const *,_matrix<float> *>::_Answer
PUBLIC	??$__ucopy_ptrs@PBU?$_matrix@M@@PAU1@@priv@stlp_std@@YAPAU?$_matrix@M@@PBU2@0PAU2@ABU__true_type@1@@Z ; stlp_std::priv::__ucopy_ptrs<_matrix<float> const *,_matrix<float> *>
PUBLIC	??$_UseTrivialUCopy@U?$_matrix@M@@U1@@stlp_std@@YA?AU?$_TrivialUCopy@U?$_matrix@M@@U1@@0@PAU?$_matrix@M@@0@Z ; stlp_std::_UseTrivialUCopy<_matrix<float>,_matrix<float> >
PUBLIC	?_Answer@?$_TrivialUCopy@U?$_matrix@M@@U1@@stlp_std@@SA?AU__true_type@2@XZ ; stlp_std::_TrivialUCopy<_matrix<float>,_matrix<float> >::_Answer
PUBLIC	??$__ucopy_aux@PBU?$_matrix@M@@PAU1@@priv@stlp_std@@YAPAU?$_matrix@M@@PBU2@0PAU2@ABU__true_type@1@@Z ; stlp_std::priv::__ucopy_aux<_matrix<float> const *,_matrix<float> *>
PUBLIC	??$uninitialized_copy@PBU?$_matrix@M@@PAU1@@stlp_std@@YAPAU?$_matrix@M@@PBU1@0PAU1@@Z ; stlp_std::uninitialized_copy<_matrix<float> const *,_matrix<float> *>
PUBLIC	??$_M_allocate_and_copy@PBU?$_matrix@M@@@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@AAEPAU?$_matrix@M@@AAIPBU3@1@Z ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::_M_allocate_and_copy<_matrix<float> const *>
PUBLIC	??$__copy_ptrs@PBU?$_matrix@M@@PAU1@@priv@stlp_std@@YAPAU?$_matrix@M@@PBU2@0PAU2@ABU__true_type@1@@Z ; stlp_std::priv::__copy_ptrs<_matrix<float> const *,_matrix<float> *>
PUBLIC	??4?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::operator=
PUBLIC	??4?$vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@stlp_std@@QAEAAV01@ABV01@@Z ; stlp_std::vector<_matrix<float>,xalloc<_matrix<float> > >::operator=
PUBLIC	??4?$xr_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@@QAEAAV0@ABV0@@Z ; xr_vector<_matrix<float>,xalloc<_matrix<float> > >::operator=
PUBLIC	?to_value_type_ptr@?$_CastTraits@U?$_matrix@M@@U1@@priv@stlp_std@@SAPAU?$_matrix@M@@PAU4@@Z ; stlp_std::priv::_CastTraits<_matrix<float>,_matrix<float> >::to_value_type_ptr
PUBLIC	?begin@?$vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@stlp_std@@QAEPAU?$_matrix@M@@XZ ; stlp_std::vector<_matrix<float>,xalloc<_matrix<float> > >::begin
PUBLIC	??$xr_alloc@U?$_matrix@M@@@@YAPAU?$_matrix@M@@I@Z ; xr_alloc<_matrix<float> >
PUBLIC	?allocate@?$xalloc@U?$_matrix@M@@@@QBEPAU?$_matrix@M@@IPBX@Z ; xalloc<_matrix<float> >::allocate
PUBLIC	?allocate@?$_STLP_alloc_proxy@PAU?$_matrix@M@@U1@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAEPAU?$_matrix@M@@I@Z ; stlp_std::priv::_STLP_alloc_proxy<_matrix<float> *,_matrix<float>,xalloc<_matrix<float> > >::allocate
PUBLIC	?allocate@?$_STLP_alloc_proxy@PAU?$_matrix@M@@U1@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@AAEPAU?$_matrix@M@@IAAIABU__false_type@3@@Z ; stlp_std::priv::_STLP_alloc_proxy<_matrix<float> *,_matrix<float>,xalloc<_matrix<float> > >::allocate
PUBLIC	?allocate@?$_STLP_alloc_proxy@PAU?$_matrix@M@@U1@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAEPAU?$_matrix@M@@IAAI@Z ; stlp_std::priv::_STLP_alloc_proxy<_matrix<float> *,_matrix<float>,xalloc<_matrix<float> > >::allocate
PUBLIC	?_M_clear@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@AAEXXZ ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::_M_clear
PUBLIC	?_M_set@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@AAEXPAU?$_matrix@M@@00@Z ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::_M_set
PUBLIC	??$__fill_n@PAU?$_matrix@M@@IU1@@priv@stlp_std@@YAPAU?$_matrix@M@@PAU2@IABU2@@Z ; stlp_std::priv::__fill_n<_matrix<float> *,unsigned int,_matrix<float> >
PUBLIC	?_M_insert_overflow@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@AAEXPAU?$_matrix@M@@ABU4@ABU__true_type@3@I_N@Z ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::_M_insert_overflow
PUBLIC	?_M_is_inside@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@ABE_NABU?$_matrix@M@@@Z ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::_M_is_inside
PUBLIC	??$__ucopy_ptrs@PAU?$_matrix@M@@PAU1@@priv@stlp_std@@YAPAU?$_matrix@M@@PAU2@00ABU__true_type@1@@Z ; stlp_std::priv::__ucopy_ptrs<_matrix<float> *,_matrix<float> *>
PUBLIC	??$__copy_backward_ptrs@PAU?$_matrix@M@@PAU1@@priv@stlp_std@@YAPAU?$_matrix@M@@PAU2@00ABU__true_type@1@@Z ; stlp_std::priv::__copy_backward_ptrs<_matrix<float> *,_matrix<float> *>
PUBLIC	??$fill@PAU?$_matrix@M@@U1@@stlp_std@@YAXPAU?$_matrix@M@@0ABU1@@Z ; stlp_std::fill<_matrix<float> *,_matrix<float> >
PUBLIC	??$_Param_Construct@U?$_matrix@M@@U1@@stlp_std@@YAXPAU?$_matrix@M@@ABU1@@Z ; stlp_std::_Param_Construct<_matrix<float>,_matrix<float> >
PUBLIC	??$__ufill@PAU?$_matrix@M@@U1@H@priv@stlp_std@@YAXPAU?$_matrix@M@@0ABU2@ABUrandom_access_iterator_tag@1@PAH@Z ; stlp_std::priv::__ufill<_matrix<float> *,_matrix<float>,int>
PUBLIC	??$__uninitialized_fill_n@PAU?$_matrix@M@@IU1@@priv@stlp_std@@YAPAU?$_matrix@M@@PAU2@IABU2@@Z ; stlp_std::priv::__uninitialized_fill_n<_matrix<float> *,unsigned int,_matrix<float> >
PUBLIC	?_M_fill_insert_aux@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@AAEXPAU?$_matrix@M@@IABU4@ABU__false_type@3@@Z ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::_M_fill_insert_aux
PUBLIC	?_M_fill_insert@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@AAEXPAU?$_matrix@M@@IABU4@@Z ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::_M_fill_insert
PUBLIC	?insert@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAEXPAU?$_matrix@M@@IABU4@@Z ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::insert
PUBLIC	??$__copy_ptrs@PAU?$_matrix@M@@PAU1@@priv@stlp_std@@YAPAU?$_matrix@M@@PAU2@00ABU__true_type@1@@Z ; stlp_std::priv::__copy_ptrs<_matrix<float> *,_matrix<float> *>
PUBLIC	??$__destroy_range_aux@PAU?$_matrix@M@@U1@@stlp_std@@YAXPAU?$_matrix@M@@00ABU__true_type@0@@Z ; stlp_std::__destroy_range_aux<_matrix<float> *,_matrix<float> >
PUBLIC	??$__destroy_range@PAU?$_matrix@M@@U1@@stlp_std@@YAXPAU?$_matrix@M@@00@Z ; stlp_std::__destroy_range<_matrix<float> *,_matrix<float> >
PUBLIC	??$_Destroy_Range@PAU?$_matrix@M@@@stlp_std@@YAXPAU?$_matrix@M@@0@Z ; stlp_std::_Destroy_Range<_matrix<float> *>
PUBLIC	?_M_erase@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@AAEPAU?$_matrix@M@@PAU4@0ABU__false_type@3@@Z ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::_M_erase
PUBLIC	?erase@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAEPAU?$_matrix@M@@PAU4@0@Z ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::erase
PUBLIC	?resize@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAEXIABU?$_matrix@M@@@Z ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::resize
PUBLIC	?to_storage_type_cref@?$_CastTraits@U?$_matrix@M@@U1@@priv@stlp_std@@SAABU?$_matrix@M@@ABU4@@Z ; stlp_std::priv::_CastTraits<_matrix<float>,_matrix<float> >::to_storage_type_cref
PUBLIC	?resize@?$vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@stlp_std@@QAEXIABU?$_matrix@M@@@Z ; stlp_std::vector<_matrix<float>,xalloc<_matrix<float> > >::resize
PUBLIC	??0?$xalloc@U?$_matrix@M@@@@QAE@XZ		; xalloc<_matrix<float> >::xalloc<_matrix<float> >
PUBLIC	??0?$xalloc@U?$_matrix@M@@@@QAE@ABV0@@Z		; xalloc<_matrix<float> >::xalloc<_matrix<float> >
PUBLIC	??0?$_STLP_alloc_proxy@PAU?$_matrix@M@@U1@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAE@ABV?$xalloc@U?$_matrix@M@@@@PAU?$_matrix@M@@@Z ; stlp_std::priv::_STLP_alloc_proxy<_matrix<float> *,_matrix<float>,xalloc<_matrix<float> > >::_STLP_alloc_proxy<_matrix<float> *,_matrix<float>,xalloc<_matrix<float> > >
PUBLIC	??0?$_Vector_base@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAE@ABV?$xalloc@U?$_matrix@M@@@@@Z ; stlp_std::priv::_Vector_base<_matrix<float>,xalloc<_matrix<float> > >::_Vector_base<_matrix<float>,xalloc<_matrix<float> > >
PUBLIC	??0?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAE@ABV?$xalloc@U?$_matrix@M@@@@@Z ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >
PUBLIC	??0?$vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@stlp_std@@QAE@ABV?$xalloc@U?$_matrix@M@@@@@Z ; stlp_std::vector<_matrix<float>,xalloc<_matrix<float> > >::vector<_matrix<float>,xalloc<_matrix<float> > >
PUBLIC	??0?$xr_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@@QAE@XZ ; xr_vector<_matrix<float>,xalloc<_matrix<float> > >::xr_vector<_matrix<float>,xalloc<_matrix<float> > >
PUBLIC	?size@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QBEIXZ ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::size
PUBLIC	?size@?$vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@stlp_std@@QBEIXZ ; stlp_std::vector<_matrix<float>,xalloc<_matrix<float> > >::size
PUBLIC	?size@?$xr_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@@QBEIXZ ; xr_vector<_matrix<float>,xalloc<_matrix<float> > >::size
PUBLIC	??$xr_new@USAnimParams@@@@YAPAUSAnimParams@@XZ	; xr_new<SAnimParams>
PUBLIC	??$xr_free@U?$_matrix@M@@@@YAXAAPAU?$_matrix@M@@@Z ; xr_free<_matrix<float> >
PUBLIC	?deallocate@?$xalloc@U?$_matrix@M@@@@QBEXPAU?$_matrix@M@@I@Z ; xalloc<_matrix<float> >::deallocate
PUBLIC	??1?$_Vector_base@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAE@XZ ; stlp_std::priv::_Vector_base<_matrix<float>,xalloc<_matrix<float> > >::~_Vector_base<_matrix<float>,xalloc<_matrix<float> > >
PUBLIC	?end@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAEPAU?$_matrix@M@@XZ ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::end
PUBLIC	?rbegin@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAU?$_matrix@M@@@3@XZ ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::rbegin
PUBLIC	?begin@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAEPAU?$_matrix@M@@XZ ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::begin
PUBLIC	??0?$reverse_iterator@PAU?$_matrix@M@@@stlp_std@@QAE@PAU?$_matrix@M@@@Z ; stlp_std::reverse_iterator<_matrix<float> *>::reverse_iterator<_matrix<float> *>
PUBLIC	?rend@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAU?$_matrix@M@@@3@XZ ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::rend
PUBLIC	??0?$reverse_iterator@PAU?$_matrix@M@@@stlp_std@@QAE@ABV01@@Z ; stlp_std::reverse_iterator<_matrix<float> *>::reverse_iterator<_matrix<float> *>
PUBLIC	??$__destroy_range_aux@V?$reverse_iterator@PAU?$_matrix@M@@@stlp_std@@U?$_matrix@M@@@stlp_std@@YAXV?$reverse_iterator@PAU?$_matrix@M@@@0@0PAU?$_matrix@M@@ABU__true_type@0@@Z ; stlp_std::__destroy_range_aux<stlp_std::reverse_iterator<_matrix<float> *>,_matrix<float> >
PUBLIC	??$__destroy_range@V?$reverse_iterator@PAU?$_matrix@M@@@stlp_std@@U?$_matrix@M@@@stlp_std@@YAXV?$reverse_iterator@PAU?$_matrix@M@@@0@0PAU?$_matrix@M@@@Z ; stlp_std::__destroy_range<stlp_std::reverse_iterator<_matrix<float> *>,_matrix<float> >
PUBLIC	??$_Destroy_Range@V?$reverse_iterator@PAU?$_matrix@M@@@stlp_std@@@stlp_std@@YAXV?$reverse_iterator@PAU?$_matrix@M@@@0@0@Z ; stlp_std::_Destroy_Range<stlp_std::reverse_iterator<_matrix<float> *> >
PUBLIC	??1?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAE@XZ ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::~_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >
PUBLIC	??1?$vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@stlp_std@@QAE@XZ ; stlp_std::vector<_matrix<float>,xalloc<_matrix<float> > >::~vector<_matrix<float>,xalloc<_matrix<float> > >
PUBLIC	??1?$xr_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@@QAE@XZ ; xr_vector<_matrix<float>,xalloc<_matrix<float> > >::~xr_vector<_matrix<float>,xalloc<_matrix<float> > >
PUBLIC	??R?$xr_special_free@$0A@USAnimParams@@@@QAEXAAPAUSAnimParams@@@Z ; xr_special_free<0,SAnimParams>::operator()
PUBLIC	??$xr_delete@USAnimParams@@@@YAXAAPAUSAnimParams@@@Z ; xr_delete<SAnimParams>
PUBLIC	?_M_throw_length_error@?$_Vector_base@MV?$xalloc@M@@@priv@stlp_std@@IBEXXZ ; stlp_std::priv::_Vector_base<float,xalloc<float> >::_M_throw_length_error
PUBLIC	?max_size@?$xalloc@M@@QBEIXZ			; xalloc<float>::max_size
PUBLIC	?max_size@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@QBEIXZ ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::max_size
PUBLIC	?_Answer@?$_BothPtrType@PAMPAM@stlp_std@@SA?AU__true_type@2@XZ ; stlp_std::_BothPtrType<float *,float *>::_Answer
PUBLIC	??$__ucopy_aux@PAMPAM@priv@stlp_std@@YAPAMPAM00ABU__true_type@1@@Z ; stlp_std::priv::__ucopy_aux<float *,float *>
PUBLIC	??$uninitialized_copy@PAMPAM@stlp_std@@YAPAMPAM00@Z ; stlp_std::uninitialized_copy<float *,float *>
PUBLIC	??$_M_allocate_and_copy@PAM@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@AAEPAMAAIPAM1@Z ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::_M_allocate_and_copy<float *>
PUBLIC	?reserve@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@QAEXI@Z ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::reserve
PUBLIC	?reserve@?$vector@MV?$xalloc@M@@@stlp_std@@QAEXI@Z ; stlp_std::vector<float,xalloc<float> >::reserve
PUBLIC	?clear@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@QAEXXZ ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::clear
PUBLIC	?clear@?$vector@MV?$xalloc@M@@@stlp_std@@QAEXXZ	; stlp_std::vector<float,xalloc<float> >::clear
PUBLIC	?clear_and_free@?$xr_vector@MV?$xalloc@M@@@@QAEXXZ ; xr_vector<float,xalloc<float> >::clear_and_free
PUBLIC	?clear@?$xr_vector@MV?$xalloc@M@@@@QAEXXZ	; xr_vector<float,xalloc<float> >::clear
PUBLIC	?_max@@YAHHH@Z					; _max
PUBLIC	?size@?$vector@MV?$xalloc@M@@@stlp_std@@QBEIXZ	; stlp_std::vector<float,xalloc<float> >::size
PUBLIC	?size@?$xr_vector@MV?$xalloc@M@@@@QBEIXZ	; xr_vector<float,xalloc<float> >::size
PUBLIC	?to_value_type_ptr@?$_CastTraits@MM@priv@stlp_std@@SAPAMPAM@Z ; stlp_std::priv::_CastTraits<float,float>::to_value_type_ptr
PUBLIC	?begin@?$vector@MV?$xalloc@M@@@stlp_std@@QAEPAMXZ ; stlp_std::vector<float,xalloc<float> >::begin
PUBLIC	??A?$xr_vector@MV?$xalloc@M@@@@QAEAAMI@Z	; xr_vector<float,xalloc<float> >::operator[]
PUBLIC	??_C@_0BF@ENHEOCDL@?$CK?$CK?$CK?5Playing?5demo?3?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0N@LNDKCEDJ@hud_weapon?50?$AA@		; `string'
PUBLIC	??_C@_0L@GPCEDEIH@hud_draw?50?$AA@		; `string'
PUBLIC	??_C@_0BF@BJCJNHMJ@?$HO?5Total?5key?9frames?3?5?$AA@ ; `string'
PUBLIC	??_C@_0N@KECBBFHI@hud_weapon?51?$AA@		; `string'
PUBLIC	??_C@_0L@HGDPAFMG@hud_draw?51?$AA@		; `string'
PUBLIC	??_C@_0DI@KDFBHPPC@?$CK?5?$FLDEMO?$FN?5FPS?3?5average?$FL?$CFf?$FN?0?5min?$FL?$CF@ ; `string'
PUBLIC	??_C@_09FLBAMLIF@?$CFs?4result?$AA@		; `string'
PUBLIC	??_C@_0BB@PFMCGCAH@benchmark?4result?$AA@	; `string'
PUBLIC	??_C@_0BC@BFKHPNCC@dx?9level?5required?$AA@	; `string'
PUBLIC	??_C@_08NELFFGLM@renderer?$AA@			; `string'
PUBLIC	??_C@_07LLDKJBMK@general?$AA@			; `string'
PUBLIC	??_C@_0BB@NKIHBPID@absolute?5minimum?$AA@	; `string'
PUBLIC	??_C@_03KLIPLJLL@min?$AA@			; `string'
PUBLIC	??_C@_0BB@DMOHLAGC@absolute?5maximum?$AA@	; `string'
PUBLIC	??_C@_03LJAEFNNE@max?$AA@			; `string'
PUBLIC	??_C@_0BF@JFNMHPHL@average?5for?5this?5run?$AA@	; `string'
PUBLIC	??_C@_07EIHJKMF@average?$AA@			; `string'
PUBLIC	??_C@_0BH@LHOALLHE@per?9frame?5middle?9point?$AA@ ; `string'
PUBLIC	??_C@_06CGLIEPEJ@middle?$AA@			; `string'
PUBLIC	??_C@_03GJOCCCFJ@?$CF7d?$AA@			; `string'
PUBLIC	??_C@_0BA@HCEKDGCO@per_frame_stats?$AA@		; `string'
PUBLIC	??_C@_04KNNLNNGO@quit?$AA@			; `string'
PUBLIC	??_7CDemoPlay@@6B@				; CDemoPlay::`vftable'
EXTRN	__imp__modf:PROC
EXTRN	__imp_?length@IReader@@QBEHXZ:PROC
EXTRN	__imp_?pointer@IReader@@QBEPAXXZ:PROC
EXTRN	__imp_?Log@@YAXPBDH@Z:PROC
EXTRN	__imp_?exist@CLocatorAPI@@QAEPBUfile@1@PBD@Z:PROC
EXTRN	__imp_?w_float@CInifile@@QAEXPBD0M0@Z:PROC
;	COMDAT ??_7CDemoPlay@@6B@
CONST	SEGMENT
??_7CDemoPlay@@6B@ DD FLAT:??_R4CDemoPlay@@6B@		; CDemoPlay::`vftable'
	DD	FLAT:??_ECDemoPlay@@UAEPAXI@Z
	DD	FLAT:?Valid@CEffectorCam@@UAEHXZ
	DD	FLAT:?ProcessCam@CDemoPlay@@UAEHAAUSCamEffectorInfo@@@Z
	DD	FLAT:?ProcessIfInvalid@CEffectorCam@@UAEXAAUSCamEffectorInfo@@@Z
	DD	FLAT:?AllowProcessingIfInvalid@CEffectorCam@@UAEHXZ
	DD	FLAT:?AbsolutePositioning@CEffectorCam@@UAE_NXZ
CONST	ENDS
;	COMDAT ??_R4CDemoPlay@@6B@
rdata$r	SEGMENT
??_R4CDemoPlay@@6B@ DD 00H				; CDemoPlay::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCDemoPlay@@@8
	DD	FLAT:??_R3CDemoPlay@@8
rdata$r	ENDS
;	COMDAT ??_R3CDemoPlay@@8
rdata$r	SEGMENT
??_R3CDemoPlay@@8 DD 00H				; CDemoPlay::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CDemoPlay@@8
rdata$r	ENDS
;	COMDAT ??_R2CDemoPlay@@8
rdata$r	SEGMENT
??_R2CDemoPlay@@8 DD FLAT:??_R1A@?0A@EA@CDemoPlay@@8	; CDemoPlay::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CEffectorCam@@8
	DD	FLAT:??_R1A@?0A@EA@SBaseEffector@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CDemoPlay@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CDemoPlay@@8 DD FLAT:??_R0?AVCDemoPlay@@@8 ; CDemoPlay::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CDemoPlay@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCDemoPlay@@@8
_DATA	SEGMENT
??_R0?AVCDemoPlay@@@8 DD FLAT:??_7type_info@@6B@	; CDemoPlay `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCDemoPlay@@', 00H
_DATA	ENDS
;	COMDAT ??_C@_04KNNLNNGO@quit?$AA@
CONST	SEGMENT
??_C@_04KNNLNNGO@quit?$AA@ DB 'quit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HCEKDGCO@per_frame_stats?$AA@
CONST	SEGMENT
??_C@_0BA@HCEKDGCO@per_frame_stats?$AA@ DB 'per_frame_stats', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03GJOCCCFJ@?$CF7d?$AA@
CONST	SEGMENT
??_C@_03GJOCCCFJ@?$CF7d?$AA@ DB '%7d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CGLIEPEJ@middle?$AA@
CONST	SEGMENT
??_C@_06CGLIEPEJ@middle?$AA@ DB 'middle', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LHOALLHE@per?9frame?5middle?9point?$AA@
CONST	SEGMENT
??_C@_0BH@LHOALLHE@per?9frame?5middle?9point?$AA@ DB 'per-frame middle-po'
	DB	'int', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_07EIHJKMF@average?$AA@
CONST	SEGMENT
??_C@_07EIHJKMF@average?$AA@ DB 'average', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JFNMHPHL@average?5for?5this?5run?$AA@
CONST	SEGMENT
??_C@_0BF@JFNMHPHL@average?5for?5this?5run?$AA@ DB 'average for this run', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03LJAEFNNE@max?$AA@
CONST	SEGMENT
??_C@_03LJAEFNNE@max?$AA@ DB 'max', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DMOHLAGC@absolute?5maximum?$AA@
CONST	SEGMENT
??_C@_0BB@DMOHLAGC@absolute?5maximum?$AA@ DB 'absolute maximum', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03KLIPLJLL@min?$AA@
CONST	SEGMENT
??_C@_03KLIPLJLL@min?$AA@ DB 'min', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NKIHBPID@absolute?5minimum?$AA@
CONST	SEGMENT
??_C@_0BB@NKIHBPID@absolute?5minimum?$AA@ DB 'absolute minimum', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07LLDKJBMK@general?$AA@
CONST	SEGMENT
??_C@_07LLDKJBMK@general?$AA@ DB 'general', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08NELFFGLM@renderer?$AA@
CONST	SEGMENT
??_C@_08NELFFGLM@renderer?$AA@ DB 'renderer', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BFKHPNCC@dx?9level?5required?$AA@
CONST	SEGMENT
??_C@_0BC@BFKHPNCC@dx?9level?5required?$AA@ DB 'dx-level required', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PFMCGCAH@benchmark?4result?$AA@
CONST	SEGMENT
??_C@_0BB@PFMCGCAH@benchmark?4result?$AA@ DB 'benchmark.result', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09FLBAMLIF@?$CFs?4result?$AA@
CONST	SEGMENT
??_C@_09FLBAMLIF@?$CFs?4result?$AA@ DB '%s.result', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@KDFBHPPC@?$CK?5?$FLDEMO?$FN?5FPS?3?5average?$FL?$CFf?$FN?0?5min?$FL?$CF@
CONST	SEGMENT
??_C@_0DI@KDFBHPPC@?$CK?5?$FLDEMO?$FN?5FPS?3?5average?$FL?$CFf?$FN?0?5min?$FL?$CF@ DB '*'
	DB	' [DEMO] FPS: average[%f], min[%f], max[%f], middle[%f]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HGDPAFMG@hud_draw?51?$AA@
CONST	SEGMENT
??_C@_0L@HGDPAFMG@hud_draw?51?$AA@ DB 'hud_draw 1', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KECBBFHI@hud_weapon?51?$AA@
CONST	SEGMENT
??_C@_0N@KECBBFHI@hud_weapon?51?$AA@ DB 'hud_weapon 1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BJCJNHMJ@?$HO?5Total?5key?9frames?3?5?$AA@
CONST	SEGMENT
??_C@_0BF@BJCJNHMJ@?$HO?5Total?5key?9frames?3?5?$AA@ DB '~ Total key-fram'
	DB	'es: ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GPCEDEIH@hud_draw?50?$AA@
CONST	SEGMENT
??_C@_0L@GPCEDEIH@hud_draw?50?$AA@ DB 'hud_draw 0', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LNDKCEDJ@hud_weapon?50?$AA@
CONST	SEGMENT
??_C@_0N@LNDKCEDJ@hud_weapon?50?$AA@ DB 'hud_weapon 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@ENHEOCDL@?$CK?$CK?$CK?5Playing?5demo?3?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BF@ENHEOCDL@?$CK?$CK?$CK?5Playing?5demo?3?5?$CFs?$AA@ DB '*** Play'
	DB	'ing demo: %s', 00H				; `string'
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_std_extensions.h
;	COMDAT ?_max@@YAHHH@Z
_TEXT	SEGMENT
_y$ = 8							; size = 4
?_max@@YAHHH@Z PROC					; _max, COMDAT
; _x$ = eax

; 160  : IC s32		_max	(s32 x, s32 y)	{ return x - ((x - y) & ((x - y) >> (sizeof(s32) * 8 - 1))); };

	mov	ecx, eax
	sub	ecx, DWORD PTR _y$[esp-4]
	mov	edx, ecx
	sar	edx, 31					; 0000001fH
	and	edx, ecx
	sub	eax, edx
	ret	0
?_max@@YAHHH@Z ENDP					; _max
; Function compile flags: /Ogtpy
; File j:\msvs8\vc\include\math.h
_TEXT	ENDS
;	COMDAT _modff
_TEXT	SEGMENT
__Di$ = -12						; size = 8
__X$ = 8						; size = 4
__Y$ = 12						; size = 4
_modff	PROC						; COMDAT

; 413  :         { double _Di, _Df = modf((double)_X, &_Di);

	fld	DWORD PTR __X$[esp-4]
	sub	esp, 12					; 0000000cH
	lea	eax, DWORD PTR __Di$[esp+12]
	push	eax
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp__modf

; 414  :         *_Y = (float)_Di;

	fld	QWORD PTR __Di$[esp+24]
	mov	ecx, DWORD PTR __Y$[esp+20]
	fstp	DWORD PTR [ecx]

; 415  :         return ((float)_Df); }

	add	esp, 24					; 00000018H
	ret	0
_modff	ENDP
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\type_traits.h
_TEXT	ENDS
;	COMDAT ??$_UseTrivialUCopy@U?$_matrix@M@@U1@@stlp_std@@YA?AU?$_TrivialUCopy@U?$_matrix@M@@U1@@0@PAU?$_matrix@M@@0@Z
_TEXT	SEGMENT
??$_UseTrivialUCopy@U?$_matrix@M@@U1@@stlp_std@@YA?AU?$_TrivialUCopy@U?$_matrix@M@@U1@@0@PAU?$_matrix@M@@0@Z PROC ; stlp_std::_UseTrivialUCopy<_matrix<float>,_matrix<float> >, COMDAT

; 489  : { return _TrivialUCopy<_Src, _Dst>(); }

	xor	al, al
	ret	0
??$_UseTrivialUCopy@U?$_matrix@M@@U1@@stlp_std@@YA?AU?$_TrivialUCopy@U?$_matrix@M@@U1@@0@PAU?$_matrix@M@@0@Z ENDP ; stlp_std::_UseTrivialUCopy<_matrix<float>,_matrix<float> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Answer@?$_TrivialUCopy@U?$_matrix@M@@U1@@stlp_std@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT
?_Answer@?$_TrivialUCopy@U?$_matrix@M@@U1@@stlp_std@@SA?AU__true_type@2@XZ PROC ; stlp_std::_TrivialUCopy<_matrix<float>,_matrix<float> >::_Answer, COMDAT

; 407  :   static _Ret _Answer() { return _Ret(); }

	xor	al, al
	ret	0
?_Answer@?$_TrivialUCopy@U?$_matrix@M@@U1@@stlp_std@@SA?AU__true_type@2@XZ ENDP ; stlp_std::_TrivialUCopy<_matrix<float>,_matrix<float> >::_Answer
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Answer@?$_BothPtrType@PAMPAM@stlp_std@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT
?_Answer@?$_BothPtrType@PAMPAM@stlp_std@@SA?AU__true_type@2@XZ PROC ; stlp_std::_BothPtrType<float *,float *>::_Answer, COMDAT

; 468  :   static _Ret _Answer() { return _Ret(); }

	xor	al, al
	ret	0
?_Answer@?$_BothPtrType@PAMPAM@stlp_std@@SA?AU__true_type@2@XZ ENDP ; stlp_std::_BothPtrType<float *,float *>::_Answer
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Answer@?$_BothPtrType@PBU?$_matrix@M@@PAU1@@stlp_std@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT
?_Answer@?$_BothPtrType@PBU?$_matrix@M@@PAU1@@stlp_std@@SA?AU__true_type@2@XZ PROC ; stlp_std::_BothPtrType<_matrix<float> const *,_matrix<float> *>::_Answer, COMDAT

; 468  :   static _Ret _Answer() { return _Ret(); }

	xor	al, al
	ret	0
?_Answer@?$_BothPtrType@PBU?$_matrix@M@@PAU1@@stlp_std@@SA?AU__true_type@2@XZ ENDP ; stlp_std::_BothPtrType<_matrix<float> const *,_matrix<float> *>::_Answer
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_construct.h
_TEXT	ENDS
;	COMDAT ??$__destroy_range_aux@PAU?$_matrix@M@@U1@@stlp_std@@YAXPAU?$_matrix@M@@00ABU__true_type@0@@Z
_TEXT	SEGMENT
??$__destroy_range_aux@PAU?$_matrix@M@@U1@@stlp_std@@YAXPAU?$_matrix@M@@00ABU__true_type@0@@Z PROC ; stlp_std::__destroy_range_aux<_matrix<float> *,_matrix<float> >, COMDAT

; 169  : __destroy_range_aux(_ForwardIterator, _ForwardIterator, _Tp*, const __true_type& /*_Trivial_destructor*/) {}

	ret	0
??$__destroy_range_aux@PAU?$_matrix@M@@U1@@stlp_std@@YAXPAU?$_matrix@M@@00ABU__true_type@0@@Z ENDP ; stlp_std::__destroy_range_aux<_matrix<float> *,_matrix<float> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$__destroy_range_aux@V?$reverse_iterator@PAU?$_matrix@M@@@stlp_std@@U?$_matrix@M@@@stlp_std@@YAXV?$reverse_iterator@PAU?$_matrix@M@@@0@0PAU?$_matrix@M@@ABU__true_type@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$__destroy_range_aux@V?$reverse_iterator@PAU?$_matrix@M@@@stlp_std@@U?$_matrix@M@@@stlp_std@@YAXV?$reverse_iterator@PAU?$_matrix@M@@@0@0PAU?$_matrix@M@@ABU__true_type@0@@Z PROC ; stlp_std::__destroy_range_aux<stlp_std::reverse_iterator<_matrix<float> *>,_matrix<float> >, COMDAT

; 169  : __destroy_range_aux(_ForwardIterator, _ForwardIterator, _Tp*, const __true_type& /*_Trivial_destructor*/) {}

	ret	0
??$__destroy_range_aux@V?$reverse_iterator@PAU?$_matrix@M@@@stlp_std@@U?$_matrix@M@@@stlp_std@@YAXV?$reverse_iterator@PAU?$_matrix@M@@@0@0PAU?$_matrix@M@@ABU__true_type@0@@Z ENDP ; stlp_std::__destroy_range_aux<stlp_std::reverse_iterator<_matrix<float> *>,_matrix<float> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_algobase.h
_TEXT	ENDS
;	COMDAT ??$fill@PAU?$_matrix@M@@U1@@stlp_std@@YAXPAU?$_matrix@M@@0ABU1@@Z
_TEXT	SEGMENT
??$fill@PAU?$_matrix@M@@U1@@stlp_std@@YAXPAU?$_matrix@M@@0ABU1@@Z PROC ; stlp_std::fill<_matrix<float> *,_matrix<float> >, COMDAT
; ___first$ = eax
; ___last$ = edx
; ___val$ = ebx

; 393  :   _STLP_DEBUG_CHECK(_STLP_PRIV __check_range(__first, __last))
; 394  :   for ( ; __first != __last; ++__first)

	cmp	eax, edx
	je	SHORT $LN1@fill@3
	push	esi
	push	edi
$LL3@fill@3:

; 395  :     *__first = __val;

	mov	edi, eax
	add	eax, 64					; 00000040H
	cmp	eax, edx
	mov	ecx, 16					; 00000010H
	mov	esi, ebx
	rep movsd
	jne	SHORT $LL3@fill@3
	pop	edi
	pop	esi
$LN1@fill@3:

; 396  : }

	ret	0
??$fill@PAU?$_matrix@M@@U1@@stlp_std@@YAXPAU?$_matrix@M@@0ABU1@@Z ENDP ; stlp_std::fill<_matrix<float> *,_matrix<float> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$__fill_n@PAU?$_matrix@M@@IU1@@priv@stlp_std@@YAPAU?$_matrix@M@@PAU2@IABU2@@Z
_TEXT	SEGMENT
??$__fill_n@PAU?$_matrix@M@@IU1@@priv@stlp_std@@YAPAU?$_matrix@M@@PAU2@IABU2@@Z PROC ; stlp_std::priv::__fill_n<_matrix<float> *,unsigned int,_matrix<float> >, COMDAT
; ___first$ = eax
; ___n$ = edx
; ___val$ = ebx

; 403  :   _STLP_FIX_LITERAL_BUG(__first)
; 404  :   for ( ; __n > 0; --__n, ++__first)

	test	edx, edx
	jbe	SHORT $LN1@fill_n@6
	push	esi
	push	edi
$LL3@fill_n@6:

; 405  :     *__first = __val;

	mov	edi, eax
	sub	edx, 1
	mov	ecx, 16					; 00000010H
	mov	esi, ebx
	add	eax, 64					; 00000040H
	test	edx, edx
	rep movsd
	ja	SHORT $LL3@fill_n@6
	pop	edi
	pop	esi
$LN1@fill_n@6:

; 406  :   return __first;
; 407  : }

	ret	0
??$__fill_n@PAU?$_matrix@M@@IU1@@priv@stlp_std@@YAPAU?$_matrix@M@@PAU2@IABU2@@Z ENDP ; stlp_std::priv::__fill_n<_matrix<float> *,unsigned int,_matrix<float> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ?_M_set@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@AAEXPAU?$_matrix@M@@00@Z
_TEXT	SEGMENT
___e$ = 8						; size = 4
?_M_set@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@AAEXPAU?$_matrix@M@@00@Z PROC ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::_M_set, COMDAT
; _this$ = eax
; ___s$ = ecx
; ___f$ = edx

; 626  :     this->_M_start = __s;

	mov	DWORD PTR [eax], ecx

; 627  :     this->_M_finish = __f;
; 628  :     this->_M_end_of_storage._M_data = __e;

	mov	ecx, DWORD PTR ___e$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], ecx

; 629  :   }

	ret	4
?_M_set@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@AAEXPAU?$_matrix@M@@00@Z ENDP ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::_M_set
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_M_is_inside@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@ABE_NABU?$_matrix@M@@@Z
_TEXT	SEGMENT
?_M_is_inside@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@ABE_NABU?$_matrix@M@@@Z PROC ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::_M_is_inside, COMDAT
; _this$ = ecx
; ___x$ = eax

; 393  :     return (&__x >= this->_M_start && &__x < this->_M_finish);

	cmp	eax, DWORD PTR [ecx]
	jb	SHORT $LN3@M_is_insid@6
	cmp	eax, DWORD PTR [ecx+4]
	jae	SHORT $LN3@M_is_insid@6
	mov	eax, 1

; 394  :   }

	ret	0
$LN3@M_is_insid@6:

; 393  :     return (&__x >= this->_M_start && &__x < this->_M_finish);

	xor	eax, eax

; 394  :   }

	ret	0
?_M_is_inside@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@ABE_NABU?$_matrix@M@@@Z ENDP ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::_M_is_inside
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_construct.h
_TEXT	ENDS
;	COMDAT ??$__destroy_range@PAU?$_matrix@M@@U1@@stlp_std@@YAXPAU?$_matrix@M@@00@Z
_TEXT	SEGMENT
??$__destroy_range@PAU?$_matrix@M@@U1@@stlp_std@@YAXPAU?$_matrix@M@@00@Z PROC ; stlp_std::__destroy_range<_matrix<float> *,_matrix<float> >, COMDAT

; 175  :   typedef typename __type_traits<_Tp>::has_trivial_destructor _Trivial_destructor;
; 176  :   __destroy_range_aux(__first, __last, __ptr, _Trivial_destructor());
; 177  : }

	ret	0
??$__destroy_range@PAU?$_matrix@M@@U1@@stlp_std@@YAXPAU?$_matrix@M@@00@Z ENDP ; stlp_std::__destroy_range<_matrix<float> *,_matrix<float> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ?max_size@?$xalloc@M@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$xalloc@M@@QBEIXZ PROC			; xalloc<float>::max_size, COMDAT

; 87   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 1073741823				; 3fffffffH
	ret	0
?max_size@?$xalloc@M@@QBEIXZ ENDP			; xalloc<float>::max_size
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\xrmemory_subst_msvc.h
_TEXT	ENDS
;	COMDAT ??R?$xr_special_free@$0A@USAnimParams@@@@QAEXAAPAUSAnimParams@@@Z
_TEXT	SEGMENT
??R?$xr_special_free@$0A@USAnimParams@@@@QAEXAAPAUSAnimParams@@@Z PROC ; xr_special_free<0,SAnimParams>::operator(), COMDAT
; _ptr$ = eax

; 143  : 		ptr->~T			();
; 144  : 		Memory.mem_free	(ptr);

	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 145  : 	}

	ret	0
??R?$xr_special_free@$0A@USAnimParams@@@@QAEXAAPAUSAnimParams@@@Z ENDP ; xr_special_free<0,SAnimParams>::operator()
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_iterator.h
_TEXT	ENDS
;	COMDAT ??0?$reverse_iterator@PAU?$_matrix@M@@@stlp_std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$reverse_iterator@PAU?$_matrix@M@@@stlp_std@@QAE@ABV01@@Z PROC ; stlp_std::reverse_iterator<_matrix<float> *>::reverse_iterator<_matrix<float> *>, COMDAT
; _this$ = eax
; ___x$ = ecx

; 66   :   reverse_iterator(const _Self& __x) : current(__x.current) {}

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	ret	0
??0?$reverse_iterator@PAU?$_matrix@M@@@stlp_std@@QAE@ABV01@@Z ENDP ; stlp_std::reverse_iterator<_matrix<float> *>::reverse_iterator<_matrix<float> *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ?capacity@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QBEIXZ PROC ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::capacity, COMDAT
; _this$ = ecx

; 187  :   size_type capacity() const    { return size_type(this->_M_end_of_storage._M_data - this->_M_start); }

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 6
	ret	0
?capacity@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QBEIXZ ENDP ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::capacity
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@QBEIXZ PROC ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::max_size, COMDAT

; 182  :     size_type __vector_max_size = size_type(-1) / sizeof(_Tp);
; 183  :     typename allocator_type::size_type __alloc_max_size = this->_M_end_of_storage.max_size();
; 184  :     return (__alloc_max_size < __vector_max_size)?__alloc_max_size:__vector_max_size;

	mov	eax, 1073741823				; 3fffffffH

; 185  :   }

	ret	0
?max_size@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@QBEIXZ ENDP ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::max_size
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\xrmemory.h
_TEXT	ENDS
;	COMDAT ??$xr_alloc@U?$_matrix@M@@@@YAPAU?$_matrix@M@@I@Z
_TEXT	SEGMENT
??$xr_alloc@U?$_matrix@M@@@@YAPAU?$_matrix@M@@I@Z PROC	; xr_alloc<_matrix<float> >, COMDAT
; _count$ = eax

; 109  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	eax, 6
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@U?$_matrix@M@@@@YAPAU?$_matrix@M@@I@Z ENDP	; xr_alloc<_matrix<float> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_construct.h
_TEXT	ENDS
;	COMDAT ??$_Destroy_Range@PAU?$_matrix@M@@@stlp_std@@YAXPAU?$_matrix@M@@0@Z
_TEXT	SEGMENT
??$_Destroy_Range@PAU?$_matrix@M@@@stlp_std@@YAXPAU?$_matrix@M@@0@Z PROC ; stlp_std::_Destroy_Range<_matrix<float> *>, COMDAT

; 181  :   __destroy_range(__first, __last, _STLP_VALUE_TYPE(__first, _ForwardIterator));
; 182  : }

	ret	0
??$_Destroy_Range@PAU?$_matrix@M@@@stlp_std@@YAXPAU?$_matrix@M@@0@Z ENDP ; stlp_std::_Destroy_Range<_matrix<float> *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\xrmemory.h
_TEXT	ENDS
;	COMDAT ??$xr_free@U?$_matrix@M@@@@YAXAAPAU?$_matrix@M@@@Z
_TEXT	SEGMENT
??$xr_free@U?$_matrix@M@@@@YAXAAPAU?$_matrix@M@@@Z PROC	; xr_free<_matrix<float> >, COMDAT
; _P$ = esi

; 111  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN1@xr_free@23
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN1@xr_free@23:
	ret	0
??$xr_free@U?$_matrix@M@@@@YAXAAPAU?$_matrix@M@@@Z ENDP	; xr_free<_matrix<float> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\xrmemory_subst_msvc.h
_TEXT	ENDS
;	COMDAT ??$xr_delete@USAnimParams@@@@YAXAAPAUSAnimParams@@@Z
_TEXT	SEGMENT
??$xr_delete@USAnimParams@@@@YAXAAPAUSAnimParams@@@Z PROC ; xr_delete<SAnimParams>, COMDAT
; _ptr$ = esi

; 151  : 	if (ptr) 

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN1@xr_delete@6

; 152  : 	{
; 153  : 		xr_special_free<is_polymorphic<T>::result,T>()(ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 154  : 		ptr = NULL;

	mov	DWORD PTR [esi], 0
$LN1@xr_delete@6:

; 155  : 	}
; 156  : }

	ret	0
??$xr_delete@USAnimParams@@@@YAXAAPAUSAnimParams@@@Z ENDP ; xr_delete<SAnimParams>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ?allocate@?$xalloc@U?$_matrix@M@@@@QBEPAU?$_matrix@M@@IPBX@Z
_TEXT	SEGMENT
?allocate@?$xalloc@U?$_matrix@M@@@@QBEPAU?$_matrix@M@@IPBX@Z PROC ; xalloc<_matrix<float> >::allocate, COMDAT
; _n$ = eax

; 81   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	eax, 6
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
?allocate@?$xalloc@U?$_matrix@M@@@@QBEPAU?$_matrix@M@@IPBX@Z ENDP ; xalloc<_matrix<float> >::allocate
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_alloc.h
_TEXT	ENDS
;	COMDAT ?allocate@?$_STLP_alloc_proxy@PAU?$_matrix@M@@U1@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAEPAU?$_matrix@M@@I@Z
_TEXT	SEGMENT
?allocate@?$_STLP_alloc_proxy@PAU?$_matrix@M@@U1@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAEPAU?$_matrix@M@@I@Z PROC ; stlp_std::priv::_STLP_alloc_proxy<_matrix<float> *,_matrix<float>,xalloc<_matrix<float> > >::allocate, COMDAT
; ___n$ = eax

; 633  :   { return _Base::allocate(__n); }

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	eax, 6
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
?allocate@?$_STLP_alloc_proxy@PAU?$_matrix@M@@U1@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAEPAU?$_matrix@M@@I@Z ENDP ; stlp_std::priv::_STLP_alloc_proxy<_matrix<float> *,_matrix<float>,xalloc<_matrix<float> > >::allocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$_STLP_alloc_proxy@PAU?$_matrix@M@@U1@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@AAEPAU?$_matrix@M@@IAAIABU__false_type@3@@Z
_TEXT	SEGMENT
?allocate@?$_STLP_alloc_proxy@PAU?$_matrix@M@@U1@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@AAEPAU?$_matrix@M@@IAAIABU__false_type@3@@Z PROC ; stlp_std::priv::_STLP_alloc_proxy<_matrix<float> *,_matrix<float>,xalloc<_matrix<float> > >::allocate, COMDAT
; ___n$ = eax
; ___allocated_n$ = ecx

; 640  :   { __allocated_n = __n; return allocate(__n); }

	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	eax, 6
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
?allocate@?$_STLP_alloc_proxy@PAU?$_matrix@M@@U1@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@AAEPAU?$_matrix@M@@IAAIABU__false_type@3@@Z ENDP ; stlp_std::priv::_STLP_alloc_proxy<_matrix<float> *,_matrix<float>,xalloc<_matrix<float> > >::allocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$_STLP_alloc_proxy@PAU?$_matrix@M@@U1@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAEPAU?$_matrix@M@@IAAI@Z
_TEXT	SEGMENT
?allocate@?$_STLP_alloc_proxy@PAU?$_matrix@M@@U1@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAEPAU?$_matrix@M@@IAAI@Z PROC ; stlp_std::priv::_STLP_alloc_proxy<_matrix<float> *,_matrix<float>,xalloc<_matrix<float> > >::allocate, COMDAT
; ___n$ = eax
; ___allocated_n$ = ecx

; 611  : #if !defined (__BORLANDC__)
; 612  :     typedef typename _IsSTLportClass<_MaybeReboundAlloc>::_Ret _STLportAlloc;
; 613  : #else
; 614  :     typedef typename __bool2type<_IsSTLportClass<_MaybeReboundAlloc>::_Is>::_Ret _STLportAlloc;
; 615  : #endif
; 616  :     return allocate(__n, __allocated_n, _STLportAlloc());

	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	eax, 6
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 617  :   }

	ret	0
?allocate@?$_STLP_alloc_proxy@PAU?$_matrix@M@@U1@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAEPAU?$_matrix@M@@IAAI@Z ENDP ; stlp_std::priv::_STLP_alloc_proxy<_matrix<float> *,_matrix<float>,xalloc<_matrix<float> > >::allocate
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ??0?$xalloc@U?$_matrix@M@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
??0?$xalloc@U?$_matrix@M@@@@QAE@ABV0@@Z PROC		; xalloc<_matrix<float> >::xalloc<_matrix<float> >, COMDAT
; _this$ = eax

; 78   : 													xalloc			(const xalloc<T>&)						{	}

	ret	0
??0?$xalloc@U?$_matrix@M@@@@QAE@ABV0@@Z ENDP		; xalloc<_matrix<float> >::xalloc<_matrix<float> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_iterator.h
_TEXT	ENDS
;	COMDAT ??0?$reverse_iterator@PAU?$_matrix@M@@@stlp_std@@QAE@PAU?$_matrix@M@@@Z
_TEXT	SEGMENT
??0?$reverse_iterator@PAU?$_matrix@M@@@stlp_std@@QAE@PAU?$_matrix@M@@@Z PROC ; stlp_std::reverse_iterator<_matrix<float> *>::reverse_iterator<_matrix<float> *>, COMDAT
; _this$ = eax
; ___x$ = ecx

; 65   :   explicit reverse_iterator(iterator_type __x) : current(__x) {}

	mov	DWORD PTR [eax], ecx
	ret	0
??0?$reverse_iterator@PAU?$_matrix@M@@@stlp_std@@QAE@PAU?$_matrix@M@@@Z ENDP ; stlp_std::reverse_iterator<_matrix<float> *>::reverse_iterator<_matrix<float> *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_tools.h
_TEXT	ENDS
;	COMDAT ?to_value_type_ptr@?$_CastTraits@MM@priv@stlp_std@@SAPAMPAM@Z
_TEXT	SEGMENT
?to_value_type_ptr@?$_CastTraits@MM@priv@stlp_std@@SAPAMPAM@Z PROC ; stlp_std::priv::_CastTraits<float,float>::to_value_type_ptr, COMDAT
; ___ptr$ = eax

; 237  :   { return __ptr; }

	ret	0
?to_value_type_ptr@?$_CastTraits@MM@priv@stlp_std@@SAPAMPAM@Z ENDP ; stlp_std::priv::_CastTraits<float,float>::to_value_type_ptr
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ?size@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QBEIXZ PROC ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::size, COMDAT
; _this$ = ecx

; 180  :   size_type size() const        { return size_type(this->_M_finish - this->_M_start); }

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 6
	ret	0
?size@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QBEIXZ ENDP ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QBEPBU?$_matrix@M@@XZ
_TEXT	SEGMENT
?end@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QBEPBU?$_matrix@M@@XZ PROC ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::end, COMDAT
; _this$ = eax

; 173  :   const_iterator end() const   { return this->_M_finish; }

	mov	eax, DWORD PTR [eax+4]
	ret	0
?end@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QBEPBU?$_matrix@M@@XZ ENDP ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAEPAU?$_matrix@M@@XZ
_TEXT	SEGMENT
?end@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAEPAU?$_matrix@M@@XZ PROC ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::end, COMDAT
; _this$ = eax

; 172  :   iterator end()               { return this->_M_finish; }

	mov	eax, DWORD PTR [eax+4]
	ret	0
?end@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAEPAU?$_matrix@M@@XZ ENDP ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QBEPBU?$_matrix@M@@XZ
_TEXT	SEGMENT
?begin@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QBEPBU?$_matrix@M@@XZ PROC ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::begin, COMDAT
; _this$ = eax

; 171  :   const_iterator begin() const { return this->_M_start; }

	mov	eax, DWORD PTR [eax]
	ret	0
?begin@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QBEPBU?$_matrix@M@@XZ ENDP ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::begin
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?get_allocator@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QBE?AV?$xalloc@U?$_matrix@M@@@@XZ
_TEXT	SEGMENT
?get_allocator@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QBE?AV?$xalloc@U?$_matrix@M@@@@XZ PROC ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::get_allocator, COMDAT
; ___$ReturnUdt$ = eax

; 134  :   { return _STLP_CONVERT_ALLOCATOR((const allocator_type&)this->_M_end_of_storage, _Tp); }

	ret	0
?get_allocator@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QBE?AV?$xalloc@U?$_matrix@M@@@@XZ ENDP ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::get_allocator
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ?deallocate@?$xalloc@U?$_matrix@M@@@@QBEXPAU?$_matrix@M@@I@Z
_TEXT	SEGMENT
?deallocate@?$xalloc@U?$_matrix@M@@@@QBEXPAU?$_matrix@M@@I@Z PROC ; xalloc<_matrix<float> >::deallocate, COMDAT
; _p$ = eax

; 83   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	test	eax, eax
	je	SHORT $LN3@deallocate@15
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN3@deallocate@15:
	ret	0
?deallocate@?$xalloc@U?$_matrix@M@@@@QBEXPAU?$_matrix@M@@I@Z ENDP ; xalloc<_matrix<float> >::deallocate
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_tools.h
_TEXT	ENDS
;	COMDAT ?to_storage_type_cref@?$_CastTraits@U?$_matrix@M@@U1@@priv@stlp_std@@SAABU?$_matrix@M@@ABU4@@Z
_TEXT	SEGMENT
?to_storage_type_cref@?$_CastTraits@U?$_matrix@M@@U1@@priv@stlp_std@@SAABU?$_matrix@M@@ABU4@@Z PROC ; stlp_std::priv::_CastTraits<_matrix<float>,_matrix<float> >::to_storage_type_cref, COMDAT
; ___ref$ = eax

; 254  :   { return __ref; }

	ret	0
?to_storage_type_cref@?$_CastTraits@U?$_matrix@M@@U1@@priv@stlp_std@@SAABU?$_matrix@M@@ABU4@@Z ENDP ; stlp_std::priv::_CastTraits<_matrix<float>,_matrix<float> >::to_storage_type_cref
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?to_value_type_ptr@?$_CastTraits@U?$_matrix@M@@U1@@priv@stlp_std@@SAPAU?$_matrix@M@@PAU4@@Z
_TEXT	SEGMENT
?to_value_type_ptr@?$_CastTraits@U?$_matrix@M@@U1@@priv@stlp_std@@SAPAU?$_matrix@M@@PAU4@@Z PROC ; stlp_std::priv::_CastTraits<_matrix<float>,_matrix<float> >::to_value_type_ptr, COMDAT
; ___ptr$ = eax

; 237  :   { return __ptr; }

	ret	0
?to_value_type_ptr@?$_CastTraits@U?$_matrix@M@@U1@@priv@stlp_std@@SAPAU?$_matrix@M@@PAU4@@Z ENDP ; stlp_std::priv::_CastTraits<_matrix<float>,_matrix<float> >::to_value_type_ptr
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ??1?$_Vector_base@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_base@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAE@XZ PROC ; stlp_std::priv::_Vector_base<_matrix<float>,xalloc<_matrix<float> > >::~_Vector_base<_matrix<float>,xalloc<_matrix<float> > >, COMDAT
; _this$ = eax

; 85   :     if (_M_start != _STLP_DEFAULT_CONSTRUCTED(pointer))

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN6@Vector_bas@7

; 86   :       _M_end_of_storage.deallocate(_M_start, _M_end_of_storage._M_data - _M_start);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN6@Vector_bas@7:

; 87   :   }

	ret	0
??1?$_Vector_base@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAE@XZ ENDP ; stlp_std::priv::_Vector_base<_matrix<float>,xalloc<_matrix<float> > >::~_Vector_base<_matrix<float>,xalloc<_matrix<float> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?empty@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QBE_NXZ PROC ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::empty, COMDAT
; _this$ = eax

; 188  :   bool empty() const            { return this->_M_start == this->_M_finish; }

	mov	ecx, DWORD PTR [eax]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	sete	dl
	mov	al, dl
	ret	0
?empty@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QBE_NXZ ENDP ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::empty
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?rbegin@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAU?$_matrix@M@@@3@XZ
_TEXT	SEGMENT
?rbegin@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAU?$_matrix@M@@@3@XZ PROC ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::rbegin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 175  :   reverse_iterator rbegin()              { return reverse_iterator(end()); }

	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	ret	0
?rbegin@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAU?$_matrix@M@@@3@XZ ENDP ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::rbegin
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAEPAU?$_matrix@M@@XZ
_TEXT	SEGMENT
?begin@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAEPAU?$_matrix@M@@XZ PROC ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::begin, COMDAT
; _this$ = eax

; 170  :   iterator begin()             { return this->_M_start; }

	mov	eax, DWORD PTR [eax]
	ret	0
?begin@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAEPAU?$_matrix@M@@XZ ENDP ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::begin
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ??0?$xalloc@U?$_matrix@M@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@U?$_matrix@M@@@@QAE@XZ PROC			; xalloc<_matrix<float> >::xalloc<_matrix<float> >, COMDAT
; _this$ = eax

; 77   : 													xalloc			()										{	}

	ret	0
??0?$xalloc@U?$_matrix@M@@@@QAE@XZ ENDP			; xalloc<_matrix<float> >::xalloc<_matrix<float> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ?size@?$vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@stlp_std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@stlp_std@@QBEIXZ PROC ; stlp_std::vector<_matrix<float>,xalloc<_matrix<float> > >::size, COMDAT
; _this$ = ecx

; 89   :   size_type size() const        { return _M_impl.size(); }

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 6
	ret	0
?size@?$vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@stlp_std@@QBEIXZ ENDP ; stlp_std::vector<_matrix<float>,xalloc<_matrix<float> > >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?empty@?$vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@stlp_std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@stlp_std@@QBE_NXZ PROC ; stlp_std::vector<_matrix<float>,xalloc<_matrix<float> > >::empty, COMDAT
; _this$ = eax

; 93   :   bool empty() const            { return _M_impl.empty(); }

	mov	ecx, DWORD PTR [eax]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	sete	dl
	mov	al, dl
	ret	0
?empty@?$vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@stlp_std@@QBE_NXZ ENDP ; stlp_std::vector<_matrix<float>,xalloc<_matrix<float> > >::empty
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@stlp_std@@QAEPAU?$_matrix@M@@XZ
_TEXT	SEGMENT
?begin@?$vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@stlp_std@@QAEPAU?$_matrix@M@@XZ PROC ; stlp_std::vector<_matrix<float>,xalloc<_matrix<float> > >::begin, COMDAT
; _this$ = eax

; 79   :   iterator begin()             { return cast_traits::to_value_type_ptr(_M_impl.begin()); }

	mov	eax, DWORD PTR [eax]
	ret	0
?begin@?$vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@stlp_std@@QAEPAU?$_matrix@M@@XZ ENDP ; stlp_std::vector<_matrix<float>,xalloc<_matrix<float> > >::begin
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ??A?$xr_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@@QAEAAU?$_matrix@M@@I@Z
_TEXT	SEGMENT
??A?$xr_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@@QAEAAU?$_matrix@M@@I@Z PROC ; xr_vector<_matrix<float>,xalloc<_matrix<float> > >::operator[], COMDAT
; _this$ = ecx
; __Pos$ = eax

; 139  : 	reference operator[]		(size_type _Pos)					{ {VERIFY2(_Pos<size(),make_string("index is out of range: index requested[%d], size of container[%d]", _Pos, size()).c_str());} return (*(begin() + _Pos)); }

	shl	eax, 6
	add	eax, DWORD PTR [ecx]
	ret	0
??A?$xr_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@@QAEAAU?$_matrix@M@@I@Z ENDP ; xr_vector<_matrix<float>,xalloc<_matrix<float> > >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$xr_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@@QBEIXZ
_TEXT	SEGMENT
?size@?$xr_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@@QBEIXZ PROC ; xr_vector<_matrix<float>,xalloc<_matrix<float> > >::size, COMDAT
; _this$ = ecx

; 126  : 	u32		size				() const							{ return (u32)inherited::size();} 

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 6
	ret	0
?size@?$xr_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@@QBEIXZ ENDP ; xr_vector<_matrix<float>,xalloc<_matrix<float> > >::size
_TEXT	ENDS
PUBLIC	__real@c0400000
PUBLIC	__real@40800000
PUBLIC	__real@c0a00000
PUBLIC	__real@bf800000
PUBLIC	?spline1@@YAXMPAU?$_vector3@M@@0@Z		; spline1
;	COMDAT __real@c0400000
; File d:\clearsky\sources\engine\xrengine\fdemoplay.cpp
CONST	SEGMENT
__real@c0400000 DD 0c0400000r			; -3
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@c0a00000
CONST	SEGMENT
__real@c0a00000 DD 0c0a00000r			; -5
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?spline1@@YAXMPAU?$_vector3@M@@0@Z
_TEXT	SEGMENT
?spline1@@YAXMPAU?$_vector3@M@@0@Z PROC			; spline1, COMDAT
; _t$ = xmm5s
; _p$ = eax
; _ret$ = ecx

; 189  : 	float     t2  = t * t;
; 190  : 	float     t3  = t2 * t;
; 191  : 	float     m[4];
; 192  : 
; 193  : 	ret->x=0.0f;
; 194  : 	ret->y=0.0f;
; 195  : 	ret->z=0.0f;
; 196  : 	m[0] = ( 0.5f * ( (-1.0f * t3) + ( 2.0f * t2) + (-1.0f * t) ) );

	movss	xmm2, DWORD PTR __real@bf800000
	xorps	xmm1, xmm1
	movaps	xmm0, xmm5
	mulss	xmm0, xmm5
	movaps	xmm4, xmm0
	mulss	xmm4, xmm5
	movaps	xmm3, xmm4
	movaps	xmm6, xmm0
	mulss	xmm6, DWORD PTR __real@40000000
	mulss	xmm3, xmm2
	addss	xmm3, xmm6
	movaps	xmm6, xmm5
	mulss	xmm6, xmm2
	movss	xmm2, DWORD PTR __real@3f000000

; 197  : 	m[1] = ( 0.5f * ( ( 3.0f * t3) + (-5.0f * t2) + ( 0.0f * t) + 2.0f ) );

	movaps	xmm7, xmm0
	mulss	xmm7, DWORD PTR __real@c0a00000
	addss	xmm3, xmm6
	movaps	xmm6, xmm5
	mulss	xmm6, xmm1
	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR _drop_angle
	mulss	xmm3, xmm2
	addss	xmm1, xmm7

; 198  : 	m[2] = ( 0.5f * ( (-3.0f * t3) + ( 4.0f * t2) + ( 1.0f * t) ) );

	movaps	xmm7, xmm0

; 199  : 	m[3] = ( 0.5f * ( ( 1.0f * t3) + (-1.0f * t2) + ( 0.0f * t) ) );

	mulss	xmm0, DWORD PTR __real@bf800000
	mulss	xmm7, DWORD PTR __real@40800000
	addss	xmm1, xmm6
	addss	xmm1, DWORD PTR __real@40000000
	mulss	xmm1, xmm2
	movaps	xmm2, xmm4
	mulss	xmm2, DWORD PTR __real@c0400000
	addss	xmm0, xmm6
	addss	xmm0, xmm4

; 200  : 
; 201  : 	for( int i=0; i<4; i++ )
; 202  : 	{
; 203  : 		ret->x += p[i].x * m[i];

	movss	xmm4, DWORD PTR [eax+36]
	addss	xmm2, xmm7
	addss	xmm2, xmm5
	movss	xmm5, DWORD PTR __real@3f000000
	mulss	xmm0, xmm5
	mulss	xmm4, xmm0
	mulss	xmm2, xmm5
	movss	xmm5, DWORD PTR [eax+24]
	mulss	xmm5, xmm2
	addss	xmm4, xmm5
	movss	xmm5, DWORD PTR [eax+12]
	mulss	xmm5, xmm1
	addss	xmm4, xmm5
	movss	xmm5, DWORD PTR [eax]
	mulss	xmm5, xmm3
	addss	xmm4, xmm5

; 204  : 		ret->y += p[i].y * m[i];

	movss	xmm5, DWORD PTR [eax+28]
	movss	DWORD PTR [ecx], xmm4
	movss	xmm4, DWORD PTR [eax+40]
	mulss	xmm4, xmm0
	mulss	xmm5, xmm2
	addss	xmm4, xmm5
	movss	xmm5, DWORD PTR [eax+16]
	mulss	xmm5, xmm1
	addss	xmm4, xmm5
	movss	xmm5, DWORD PTR [eax+4]
	mulss	xmm5, xmm3
	addss	xmm4, xmm5
	movss	DWORD PTR [ecx+4], xmm4

; 205  : 		ret->z += p[i].z * m[i];

	movss	xmm4, DWORD PTR [eax+44]
	mulss	xmm4, xmm0
	movss	xmm0, DWORD PTR [eax+32]
	mulss	xmm0, xmm2
	addss	xmm4, xmm0
	movss	xmm0, DWORD PTR [eax+20]
	mulss	xmm0, xmm1
	addss	xmm4, xmm0
	movss	xmm0, DWORD PTR [eax+8]
	mulss	xmm0, xmm3
	addss	xmm4, xmm0
	movss	DWORD PTR [ecx+8], xmm4

; 206  : 	}
; 207  : }

	ret	0
?spline1@@YAXMPAU?$_vector3@M@@0@Z ENDP			; spline1
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_construct.h
;	COMDAT ??$_Param_Construct@U?$_matrix@M@@U1@@stlp_std@@YAXPAU?$_matrix@M@@ABU1@@Z
_TEXT	SEGMENT
??$_Param_Construct@U?$_matrix@M@@U1@@stlp_std@@YAXPAU?$_matrix@M@@ABU1@@Z PROC ; stlp_std::_Param_Construct<_matrix<float>,_matrix<float> >, COMDAT
; ___p$ = eax
; ___val$ = edx

; 117  : inline void _Param_Construct(_T1* __p, const _T2& __val) {

	push	edi
	mov	edi, eax

; 118  : #if defined (_STLP_DEBUG_UNINITIALIZED)
; 119  :   memset((char*)__p, _STLP_SHRED_BYTE, sizeof(_T1));
; 120  : #endif
; 121  :   _STLP_PLACEMENT_NEW (__p) _T1(__val);

	test	edi, edi
	je	SHORT $LN3@Param_Cons@5
	push	esi
	mov	ecx, 16					; 00000010H
	mov	esi, edx
	rep movsd
	pop	esi
$LN3@Param_Cons@5:
	pop	edi

; 122  : }

	ret	0
??$_Param_Construct@U?$_matrix@M@@U1@@stlp_std@@YAXPAU?$_matrix@M@@ABU1@@Z ENDP ; stlp_std::_Param_Construct<_matrix<float>,_matrix<float> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_uninitialized.h
_TEXT	ENDS
;	COMDAT ??$__ufill@PAU?$_matrix@M@@U1@H@priv@stlp_std@@YAXPAU?$_matrix@M@@0ABU2@ABUrandom_access_iterator_tag@1@PAH@Z
_TEXT	SEGMENT
??$__ufill@PAU?$_matrix@M@@U1@H@priv@stlp_std@@YAXPAU?$_matrix@M@@0ABU2@ABUrandom_access_iterator_tag@1@PAH@Z PROC ; stlp_std::priv::__ufill<_matrix<float> *,_matrix<float>,int>, COMDAT
; ___first$ = edx
; ___last$ = eax
; ___x$ = ebx

; 247  :   _ForwardIter __cur = __first;
; 248  :   _STLP_TRY {
; 249  :     for (_Distance __n = __last - __first; __n > 0; --__n, ++__cur)

	sub	eax, edx
	sar	eax, 6
	test	eax, eax
	jle	SHORT $LN1@ufill@3
	push	esi
	push	edi
	npad	5
$LL3@ufill@3:

; 250  :       _Param_Construct(&*__cur, __x);

	test	edx, edx
	je	SHORT $LN2@ufill@3
	mov	ecx, 16					; 00000010H
	mov	esi, ebx
	mov	edi, edx
	rep movsd
$LN2@ufill@3:
	sub	eax, 1
	add	edx, 64					; 00000040H
	test	eax, eax
	jg	SHORT $LL3@ufill@3
	pop	edi
	pop	esi
$LN1@ufill@3:

; 251  :   }
; 252  :   _STLP_UNWIND(_STLP_STD::_Destroy_Range(__first, __cur))
; 253  : }

	ret	0
??$__ufill@PAU?$_matrix@M@@U1@H@priv@stlp_std@@YAXPAU?$_matrix@M@@0ABU2@ABUrandom_access_iterator_tag@1@PAH@Z ENDP ; stlp_std::priv::__ufill<_matrix<float> *,_matrix<float>,int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$__uninitialized_fill_n@PAU?$_matrix@M@@IU1@@priv@stlp_std@@YAPAU?$_matrix@M@@PAU2@IABU2@@Z
_TEXT	SEGMENT
___x$ = 8						; size = 4
??$__uninitialized_fill_n@PAU?$_matrix@M@@IU1@@priv@stlp_std@@YAPAU?$_matrix@M@@PAU2@IABU2@@Z PROC ; stlp_std::priv::__uninitialized_fill_n<_matrix<float> *,unsigned int,_matrix<float> >, COMDAT
; ___first$ = ecx
; ___n$ = eax

; 313  : inline _ForwardIter __uninitialized_fill_n(_ForwardIter __first, _Size __n, const _Tp& __x) {

	push	ebx
	mov	ebx, ecx

; 314  :   _ForwardIter __last = __first + __n;

	shl	eax, 6
	add	eax, ebx

; 315  :   __ufill(__first, __last, __x, random_access_iterator_tag(), (ptrdiff_t*)0);

	mov	edx, eax
	sub	edx, ebx
	sar	edx, 6
	test	edx, edx
	push	ebp
	mov	ebp, DWORD PTR ___x$[esp+4]
	jle	SHORT $LN3@uninitiali@3
	push	esi
	push	edi
	npad	6
$LL5@uninitiali@3:
	test	ebx, ebx
	je	SHORT $LN4@uninitiali@3
	mov	ecx, 16					; 00000010H
	mov	esi, ebp
	mov	edi, ebx
	rep movsd
$LN4@uninitiali@3:
	sub	edx, 1
	add	ebx, 64					; 00000040H
	test	edx, edx
	jg	SHORT $LL5@uninitiali@3
	pop	edi
	pop	esi
$LN3@uninitiali@3:
	pop	ebp
	pop	ebx

; 316  :   return __last;
; 317  : }

	ret	0
??$__uninitialized_fill_n@PAU?$_matrix@M@@IU1@@priv@stlp_std@@YAPAU?$_matrix@M@@PAU2@IABU2@@Z ENDP ; stlp_std::priv::__uninitialized_fill_n<_matrix<float> *,unsigned int,_matrix<float> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_algobase.h
_TEXT	ENDS
;	COMDAT ??$__copy_backward_ptrs@PAU?$_matrix@M@@PAU1@@priv@stlp_std@@YAPAU?$_matrix@M@@PAU2@00ABU__true_type@1@@Z
_TEXT	SEGMENT
??$__copy_backward_ptrs@PAU?$_matrix@M@@PAU1@@priv@stlp_std@@YAPAU?$_matrix@M@@PAU2@00ABU__true_type@1@@Z PROC ; stlp_std::priv::__copy_backward_ptrs<_matrix<float> *,_matrix<float> *>, COMDAT
; ___first$ = edx
; ___last$ = ecx
; ___result$ = eax

; 294  :   return (_OutputIter)__copy_trivial_backward(__first, __last, __result);

	sub	ecx, edx
	test	ecx, ecx
	jle	SHORT $LN6@copy_backw@18
	push	ecx
	push	edx
	sub	eax, ecx
	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
$LN6@copy_backw@18:

; 295  : }

	ret	0
??$__copy_backward_ptrs@PAU?$_matrix@M@@PAU1@@priv@stlp_std@@YAPAU?$_matrix@M@@PAU2@00ABU__true_type@1@@Z ENDP ; stlp_std::priv::__copy_backward_ptrs<_matrix<float> *,_matrix<float> *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_uninitialized.h
_TEXT	ENDS
;	COMDAT ??$__ucopy_ptrs@PAU?$_matrix@M@@PAU1@@priv@stlp_std@@YAPAU?$_matrix@M@@PAU2@00ABU__true_type@1@@Z
_TEXT	SEGMENT
??$__ucopy_ptrs@PAU?$_matrix@M@@PAU1@@priv@stlp_std@@YAPAU?$_matrix@M@@PAU2@00ABU__true_type@1@@Z PROC ; stlp_std::priv::__ucopy_ptrs<_matrix<float> *,_matrix<float> *>, COMDAT
; ___first$ = ecx
; ___last$ = edx
; ___result$ = eax

; 117  :                                 const __true_type& /*TrivialUCopy*/) {

	push	esi
	mov	esi, edx

; 118  :   // we know they all pointers, so this cast is OK
; 119  :   //  return (_OutputIter)__copy_trivial(&(*__first), &(*__last), &(*__result));
; 120  :   return (_OutputIter)__ucopy_trivial(__first, __last, __result);

	cmp	esi, ecx
	je	SHORT $LN6@ucopy_ptrs@6
	sub	esi, ecx
	push	esi
	push	ecx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	add	eax, esi
$LN6@ucopy_ptrs@6:
	pop	esi

; 121  : }

	ret	0
??$__ucopy_ptrs@PAU?$_matrix@M@@PAU1@@priv@stlp_std@@YAPAU?$_matrix@M@@PAU2@00ABU__true_type@1@@Z ENDP ; stlp_std::priv::__ucopy_ptrs<_matrix<float> *,_matrix<float> *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_construct.h
_TEXT	ENDS
;	COMDAT ??$__destroy_range@V?$reverse_iterator@PAU?$_matrix@M@@@stlp_std@@U?$_matrix@M@@@stlp_std@@YAXV?$reverse_iterator@PAU?$_matrix@M@@@0@0PAU?$_matrix@M@@@Z
_TEXT	SEGMENT
___first$ = 8						; size = 4
___last$ = 12						; size = 4
??$__destroy_range@V?$reverse_iterator@PAU?$_matrix@M@@@stlp_std@@U?$_matrix@M@@@stlp_std@@YAXV?$reverse_iterator@PAU?$_matrix@M@@@0@0PAU?$_matrix@M@@@Z PROC ; stlp_std::__destroy_range<stlp_std::reverse_iterator<_matrix<float> *>,_matrix<float> >, COMDAT

; 175  :   typedef typename __type_traits<_Tp>::has_trivial_destructor _Trivial_destructor;
; 176  :   __destroy_range_aux(__first, __last, __ptr, _Trivial_destructor());
; 177  : }

	ret	0
??$__destroy_range@V?$reverse_iterator@PAU?$_matrix@M@@@stlp_std@@U?$_matrix@M@@@stlp_std@@YAXV?$reverse_iterator@PAU?$_matrix@M@@@0@0PAU?$_matrix@M@@@Z ENDP ; stlp_std::__destroy_range<stlp_std::reverse_iterator<_matrix<float> *>,_matrix<float> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.c
_TEXT	ENDS
;	COMDAT ?_M_throw_length_error@?$_Vector_base@MV?$xalloc@M@@@priv@stlp_std@@IBEXXZ
_TEXT	SEGMENT
?_M_throw_length_error@?$_Vector_base@MV?$xalloc@M@@@priv@stlp_std@@IBEXXZ PROC ; stlp_std::priv::_Vector_base<float,xalloc<float> >::_M_throw_length_error, COMDAT

; 41   :   __stl_throw_length_error("vector");

	push	OFFSET ??_C@_06NBFPPGEG@vector?$AA@
	call	DWORD PTR __imp__puts
	add	esp, 4
	jmp	DWORD PTR __imp__abort
?_M_throw_length_error@?$_Vector_base@MV?$xalloc@M@@@priv@stlp_std@@IBEXXZ ENDP ; stlp_std::priv::_Vector_base<float,xalloc<float> >::_M_throw_length_error
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_algobase.h
_TEXT	ENDS
;	COMDAT ??$__copy_ptrs@PBU?$_matrix@M@@PAU1@@priv@stlp_std@@YAPAU?$_matrix@M@@PBU2@0PAU2@ABU__true_type@1@@Z
_TEXT	SEGMENT
??$__copy_ptrs@PBU?$_matrix@M@@PAU1@@priv@stlp_std@@YAPAU?$_matrix@M@@PBU2@0PAU2@ABU__true_type@1@@Z PROC ; stlp_std::priv::__copy_ptrs<_matrix<float> const *,_matrix<float> *>, COMDAT
; ___first$ = edx
; ___last$ = ecx
; ___result$ = eax

; 255  :   // we know they all pointers, so this cast is OK
; 256  :   //  return (_OutputIter)__copy_trivial(&(*__first), &(*__last), &(*__result));
; 257  :   return (_OutputIter)__copy_trivial(__first, __last, __result);

	sub	ecx, edx
	push	esi
	mov	esi, ecx
	je	SHORT $LN6@copy_ptrs@9
	push	esi
	push	edx
	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	add	eax, esi
$LN6@copy_ptrs@9:
	pop	esi

; 258  : }

	ret	0
??$__copy_ptrs@PBU?$_matrix@M@@PAU1@@priv@stlp_std@@YAPAU?$_matrix@M@@PBU2@0PAU2@ABU__true_type@1@@Z ENDP ; stlp_std::priv::__copy_ptrs<_matrix<float> const *,_matrix<float> *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.c
_TEXT	ENDS
;	COMDAT ?_M_fill_insert_aux@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@AAEXPAU?$_matrix@M@@IABU4@ABU__false_type@3@@Z
_TEXT	SEGMENT
___x_copy$135262 = -68					; size = 64
tv268 = 8						; size = 4
___pos$ = 8						; size = 4
___n$ = 12						; size = 4
$T241021 = 16						; size = 1
___x$ = 16						; size = 4
___formal$ = 20						; size = 4
?_M_fill_insert_aux@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@AAEXPAU?$_matrix@M@@IABU4@ABU__false_type@3@@Z PROC ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::_M_fill_insert_aux, COMDAT
; _this$ = ecx

; 144  :   //Here self referencing needs to be checked even for non movable types.
; 145  :   if (_M_is_inside(__x)) {

	mov	edx, DWORD PTR ___x$[esp-4]
	sub	esp, 68					; 00000044H
	push	ebx
	push	ebp
	mov	ebp, ecx
	cmp	edx, DWORD PTR [ebp]
	push	esi
	push	edi
	jb	SHORT $LN3@M_fill_ins@3
	cmp	edx, DWORD PTR [ebp+4]
	jae	SHORT $LN3@M_fill_ins@3

; 146  :     _Tp __x_copy = __x;

	mov	esi, edx

; 147  :     _M_fill_insert_aux(__pos, __n, __x_copy, __false_type());

	mov	edx, DWORD PTR ___n$[esp+80]
	mov	ecx, 16					; 00000010H
	lea	edi, DWORD PTR ___x_copy$135262[esp+84]
	rep movsd
	lea	eax, DWORD PTR $T241021[esp+80]
	push	eax
	mov	eax, DWORD PTR ___pos$[esp+84]
	lea	ecx, DWORD PTR ___x_copy$135262[esp+88]
	push	ecx
	push	edx
	push	eax
	mov	ecx, ebp
	mov	BYTE PTR $T241021[esp+96], 0
	call	?_M_fill_insert_aux@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@AAEXPAU?$_matrix@M@@IABU4@ABU__false_type@3@@Z ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::_M_fill_insert_aux

; 162  :   }
; 163  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 68					; 00000044H
	ret	16					; 00000010H
$LN3@M_fill_ins@3:

; 148  :     return;
; 149  :   }
; 150  :   const size_type __elems_after = this->_M_finish - __pos;

	mov	ebx, DWORD PTR [ebp+4]
	mov	edi, DWORD PTR ___pos$[esp+80]

; 151  :   pointer __old_finish = this->_M_finish;
; 152  :   if (__elems_after > __n) {

	mov	eax, DWORD PTR ___n$[esp+80]
	mov	esi, ebx
	sub	esi, edi
	sar	esi, 6
	cmp	esi, eax
	jbe	SHORT $LN2@M_fill_ins@3

; 153  :     _STLP_PRIV __ucopy_ptrs(this->_M_finish - __n, this->_M_finish, this->_M_finish, _TrivialUCopy());

	shl	eax, 6
	mov	ecx, eax
	mov	esi, ebx
	sub	esi, ecx
	cmp	ebx, esi
	mov	DWORD PTR tv268[esp+80], ecx
	je	SHORT $LN15@M_fill_ins@3
	mov	ecx, ebx
	sub	ecx, esi
	push	ecx
	push	esi
	push	ebx
	call	_memcpy
	mov	edx, DWORD PTR ___x$[esp+92]
	mov	ecx, DWORD PTR tv268[esp+92]
	add	esp, 12					; 0000000cH
$LN15@M_fill_ins@3:

; 154  :     this->_M_finish += __n;

	add	DWORD PTR [ebp+4], ecx

; 155  :     _STLP_PRIV __copy_backward_ptrs(__pos, __old_finish - __n, __old_finish, _TrivialCopy());

	sub	esi, edi
	test	esi, esi
	jle	SHORT $LN20@M_fill_ins@3
	push	esi
	push	edi
	sub	ebx, esi
	push	ebx
	call	DWORD PTR __imp__memmove
	mov	edx, DWORD PTR ___x$[esp+92]
	mov	ecx, DWORD PTR tv268[esp+92]
	add	esp, 12					; 0000000cH
$LN20@M_fill_ins@3:

; 156  :     _STLP_STD::fill(__pos, __pos + __n, __x);

	lea	ebx, DWORD PTR [ecx+edi]
	cmp	edi, ebx
	mov	eax, edi
	je	SHORT $LN33@M_fill_ins@3
$LL24@M_fill_ins@3:
	mov	edi, eax
	add	eax, 64					; 00000040H
	cmp	eax, ebx
	mov	ecx, 16					; 00000010H
	mov	esi, edx
	rep movsd
	jne	SHORT $LL24@M_fill_ins@3

; 162  :   }
; 163  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 68					; 00000044H
	ret	16					; 00000010H
$LN2@M_fill_ins@3:

; 157  :   } else {
; 158  :     this->_M_finish = _STLP_PRIV __uninitialized_fill_n(this->_M_finish, __n - __elems_after, __x);

	push	edx
	sub	eax, esi
	mov	ecx, ebx
	call	??$__uninitialized_fill_n@PAU?$_matrix@M@@IU1@@priv@stlp_std@@YAPAU?$_matrix@M@@PAU2@IABU2@@Z ; stlp_std::priv::__uninitialized_fill_n<_matrix<float> *,unsigned int,_matrix<float> >
	add	esp, 4

; 159  :     _STLP_PRIV __ucopy_ptrs(__pos, __old_finish, this->_M_finish, _TrivialUCopy());

	cmp	ebx, edi
	mov	DWORD PTR [ebp+4], eax
	je	SHORT $LN32@M_fill_ins@3
	mov	edx, ebx
	sub	edx, edi
	push	edx
	push	edi
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN32@M_fill_ins@3:

; 160  :     this->_M_finish += __elems_after;

	shl	esi, 6
	add	DWORD PTR [ebp+4], esi

; 161  :     _STLP_STD::fill(__pos, __old_finish, __x);

	cmp	edi, ebx
	mov	eax, edi
	je	SHORT $LN33@M_fill_ins@3
	npad	1
$LL35@M_fill_ins@3:
	mov	esi, DWORD PTR ___x$[esp+80]
	mov	edi, eax
	add	eax, 64					; 00000040H
	cmp	eax, ebx
	mov	ecx, 16					; 00000010H
	rep movsd
	jne	SHORT $LL35@M_fill_ins@3
$LN33@M_fill_ins@3:

; 162  :   }
; 163  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 68					; 00000044H
	ret	16					; 00000010H
?_M_fill_insert_aux@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@AAEXPAU?$_matrix@M@@IABU4@ABU__false_type@3@@Z ENDP ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::_M_fill_insert_aux
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_algobase.h
_TEXT	ENDS
;	COMDAT ??$__copy_ptrs@PAU?$_matrix@M@@PAU1@@priv@stlp_std@@YAPAU?$_matrix@M@@PAU2@00ABU__true_type@1@@Z
_TEXT	SEGMENT
??$__copy_ptrs@PAU?$_matrix@M@@PAU1@@priv@stlp_std@@YAPAU?$_matrix@M@@PAU2@00ABU__true_type@1@@Z PROC ; stlp_std::priv::__copy_ptrs<_matrix<float> *,_matrix<float> *>, COMDAT
; ___first$ = edx
; ___last$ = ecx
; ___result$ = eax

; 255  :   // we know they all pointers, so this cast is OK
; 256  :   //  return (_OutputIter)__copy_trivial(&(*__first), &(*__last), &(*__result));
; 257  :   return (_OutputIter)__copy_trivial(__first, __last, __result);

	sub	ecx, edx
	push	esi
	mov	esi, ecx
	je	SHORT $LN6@copy_ptrs@10
	push	esi
	push	edx
	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	add	eax, esi
$LN6@copy_ptrs@10:
	pop	esi

; 258  : }

	ret	0
??$__copy_ptrs@PAU?$_matrix@M@@PAU1@@priv@stlp_std@@YAPAU?$_matrix@M@@PAU2@00ABU__true_type@1@@Z ENDP ; stlp_std::priv::__copy_ptrs<_matrix<float> *,_matrix<float> *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_uninitialized.h
_TEXT	ENDS
;	COMDAT ??$__ucopy_ptrs@PBU?$_matrix@M@@PAU1@@priv@stlp_std@@YAPAU?$_matrix@M@@PBU2@0PAU2@ABU__true_type@1@@Z
_TEXT	SEGMENT
??$__ucopy_ptrs@PBU?$_matrix@M@@PAU1@@priv@stlp_std@@YAPAU?$_matrix@M@@PBU2@0PAU2@ABU__true_type@1@@Z PROC ; stlp_std::priv::__ucopy_ptrs<_matrix<float> const *,_matrix<float> *>, COMDAT
; ___first$ = ecx
; ___last$ = edx
; ___result$ = eax

; 117  :                                 const __true_type& /*TrivialUCopy*/) {

	push	esi
	mov	esi, edx

; 118  :   // we know they all pointers, so this cast is OK
; 119  :   //  return (_OutputIter)__copy_trivial(&(*__first), &(*__last), &(*__result));
; 120  :   return (_OutputIter)__ucopy_trivial(__first, __last, __result);

	cmp	esi, ecx
	je	SHORT $LN6@ucopy_ptrs@7
	sub	esi, ecx
	push	esi
	push	ecx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	add	eax, esi
$LN6@ucopy_ptrs@7:
	pop	esi

; 121  : }

	ret	0
??$__ucopy_ptrs@PBU?$_matrix@M@@PAU1@@priv@stlp_std@@YAPAU?$_matrix@M@@PBU2@0PAU2@ABU__true_type@1@@Z ENDP ; stlp_std::priv::__ucopy_ptrs<_matrix<float> const *,_matrix<float> *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_construct.h
_TEXT	ENDS
;	COMDAT ??$_Copy_Construct@M@stlp_std@@YAXPAMABM@Z
_TEXT	SEGMENT
??$_Copy_Construct@M@stlp_std@@YAXPAMABM@Z PROC		; stlp_std::_Copy_Construct<float>, COMDAT
; ___p$ = eax
; ___val$ = ecx

; 110  : #if defined (_STLP_DEBUG_UNINITIALIZED)
; 111  :   memset((char*)__p, _STLP_SHRED_BYTE, sizeof(_Tp));
; 112  : #endif
; 113  :   _STLP_PLACEMENT_NEW (__p) _Tp(__val);

	test	eax, eax
	je	SHORT $LN3@Copy_Const@7
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]
$LN3@Copy_Const@7:

; 114  : }

	ret	0
??$_Copy_Construct@M@stlp_std@@YAXPAMABM@Z ENDP		; stlp_std::_Copy_Construct<float>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_Range@V?$reverse_iterator@PAU?$_matrix@M@@@stlp_std@@@stlp_std@@YAXV?$reverse_iterator@PAU?$_matrix@M@@@0@0@Z
_TEXT	SEGMENT
___first$ = 8						; size = 4
___last$ = 12						; size = 4
??$_Destroy_Range@V?$reverse_iterator@PAU?$_matrix@M@@@stlp_std@@@stlp_std@@YAXV?$reverse_iterator@PAU?$_matrix@M@@@0@0@Z PROC ; stlp_std::_Destroy_Range<stlp_std::reverse_iterator<_matrix<float> *> >, COMDAT

; 181  :   __destroy_range(__first, __last, _STLP_VALUE_TYPE(__first, _ForwardIterator));
; 182  : }

	ret	0
??$_Destroy_Range@V?$reverse_iterator@PAU?$_matrix@M@@@stlp_std@@@stlp_std@@YAXV?$reverse_iterator@PAU?$_matrix@M@@@0@0@Z ENDP ; stlp_std::_Destroy_Range<stlp_std::reverse_iterator<_matrix<float> *> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\xrmemory_subst_msvc.h
_TEXT	ENDS
;	COMDAT ??$xr_new@USAnimParams@@@@YAPAUSAnimParams@@XZ
_TEXT	SEGMENT
??$xr_new@USAnimParams@@@@YAPAUSAnimParams@@XZ PROC	; xr_new<SAnimParams>, COMDAT

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	24					; 00000018H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 69   : 	return new (ptr) T();

	xor	ecx, ecx
	cmp	eax, ecx
	je	SHORT $LN3@xr_new@4
	xorps	xmm0, xmm0
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+16], ecx
	movss	DWORD PTR [eax], xmm0
	movss	DWORD PTR [eax+8], xmm0
	movss	DWORD PTR [eax+12], xmm0
	movss	DWORD PTR [eax+4], xmm0

; 70   : }

	ret	0
$LN3@xr_new@4:

; 69   : 	return new (ptr) T();

	xor	eax, eax

; 70   : }

	ret	0
??$xr_new@USAnimParams@@@@YAPAUSAnimParams@@XZ ENDP	; xr_new<SAnimParams>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_alloc.h
_TEXT	ENDS
;	COMDAT ??0?$_STLP_alloc_proxy@PAU?$_matrix@M@@U1@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAE@ABV?$xalloc@U?$_matrix@M@@@@PAU?$_matrix@M@@@Z
_TEXT	SEGMENT
??0?$_STLP_alloc_proxy@PAU?$_matrix@M@@U1@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAE@ABV?$xalloc@U?$_matrix@M@@@@PAU?$_matrix@M@@@Z PROC ; stlp_std::priv::_STLP_alloc_proxy<_matrix<float> *,_matrix<float>,xalloc<_matrix<float> > >::_STLP_alloc_proxy<_matrix<float> *,_matrix<float>,xalloc<_matrix<float> > >, COMDAT
; _this$ = eax

; 571  :     _MaybeReboundAlloc(__a), _M_data(__p) {}

	mov	DWORD PTR [eax], 0
	ret	0
??0?$_STLP_alloc_proxy@PAU?$_matrix@M@@U1@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAE@ABV?$xalloc@U?$_matrix@M@@@@PAU?$_matrix@M@@@Z ENDP ; stlp_std::priv::_STLP_alloc_proxy<_matrix<float> *,_matrix<float>,xalloc<_matrix<float> > >::_STLP_alloc_proxy<_matrix<float> *,_matrix<float>,xalloc<_matrix<float> > >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ??0?$_Vector_base@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAE@ABV?$xalloc@U?$_matrix@M@@@@@Z
_TEXT	SEGMENT
??0?$_Vector_base@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAE@ABV?$xalloc@U?$_matrix@M@@@@@Z PROC ; stlp_std::priv::_Vector_base<_matrix<float>,xalloc<_matrix<float> > >::_Vector_base<_matrix<float>,xalloc<_matrix<float> > >, COMDAT
; _this$ = eax

; 67   :     : _M_start(0), _M_finish(0), _M_end_of_storage(__a, 0) {}

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$_Vector_base@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAE@ABV?$xalloc@U?$_matrix@M@@@@@Z ENDP ; stlp_std::priv::_Vector_base<_matrix<float>,xalloc<_matrix<float> > >::_Vector_base<_matrix<float>,xalloc<_matrix<float> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_M_erase@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@AAEPAU?$_matrix@M@@PAU4@0ABU__false_type@3@@Z
_TEXT	SEGMENT
?_M_erase@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@AAEPAU?$_matrix@M@@PAU4@0ABU__false_type@3@@Z PROC ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::_M_erase, COMDAT
; _this$ = ebx
; ___first$ = edi
; ___last$ = eax

; 578  :   iterator _M_erase(iterator __first, iterator __last, const __false_type& /*_Movable*/) {

	push	esi

; 579  :     pointer __i = _STLP_PRIV __copy_ptrs(__last, this->_M_finish, __first, _TrivialCopy());

	mov	esi, DWORD PTR [ebx+4]
	sub	esi, eax
	je	SHORT $LN7@M_erase@8
	push	esi
	push	eax
	push	edi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	add	eax, esi

; 580  :     _STLP_STD::_Destroy_Range(__i, this->_M_finish);
; 581  :     this->_M_finish = __i;

	mov	DWORD PTR [ebx+4], eax

; 582  :     return __first;

	mov	eax, edi
	pop	esi

; 583  :   }

	ret	0

; 579  :     pointer __i = _STLP_PRIV __copy_ptrs(__last, this->_M_finish, __first, _TrivialCopy());

$LN7@M_erase@8:

; 580  :     _STLP_STD::_Destroy_Range(__i, this->_M_finish);
; 581  :     this->_M_finish = __i;

	mov	DWORD PTR [ebx+4], edi

; 582  :     return __first;

	mov	eax, edi
	pop	esi

; 583  :   }

	ret	0
?_M_erase@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@AAEPAU?$_matrix@M@@PAU4@0ABU__false_type@3@@Z ENDP ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::_M_erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_base@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAE@IABV?$xalloc@U?$_matrix@M@@@@@Z
_TEXT	SEGMENT
??0?$_Vector_base@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAE@IABV?$xalloc@U?$_matrix@M@@@@@Z PROC ; stlp_std::priv::_Vector_base<_matrix<float>,xalloc<_matrix<float> > >::_Vector_base<_matrix<float>,xalloc<_matrix<float> > >, COMDAT
; _this$ = esi
; ___n$ = eax

; 70   :     : _M_start(0), _M_finish(0), _M_end_of_storage(__a, 0) {

	xor	ecx, ecx
	push	edi

; 71   :     _M_start = _M_end_of_storage.allocate(__n, __n);

	shl	eax, 6
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [esi+4], ecx
	mov	edi, eax
	mov	DWORD PTR [esi+8], ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 72   :     _M_finish = _M_start;
; 73   :     _M_end_of_storage._M_data = _M_start + __n;

	add	edi, eax
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], edi

; 74   :     _STLP_MPWFIX_TRY _STLP_MPWFIX_CATCH
; 75   :   }

	mov	eax, esi
	pop	edi
	ret	0
??0?$_Vector_base@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAE@IABV?$xalloc@U?$_matrix@M@@@@@Z ENDP ; stlp_std::priv::_Vector_base<_matrix<float>,xalloc<_matrix<float> > >::_Vector_base<_matrix<float>,xalloc<_matrix<float> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?erase@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAEPAU?$_matrix@M@@PAU4@0@Z
_TEXT	SEGMENT
?erase@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAEPAU?$_matrix@M@@PAU4@0@Z PROC ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::erase, COMDAT
; _this$ = ebx
; ___first$ = edi
; ___last$ = eax

; 590  :     if (__first == __last)

	cmp	edi, eax

; 591  :       return __first;

	je	SHORT $LN12@erase@7
	push	esi

; 592  :     return _M_erase(__first, __last, _Movable());

	mov	esi, DWORD PTR [ebx+4]
	sub	esi, eax
	je	SHORT $LN10@erase@7
	push	esi
	push	eax
	push	edi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	add	eax, esi
	mov	DWORD PTR [ebx+4], eax
	pop	esi
	mov	eax, edi

; 593  :   }

	ret	0

; 592  :     return _M_erase(__first, __last, _Movable());

$LN10@erase@7:
	mov	eax, edi
	mov	DWORD PTR [ebx+4], eax
	pop	esi
$LN12@erase@7:
	mov	eax, edi

; 593  :   }

	ret	0
?erase@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAEPAU?$_matrix@M@@PAU4@0@Z ENDP ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAE@ABV?$xalloc@U?$_matrix@M@@@@@Z
_TEXT	SEGMENT
??0?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAE@ABV?$xalloc@U?$_matrix@M@@@@@Z PROC ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >, COMDAT
; _this$ = eax

; 208  :     : _STLP_PRIV _Vector_base<_Tp, _Alloc>(__a) {}

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAE@ABV?$xalloc@U?$_matrix@M@@@@@Z ENDP ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAE@ABV012@@Z
_TEXT	SEGMENT
??0?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAE@ABV012@@Z PROC ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >, COMDAT
; _this$ = esi
; ___x$ = eax

; 236  :   { this->_M_finish = _STLP_PRIV __ucopy_ptrs(__x.begin(), __x.end(), this->_M_start, _TrivialUCopy()); }

	push	ebx
	push	edi
	mov	edi, eax
	mov	eax, DWORD PTR [edi+4]
	sub	eax, DWORD PTR [edi]
	xor	ecx, ecx
	sar	eax, 6
	shl	eax, 6
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [esi+4], ecx
	mov	ebx, eax
	mov	DWORD PTR [esi+8], ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	ebx
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	add	ebx, eax
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], ebx
	mov	ebx, DWORD PTR [edi+4]
	mov	edi, DWORD PTR [edi]
	cmp	ebx, edi
	je	SHORT $LN35@Impl_vecto@4
	sub	ebx, edi
	push	ebx
	push	edi
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	add	eax, ebx
$LN35@Impl_vecto@4:
	pop	edi
	mov	DWORD PTR [esi+4], eax
	mov	eax, esi
	pop	ebx
	ret	0
??0?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAE@ABV012@@Z ENDP ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?rend@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAU?$_matrix@M@@@3@XZ
_TEXT	SEGMENT
?rend@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAU?$_matrix@M@@@3@XZ PROC ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::rend, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 177  :   reverse_iterator rend()                { return reverse_iterator(begin()); }

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	ret	0
?rend@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAE?AV?$reverse_iterator@PAU?$_matrix@M@@@3@XZ ENDP ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::rend
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ?size@?$vector@MV?$xalloc@M@@@stlp_std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@MV?$xalloc@M@@@stlp_std@@QBEIXZ PROC	; stlp_std::vector<float,xalloc<float> >::size, COMDAT
; _this$ = ecx

; 89   :   size_type size() const        { return _M_impl.size(); }

	jmp	?size@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@QBEIXZ ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::size
?size@?$vector@MV?$xalloc@M@@@stlp_std@@QBEIXZ ENDP	; stlp_std::vector<float,xalloc<float> >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@MV?$xalloc@M@@@stlp_std@@QAEPAMXZ
_TEXT	SEGMENT
?begin@?$vector@MV?$xalloc@M@@@stlp_std@@QAEPAMXZ PROC	; stlp_std::vector<float,xalloc<float> >::begin, COMDAT
; _this$ = ecx

; 79   :   iterator begin()             { return cast_traits::to_value_type_ptr(_M_impl.begin()); }

	jmp	?begin@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@QAEPAMXZ ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::begin
?begin@?$vector@MV?$xalloc@M@@@stlp_std@@QAEPAMXZ ENDP	; stlp_std::vector<float,xalloc<float> >::begin
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ??1?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAE@XZ PROC ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::~_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >, COMDAT
; _this$ = eax

; 286  :   ~vector() { _STLP_STD::_Destroy_Range(rbegin(), rend()); }

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN34@Impl_vecto@5
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN34@Impl_vecto@5:
	ret	0
??1?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAE@XZ ENDP ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::~_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ??0?$vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@stlp_std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@stlp_std@@QAE@ABV01@@Z PROC ; stlp_std::vector<_matrix<float>,xalloc<_matrix<float> > >::vector<_matrix<float>,xalloc<_matrix<float> > >, COMDAT
; _this$ = esi
; ___x$ = eax

; 123  :   vector(const _Self& __x)

	push	ebx
	push	edi
	mov	edi, eax
	mov	eax, DWORD PTR [edi+4]
	sub	eax, DWORD PTR [edi]
	xor	ecx, ecx
	sar	eax, 6
	shl	eax, 6
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [esi+4], ecx
	mov	ebx, eax
	mov	DWORD PTR [esi+8], ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	ebx
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	add	ebx, eax
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], ebx
	mov	ebx, DWORD PTR [edi+4]
	mov	edi, DWORD PTR [edi]
	cmp	ebx, edi
	je	SHORT $LN37@vector@6
	sub	ebx, edi
	push	ebx
	push	edi
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	add	eax, ebx
$LN37@vector@6:
	pop	edi
	mov	DWORD PTR [esi+4], eax
	mov	eax, esi
	pop	ebx
	ret	0
??0?$vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@stlp_std@@QAE@ABV01@@Z ENDP ; stlp_std::vector<_matrix<float>,xalloc<_matrix<float> > >::vector<_matrix<float>,xalloc<_matrix<float> > >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ??A?$xr_vector@MV?$xalloc@M@@@@QAEAAMI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$xr_vector@MV?$xalloc@M@@@@QAEAAMI@Z PROC		; xr_vector<float,xalloc<float> >::operator[], COMDAT
; _this$ = ecx

; 139  : 	reference operator[]		(size_type _Pos)					{ {VERIFY2(_Pos<size(),make_string("index is out of range: index requested[%d], size of container[%d]", _Pos, size()).c_str());} return (*(begin() + _Pos)); }

	call	?begin@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@QAEPAMXZ ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::begin
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]
	ret	4
??A?$xr_vector@MV?$xalloc@M@@@@QAEAAMI@Z ENDP		; xr_vector<float,xalloc<float> >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$xr_vector@MV?$xalloc@M@@@@QBEIXZ
_TEXT	SEGMENT
?size@?$xr_vector@MV?$xalloc@M@@@@QBEIXZ PROC		; xr_vector<float,xalloc<float> >::size, COMDAT
; _this$ = ecx

; 126  : 	u32		size				() const							{ return (u32)inherited::size();} 

	jmp	?size@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@QBEIXZ ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::size
?size@?$xr_vector@MV?$xalloc@M@@@@QBEIXZ ENDP		; xr_vector<float,xalloc<float> >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@stlp_std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@stlp_std@@QAE@XZ PROC ; stlp_std::vector<_matrix<float>,xalloc<_matrix<float> > >::~vector<_matrix<float>,xalloc<_matrix<float> > >, COMDAT
; _this$ = eax
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN36@vector@7
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN36@vector@7:
	ret	0
??1?$vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@stlp_std@@QAE@XZ ENDP ; stlp_std::vector<_matrix<float>,xalloc<_matrix<float> > >::~vector<_matrix<float>,xalloc<_matrix<float> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$xr_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@@QAE@XZ PROC ; xr_vector<_matrix<float>,xalloc<_matrix<float> > >::~xr_vector<_matrix<float>,xalloc<_matrix<float> > >, COMDAT
; _this$ = eax
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN38@xr_vector@3
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN38@xr_vector@3:
	ret	0
??1?$xr_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@@QAE@XZ ENDP ; xr_vector<_matrix<float>,xalloc<_matrix<float> > >::~xr_vector<_matrix<float>,xalloc<_matrix<float> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$xr_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
??0?$xr_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@@QAE@ABV0@@Z PROC ; xr_vector<_matrix<float>,xalloc<_matrix<float> > >::xr_vector<_matrix<float>,xalloc<_matrix<float> > >, COMDAT
; _this$ = esi
; ___that$ = eax
	push	ebx
	push	edi
	mov	edi, eax
	mov	eax, DWORD PTR [edi+4]
	sub	eax, DWORD PTR [edi]
	xor	ecx, ecx
	sar	eax, 6
	shl	eax, 6
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [esi+4], ecx
	mov	ebx, eax
	mov	DWORD PTR [esi+8], ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	ebx
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	add	ebx, eax
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], ebx
	mov	ebx, DWORD PTR [edi+4]
	mov	edi, DWORD PTR [edi]
	cmp	ebx, edi
	je	SHORT $LN39@xr_vector@4
	sub	ebx, edi
	push	ebx
	push	edi
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	add	eax, ebx
$LN39@xr_vector@4:
	pop	edi
	mov	DWORD PTR [esi+4], eax
	mov	eax, esi
	pop	ebx
	ret	0
??0?$xr_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@@QAE@ABV0@@Z ENDP ; xr_vector<_matrix<float>,xalloc<_matrix<float> > >::xr_vector<_matrix<float>,xalloc<_matrix<float> > >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_uninitialized.h
;	COMDAT ??$__ucopy_aux@PAMPAM@priv@stlp_std@@YAPAMPAM00ABU__true_type@1@@Z
_TEXT	SEGMENT
??$__ucopy_aux@PAMPAM@priv@stlp_std@@YAPAMPAM00ABU__true_type@1@@Z PROC ; stlp_std::priv::__ucopy_aux<float *,float *>, COMDAT
; ___first$ = edi
; ___last$ = eax
; ___result$ = ebx

; 125  :                                const __true_type& /*BothPtrType*/) {

	push	esi

; 126  :   return __ucopy_ptrs(__first, __last, __result,
; 127  :                       _UseTrivialUCopy(_STLP_VALUE_TYPE(__first, _InputIter),
; 128  :                                        _STLP_VALUE_TYPE(__result, _OutputIter))._Answer());

	push	0
	push	0
	mov	esi, eax
	call	??$_UseTrivialUCopy@MM@stlp_std@@YA?AU?$_TrivialUCopy@MM@0@PAM0@Z ; stlp_std::_UseTrivialUCopy<float,float>
	add	esp, 8
	call	?_Answer@?$_TrivialUCopy@MM@stlp_std@@SA?AU__true_type@2@XZ ; stlp_std::_TrivialUCopy<float,float>::_Answer
	cmp	esi, edi
	jne	SHORT $LN11@ucopy_aux@5
	mov	eax, ebx
	pop	esi

; 129  : }

	ret	0

; 126  :   return __ucopy_ptrs(__first, __last, __result,
; 127  :                       _UseTrivialUCopy(_STLP_VALUE_TYPE(__first, _InputIter),
; 128  :                                        _STLP_VALUE_TYPE(__result, _OutputIter))._Answer());

$LN11@ucopy_aux@5:
	sub	esi, edi
	push	esi
	push	edi
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
	add	eax, esi
	pop	esi

; 129  : }

	ret	0
??$__ucopy_aux@PAMPAM@priv@stlp_std@@YAPAMPAM00ABU__true_type@1@@Z ENDP ; stlp_std::priv::__ucopy_aux<float *,float *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$__ucopy_aux@PBU?$_matrix@M@@PAU1@@priv@stlp_std@@YAPAU?$_matrix@M@@PBU2@0PAU2@ABU__true_type@1@@Z
_TEXT	SEGMENT
??$__ucopy_aux@PBU?$_matrix@M@@PAU1@@priv@stlp_std@@YAPAU?$_matrix@M@@PBU2@0PAU2@ABU__true_type@1@@Z PROC ; stlp_std::priv::__ucopy_aux<_matrix<float> const *,_matrix<float> *>, COMDAT
; ___first$ = ecx
; ___last$ = edx
; ___result$ = eax

; 125  :                                const __true_type& /*BothPtrType*/) {

	push	esi
	mov	esi, edx

; 126  :   return __ucopy_ptrs(__first, __last, __result,
; 127  :                       _UseTrivialUCopy(_STLP_VALUE_TYPE(__first, _InputIter),
; 128  :                                        _STLP_VALUE_TYPE(__result, _OutputIter))._Answer());

	cmp	esi, ecx
	je	SHORT $LN12@ucopy_aux@6
	sub	esi, ecx
	push	esi
	push	ecx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	add	eax, esi
$LN12@ucopy_aux@6:
	pop	esi

; 129  : }

	ret	0
??$__ucopy_aux@PBU?$_matrix@M@@PAU1@@priv@stlp_std@@YAPAU?$_matrix@M@@PBU2@0PAU2@ABU__true_type@1@@Z ENDP ; stlp_std::priv::__ucopy_aux<_matrix<float> const *,_matrix<float> *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$uninitialized_copy@PAMPAM@stlp_std@@YAPAMPAM00@Z
_TEXT	SEGMENT
??$uninitialized_copy@PAMPAM@stlp_std@@YAPAMPAM00@Z PROC ; stlp_std::uninitialized_copy<float *,float *>, COMDAT
; ___first$ = edi
; ___last$ = eax
; ___result$ = ebx

; 144  : { return _STLP_PRIV __ucopy_aux(__first, __last, __result, _BothPtrType< _InputIter, _ForwardIter>::_Answer()); }

	push	esi
	push	0
	push	0
	mov	esi, eax
	call	??$_UseTrivialUCopy@MM@stlp_std@@YA?AU?$_TrivialUCopy@MM@0@PAM0@Z ; stlp_std::_UseTrivialUCopy<float,float>
	add	esp, 8
	call	?_Answer@?$_TrivialUCopy@MM@stlp_std@@SA?AU__true_type@2@XZ ; stlp_std::_TrivialUCopy<float,float>::_Answer
	cmp	esi, edi
	jne	SHORT $LN15@uninitiali@12
	mov	eax, ebx
	pop	esi
	ret	0
$LN15@uninitiali@12:
	sub	esi, edi
	push	esi
	push	edi
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
	add	eax, esi
	pop	esi
	ret	0
??$uninitialized_copy@PAMPAM@stlp_std@@YAPAMPAM00@Z ENDP ; stlp_std::uninitialized_copy<float *,float *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$uninitialized_copy@PBU?$_matrix@M@@PAU1@@stlp_std@@YAPAU?$_matrix@M@@PBU1@0PAU1@@Z
_TEXT	SEGMENT
??$uninitialized_copy@PBU?$_matrix@M@@PAU1@@stlp_std@@YAPAU?$_matrix@M@@PBU1@0PAU1@@Z PROC ; stlp_std::uninitialized_copy<_matrix<float> const *,_matrix<float> *>, COMDAT
; ___first$ = ecx
; ___last$ = edx
; ___result$ = eax

; 144  : { return _STLP_PRIV __ucopy_aux(__first, __last, __result, _BothPtrType< _InputIter, _ForwardIter>::_Answer()); }

	push	esi
	mov	esi, edx
	cmp	esi, ecx
	je	SHORT $LN16@uninitiali@13
	sub	esi, ecx
	push	esi
	push	ecx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	add	eax, esi
$LN16@uninitiali@13:
	pop	esi
	ret	0
??$uninitialized_copy@PBU?$_matrix@M@@PAU1@@stlp_std@@YAPAU?$_matrix@M@@PBU1@0PAU1@@Z ENDP ; stlp_std::uninitialized_copy<_matrix<float> const *,_matrix<float> *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ??$_M_allocate_and_copy@PAM@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@AAEPAMAAIPAM1@Z
_TEXT	SEGMENT
___last$ = 8						; size = 4
??$_M_allocate_and_copy@PAM@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@AAEPAMAAIPAM1@Z PROC ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::_M_allocate_and_copy<float *>, COMDAT
; _this$ = ecx
; ___n$ = eax
; ___first$ = ebx

; 633  :   pointer _M_allocate_and_copy(size_type& __n,

	push	esi
	mov	esi, DWORD PTR ___last$[esp]
	push	edi

; 634  :                                _ForwardIterator __first, _ForwardIterator __last)
; 635  : #else /* _STLP_MEMBER_TEMPLATES */
; 636  :   pointer _M_allocate_and_copy(size_type& __n,
; 637  :                                const_pointer __first, const_pointer __last)
; 638  : #endif /* _STLP_MEMBER_TEMPLATES */
; 639  :   {
; 640  :     pointer __result = this->_M_end_of_storage.allocate(__n, __n);

	push	eax
	mov	eax, DWORD PTR [eax]
	push	eax
	add	ecx, 8
	call	?allocate@?$_STLP_alloc_proxy@PAMMV?$xalloc@M@@@priv@stlp_std@@QAEPAMIAAI@Z ; stlp_std::priv::_STLP_alloc_proxy<float *,float,xalloc<float> >::allocate

; 641  :     _STLP_TRY {
; 642  :       uninitialized_copy(__first, __last, __result);

	push	0
	push	0
	mov	edi, eax
	call	??$_UseTrivialUCopy@MM@stlp_std@@YA?AU?$_TrivialUCopy@MM@0@PAM0@Z ; stlp_std::_UseTrivialUCopy<float,float>
	add	esp, 8
	call	?_Answer@?$_TrivialUCopy@MM@stlp_std@@SA?AU__true_type@2@XZ ; stlp_std::_TrivialUCopy<float,float>::_Answer
	cmp	esi, ebx
	je	SHORT $LN29@M_allocate@5
	sub	esi, ebx
	push	esi
	push	ebx
	push	edi
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN29@M_allocate@5:

; 643  :       return __result;

	mov	eax, edi
	pop	edi
	pop	esi

; 644  :     }
; 645  :     _STLP_UNWIND(this->_M_end_of_storage.deallocate(__result, __n))
; 646  :     _STLP_RET_AFTER_THROW(__result)
; 647  :   }

	ret	4
??$_M_allocate_and_copy@PAM@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@AAEPAMAAIPAM1@Z ENDP ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::_M_allocate_and_copy<float *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_M_allocate_and_copy@PBU?$_matrix@M@@@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@AAEPAU?$_matrix@M@@AAIPBU3@1@Z
_TEXT	SEGMENT
??$_M_allocate_and_copy@PBU?$_matrix@M@@@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@AAEPAU?$_matrix@M@@AAIPBU3@1@Z PROC ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::_M_allocate_and_copy<_matrix<float> const *>, COMDAT
; ___n$ = eax
; ___first$ = ebx
; ___last$ = ecx

; 634  :                                _ForwardIterator __first, _ForwardIterator __last)
; 635  : #else /* _STLP_MEMBER_TEMPLATES */
; 636  :   pointer _M_allocate_and_copy(size_type& __n,
; 637  :                                const_pointer __first, const_pointer __last)
; 638  : #endif /* _STLP_MEMBER_TEMPLATES */
; 639  :   {
; 640  :     pointer __result = this->_M_end_of_storage.allocate(__n, __n);

	mov	eax, DWORD PTR [eax]
	push	esi
	push	edi
	shl	eax, 6
	mov	esi, ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 641  :     _STLP_TRY {
; 642  :       uninitialized_copy(__first, __last, __result);

	cmp	esi, ebx
	mov	edi, eax
	je	SHORT $LN28@M_allocate@6
	sub	esi, ebx
	push	esi
	push	ebx
	push	edi
	call	_memcpy
	add	esp, 12					; 0000000cH

; 643  :       return __result;

	mov	eax, edi
$LN28@M_allocate@6:
	pop	edi
	pop	esi

; 644  :     }
; 645  :     _STLP_UNWIND(this->_M_end_of_storage.deallocate(__result, __n))
; 646  :     _STLP_RET_AFTER_THROW(__result)
; 647  :   }

	ret	0
??$_M_allocate_and_copy@PBU?$_matrix@M@@@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@AAEPAU?$_matrix@M@@AAIPBU3@1@Z ENDP ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::_M_allocate_and_copy<_matrix<float> const *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_M_clear@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@AAEXXZ
_TEXT	SEGMENT
?_M_clear@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@AAEXXZ PROC ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::_M_clear, COMDAT
; _this$ = eax

; 616  :     _STLP_STD::_Destroy_Range(rbegin(), rend());
; 617  :     this->_M_end_of_storage.deallocate(this->_M_start, this->_M_end_of_storage._M_data - this->_M_start);

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN31@M_clear@5
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN31@M_clear@5:

; 618  :   }

	ret	0
?_M_clear@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@AAEXXZ ENDP ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::_M_clear
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.c
_TEXT	ENDS
;	COMDAT ??4?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z
_TEXT	SEGMENT
tv420 = 8						; size = 4
_this$ = 8						; size = 4
___result$295004 = 12					; size = 4
___x$ = 12						; size = 4
??4?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z PROC ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::operator=, COMDAT

; 178  :   if (&__x != this) {

	mov	ecx, DWORD PTR ___x$[esp-4]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _this$[esp+4]
	cmp	ecx, ebp
	push	esi
	push	edi
	je	$LN97@operator@45

; 179  :     const size_type __xlen = __x.size();

	mov	ebx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [ecx]

; 180  :     if (__xlen > capacity()) {

	mov	edx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [ebp+8]
	mov	edi, ebx
	sub	edi, esi
	sub	eax, edx
	sar	edi, 6
	sar	eax, 6
	cmp	edi, eax
	jbe	SHORT $LN4@operator@45

; 181  :       size_type __len = __xlen;
; 182  :       pointer __tmp = _M_allocate_and_copy(__len, __CONST_CAST(const_pointer, __x._M_start) + 0,
; 183  :                                                   __CONST_CAST(const_pointer, __x._M_finish) + 0);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	eax, edi
	shl	eax, 6
	push	eax
	mov	DWORD PTR tv420[esp+16], eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	cmp	ebx, esi
	mov	DWORD PTR ___result$295004[esp+12], eax
	je	SHORT $LN39@operator@45
	sub	ebx, esi
	push	ebx
	push	esi
	push	eax
	call	_memcpy
	mov	eax, DWORD PTR ___result$295004[esp+24]
	add	esp, 12					; 0000000cH
$LN39@operator@45:

; 184  :       _M_clear();

	mov	ecx, DWORD PTR [ebp]
	test	ecx, ecx
	je	SHORT $LN70@operator@45
	push	ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	eax, DWORD PTR ___result$295004[esp+12]
$LN70@operator@45:

; 185  :       this->_M_start = __tmp;
; 186  :       this->_M_end_of_storage._M_data = this->_M_start + __len;

	mov	ecx, DWORD PTR tv420[esp+12]
	add	ecx, eax

; 196  :     }
; 197  :     this->_M_finish = this->_M_start + __xlen;

	shl	edi, 6
	add	edi, eax
	mov	DWORD PTR [ebp], eax
	mov	DWORD PTR [ebp+8], ecx
	mov	DWORD PTR [ebp+4], edi

; 198  :   }
; 199  :   return *this;

	mov	eax, ebp

; 200  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	8
$LN4@operator@45:

; 187  :     } else if (size() >= __xlen) {

	mov	eax, DWORD PTR [ebp+4]
	sub	eax, edx
	sar	eax, 6
	cmp	eax, edi
	jb	SHORT $LN2@operator@45

; 188  :       pointer __i = _STLP_PRIV __copy_ptrs(__CONST_CAST(const_pointer, __x._M_start) + 0,
; 189  :                                            __CONST_CAST(const_pointer, __x._M_finish) + 0, this->_M_start, _TrivialCopy());

	sub	ebx, esi
	je	SHORT $LN96@operator@45
	push	ebx
	push	esi
	push	edx
	call	DWORD PTR __imp__memmove

; 190  :       _STLP_STD::_Destroy_Range(__i, this->_M_finish);
; 191  :     } else {

	jmp	SHORT $LN98@operator@45
$LN2@operator@45:

; 192  :       _STLP_PRIV __copy_ptrs(__CONST_CAST(const_pointer, __x._M_start),
; 193  :                              __CONST_CAST(const_pointer, __x._M_start) + size(), this->_M_start, _TrivialCopy());

	shl	eax, 6
	sub	eax, esi
	add	eax, esi
	je	SHORT $LN87@operator@45
	push	eax
	push	esi
	push	edx
	call	DWORD PTR __imp__memmove
	mov	ecx, DWORD PTR ___x$[esp+24]
	add	esp, 12					; 0000000cH
$LN87@operator@45:

; 194  :       _STLP_PRIV __ucopy_ptrs(__CONST_CAST(const_pointer, __x._M_start) + size(),
; 195  :                               __CONST_CAST(const_pointer, __x._M_finish) + 0, this->_M_finish, _TrivialUCopy());

	mov	esi, DWORD PTR [ebp+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, esi
	sub	eax, DWORD PTR [ebp]
	sar	eax, 6
	shl	eax, 6
	add	eax, DWORD PTR [ecx]
	cmp	edx, eax
	je	SHORT $LN96@operator@45
	sub	edx, eax
	push	edx
	push	eax
	push	esi
	call	_memcpy
$LN98@operator@45:
	add	esp, 12					; 0000000cH
$LN96@operator@45:

; 196  :     }
; 197  :     this->_M_finish = this->_M_start + __xlen;

	shl	edi, 6
	add	edi, DWORD PTR [ebp]
	mov	DWORD PTR [ebp+4], edi
$LN97@operator@45:

; 200  : }

	pop	edi
	pop	esi
	mov	eax, ebp
	pop	ebp
	pop	ebx
	ret	8
??4?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ENDP ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::operator=
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ?clear@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@QAEXXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?clear@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@QAEXXZ PROC ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::clear, COMDAT

; 610  :   void clear() {

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _this$[esp+4]

; 611  :     erase(begin(), end());

	mov	ecx, ebp
	call	?end@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@QAEPAMXZ ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::end
	mov	ecx, ebp
	mov	ebx, eax
	call	?begin@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@QAEPAMXZ ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::begin
	cmp	eax, ebx
	je	SHORT $LN10@clear@23
	push	esi
	push	edi
	mov	edi, DWORD PTR [ebp+4]
	sub	edi, ebx
	je	SHORT $LN16@clear@23
	push	edi
	push	ebx
	push	eax
	call	DWORD PTR __imp__memmove
	mov	esi, eax
	add	esp, 12					; 0000000cH
	add	esi, edi
	jmp	SHORT $LN17@clear@23
$LN16@clear@23:
	mov	esi, eax
$LN17@clear@23:
	mov	eax, DWORD PTR [ebp+4]
	push	eax
	push	esi
	call	??$_Destroy_Range@PAM@stlp_std@@YAXPAM0@Z ; stlp_std::_Destroy_Range<float *>
	add	esp, 8
	pop	edi
	mov	DWORD PTR [ebp+4], esi
	pop	esi
$LN10@clear@23:
	pop	ebp
	pop	ebx

; 612  :   }

	ret	4
?clear@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@QAEXXZ ENDP ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::clear
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ?clear@?$vector@MV?$xalloc@M@@@stlp_std@@QAEXXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?clear@?$vector@MV?$xalloc@M@@@stlp_std@@QAEXXZ PROC	; stlp_std::vector<float,xalloc<float> >::clear, COMDAT

; 223  :   void clear() { _M_impl.clear(); }

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _this$[esp+4]
	mov	ecx, ebp
	call	?end@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@QAEPAMXZ ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::end
	mov	ecx, ebp
	mov	ebx, eax
	call	?begin@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@QAEPAMXZ ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::begin
	cmp	eax, ebx
	je	SHORT $LN12@clear@24
	push	esi
	push	edi
	mov	edi, DWORD PTR [ebp+4]
	sub	edi, ebx
	je	SHORT $LN18@clear@24
	push	edi
	push	ebx
	push	eax
	call	DWORD PTR __imp__memmove
	mov	esi, eax
	add	esp, 12					; 0000000cH
	add	esi, edi
	jmp	SHORT $LN19@clear@24
$LN18@clear@24:
	mov	esi, eax
$LN19@clear@24:
	mov	eax, DWORD PTR [ebp+4]
	push	eax
	push	esi
	call	??$_Destroy_Range@PAM@stlp_std@@YAXPAM0@Z ; stlp_std::_Destroy_Range<float *>
	add	esp, 8
	pop	edi
	mov	DWORD PTR [ebp+4], esi
	pop	esi
$LN12@clear@24:
	pop	ebp
	pop	ebx
	ret	4
?clear@?$vector@MV?$xalloc@M@@@stlp_std@@QAEXXZ ENDP	; stlp_std::vector<float,xalloc<float> >::clear
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@stlp_std@@QAE@ABV?$xalloc@U?$_matrix@M@@@@@Z
_TEXT	SEGMENT
??0?$vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@stlp_std@@QAE@ABV?$xalloc@U?$_matrix@M@@@@@Z PROC ; stlp_std::vector<_matrix<float>,xalloc<_matrix<float> > >::vector<_matrix<float>,xalloc<_matrix<float> > >, COMDAT
; _this$ = eax

; 106  :   explicit vector(const allocator_type& __a = allocator_type())

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@stlp_std@@QAE@ABV?$xalloc@U?$_matrix@M@@@@@Z ENDP ; stlp_std::vector<_matrix<float>,xalloc<_matrix<float> > >::vector<_matrix<float>,xalloc<_matrix<float> > >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ?clear_and_free@?$xr_vector@MV?$xalloc@M@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?clear_and_free@?$xr_vector@MV?$xalloc@M@@@@QAEXXZ PROC	; xr_vector<float,xalloc<float> >::clear_and_free, COMDAT

; 128  : 	void	clear_and_free		()									{ inherited::clear();			}

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _this$[esp+4]
	mov	ecx, ebp
	call	?end@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@QAEPAMXZ ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::end
	mov	ecx, ebp
	mov	ebx, eax
	call	?begin@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@QAEPAMXZ ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::begin
	cmp	eax, ebx
	je	SHORT $LN14@clear_and_@7
	push	esi
	push	edi
	mov	edi, DWORD PTR [ebp+4]
	sub	edi, ebx
	je	SHORT $LN20@clear_and_@7
	push	edi
	push	ebx
	push	eax
	call	DWORD PTR __imp__memmove
	mov	esi, eax
	add	esp, 12					; 0000000cH
	add	esi, edi
	jmp	SHORT $LN21@clear_and_@7
$LN20@clear_and_@7:
	mov	esi, eax
$LN21@clear_and_@7:
	mov	eax, DWORD PTR [ebp+4]
	push	eax
	push	esi
	call	??$_Destroy_Range@PAM@stlp_std@@YAXPAM0@Z ; stlp_std::_Destroy_Range<float *>
	add	esp, 8
	pop	edi
	mov	DWORD PTR [ebp+4], esi
	pop	esi
$LN14@clear_and_@7:
	pop	ebp
	pop	ebx
	ret	4
?clear_and_free@?$xr_vector@MV?$xalloc@M@@@@QAEXXZ ENDP	; xr_vector<float,xalloc<float> >::clear_and_free
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ??4?$vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@stlp_std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
??4?$vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@stlp_std@@QAEAAV01@ABV01@@Z PROC ; stlp_std::vector<_matrix<float>,xalloc<_matrix<float> > >::operator=, COMDAT
; _this$ = esi
; ___x$ = eax

; 149  :   _Self& operator=(const _Self& __x) { _M_impl = __x._M_impl; return *this; }

	push	eax
	push	esi
	call	??4?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::operator=
	mov	eax, esi
	ret	0
??4?$vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@stlp_std@@QAEAAV01@ABV01@@Z ENDP ; stlp_std::vector<_matrix<float>,xalloc<_matrix<float> > >::operator=
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ??0?$xr_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@@QAE@XZ PROC ; xr_vector<_matrix<float>,xalloc<_matrix<float> > >::xr_vector<_matrix<float>,xalloc<_matrix<float> > >, COMDAT
; _this$ = eax

; 123  : 			xr_vector			()									: inherited	()					{}

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$xr_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@@QAE@XZ ENDP ; xr_vector<_matrix<float>,xalloc<_matrix<float> > >::xr_vector<_matrix<float>,xalloc<_matrix<float> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?clear@?$xr_vector@MV?$xalloc@M@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?clear@?$xr_vector@MV?$xalloc@M@@@@QAEXXZ PROC		; xr_vector<float,xalloc<float> >::clear, COMDAT

; 133  : 	void	clear				()									{ clear_and_free	();			}

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _this$[esp+4]
	mov	ecx, ebp
	call	?end@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@QAEPAMXZ ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::end
	mov	ecx, ebp
	mov	ebx, eax
	call	?begin@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@QAEPAMXZ ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::begin
	cmp	eax, ebx
	je	SHORT $LN16@clear@25
	push	esi
	push	edi
	mov	edi, DWORD PTR [ebp+4]
	sub	edi, ebx
	je	SHORT $LN22@clear@25
	push	edi
	push	ebx
	push	eax
	call	DWORD PTR __imp__memmove
	mov	esi, eax
	add	esp, 12					; 0000000cH
	add	esi, edi
	jmp	SHORT $LN23@clear@25
$LN22@clear@25:
	mov	esi, eax
$LN23@clear@25:
	mov	eax, DWORD PTR [ebp+4]
	push	eax
	push	esi
	call	??$_Destroy_Range@PAM@stlp_std@@YAXPAM0@Z ; stlp_std::_Destroy_Range<float *>
	add	esp, 8
	pop	edi
	mov	DWORD PTR [ebp+4], esi
	pop	esi
$LN16@clear@25:
	pop	ebp
	pop	ebx
	ret	4
?clear@?$xr_vector@MV?$xalloc@M@@@@QAEXXZ ENDP		; xr_vector<float,xalloc<float> >::clear
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4?$xr_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
??4?$xr_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@@QAEAAV0@ABV0@@Z PROC ; xr_vector<_matrix<float>,xalloc<_matrix<float> > >::operator=, COMDAT
; _this$ = esi
; ___that$ = eax
	push	eax
	push	esi
	call	??4?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::operator=
	mov	eax, esi
	ret	0
??4?$xr_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@@QAEAAV0@ABV0@@Z ENDP ; xr_vector<_matrix<float>,xalloc<_matrix<float> > >::operator=
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.c
;	COMDAT ?_M_insert_overflow@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@AAEXPAU?$_matrix@M@@ABU4@ABU__true_type@3@I_N@Z
_TEXT	SEGMENT
___old_size$ = -8					; size = 4
tv298 = -4						; size = 4
___pos$ = 8						; size = 4
___x$ = 12						; size = 4
___fill_len$ = 16					; size = 4
?_M_insert_overflow@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@AAEXPAU?$_matrix@M@@ABU4@ABU__true_type@3@I_N@Z PROC ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::_M_insert_overflow, COMDAT
; _this$ = ebx

; 109  :                                              size_type __fill_len, bool __atend ) {

	sub	esp, 8

; 110  :   const size_type __old_size = size();

	mov	eax, DWORD PTR [ebx+4]
	sub	eax, DWORD PTR [ebx]
	push	ebp
	push	esi
	push	edi

; 111  :   size_type __len = __old_size + (max)(__old_size, __fill_len);

	lea	ecx, DWORD PTR ___fill_len$[esp+16]
	push	ecx
	lea	edx, DWORD PTR ___old_size$[esp+24]
	sar	eax, 6
	push	edx
	mov	DWORD PTR ___old_size$[esp+28], eax
	call	??$max@I@stlp_std@@YAABIABI0@Z		; stlp_std::max<unsigned int>
	mov	eax, DWORD PTR [eax]
	add	eax, DWORD PTR ___old_size$[esp+28]

; 112  : 
; 113  :   pointer __new_start = this->_M_end_of_storage.allocate(__len, __len);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	eax, 6
	add	esp, 8
	push	eax
	mov	DWORD PTR tv298[esp+24], eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 114  :   pointer __new_finish = __STATIC_CAST(pointer, _STLP_PRIV __copy_trivial(this->_M_start, __pos, __new_start));

	mov	esi, DWORD PTR ___pos$[esp+16]
	mov	ebp, eax
	mov	eax, DWORD PTR [ebx]
	sub	esi, eax
	je	SHORT $LN22@M_insert_o@11
	push	esi
	push	eax
	push	ebp
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	add	eax, esi
	jmp	SHORT $LN23@M_insert_o@11
$LN22@M_insert_o@11:
	mov	eax, ebp
$LN23@M_insert_o@11:

; 115  :   // handle insertion
; 116  :   __new_finish = _STLP_PRIV __fill_n(__new_finish, __fill_len, __x);

	mov	edx, DWORD PTR ___fill_len$[esp+16]
	test	edx, edx
	jbe	SHORT $LN24@M_insert_o@11
$LL26@M_insert_o@11:
	mov	esi, DWORD PTR ___x$[esp+16]
	mov	edi, eax
	sub	edx, 1
	mov	ecx, 16					; 00000010H
	add	eax, 64					; 00000040H
	test	edx, edx
	rep movsd
	ja	SHORT $LL26@M_insert_o@11
$LN24@M_insert_o@11:

; 117  :   if (!__atend)
; 118  :     __new_finish = __STATIC_CAST(pointer, _STLP_PRIV __copy_trivial(__pos, this->_M_finish, __new_finish)); // copy remainder

	mov	esi, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR ___pos$[esp+16]
	sub	esi, ecx
	mov	edi, eax
	je	SHORT $LN31@M_insert_o@11
	push	esi
	push	ecx
	push	eax
	call	DWORD PTR __imp__memmove
	mov	edi, eax
	add	esp, 12					; 0000000cH
	add	edi, esi
$LN31@M_insert_o@11:

; 119  :   _M_clear();

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN63@M_insert_o@11
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN63@M_insert_o@11:

; 120  :   _M_set(__new_start, __new_finish, __new_start + __len);

	mov	eax, DWORD PTR tv298[esp+20]
	mov	DWORD PTR [ebx+4], edi

; 121  : }

	pop	edi
	add	eax, ebp
	pop	esi
	mov	DWORD PTR [ebx], ebp
	mov	DWORD PTR [ebx+8], eax
	pop	ebp
	add	esp, 8
	ret	12					; 0000000cH
?_M_insert_overflow@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@AAEXPAU?$_matrix@M@@ABU4@ABU__true_type@3@I_N@Z ENDP ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::_M_insert_overflow
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?reserve@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@QAEXI@Z
_TEXT	SEGMENT
___n$ = -4						; size = 4
?reserve@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@QAEXI@Z PROC ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::reserve, COMDAT
; _this$ = esi

; 64   : void vector<_Tp, _Alloc>::reserve(size_type __n) {

	push	ecx

; 65   :   if (capacity() < __n) {

	mov	ecx, esi
	mov	DWORD PTR ___n$[esp+4], 1024		; 00000400H
	call	?capacity@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@QBEIXZ ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::capacity
	mov	ecx, DWORD PTR ___n$[esp+4]
	cmp	eax, ecx
	jae	SHORT $LN34@reserve@2

; 66   :     if (max_size() < __n) {

	cmp	ecx, 1073741823				; 3fffffffH
	jbe	SHORT $LN3@reserve@2

; 67   :       this->_M_throw_length_error();

	push	OFFSET ??_C@_06NBFPPGEG@vector?$AA@
	call	DWORD PTR __imp__puts
	add	esp, 4
	call	DWORD PTR __imp__abort
$LN37@reserve@2:
$LN3@reserve@2:
	push	ebx
	push	ebp
	push	edi

; 68   :     }
; 69   : 
; 70   :     const size_type __old_size = size();

	mov	ecx, esi
	call	?size@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@QBEIXZ ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::size

; 71   :     pointer __tmp;
; 72   :     if (this->_M_start) {

	mov	ebx, DWORD PTR [esi]
	test	ebx, ebx
	mov	ebp, eax
	je	SHORT $LN2@reserve@2

; 73   :       __tmp = _M_allocate_and_copy(__n, this->_M_start, this->_M_finish);

	mov	eax, DWORD PTR [esi+4]
	push	eax
	lea	eax, DWORD PTR ___n$[esp+20]
	mov	ecx, esi
	call	??$_M_allocate_and_copy@PAM@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@AAEPAMAAIPAM1@Z ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::_M_allocate_and_copy<float *>

; 74   :       _M_clear();

	mov	ecx, esi
	mov	edi, eax
	call	?_M_clear@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@AAEXXZ ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::_M_clear

; 75   :     } else {

	jmp	SHORT $LN1@reserve@2
$LN2@reserve@2:

; 76   :       __tmp = this->_M_end_of_storage.allocate(__n, __n);

	mov	edx, DWORD PTR ___n$[esp+16]
	lea	ecx, DWORD PTR ___n$[esp+16]
	push	ecx
	push	edx
	lea	ecx, DWORD PTR [esi+8]
	call	?allocate@?$_STLP_alloc_proxy@PAMMV?$xalloc@M@@@priv@stlp_std@@QAEPAMIAAI@Z ; stlp_std::priv::_STLP_alloc_proxy<float *,float,xalloc<float> >::allocate
	mov	edi, eax
$LN1@reserve@2:

; 77   :     }
; 78   :     _M_set(__tmp, __tmp + __old_size, __tmp + __n);

	mov	ecx, DWORD PTR ___n$[esp+16]
	lea	eax, DWORD PTR [edi+ebp*4]
	lea	edx, DWORD PTR [edi+ecx*4]
	mov	DWORD PTR [esi], edi
	pop	edi
	pop	ebp
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], edx
	pop	ebx
$LN34@reserve@2:

; 79   :   }
; 80   : }

	pop	ecx
	ret	0
$LN36@reserve@2:
?reserve@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@QAEXI@Z ENDP ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::reserve
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_M_fill_insert@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@AAEXPAU?$_matrix@M@@IABU4@@Z
_TEXT	SEGMENT
$T370731 = -1						; size = 1
?_M_fill_insert@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@AAEXPAU?$_matrix@M@@IABU4@@Z PROC ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::_M_fill_insert, COMDAT
; _this$ = ecx
; ___pos$ = esi
; ___n$ = eax
; ___x$ = edx

; 167  :                                          size_type __n, const _Tp& __x) {

	push	ecx

; 168  :   if (__n != 0) {

	test	eax, eax
	push	ebx
	push	edi
	je	SHORT $LN1@M_fill_ins@14

; 169  :     if (size_type(this->_M_end_of_storage._M_data - this->_M_finish) >= __n) {

	mov	edi, DWORD PTR [ecx+8]
	sub	edi, DWORD PTR [ecx+4]
	sar	edi, 6
	cmp	edi, eax
	jb	SHORT $LN2@M_fill_ins@14

; 170  :       _M_fill_insert_aux(__pos, __n, __x, _Movable());

	lea	edi, DWORD PTR $T370731[esp+12]
	push	edi
	push	edx
	push	eax
	push	esi
	call	?_M_fill_insert_aux@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@AAEXPAU?$_matrix@M@@IABU4@ABU__false_type@3@@Z ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::_M_fill_insert_aux

; 173  :   }
; 174  : }

	pop	edi
	pop	ebx
	pop	ecx
	ret	0
$LN2@M_fill_ins@14:

; 171  :     } else
; 172  :       _M_insert_overflow(__pos, __x, _TrivialCopy(), __n);

	push	eax
	push	edx
	push	esi
	mov	ebx, ecx
	call	?_M_insert_overflow@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@AAEXPAU?$_matrix@M@@ABU4@ABU__true_type@3@I_N@Z ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::_M_insert_overflow
$LN1@M_fill_ins@14:

; 173  :   }
; 174  : }

	pop	edi
	pop	ebx
	pop	ecx
	ret	0
?_M_fill_insert@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@AAEXPAU?$_matrix@M@@IABU4@@Z ENDP ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::_M_fill_insert
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
_TEXT	ENDS
;	COMDAT ?insert@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAEXPAU?$_matrix@M@@IABU4@@Z
_TEXT	SEGMENT
$T370740 = -1						; size = 1
?insert@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAEXPAU?$_matrix@M@@IABU4@@Z PROC ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::insert, COMDAT
; _this$ = ecx
; ___pos$ = esi
; ___n$ = eax
; ___x$ = edx

; 529  :   { _M_fill_insert(__pos, __n, __x); }

	push	ecx
	test	eax, eax
	push	ebx
	push	edi
	je	SHORT $LN3@insert@6
	mov	edi, DWORD PTR [ecx+8]
	sub	edi, DWORD PTR [ecx+4]
	sar	edi, 6
	cmp	edi, eax
	jb	SHORT $LN4@insert@6
	lea	edi, DWORD PTR $T370740[esp+12]
	push	edi
	push	edx
	push	eax
	push	esi
	call	?_M_fill_insert_aux@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@AAEXPAU?$_matrix@M@@IABU4@ABU__false_type@3@@Z ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::_M_fill_insert_aux
	pop	edi
	pop	ebx
	pop	ecx
	ret	0
$LN4@insert@6:
	push	eax
	push	edx
	push	esi
	mov	ebx, ecx
	call	?_M_insert_overflow@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@AAEXPAU?$_matrix@M@@ABU4@ABU__true_type@3@I_N@Z ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::_M_insert_overflow
$LN3@insert@6:
	pop	edi
	pop	ebx
	pop	ecx
	ret	0
?insert@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAEXPAU?$_matrix@M@@IABU4@@Z ENDP ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::insert
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?resize@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAEXIABU?$_matrix@M@@@Z
_TEXT	SEGMENT
$T370828 = -1						; size = 1
?resize@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAEXIABU?$_matrix@M@@@Z PROC ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::resize, COMDAT
; _this$ = eax
; ___new_size$ = edx
; ___x$ = edi

; 596  :   void resize(size_type __new_size, const _Tp& __x = _STLP_DEFAULT_CONSTRUCTED(_Tp)) {

	push	ecx
	push	ebx
	mov	ebx, eax

; 597  : #else
; 598  :   void resize(size_type __new_size, const _Tp& __x) {
; 599  : #endif /*_STLP_DONT_SUP_DFLT_PARAM*/
; 600  :     if (__new_size < size())

	mov	eax, DWORD PTR [ebx+4]
	push	esi
	mov	esi, DWORD PTR [ebx]
	mov	ecx, eax
	sub	ecx, esi
	sar	ecx, 6
	cmp	edx, ecx
	jae	SHORT $LN2@resize@4

; 601  :       erase(begin() + __new_size, end());

	shl	edx, 6
	add	edx, esi
	cmp	edx, eax
	je	SHORT $LN28@resize@4
	mov	esi, eax
	sub	esi, eax
	je	SHORT $LN20@resize@4
	push	esi
	push	eax
	push	edx
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	add	eax, esi
	mov	DWORD PTR [ebx+4], eax

; 604  :   }

	pop	esi
	pop	ebx
	pop	ecx
	ret	0

; 601  :       erase(begin() + __new_size, end());

$LN20@resize@4:
	mov	eax, edx
	mov	DWORD PTR [ebx+4], eax

; 604  :   }

	pop	esi
	pop	ebx
	pop	ecx
	ret	0
$LN2@resize@4:

; 602  :     else
; 603  :       insert(end(), __new_size - size(), __x);

	sub	edx, ecx
	je	SHORT $LN28@resize@4
	mov	ecx, DWORD PTR [ebx+8]
	sub	ecx, eax
	sar	ecx, 6
	cmp	ecx, edx
	jb	SHORT $LN29@resize@4
	lea	ecx, DWORD PTR $T370828[esp+12]
	push	ecx
	push	edi
	push	edx
	push	eax
	mov	ecx, ebx
	call	?_M_fill_insert_aux@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@AAEXPAU?$_matrix@M@@IABU4@ABU__false_type@3@@Z ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::_M_fill_insert_aux

; 604  :   }

	pop	esi
	pop	ebx
	pop	ecx
	ret	0

; 602  :     else
; 603  :       insert(end(), __new_size - size(), __x);

$LN29@resize@4:
	push	edx
	push	edi
	push	eax
	call	?_M_insert_overflow@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@AAEXPAU?$_matrix@M@@ABU4@ABU__true_type@3@I_N@Z ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::_M_insert_overflow
$LN28@resize@4:

; 604  :   }

	pop	esi
	pop	ebx
	pop	ecx
	ret	0
?resize@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAEXIABU?$_matrix@M@@@Z ENDP ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::resize
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ?resize@?$vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@stlp_std@@QAEXIABU?$_matrix@M@@@Z
_TEXT	SEGMENT
?resize@?$vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@stlp_std@@QAEXIABU?$_matrix@M@@@Z PROC ; stlp_std::vector<_matrix<float>,xalloc<_matrix<float> > >::resize, COMDAT
; _this$ = eax
; ___new_size$ = edx
; ___x$ = edi

; 217  :   { _M_impl.resize(__new_size, cast_traits::to_storage_type_cref(__x)); }

	push	ecx
	call	?resize@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAEXIABU?$_matrix@M@@@Z ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::resize
	pop	ecx
	ret	0
?resize@?$vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@stlp_std@@QAEXIABU?$_matrix@M@@@Z ENDP ; stlp_std::vector<_matrix<float>,xalloc<_matrix<float> > >::resize
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?reserve@?$vector@MV?$xalloc@M@@@stlp_std@@QAEXI@Z
_TEXT	SEGMENT
?reserve@?$vector@MV?$xalloc@M@@@stlp_std@@QAEXI@Z PROC	; stlp_std::vector<float,xalloc<float> >::reserve, COMDAT
; _this$ = esi

; 151  :   void reserve(size_type __n) {_M_impl.reserve(__n);}

	jmp	?reserve@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@QAEXI@Z ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::reserve
?reserve@?$vector@MV?$xalloc@M@@@stlp_std@@QAEXI@Z ENDP	; stlp_std::vector<float,xalloc<float> >::reserve
_TEXT	ENDS
PUBLIC	?stat_Start@CDemoPlay@@AAEXXZ			; CDemoPlay::stat_Start
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\fdemoplay.cpp
;	COMDAT ?stat_Start@CDemoPlay@@AAEXXZ
_TEXT	SEGMENT
?stat_Start@CDemoPlay@@AAEXXZ PROC			; CDemoPlay::stat_Start, COMDAT
; _this$ = ecx

; 78   : {

	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 79   : 	//if (stat_started)		return;
; 80   : 	VERIFY(!stat_started);
; 81   : 	stat_started			= TRUE				;
; 82   : 	Sleep					(1)					;

	push	1
	mov	DWORD PTR [edi+60], 1
	call	DWORD PTR __imp__Sleep@4

; 83   : 	stat_StartFrame			=	Device.dwFrame	;

	mov	eax, DWORD PTR ?Device@@3VCRenderDevice@@A+24

; 84   : 	stat_Timer_frame.Start	()					;

	mov	ebx, DWORD PTR __imp_?QPC@CPU@@YA_KXZ
	xor	esi, esi
	mov	DWORD PTR [edi+176], eax
	cmp	DWORD PTR [edi+88], esi
	jne	SHORT $LN7@stat_Start
	call	ebx
	sub	eax, DWORD PTR [edi+80]
	mov	DWORD PTR [edi+104], esi
	sbb	edx, DWORD PTR [edi+84]
	mov	DWORD PTR [edi+64], eax
	mov	DWORD PTR [edi+68], edx
	mov	DWORD PTR [edi+108], esi
	mov	DWORD PTR [edi+112], esi
	mov	DWORD PTR [edi+116], esi
$LN7@stat_Start:

; 85   : 	stat_Timer_total.Start	()					;

	cmp	DWORD PTR [edi+144], esi
	jne	SHORT $LN13@stat_Start
	call	ebx
	sub	eax, DWORD PTR [edi+136]
	mov	DWORD PTR [edi+160], esi
	sbb	edx, DWORD PTR [edi+140]
	mov	DWORD PTR [edi+120], eax
	mov	DWORD PTR [edi+124], edx
	mov	DWORD PTR [edi+164], esi
	mov	DWORD PTR [edi+168], esi
	mov	DWORD PTR [edi+172], esi
$LN13@stat_Start:

; 86   : 	stat_table.clear		()					;

	lea	esi, DWORD PTR [edi+180]
	mov	ecx, esi
	call	?end@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@QAEPAMXZ ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::end
	mov	ecx, esi
	mov	ebx, eax
	call	?begin@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@QAEPAMXZ ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::begin
	cmp	eax, ebx
	je	SHORT $LN33@stat_Start
	push	ebp
	mov	ebp, DWORD PTR [esi+4]
	sub	ebp, ebx
	je	SHORT $LN39@stat_Start
	push	ebp
	push	ebx
	push	eax
	call	DWORD PTR __imp__memmove
	mov	ebx, eax
	add	esp, 12					; 0000000cH
	add	ebx, ebp
	jmp	SHORT $LN40@stat_Start
$LN39@stat_Start:
	mov	ebx, eax
$LN40@stat_Start:
	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	push	ebx
	call	??$_Destroy_Range@PAM@stlp_std@@YAXPAM0@Z ; stlp_std::_Destroy_Range<float *>
	add	esp, 8
	mov	DWORD PTR [esi+4], ebx
	pop	ebp
$LN33@stat_Start:

; 87   : 	stat_table.reserve		(1024)				;

	call	?reserve@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@QAEXI@Z ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::reserve

; 88   : 	fStartTime				= 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR [edi+48], xmm0
	pop	edi
	pop	esi
	pop	ebx

; 89   : }

	ret	0
?stat_Start@CDemoPlay@@AAEXXZ ENDP			; CDemoPlay::stat_Start
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_vector.h
;	COMDAT ?push_back@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@QAEXABM@Z
_TEXT	SEGMENT
?push_back@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@QAEXABM@Z PROC ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::push_back, COMDAT
; _this$ = ecx
; ___x$ = eax

; 360  :   void push_back(const _Tp& __x) {

	push	edi
	mov	edi, ecx

; 361  : #endif /*!_STLP_DONT_SUP_DFLT_PARAM && !_STLP_NO_ANACHRONISMS*/
; 362  :     if (this->_M_finish != this->_M_end_of_storage._M_data) {

	mov	ecx, DWORD PTR [edi+4]
	cmp	ecx, DWORD PTR [edi+8]
	je	SHORT $LN2@push_back@45

; 363  :       _Copy_Construct(this->_M_finish, __x);

	test	ecx, ecx
	je	SHORT $LN7@push_back@45
	fld	DWORD PTR [eax]
	fstp	DWORD PTR [ecx]
$LN7@push_back@45:

; 364  :       ++this->_M_finish;

	add	DWORD PTR [edi+4], 4
	pop	edi

; 368  :   }

	ret	0
$LN2@push_back@45:

; 365  :     }
; 366  :     else
; 367  :       _M_insert_overflow(this->_M_finish, __x, _TrivialCopy(), 1UL, true);

	push	1
	push	1
	push	ecx
	call	?_M_insert_overflow@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@AAEXPAMABMABU__true_type@3@I_N@Z ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::_M_insert_overflow
	pop	edi

; 368  :   }

	ret	0
?push_back@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@QAEXABM@Z ENDP ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::push_back
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@MV?$xalloc@M@@@stlp_std@@QAEXABM@Z
_TEXT	SEGMENT
?push_back@?$vector@MV?$xalloc@M@@@stlp_std@@QAEXABM@Z PROC ; stlp_std::vector<float,xalloc<float> >::push_back, COMDAT
; _this$ = ecx
; ___x$ = eax

; 171  :   { _M_impl.push_back(cast_traits::to_storage_type_cref(__x)); }

	push	edi
	mov	edi, ecx
	mov	ecx, DWORD PTR [edi+4]
	cmp	ecx, DWORD PTR [edi+8]
	je	SHORT $LN6@push_back@46
	test	ecx, ecx
	je	SHORT $LN11@push_back@46
	fld	DWORD PTR [eax]
	fstp	DWORD PTR [ecx]
$LN11@push_back@46:
	add	DWORD PTR [edi+4], 4
	pop	edi
	ret	0
$LN6@push_back@46:
	push	1
	push	1
	push	ecx
	call	?_M_insert_overflow@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@AAEXPAMABMABU__true_type@3@I_N@Z ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::_M_insert_overflow
	pop	edi
	ret	0
?push_back@?$vector@MV?$xalloc@M@@@stlp_std@@QAEXABM@Z ENDP ; stlp_std::vector<float,xalloc<float> >::push_back
_TEXT	ENDS
PUBLIC	??4CDemoPlay@@QAEAAV0@ABV0@@Z			; CDemoPlay::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4CDemoPlay@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4CDemoPlay@@QAEAAV0@ABV0@@Z PROC			; CDemoPlay::operator=, COMDAT
; _this$ = ecx
	push	ebx
	mov	ebx, ecx
	push	ebp
	mov	ebp, DWORD PTR ___that$[esp+4]
	mov	eax, DWORD PTR [ebp+8]
	mov	DWORD PTR [ebx+8], eax
	mov	ecx, DWORD PTR [ebp+4]
	mov	DWORD PTR [ebx+4], ecx
	mov	edx, DWORD PTR [ebp+12]
	mov	DWORD PTR [ebx+12], edx
	fld	DWORD PTR [ebp+16]
	fstp	DWORD PTR [ebx+16]
	mov	al, BYTE PTR [ebp+20]
	push	esi
	mov	BYTE PTR [ebx+20], al
	mov	ecx, DWORD PTR [ebp+24]
	push	edi
	mov	DWORD PTR [ebx+24], ecx
	mov	edx, DWORD PTR [ebp+28]
	lea	eax, DWORD PTR [ebp+32]
	push	eax
	lea	ecx, DWORD PTR [ebx+32]
	push	ecx
	mov	DWORD PTR [ebx+28], edx
	call	??4?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAEAAV012@ABV012@@Z ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::operator=
	mov	edx, DWORD PTR [ebp+44]
	mov	DWORD PTR [ebx+44], edx
	fld	DWORD PTR [ebp+48]
	fstp	DWORD PTR [ebx+48]
	lea	esi, DWORD PTR [ebp+64]
	fld	DWORD PTR [ebp+52]
	lea	edi, DWORD PTR [ebx+64]
	fstp	DWORD PTR [ebx+52]
	mov	eax, DWORD PTR [ebp+56]
	mov	DWORD PTR [ebx+56], eax
	mov	ecx, DWORD PTR [ebp+60]
	mov	DWORD PTR [ebx+60], ecx
	mov	ecx, 14					; 0000000eH
	rep movsd
	lea	esi, DWORD PTR [ebp+120]
	lea	edi, DWORD PTR [ebx+120]
	mov	ecx, 14					; 0000000eH
	rep movsd
	mov	edx, DWORD PTR [ebp+176]
	add	ebp, 180				; 000000b4H
	push	ebp
	lea	ecx, DWORD PTR [ebx+180]
	mov	DWORD PTR [ebx+176], edx
	call	??4?$vector@MV?$xalloc@M@@@stlp_std@@QAEAAV01@ABV01@@Z ; stlp_std::vector<float,xalloc<float> >::operator=
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ebx
	pop	ebx
	ret	4
??4CDemoPlay@@QAEAAV0@ABV0@@Z ENDP			; CDemoPlay::operator=
PUBLIC	??0CDemoPlay@@QAE@ABV0@@Z			; CDemoPlay::CDemoPlay
; Function compile flags: /Ogtpy
;	COMDAT ??0CDemoPlay@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0CDemoPlay@@QAE@ABV0@@Z PROC				; CDemoPlay::CDemoPlay, COMDAT
; _this$ = ecx
	push	ebx
	mov	ebx, ecx
	mov	DWORD PTR [ebx], OFFSET ??_7SBaseEffector@@6B@
	xor	ecx, ecx
	mov	DWORD PTR [ebx+4], ecx
	mov	DWORD PTR [ebx+8], ecx
	push	ebp
	mov	ebp, DWORD PTR ___that$[esp+4]
	mov	eax, DWORD PTR [ebp+8]
	mov	DWORD PTR [ebx+8], eax
	mov	edx, DWORD PTR [ebp+4]
	mov	DWORD PTR [ebx+4], edx
	mov	DWORD PTR [ebx], OFFSET ??_7CEffectorCam@@6B@
	mov	eax, DWORD PTR [ebp+12]
	mov	DWORD PTR [ebx+12], eax
	fld	DWORD PTR [ebp+16]
	fstp	DWORD PTR [ebx+16]
	mov	dl, BYTE PTR [ebp+20]
	mov	BYTE PTR [ebx+20], dl
	mov	DWORD PTR [ebx], OFFSET ??_7CDemoPlay@@6B@
	mov	eax, DWORD PTR [ebp+24]
	mov	DWORD PTR [ebx+24], eax
	mov	edx, DWORD PTR [ebp+28]
	mov	DWORD PTR [ebx+28], edx
	mov	eax, DWORD PTR [ebp+36]
	sub	eax, DWORD PTR [ebp+32]
	push	esi
	sar	eax, 6
	shl	eax, 6
	mov	DWORD PTR [ebx+32], ecx
	mov	DWORD PTR [ebx+36], ecx
	push	edi
	mov	esi, eax
	mov	DWORD PTR [ebx+40], ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	add	esi, eax
	mov	DWORD PTR [ebx+32], eax
	mov	DWORD PTR [ebx+36], eax
	mov	DWORD PTR [ebx+40], esi
	mov	edx, DWORD PTR [ebp+36]
	mov	ecx, DWORD PTR [ebp+32]
	cmp	edx, ecx
	je	SHORT $LN54@CDemoPlay
	mov	esi, edx
	sub	esi, ecx
	push	esi
	push	ecx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	add	eax, esi
$LN54@CDemoPlay:
	mov	DWORD PTR [ebx+36], eax
	mov	eax, DWORD PTR [ebp+44]
	mov	DWORD PTR [ebx+44], eax
	fld	DWORD PTR [ebp+48]
	fstp	DWORD PTR [ebx+48]
	lea	esi, DWORD PTR [ebp+64]
	fld	DWORD PTR [ebp+52]
	lea	edi, DWORD PTR [ebx+64]
	fstp	DWORD PTR [ebx+52]
	mov	ecx, DWORD PTR [ebp+56]
	mov	DWORD PTR [ebx+56], ecx
	mov	edx, DWORD PTR [ebp+60]
	mov	DWORD PTR [ebx+60], edx
	mov	ecx, 14					; 0000000eH
	rep movsd
	lea	esi, DWORD PTR [ebp+120]
	lea	edi, DWORD PTR [ebx+120]
	mov	ecx, 14					; 0000000eH
	rep movsd
	mov	eax, DWORD PTR [ebp+176]
	add	ebp, 180				; 000000b4H
	push	ebp
	lea	ecx, DWORD PTR [ebx+180]
	mov	DWORD PTR [ebx+176], eax
	call	??0?$vector@MV?$xalloc@M@@@stlp_std@@QAE@ABV01@@Z ; stlp_std::vector<float,xalloc<float> >::vector<float,xalloc<float> >
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ebx
	pop	ebx
	ret	4
??0CDemoPlay@@QAE@ABV0@@Z ENDP				; CDemoPlay::CDemoPlay
PUBLIC	?stat_Stop@CDemoPlay@@AAEXXZ			; CDemoPlay::stat_Stop
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\fdemoplay.cpp
;	COMDAT ?stat_Stop@CDemoPlay@@AAEXXZ
_TEXT	SEGMENT
_rfps_middlepoint$ = -1132				; size = 4
_rfps_min$ = -1128					; size = 4
_rfps_max$ = -1124					; size = 4
tv630 = -1120						; size = 2
_fTime$127664 = -1120					; size = 4
tv627 = -1116						; size = 4
_it$127660 = -1116					; size = 4
tv636 = -1112						; size = 4
tv625 = -1112						; size = 8
tv616 = -1112						; size = 4
tv602 = -1112						; size = 4
tv589 = -1112						; size = 4
tv454 = -1112						; size = 4
tv160 = -1112						; size = 4
_rfps_average$ = -1104					; size = 4
tv442 = -1100						; size = 4
_id$127710 = -1096					; size = 32
_res$127693 = -1064					; size = 540
_fname$127682 = -520					; size = 520
?stat_Stop@CDemoPlay@@AAEXXZ PROC			; CDemoPlay::stat_Stop, COMDAT
; _this$ = ecx

; 94   : {

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	sub	esp, 1136				; 00000470H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 95   : 	if (!stat_started)		return;

	cmp	DWORD PTR [esi+60], 0
	push	edi
	je	$LN10@stat_Stop

; 96   : 
; 97   : 	//g_SASH.EndBenchmark();
; 98   : 
; 99   : 	stat_started			= FALSE;
; 100  : 	float	stat_total		= stat_Timer_total.GetElapsed_sec	();

	lea	ecx, DWORD PTR [esi+120]
	mov	DWORD PTR [esi+60], 0
	call	DWORD PTR __imp_?GetElapsed_sec@CTimer@@QBEMXZ

; 101  : 
; 102  : 	float	rfps_min, rfps_max, rfps_middlepoint, rfps_average	;
; 103  : 
; 104  : 	// total
; 105  : 	u32	dwFramesTotal		= Device.dwFrame-stat_StartFrame	;

	mov	eax, DWORD PTR ?Device@@3VCRenderDevice@@A+24
	sub	eax, DWORD PTR [esi+176]

; 106  : 	rfps_average			= float(dwFramesTotal)/stat_total	;

	test	eax, eax
	mov	DWORD PTR tv636[esp+1152], eax
	fild	DWORD PTR tv636[esp+1152]
	jge	SHORT $LN137@stat_Stop
	fadd	DWORD PTR __real@4f800000
$LN137@stat_Stop:
	fdivrp	ST(1), ST(0)

; 107  : 
; 108  : 	// min/max/average
; 109  : 	rfps_min				= flt_max;

	movss	xmm0, DWORD PTR __real@7f7fffff
	movss	DWORD PTR _rfps_min$[esp+1152], xmm0

; 110  : 	rfps_max				= flt_min;

	movss	xmm0, DWORD PTR __real@ff7fffff
	movss	DWORD PTR _rfps_max$[esp+1152], xmm0

; 111  : 	rfps_middlepoint		= 0;

	xorps	xmm0, xmm0

; 112  : 
; 113  : 	//	Filtered FPS
; 114  : 	const u32 iAvgFPS		=	_max((u32)rfps_average,10);
; 115  : 	const u32 WindowSize	=	_max(16, iAvgFPS/2);
; 116  : 
; 117  : 	if ( stat_table.size() > WindowSize*4 )

	add	esi, 180				; 000000b4H
	mov	ebx, 16					; 00000010H
	movss	DWORD PTR _rfps_middlepoint$[esp+1152], xmm0
	fnstcw	WORD PTR tv630[esp+1152]
	fst	DWORD PTR _rfps_average$[esp+1152]
	movzx	eax, WORD PTR tv630[esp+1152]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv627[esp+1152], eax
	fldcw	WORD PTR tv627[esp+1152]
	fistp	QWORD PTR tv625[esp+1152]
	mov	eax, DWORD PTR tv625[esp+1152]
	lea	ecx, DWORD PTR [eax-10]
	lea	edx, DWORD PTR [eax-10]
	fldcw	WORD PTR tv630[esp+1152]
	sar	ecx, 31					; 0000001fH
	and	ecx, edx
	sub	eax, ecx
	shr	eax, 1
	mov	ecx, 16					; 00000010H
	sub	ecx, eax
	mov	eax, ecx
	sar	eax, 31					; 0000001fH
	and	eax, ecx
	mov	ecx, esi
	sub	ebx, eax
	call	?size@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@QBEIXZ ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::size
	lea	ecx, DWORD PTR [ebx*4]
	cmp	eax, ecx

; 118  : 	{
; 119  : 		for (u32	it=2; it<stat_table.size()-WindowSize+1; it++)

	mov	ecx, esi
	jbe	$LN25@stat_Stop
	mov	ebp, 1
	mov	edi, 2
	sub	ebp, ebx
	mov	DWORD PTR _it$127660[esp+1152], edi
	mov	DWORD PTR tv442[esp+1152], ebp
	call	?size@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@QBEIXZ ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::size
	add	eax, ebp
	cmp	eax, edi
	jbe	$LN22@stat_Stop
	mov	edx, ebx
	test	edx, edx
	mov	DWORD PTR tv616[esp+1152], edx
	fild	DWORD PTR tv616[esp+1152]
	jge	SHORT $LN138@stat_Stop
	fadd	DWORD PTR __real@4f800000
$LN138@stat_Stop:
	fstp	DWORD PTR tv454[esp+1152]
$LN24@stat_Stop:

; 120  : 		{
; 121  : 			float	fTime = 0;
; 122  : 			for (u32 i=0; i<WindowSize; ++i)

	test	ebx, ebx
	xorps	xmm1, xmm1
	movss	DWORD PTR _fTime$127664[esp+1152], xmm1
	jbe	SHORT $LN19@stat_Stop
	add	edi, edi
	add	edi, edi
	mov	ebp, ebx
$LL21@stat_Stop:

; 123  : 				fTime += stat_table[it+i];

	mov	ecx, esi
	call	?begin@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@QAEPAMXZ ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::begin
	movss	xmm1, DWORD PTR [edi+eax]
	addss	xmm1, DWORD PTR _fTime$127664[esp+1152]
	add	edi, 4
	sub	ebp, 1
	movss	DWORD PTR _fTime$127664[esp+1152], xmm1
	jne	SHORT $LL21@stat_Stop
	mov	edi, DWORD PTR _it$127660[esp+1152]
	mov	ebp, DWORD PTR tv442[esp+1152]
$LN19@stat_Stop:

; 124  : 			float	fps	= WindowSize / fTime;

	movss	xmm0, DWORD PTR tv454[esp+1152]
	divss	xmm0, xmm1

; 125  : 			if		(fps<rfps_min)	rfps_min = fps;

	movss	xmm1, DWORD PTR _rfps_min$[esp+1152]
	comiss	xmm1, xmm0
	jbe	SHORT $LN18@stat_Stop
	movss	DWORD PTR _rfps_min$[esp+1152], xmm0
$LN18@stat_Stop:

; 126  : 			if		(fps>rfps_max)	rfps_max = fps;

	comiss	xmm0, DWORD PTR _rfps_max$[esp+1152]
	jbe	SHORT $LN17@stat_Stop
	movss	DWORD PTR _rfps_max$[esp+1152], xmm0
$LN17@stat_Stop:

; 127  : 			rfps_middlepoint	+=	fps;

	addss	xmm0, DWORD PTR _rfps_middlepoint$[esp+1152]
	add	edi, 1
	mov	ecx, esi
	movss	DWORD PTR _rfps_middlepoint$[esp+1152], xmm0
	mov	DWORD PTR _it$127660[esp+1152], edi
	call	?size@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@QBEIXZ ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::size
	add	eax, ebp
	cmp	edi, eax
	jb	$LN24@stat_Stop
$LN22@stat_Stop:

; 128  : 		}
; 129  : 
; 130  : 		rfps_middlepoint		/= float(stat_table.size()-1-WindowSize+1);

	mov	ecx, esi
	call	?size@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@QBEIXZ ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::size
	sub	eax, ebx
	mov	DWORD PTR tv602[esp+1152], eax
	fild	DWORD PTR tv602[esp+1152]

; 131  : 	}
; 132  : 	else

	jmp	SHORT $LN143@stat_Stop
$LN25@stat_Stop:

; 133  : 	{
; 134  : 		for (u32	it=1; it<stat_table.size(); it++)

	mov	edi, 1
	call	?size@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@QBEIXZ ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::size
	cmp	eax, edi
	jbe	SHORT $LN13@stat_Stop
	npad	5
$LL15@stat_Stop:

; 135  : 		{
; 136  : 			float	fps	= 1.f / stat_table[it];

	mov	ecx, esi
	call	?begin@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@QAEPAMXZ ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::begin
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR [eax+edi*4]

; 137  : 			if		(fps<rfps_min)	rfps_min = fps;

	movss	xmm1, DWORD PTR _rfps_min$[esp+1152]
	comiss	xmm1, xmm0
	jbe	SHORT $LN12@stat_Stop
	movss	DWORD PTR _rfps_min$[esp+1152], xmm0
$LN12@stat_Stop:

; 138  : 			if		(fps>rfps_max)	rfps_max = fps;

	comiss	xmm0, DWORD PTR _rfps_max$[esp+1152]
	jbe	SHORT $LN11@stat_Stop
	movss	DWORD PTR _rfps_max$[esp+1152], xmm0
$LN11@stat_Stop:

; 139  : 			rfps_middlepoint	+=	fps;

	addss	xmm0, DWORD PTR _rfps_middlepoint$[esp+1152]
	mov	ecx, esi
	movss	DWORD PTR _rfps_middlepoint$[esp+1152], xmm0
	add	edi, 1
	call	?size@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@QBEIXZ ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::size
	cmp	edi, eax
	jb	SHORT $LL15@stat_Stop
$LN13@stat_Stop:

; 140  : 		}
; 141  : 		rfps_middlepoint		/= float(stat_table.size()-1);

	mov	ecx, esi
	call	?size@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@QBEIXZ ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::size
	sub	eax, 1
	mov	DWORD PTR tv589[esp+1152], eax
	fild	DWORD PTR tv589[esp+1152]
$LN143@stat_Stop:
	test	eax, eax
	jge	SHORT $LN140@stat_Stop
	fadd	DWORD PTR __real@4f800000
$LN140@stat_Stop:
	fdivr	DWORD PTR _rfps_middlepoint$[esp+1152]

; 142  : 	}
; 143  : 
; 144  : 	/*
; 145  : 	for (u32	it=1; it<stat_table.size(); it++)
; 146  : 	{
; 147  : 		float	fps	= 1.f / stat_table[it];
; 148  : 		if		(fps<rfps_min)	rfps_min = fps;
; 149  : 		if		(fps>rfps_max)	rfps_max = fps;
; 150  : 		rfps_middlepoint	+=	fps;
; 151  : 	}
; 152  : 	rfps_middlepoint		/= float(stat_table.size()-1);
; 153  : 	*/
; 154  : 
; 155  : 	Msg("* [DEMO] FPS: average[%f], min[%f], max[%f], middle[%f]",rfps_average,rfps_min,rfps_max,rfps_middlepoint);

	sub	esp, 32					; 00000020H
	fst	DWORD PTR _rfps_middlepoint$[esp+1184]
	fstp	QWORD PTR [esp+24]
	fld	DWORD PTR _rfps_max$[esp+1184]
	fstp	QWORD PTR [esp+16]
	fld	DWORD PTR _rfps_min$[esp+1184]
	fstp	QWORD PTR [esp+8]
	fld	DWORD PTR _rfps_average$[esp+1184]
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0DI@KDFBHPPC@?$CK?5?$FLDEMO?$FN?5FPS?3?5average?$FL?$CFf?$FN?0?5min?$FL?$CF@
	call	DWORD PTR __imp_?Msg@@YAXPBDZZ
	add	esp, 36					; 00000024H

; 156  : 
; 157  : 	if(g_bBenchmark)

	cmp	BYTE PTR ?g_bBenchmark@@3_NA, 0		; g_bBenchmark
	je	$LN10@stat_Stop

; 158  : 	{
; 159  : 		string_path			fname;
; 160  : 
; 161  : 		if(xr_strlen(g_sBenchmarkName))

	mov	eax, OFFSET ?g_sBenchmarkName@@3PADA	; g_sBenchmarkName
	lea	edx, DWORD PTR [eax+1]
$LL134@stat_Stop:
	mov	cl, BYTE PTR [eax]
	add	eax, 1
	test	cl, cl
	jne	SHORT $LL134@stat_Stop
	sub	eax, edx
	je	SHORT $LN9@stat_Stop

; 162  : 			xr_sprintf	(fname,sizeof(fname),"%s.result",g_sBenchmarkName);

	push	OFFSET ?g_sBenchmarkName@@3PADA		; g_sBenchmarkName
	lea	eax, DWORD PTR _fname$127682[esp+1156]
	push	OFFSET ??_C@_09FLBAMLIF@?$CFs?4result?$AA@
	push	eax
	mov	eax, 520				; 00000208H
	call	?xr_sprintf@@YAHPADIPBDZZ		; xr_sprintf
	add	esp, 12					; 0000000cH

; 163  : 		else

	jmp	SHORT $LN91@stat_Stop
$LN9@stat_Stop:

; 164  : 			xr_strcpy	(fname,sizeof(fname),"benchmark.result");

	push	520					; 00000208H
	push	OFFSET ??_C@_0BB@PFMCGCAH@benchmark?4result?$AA@
	lea	ecx, DWORD PTR _fname$127682[esp+1160]
	push	520					; 00000208H
	push	ecx
	call	DWORD PTR __imp__strncpy_s
	add	esp, 16					; 00000010H
$LN91@stat_Stop:

; 165  : 
; 166  : 
; 167  : 		FS.update_path		(fname,"$app_data_root$",fname);

	mov	ecx, DWORD PTR __imp_?xr_FS@@3PAVCLocatorAPI@@A
	mov	ecx, DWORD PTR [ecx]
	lea	edx, DWORD PTR _fname$127682[esp+1152]
	push	edx
	push	OFFSET ??_C@_0BA@BDJNLMJI@$app_data_root$?$AA@
	mov	eax, edx
	push	eax
	call	DWORD PTR __imp_?update_path@CLocatorAPI@@QAEPBDAAY0CAI@DPBD1@Z

; 168  : 		CInifile			res		(fname,FALSE,FALSE,TRUE);

	sub	esp, 8
	mov	ecx, esp
	call	??0?$FastDelegate@$$A6A_NPBD@Z@fastdelegate@@QAE@XZ ; fastdelegate::FastDelegate<bool __cdecl(char const *)>::FastDelegate<bool __cdecl(char const *)>
	push	0
	push	1
	push	0
	push	0
	lea	edx, DWORD PTR _fname$127682[esp+1176]
	push	edx
	lea	ecx, DWORD PTR _res$127693[esp+1180]
	call	DWORD PTR __imp_??0CInifile@@QAE@PBDHHHIV?$FastDelegate@$$A6A_NPBD@Z@fastdelegate@@@Z

; 169  : 		res.w_float			("general","renderer",	float(::Render->get_generation())/10.f,	"dx-level required"		);

	mov	eax, DWORD PTR __imp_?Render@@3PAVIRender_interface@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	push	OFFSET ??_C@_0BC@BFKHPNCC@dx?9level?5required?$AA@
	call	eax
	mov	ebx, DWORD PTR __imp_?w_float@CInifile@@QAEXPBD0M0@Z
	push	ecx
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR _psShedulerReaction
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_08NELFFGLM@renderer?$AA@
	push	OFFSET ??_C@_07LLDKJBMK@general?$AA@
	lea	ecx, DWORD PTR _res$127693[esp+1168]
	call	ebx

; 170  : 		res.w_float			("general","min",		rfps_min,								"absolute minimum"		);

	fld	DWORD PTR _rfps_min$[esp+1152]
	push	OFFSET ??_C@_0BB@NKIHBPID@absolute?5minimum?$AA@
	push	ecx
	fstp	DWORD PTR [esp]
	push	OFFSET ??_C@_03KLIPLJLL@min?$AA@
	push	OFFSET ??_C@_07LLDKJBMK@general?$AA@
	lea	ecx, DWORD PTR _res$127693[esp+1168]
	call	ebx

; 171  : 		res.w_float			("general","max",		rfps_max,								"absolute maximum"		);

	fld	DWORD PTR _rfps_max$[esp+1152]
	push	OFFSET ??_C@_0BB@DMOHLAGC@absolute?5maximum?$AA@
	push	ecx
	fstp	DWORD PTR [esp]
	push	OFFSET ??_C@_03LJAEFNNE@max?$AA@
	push	OFFSET ??_C@_07LLDKJBMK@general?$AA@
	lea	ecx, DWORD PTR _res$127693[esp+1168]
	call	ebx

; 172  : 		res.w_float			("general","average",	rfps_average,							"average for this run"	);

	fld	DWORD PTR _rfps_average$[esp+1152]
	push	OFFSET ??_C@_0BF@JFNMHPHL@average?5for?5this?5run?$AA@
	push	ecx
	fstp	DWORD PTR [esp]
	push	OFFSET ??_C@_07EIHJKMF@average?$AA@
	push	OFFSET ??_C@_07LLDKJBMK@general?$AA@
	lea	ecx, DWORD PTR _res$127693[esp+1168]
	call	ebx

; 173  : 		res.w_float			("general","middle",	rfps_middlepoint,						"per-frame middle-point");

	fld	DWORD PTR _rfps_middlepoint$[esp+1152]
	push	OFFSET ??_C@_0BH@LHOALLHE@per?9frame?5middle?9point?$AA@
	push	ecx
	fstp	DWORD PTR [esp]
	push	OFFSET ??_C@_06CGLIEPEJ@middle?$AA@
	push	OFFSET ??_C@_07LLDKJBMK@general?$AA@
	lea	ecx, DWORD PTR _res$127693[esp+1168]
	call	ebx

; 174  : 		for (u32	it=1; it<stat_table.size(); it++)

	mov	ecx, esi
	mov	edi, 1
	call	?size@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@QBEIXZ ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::size
	cmp	eax, edi
	jbe	SHORT $LN5@stat_Stop
	npad	1
$LL7@stat_Stop:

; 175  : 		{
; 176  : 			string32		id;
; 177  : 			xr_sprintf		(id,sizeof(id),"%7d",it);

	push	edi
	lea	ecx, DWORD PTR _id$127710[esp+1156]
	push	OFFSET ??_C@_03GJOCCCFJ@?$CF7d?$AA@
	push	ecx
	mov	eax, 32					; 00000020H
	call	?xr_sprintf@@YAHPADIPBDZZ		; xr_sprintf
	add	esp, 12					; 0000000cH

; 178  : 			for (u32 c=0; id[c]; c++) if (' '==id[c]) id[c] = '0';

	cmp	BYTE PTR _id$127710[esp+1152], 0
	je	SHORT $LN113@stat_Stop

; 140  : 		}
; 141  : 		rfps_middlepoint		/= float(stat_table.size()-1);

	lea	eax, DWORD PTR _id$127710[esp+1152]
$LL4@stat_Stop:

; 178  : 			for (u32 c=0; id[c]; c++) if (' '==id[c]) id[c] = '0';

	cmp	BYTE PTR [eax], 32			; 00000020H
	jne	SHORT $LN3@stat_Stop
	mov	BYTE PTR [eax], 48			; 00000030H
$LN3@stat_Stop:
	add	eax, 1
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LL4@stat_Stop

; 179  : 			res.w_float		("per_frame_stats",	id, 1.f / stat_table[it]);

$LN113@stat_Stop:
	mov	ecx, esi
	call	?begin@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@QAEPAMXZ ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::begin
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR [eax+edi*4]
	push	0
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _id$127710[esp+1160]
	push	edx
	push	OFFSET ??_C@_0BA@HCEKDGCO@per_frame_stats?$AA@
	lea	ecx, DWORD PTR _res$127693[esp+1168]
	call	ebx
	mov	ecx, esi
	add	edi, 1
	call	?size@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@QBEIXZ ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::size
	cmp	edi, eax
	jb	SHORT $LL7@stat_Stop
$LN5@stat_Stop:

; 180  : 		}
; 181  : 
; 182  : 		Console->Execute	("quit");

	mov	ecx, DWORD PTR ?Console@@3PAVCConsole@@A ; Console
	push	0
	push	OFFSET ??_C@_04KNNLNNGO@quit?$AA@
	call	?ExecuteCommand@CConsole@@QAEXPBD_N@Z	; CConsole::ExecuteCommand

; 183  : 	}

	lea	ecx, DWORD PTR _res$127693[esp+1152]
	call	DWORD PTR __imp_??1CInifile@@UAE@XZ
$LN10@stat_Stop:

; 184  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?stat_Stop@CDemoPlay@@AAEXXZ ENDP			; CDemoPlay::stat_Stop
_TEXT	ENDS
PUBLIC	??1CDemoPlay@@UAE@XZ				; CDemoPlay::~CDemoPlay
; Function compile flags: /Ogtpy
;	COMDAT ??1CDemoPlay@@UAE@XZ
_TEXT	SEGMENT
??1CDemoPlay@@UAE@XZ PROC				; CDemoPlay::~CDemoPlay, COMDAT
; _this$ = ecx

; 68   : {

	push	ebp
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR [esi], OFFSET ??_7CDemoPlay@@6B@

; 69   : 	stat_Stop				();

	call	?stat_Stop@CDemoPlay@@AAEXXZ		; CDemoPlay::stat_Stop

; 70   : 	xr_delete				(m_pMotion	);

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	mov	ebp, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	je	SHORT $LN5@CDemoPlay@2
	push	eax
	call	___RTCastToVoid
	mov	ecx, DWORD PTR [esi+24]
	mov	edi, eax
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	add	esp, 4
	push	0
	call	edx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edi
	call	ebp
	mov	DWORD PTR [esi+24], 0
$LN5@CDemoPlay@2:

; 71   : 	xr_delete				(m_MParam	);

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN10@CDemoPlay@2
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebp
	mov	DWORD PTR [esi+28], 0
$LN10@CDemoPlay@2:

; 72   : 	Console->Execute		("hud_weapon 1");

	mov	ecx, DWORD PTR ?Console@@3PAVCConsole@@A ; Console
	push	0
	push	OFFSET ??_C@_0N@KECBBFHI@hud_weapon?51?$AA@
	call	?ExecuteCommand@CConsole@@QAEXPBD_N@Z	; CConsole::ExecuteCommand

; 73   : 	if(g_bBenchmark || g_SASH.IsRunning())		

	cmp	BYTE PTR ?g_bBenchmark@@3_NA, 0		; g_bBenchmark
	jne	SHORT $LN1@CDemoPlay@2
	cmp	BYTE PTR ?g_SASH@@3VxrSASH@@A+2, 0
	je	SHORT $LN19@CDemoPlay@2
$LN1@CDemoPlay@2:

; 74   : 		Console->Execute	("hud_draw 1");

	mov	ecx, DWORD PTR ?Console@@3PAVCConsole@@A ; Console
	push	0
	push	OFFSET ??_C@_0L@HGDPAFMG@hud_draw?51?$AA@
	call	?ExecuteCommand@CConsole@@QAEXPBD_N@Z	; CConsole::ExecuteCommand
$LN19@CDemoPlay@2:

; 75   : }

	lea	ecx, DWORD PTR [esi+180]
	call	??1?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@QAE@XZ ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::~_Impl_vector<float,xalloc<float> >
	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN69@CDemoPlay@2
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebp
$LN69@CDemoPlay@2:
	pop	edi
	mov	DWORD PTR [esi], OFFSET ??_7SBaseEffector@@6B@
	pop	esi
	pop	ebp
	ret	0
??1CDemoPlay@@UAE@XZ ENDP				; CDemoPlay::~CDemoPlay
_TEXT	ENDS
PUBLIC	??0CDemoPlay@@QAE@PBDMIM@Z			; CDemoPlay::CDemoPlay
; Function compile flags: /Ogtpy
;	COMDAT ??0CDemoPlay@@QAE@PBDMIM@Z
_TEXT	SEGMENT
$T530784 = -1113					; size = 1
_fs$127606 = -1112					; size = 4
_sz$127607 = -1108					; size = 4
$T530638 = -1104					; size = 64
_nm$ = -1040						; size = 520
_fn$ = -520						; size = 520
_name$ = 8						; size = 4
_ms$ = 12						; size = 4
_cycles$ = 16						; size = 4
_life_time$ = 20					; size = 4
??0CDemoPlay@@QAE@PBDMIM@Z PROC				; CDemoPlay::CDemoPlay, COMDAT
; _this$ = ecx

; 20   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	movss	xmm0, DWORD PTR _life_time$[ebp]
	sub	esp, 1116				; 0000045cH
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi
	xor	edi, edi
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi+12], edi
	movss	DWORD PTR [esi+16], xmm0
	mov	BYTE PTR [esi+20], 1
	mov	DWORD PTR [esi], OFFSET ??_7CDemoPlay@@6B@
	lea	ebx, DWORD PTR [esi+32]
	mov	DWORD PTR [ebx], edi
	mov	DWORD PTR [ebx+4], edi
	lea	ecx, DWORD PTR [esi+64]
	mov	DWORD PTR [ebx+8], edi
	call	DWORD PTR __imp_??0CTimer@@QAE@XZ
	lea	ecx, DWORD PTR [esi+120]
	call	DWORD PTR __imp_??0CTimer@@QAE@XZ
	push	edi
	lea	eax, DWORD PTR $T530784[esp+1132]
	push	eax
	lea	ecx, DWORD PTR [esi+188]
	mov	DWORD PTR [esi+180], edi
	mov	DWORD PTR [esi+184], edi
	call	??0?$_STLP_alloc_proxy@PAMMV?$xalloc@M@@@priv@stlp_std@@QAE@ABV?$xalloc@M@@PAM@Z ; stlp_std::priv::_STLP_alloc_proxy<float *,float,xalloc<float> >::_STLP_alloc_proxy<float *,float,xalloc<float> >

; 21   : 	Msg					("*** Playing demo: %s",name);

	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BF@ENHEOCDL@?$CK?$CK?$CK?5Playing?5demo?3?5?$CFs?$AA@
	call	DWORD PTR __imp_?Msg@@YAXPBDZZ

; 22   : 	Console->Execute	("hud_weapon 0");

	mov	ecx, DWORD PTR ?Console@@3PAVCConsole@@A ; Console
	add	esp, 8
	push	edi
	push	OFFSET ??_C@_0N@LNDKCEDJ@hud_weapon?50?$AA@
	call	?ExecuteCommand@CConsole@@QAEXPBD_N@Z	; CConsole::ExecuteCommand

; 23   : 	if( g_bBenchmark || g_SASH.IsRunning() )

	cmp	BYTE PTR ?g_bBenchmark@@3_NA, 0		; g_bBenchmark
	jne	SHORT $LN7@CDemoPlay@3
	cmp	BYTE PTR ?g_SASH@@3VxrSASH@@A+2, 0
	je	SHORT $LN67@CDemoPlay@3
$LN7@CDemoPlay@3:

; 24   : 		Console->Execute	("hud_draw 0");

	mov	ecx, DWORD PTR ?Console@@3PAVCConsole@@A ; Console
	push	edi
	push	OFFSET ??_C@_0L@GPCEDEIH@hud_draw?50?$AA@
	call	?ExecuteCommand@CConsole@@QAEXPBD_N@Z	; CConsole::ExecuteCommand
$LN67@CDemoPlay@3:

; 25   : 
; 26   : 	fSpeed				= ms;
; 27   : 	dwCyclesLeft		= cycles?cycles:1;

	mov	eax, DWORD PTR _cycles$[ebp]
	cmp	eax, edi
	movss	xmm0, DWORD PTR _ms$[ebp]
	movss	DWORD PTR [esi+52], xmm0
	jne	SHORT $LN12@CDemoPlay@3
	mov	eax, 1
$LN12@CDemoPlay@3:

; 28   : 
; 29   : 	m_pMotion			= 0;
; 30   : 	m_MParam			= 0;
; 31   : 	string_path			nm, fn;
; 32   : 	xr_strcpy			(nm,sizeof(nm),name);	

	mov	edx, DWORD PTR _name$[ebp]
	push	520					; 00000208H
	push	edx
	mov	DWORD PTR [esi+56], eax
	lea	eax, DWORD PTR _nm$[esp+1136]
	push	520					; 00000208H
	push	eax
	mov	DWORD PTR [esi+24], edi
	mov	DWORD PTR [esi+28], edi
	call	DWORD PTR __imp__strncpy_s

; 33   : 	LPSTR extp			=strext(nm);

	lea	ecx, DWORD PTR _nm$[esp+1144]
	push	46					; 0000002eH
	push	ecx
	call	DWORD PTR __imp__strrchr
	add	esp, 24					; 00000018H

; 34   : 	if (extp)	

	cmp	eax, edi
	je	SHORT $LN73@CDemoPlay@3

; 35   : 		xr_strcpy			( nm, sizeof( nm ) - ( extp - nm ), ".anm");

	lea	ecx, DWORD PTR _nm$[esp+1648]
	sub	ecx, eax
	push	ecx
	push	OFFSET ??_C@_04FGKMPKCB@?4anm?$AA@
	push	ecx
	lea	edx, DWORD PTR _nm$[esp+1140]
	push	edx
	call	DWORD PTR __imp__strncpy_s
	add	esp, 16					; 00000010H
$LN73@CDemoPlay@3:

; 36   : 
; 37   : 	if ( FS.exist(fn,"$level$",nm) || FS.exist(fn,"$game_anims$",nm) )

	mov	edx, DWORD PTR __imp_?xr_FS@@3PAVCLocatorAPI@@A
	lea	eax, DWORD PTR _nm$[esp+1128]
	push	eax
	push	OFFSET ??_C@_07DJIBDFPO@$level$?$AA@
	lea	ecx, DWORD PTR _fn$[esp+1136]
	push	ecx
	mov	ecx, DWORD PTR [edx]
	call	DWORD PTR __imp_?exist@CLocatorAPI@@QAEPBUfile@1@AAY0CAI@DPBD1@Z
	test	eax, eax
	jne	$LN4@CDemoPlay@3
	mov	edx, DWORD PTR __imp_?xr_FS@@3PAVCLocatorAPI@@A
	lea	eax, DWORD PTR _nm$[esp+1128]
	push	eax
	push	OFFSET ??_C@_0N@BFDJNKBG@$game_anims$?$AA@
	lea	ecx, DWORD PTR _fn$[esp+1136]
	push	ecx
	mov	ecx, DWORD PTR [edx]
	call	DWORD PTR __imp_?exist@CLocatorAPI@@QAEPBUfile@1@AAY0CAI@DPBD1@Z
	test	eax, eax
	jne	$LN4@CDemoPlay@3

; 44   : 	}else{
; 45   : 		if (!FS.exist(name))						{

	mov	eax, DWORD PTR _name$[ebp]
	mov	ecx, DWORD PTR __imp_?xr_FS@@3PAVCLocatorAPI@@A
	mov	ecx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR __imp_?exist@CLocatorAPI@@QAEPBUfile@1@PBD@Z
	test	eax, eax

; 46   : 			g_pGameLevel->Cameras().RemoveCamEffector	(cefDemo);
; 47   : 			return		;

	je	SHORT $LN128@CDemoPlay@3

; 48   : 		}
; 49   : 		IReader*	fs	= FS.r_open	(name);

	mov	edx, DWORD PTR _name$[ebp]
	mov	eax, DWORD PTR __imp_?xr_FS@@3PAVCLocatorAPI@@A
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	edi
	call	DWORD PTR __imp_?r_open@CLocatorAPI@@QAEPAVIReader@@PBD0@Z
	mov	DWORD PTR _fs$127606[esp+1128], eax

; 50   : 		u32 sz			= fs->length();

	mov	eax, DWORD PTR [eax+16]

; 51   : 		if				(sz%sizeof(Fmatrix) != 0)	{

	test	al, 63					; 0000003fH
	mov	DWORD PTR _sz$127607[esp+1128], eax
	je	SHORT $LN1@CDemoPlay@3

; 52   : 			FS.r_close	(fs);

	mov	ecx, DWORD PTR __imp_?xr_FS@@3PAVCLocatorAPI@@A
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR _fs$127606[esp+1128]
	push	eax
	call	DWORD PTR __imp_?r_close@CLocatorAPI@@QAEXAAPAVIReader@@@Z
$LN128@CDemoPlay@3:

; 53   : 			g_pGameLevel->Cameras().RemoveCamEffector	(cefDemo);

	mov	edx, DWORD PTR ?g_pGameLevel@@3PAVIGame_Level@@A ; g_pGameLevel
	mov	ecx, DWORD PTR [edx+60]
	push	edi
	call	?RemoveCamEffector@CCameraManager@@QAEXW4ECamEffectorType@@@Z ; CCameraManager::RemoveCamEffector

; 65   : }

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN1@CDemoPlay@3:

; 54   : 			return		;
; 55   : 		}
; 56   : 		
; 57   : 		seq.resize		(sz/sizeof(Fmatrix));

	push	64					; 00000040H
	lea	eax, DWORD PTR $T530638[esp+1132]
	push	edi
	push	eax
	call	_memset
	mov	edx, DWORD PTR _sz$127607[esp+1140]
	add	esp, 12					; 0000000cH
	shr	edx, 6
	lea	edi, DWORD PTR $T530638[esp+1128]
	mov	eax, ebx
	call	?resize@?$_Impl_vector@U?$_matrix@M@@V?$xalloc@U?$_matrix@M@@@@@priv@stlp_std@@QAEXIABU?$_matrix@M@@@Z ; stlp_std::priv::_Impl_vector<_matrix<float>,xalloc<_matrix<float> > >::resize

; 58   : 		m_count			= seq.size();

	mov	ecx, DWORD PTR [ebx+4]
	sub	ecx, DWORD PTR [ebx]

; 59   : 		CopyMemory	(&*seq.begin(),fs->pointer(),sz);

	mov	eax, DWORD PTR _fs$127606[esp+1128]
	mov	edx, DWORD PTR _sz$127607[esp+1128]
	sar	ecx, 6
	mov	DWORD PTR [esi+44], ecx
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, DWORD PTR [eax+8]
	push	edx
	mov	edx, DWORD PTR [ebx]
	push	ecx
	push	edx
	call	_memcpy

; 60   : 		FS.r_close		(fs);

	mov	ecx, DWORD PTR __imp_?xr_FS@@3PAVCLocatorAPI@@A
	mov	ecx, DWORD PTR [ecx]
	add	esp, 12					; 0000000cH
	lea	eax, DWORD PTR _fs$127606[esp+1128]
	push	eax
	call	DWORD PTR __imp_?r_close@CLocatorAPI@@QAEXAAPAVIReader@@@Z

; 61   : 		Log				("~ Total key-frames: ",m_count);

	mov	edx, DWORD PTR [esi+44]
	push	edx
	push	OFFSET ??_C@_0BF@BJCJNHMJ@?$HO?5Total?5key?9frames?3?5?$AA@
	call	DWORD PTR __imp_?Log@@YAXPBDH@Z
	add	esp, 8
	xor	edi, edi
	jmp	$LN3@CDemoPlay@3
$LN4@CDemoPlay@3:

; 38   : 	{
; 39   : 		m_pMotion				= xr_new<COMotion>		();

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ebx, DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	push	48					; 00000030H
	call	ebx
	cmp	eax, edi
	je	SHORT $LN77@CDemoPlay@3
	mov	ecx, eax
	call	??0COMotion@@QAE@XZ			; COMotion::COMotion
	jmp	SHORT $LN78@CDemoPlay@3
$LN77@CDemoPlay@3:
	xor	eax, eax
$LN78@CDemoPlay@3:
	mov	DWORD PTR [esi+24], eax

; 40   : 		m_pMotion->LoadMotion	(fn);

	mov	edx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx+16]
	lea	ecx, DWORD PTR _fn$[esp+1128]
	push	ecx
	mov	ecx, eax
	call	edx

; 41   : 		m_MParam				= xr_new<SAnimParams>	();

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	24					; 00000018H
	call	ebx
	cmp	eax, edi
	je	SHORT $LN83@CDemoPlay@3
	xorps	xmm0, xmm0
	mov	DWORD PTR [eax+20], edi
	mov	DWORD PTR [eax+16], edi
	movss	DWORD PTR [eax], xmm0
	movss	DWORD PTR [eax+8], xmm0
	movss	DWORD PTR [eax+12], xmm0
	movss	DWORD PTR [eax+4], xmm0
	jmp	SHORT $LN84@CDemoPlay@3
$LN83@CDemoPlay@3:
	xor	eax, eax
$LN84@CDemoPlay@3:

; 42   : 		m_MParam->Set			(m_pMotion);

	mov	ecx, DWORD PTR [esi+24]
	movss	xmm0, DWORD PTR __real@3f800000
	mov	DWORD PTR [esi+28], eax
	movss	xmm1, DWORD PTR [ecx+16]
	mov	edx, DWORD PTR [ecx+12]
	divss	xmm0, xmm1
	cvtsi2ss xmm1, DWORD PTR [ecx+8]
	mulss	xmm1, xmm0
	movss	DWORD PTR [eax+8], xmm1
	cvtsi2ss xmm1, edx
	mulss	xmm1, xmm0
	movss	xmm0, DWORD PTR [eax+8]
	movss	DWORD PTR [eax+12], xmm1
	movss	DWORD PTR [eax], xmm0
	movss	DWORD PTR [eax+4], xmm0

; 43   : 		m_MParam->Play			();

	mov	eax, DWORD PTR [esi+28]
	movss	xmm0, DWORD PTR [eax+8]
	mov	DWORD PTR [eax+16], 1
	movss	DWORD PTR [eax], xmm0
	movss	DWORD PTR [eax+4], xmm0
$LN3@CDemoPlay@3:

; 62   : 	}
; 63   : 	stat_started		= FALSE;
; 64   : 	Device.PreCache		(50, true, false);

	push	edi
	push	1
	push	50					; 00000032H
	mov	ecx, OFFSET ?Device@@3VCRenderDevice@@A	; Device
	mov	DWORD PTR [esi+60], edi
	call	?PreCache@CRenderDevice@@QAEXI_N0@Z	; CRenderDevice::PreCache

; 65   : }

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??0CDemoPlay@@QAE@PBDMIM@Z ENDP				; CDemoPlay::CDemoPlay
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_ECDemoPlay@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_ECDemoPlay@@UAEPAXI@Z PROC				; CDemoPlay::`vector deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 2
	push	ebp
	mov	ebp, ecx
	je	SHORT $LN3@vector@100
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR [ebp-4]
	lea	ebx, DWORD PTR [ebp-4]
	lea	esi, DWORD PTR [edi+edi*2]
	shl	esi, 6
	add	esi, ebp
	sub	edi, 1
	js	SHORT $LN6@vector@100
$LL7@vector@100:
	sub	esi, 192				; 000000c0H
	mov	ecx, esi
	call	??1CDemoPlay@@UAE@XZ			; CDemoPlay::~CDemoPlay
	sub	edi, 1
	jns	SHORT $LL7@vector@100
$LN6@vector@100:
	test	BYTE PTR ___flags$[esp+12], 1
	je	SHORT $LN12@vector@100
	test	ebx, ebx
	je	SHORT $LN12@vector@100
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	ebx
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN12@vector@100:
	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx
	pop	ebp
	ret	4
$LN3@vector@100:
	call	??1CDemoPlay@@UAE@XZ			; CDemoPlay::~CDemoPlay
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN17@vector@100
	test	ebp, ebp
	je	SHORT $LN17@vector@100
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	ebp
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN17@vector@100:
	mov	eax, ebp
	pop	ebp
	ret	4
??_ECDemoPlay@@UAEPAXI@Z ENDP				; CDemoPlay::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_GCDemoPlay@@UAEPAXI@Z			; CDemoPlay::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GCDemoPlay@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCDemoPlay@@UAEPAXI@Z PROC				; CDemoPlay::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CDemoPlay@@UAE@XZ			; CDemoPlay::~CDemoPlay
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN10@scalar@90
	test	esi, esi
	je	SHORT $LN10@scalar@90
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN10@scalar@90:
	mov	eax, esi
	pop	esi
	ret	4
??_GCDemoPlay@@UAEPAXI@Z ENDP				; CDemoPlay::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ?ProcessCam@CDemoPlay@@UAEHAAUSCamEffectorInfo@@@Z
_TEXT	SEGMENT
tv509 = -120						; size = 4
_a$544254 = -120					; size = 4
_m2$127776 = -120					; size = 4
_p$127751 = -120					; size = 4
$T544158 = -120						; size = 4
tv1444 = -116						; size = 4
_t$127752 = -116					; size = 4
tv1634 = -112						; size = 4
tv1603 = -108						; size = 4
tv1608 = -104						; size = 4
tv1639 = -100						; size = 4
tv1613 = -96						; size = 4
tv1618 = -92						; size = 4
tv1622 = -88						; size = 4
_this$ = -84						; size = 4
__Di$544250 = -80					; size = 8
_R$127745 = -80						; size = 12
_mInvCamera$127789 = -64				; size = 64
_v$127779 = -64						; size = 48
_mRotate$127746 = -64					; size = 64
_info$ = 8						; size = 4
?ProcessCam@CDemoPlay@@UAEHAAUSCamEffectorInfo@@@Z PROC	; CDemoPlay::ProcessCam, COMDAT
; _this$ = ecx

; 210  : {

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	sub	esp, 180				; 000000b4H
	push	ebx
	push	esi
	push	edi

; 211  : 	// skeep a few frames before counting
; 212  : 	if (Device.dwPrecacheFrame)	return	TRUE;

	xor	edi, edi
	cmp	DWORD PTR ?Device@@3VCRenderDevice@@A+12, edi
	mov	ebx, ecx
	mov	DWORD PTR _this$[esp+192], ebx
	jne	$LN18@ProcessCam@3

; 213  : 
; 214  : 	if (stat_started)

	cmp	DWORD PTR [ebx+60], edi
	jne	SHORT $LN21@ProcessCam@3

; 215  : 	{
; 216  : 		//g_SASH.DisplayFrame(Device.fTimeGlobal);
; 217  : 	}
; 218  : 	else
; 219  : 	{
; 220  : 		//g_SASH.StartBenchmark();
; 221  : 		stat_Start();

	call	?stat_Start@CDemoPlay@@AAEXXZ		; CDemoPlay::stat_Start
$LN21@ProcessCam@3:

; 222  : 	}
; 223  : 
; 224  : 	// Per-frame statistics
; 225  : 	{
; 226  : 		stat_table.push_back		(stat_Timer_frame.GetElapsed_sec());

	lea	esi, DWORD PTR [ebx+64]
	mov	ecx, esi
	call	DWORD PTR __imp_?GetElapsed_sec@CTimer@@QBEMXZ
	fstp	DWORD PTR $T544158[esp+192]
	mov	eax, DWORD PTR [ebx+184]
	cmp	eax, DWORD PTR [ebx+188]
	lea	ecx, DWORD PTR [ebx+180]
	je	SHORT $LN31@ProcessCam@3
	cmp	eax, edi
	je	SHORT $LN36@ProcessCam@3
	movss	xmm0, DWORD PTR $T544158[esp+192]
	movss	DWORD PTR [eax], xmm0
$LN36@ProcessCam@3:
	add	DWORD PTR [ecx+4], 4
	jmp	SHORT $LN30@ProcessCam@3
$LN31@ProcessCam@3:
	push	1
	push	1
	push	eax
	lea	eax, DWORD PTR $T544158[esp+204]
	mov	edi, ecx
	call	?_M_insert_overflow@?$_Impl_vector@MV?$xalloc@M@@@priv@stlp_std@@AAEXPAMABMABU__true_type@3@I_N@Z ; stlp_std::priv::_Impl_vector<float,xalloc<float> >::_M_insert_overflow
	xor	edi, edi
$LN30@ProcessCam@3:

; 227  : 		stat_Timer_frame.Start		();

	cmp	DWORD PTR [esi+24], edi
	jne	SHORT $LN41@ProcessCam@3
	call	DWORD PTR __imp_?QPC@CPU@@YA_KXZ
	sub	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [esi+40], edi
	sbb	edx, DWORD PTR [esi+20]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], edx
	mov	DWORD PTR [esi+44], edi
	mov	DWORD PTR [esi+48], edi
	mov	DWORD PTR [esi+52], edi
$LN41@ProcessCam@3:

; 228  : 	}
; 229  : 
; 230  : 	// Process motion
; 231  : 	if (m_pMotion)

	mov	ecx, DWORD PTR [ebx+24]
	cmp	ecx, edi
	je	$LN20@ProcessCam@3

; 232  : 	{
; 233  : 		Fvector R;
; 234  : 		Fmatrix mRotate;
; 235  : 		m_pMotion->_Evaluate	(m_MParam->Frame(),info.p,R);

	mov	edx, DWORD PTR _info$[ebp]
	lea	eax, DWORD PTR _R$127745[esp+192]
	push	eax
	mov	eax, DWORD PTR [ebx+28]
	fld	DWORD PTR [eax]
	push	edx
	push	ecx
	fstp	DWORD PTR [esp]
	call	?_Evaluate@COMotion@@QAEXMAAU?$_vector3@M@@0@Z ; COMotion::_Evaluate

; 236  : 		m_MParam->Update		(Device.fTimeDelta,1.f,true);

	fld1
	mov	edi, DWORD PTR [ebx+28]
	movss	xmm0, DWORD PTR ?Device@@3VCRenderDevice@@A+28
	push	1
	push	ecx
	fstp	DWORD PTR [esp]
	call	?Update@SAnimParams@@QAEXMM_N@Z		; SAnimParams::Update

; 237  : 		fLifeTime				-= Device.fTimeDelta;

	movss	xmm0, DWORD PTR [ebx+16]
	subss	xmm0, DWORD PTR ?Device@@3VCRenderDevice@@A+28

; 238  : 		if (m_MParam->bWrapped)	{ stat_Stop(); stat_Start(); }

	mov	ecx, DWORD PTR [ebx+28]
	movss	DWORD PTR [ebx+16], xmm0
	cmp	DWORD PTR [ecx+20], 0
	je	SHORT $LN19@ProcessCam@3
	mov	ecx, ebx
	call	?stat_Stop@CDemoPlay@@AAEXXZ		; CDemoPlay::stat_Stop
	mov	ecx, ebx
	call	?stat_Start@CDemoPlay@@AAEXXZ		; CDemoPlay::stat_Start
$LN19@ProcessCam@3:

; 239  : 		mRotate.setXYZi			(R.x,R.y,R.z);

	fld	DWORD PTR _R$127745[esp+200]
	sub	esp, 12					; 0000000cH
	fstp	DWORD PTR [esp+8]
	lea	esi, DWORD PTR _mRotate$127746[esp+204]
	fld	DWORD PTR _R$127745[esp+208]
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR _R$127745[esp+204]
	fstp	DWORD PTR [esp]
	call	?setXYZi@?$_matrix@M@@QAEAAU1@MMM@Z	; _matrix<float>::setXYZi

; 240  : 		info.d.set				(mRotate.k);

	mov	eax, DWORD PTR _info$[ebp]
	movss	xmm0, DWORD PTR _mRotate$127746[esp+224]
	movss	DWORD PTR [eax+12], xmm0
	movss	xmm0, DWORD PTR _mRotate$127746[esp+228]
	movss	DWORD PTR [eax+16], xmm0
	movss	xmm0, DWORD PTR _mRotate$127746[esp+232]
	movss	DWORD PTR [eax+20], xmm0

; 241  : 		info.n.set				(mRotate.j);

	movss	xmm0, DWORD PTR _mRotate$127746[esp+208]
	movss	DWORD PTR [eax+24], xmm0
	movss	xmm0, DWORD PTR _mRotate$127746[esp+212]
	movss	DWORD PTR [eax+28], xmm0
	movss	xmm0, DWORD PTR _mRotate$127746[esp+216]
	movss	DWORD PTR [eax+32], xmm0

; 295  : 	}
; 296  : 	return TRUE;

	mov	eax, 1

; 297  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN20@ProcessCam@3:

; 242  : 	}
; 243  : 	else
; 244  : 	{
; 245  : 		if (seq.empty()) {

	mov	edx, DWORD PTR [ebx+32]
	cmp	edx, DWORD PTR [ebx+36]
	jne	SHORT $LN17@ProcessCam@3

; 246  : 			g_pGameLevel->Cameras().RemoveCamEffector(cefDemo);

	mov	eax, DWORD PTR ?g_pGameLevel@@3PAVIGame_Level@@A ; g_pGameLevel
	mov	ecx, DWORD PTR [eax+60]
	push	edi
	call	?RemoveCamEffector@CCameraManager@@QAEXW4ECamEffectorType@@@Z ; CCameraManager::RemoveCamEffector

; 295  : 	}
; 296  : 	return TRUE;

	mov	eax, 1

; 297  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN17@ProcessCam@3:

; 247  : 			return		TRUE;
; 248  : 		}
; 249  : 
; 250  : 		fStartTime		+=	Device.fTimeDelta;

	movss	xmm0, DWORD PTR [ebx+48]
	addss	xmm0, DWORD PTR ?Device@@3VCRenderDevice@@A+28

; 251  : 		
; 252  : 		float	ip;
; 253  : 		float	p		=	fStartTime/fSpeed;
; 254  : 		float	t		=	modff(p, &ip);

	lea	ecx, DWORD PTR __Di$544250[esp+192]
	movss	DWORD PTR [ebx+48], xmm0
	divss	xmm0, DWORD PTR [ebx+52]
	push	ecx
	movss	DWORD PTR _p$127751[esp+196], xmm0
	fld	DWORD PTR _p$127751[esp+196]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp__modf
	fstp	DWORD PTR _t$127752[esp+204]

; 255  : 		int		frame	=	iFloor(ip);

	mov	ecx, 158				; 0000009eH
	fld	QWORD PTR __Di$544250[esp+204]

; 256  : 		VERIFY	(t>=0);
; 257  : 		
; 258  : 		if (frame>=m_count)

	xorps	xmm7, xmm7
	fstp	DWORD PTR _a$544254[esp+204]
	mov	esi, DWORD PTR _a$544254[esp+204]
	mov	edx, esi
	sar	edx, 23					; 00000017H
	and	edx, 255				; 000000ffH
	sub	ecx, edx
	mov	edx, esi
	or	edx, -8388608				; ff800000H
	shl	edx, 8
	shr	edx, cl
	sub	ecx, 96					; 00000060H
	mov	eax, 1
	shl	eax, cl
	add	esp, 12					; 0000000cH
	sub	eax, 1
	sar	eax, 8
	and	eax, esi
	neg	eax
	sbb	eax, eax
	add	eax, 1
	sar	esi, 31					; 0000001fH
	and	eax, esi
	sub	edx, eax
	mov	eax, DWORD PTR [ebx+44]
	add	ecx, 64					; 00000040H
	sar	ecx, 31					; 0000001fH
	and	edx, ecx
	xor	edx, esi
	cmp	edx, eax
	jl	SHORT $LN13@ProcessCam@3

; 259  : 		{
; 260  : 			dwCyclesLeft			--	;

	add	DWORD PTR [ebx+56], -1

; 261  : 			if (0==dwCyclesLeft)	return FALSE;

	jne	SHORT $LN12@ProcessCam@3
	xor	eax, eax

; 297  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN12@ProcessCam@3:

; 262  : 			fStartTime				= 0	;

	movss	DWORD PTR [ebx+48], xmm7
$LN13@ProcessCam@3:

; 263  : 			// just continue
; 264  : 			// stat_Stop			();
; 265  : 			// stat_Start			();
; 266  : 		}
; 267  : 		
; 268  : 		int f1=frame; FIX(f1);

	cmp	edx, eax
	mov	ecx, edx
	jl	SHORT $LN10@ProcessCam@3
	mov	edx, eax
$LL11@ProcessCam@3:
	sub	ecx, eax
	cmp	ecx, edx
	jge	SHORT $LL11@ProcessCam@3
$LN10@ProcessCam@3:

; 269  : 		int f2=f1+1;  FIX(f2);

	lea	edx, DWORD PTR [ecx+1]
	cmp	edx, eax
	jl	SHORT $LN8@ProcessCam@3
	mov	esi, eax
$LL9@ProcessCam@3:
	sub	edx, eax
	cmp	edx, esi
	jge	SHORT $LL9@ProcessCam@3
$LN8@ProcessCam@3:

; 270  : 		int f3=f2+1;  FIX(f3);

	lea	esi, DWORD PTR [edx+1]
	cmp	esi, eax
	jl	SHORT $LN6@ProcessCam@3
	mov	edi, eax
$LL7@ProcessCam@3:
	sub	esi, eax
	cmp	esi, edi
	jge	SHORT $LL7@ProcessCam@3
$LN6@ProcessCam@3:

; 271  : 		int f4=f3+1;  FIX(f4);

	lea	edi, DWORD PTR [esi+1]
	cmp	edi, eax
	jl	SHORT $LN64@ProcessCam@3
	npad	2
$LL5@ProcessCam@3:
	sub	edi, eax
	cmp	edi, eax
	jge	SHORT $LL5@ProcessCam@3

; 272  : 		
; 273  : 		Fmatrix *m1,*m2,*m3,*m4;
; 274  : 		Fvector v[4];
; 275  : 		m1 = (Fmatrix *) &seq[f1];

$LN64@ProcessCam@3:
	mov	eax, DWORD PTR [ebx+32]

; 276  : 		m2 = (Fmatrix *) &seq[f2];
; 277  : 		m3 = (Fmatrix *) &seq[f3];
; 278  : 		m4 = (Fmatrix *) &seq[f4];

	movss	xmm5, DWORD PTR _t$127752[esp+192]

; 279  : 		
; 280  : 		for (int i=0; i<4; i++) {
; 281  : 			v[0].x = m1->m[i][0]; v[0].y = m1->m[i][1];  v[0].z = m1->m[i][2];
; 282  : 			v[1].x = m2->m[i][0]; v[1].y = m2->m[i][1];  v[1].z = m2->m[i][2];
; 283  : 			v[2].x = m3->m[i][0]; v[2].y = m3->m[i][1];  v[2].z = m3->m[i][2];
; 284  : 			v[3].x = m4->m[i][0]; v[3].y = m4->m[i][1];  v[3].z = m4->m[i][2];
; 285  : 			spline1	( t, &(v[0]), (Fvector *) &(Device.mView.m[i][0]) );

	movss	xmm0, DWORD PTR __real@bf800000
	shl	ecx, 6
	add	ecx, eax
	shl	edx, 6
	add	edx, eax
	mov	ebx, edx
	mov	DWORD PTR _m2$127776[esp+192], ebx
	sub	ebx, ecx
	mov	DWORD PTR tv1603[esp+192], ebx
	shl	esi, 6
	add	esi, eax
	mov	ebx, esi
	sub	ebx, ecx
	mov	DWORD PTR tv1608[esp+192], ebx
	shl	edi, 6
	add	edi, eax
	mov	ebx, edi
	sub	ebx, ecx
	mov	DWORD PTR tv1613[esp+192], ebx
	mov	ebx, OFFSET ?Device@@3VCRenderDevice@@A+92
	sub	ebx, ecx
	mov	DWORD PTR tv1618[esp+192], ebx
	movaps	xmm3, xmm5
	mulss	xmm3, xmm5
	movaps	xmm4, xmm3
	mulss	xmm4, xmm5
	movaps	xmm1, xmm3
	mulss	xmm1, DWORD PTR __real@40000000
	mov	ebx, OFFSET ?Device@@3VCRenderDevice@@A+96
	sub	ebx, ecx
	movaps	xmm2, xmm4
	mulss	xmm2, xmm0
	addss	xmm2, xmm1
	lea	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR tv1622[esp+192], ebx
	movaps	xmm1, xmm5
	mulss	xmm1, xmm0
	addss	xmm2, xmm1
	movss	xmm1, DWORD PTR __real@3f000000
	movaps	xmm6, xmm5
	mulss	xmm6, xmm7
	movaps	xmm7, xmm3
	mulss	xmm7, DWORD PTR __real@c0a00000
	mov	ebx, OFFSET ?Device@@3VCRenderDevice@@A+88
	sub	ebx, ecx
	mov	ecx, DWORD PTR _m2$127776[esp+192]
	sub	ecx, esi
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR _drop_angle
	addss	xmm0, xmm7
	mulss	xmm2, xmm1
	addss	xmm0, xmm6
	addss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, xmm1
	movaps	xmm7, xmm3
	mulss	xmm3, DWORD PTR __real@bf800000
	mulss	xmm7, DWORD PTR __real@40800000
	mov	DWORD PTR tv1634[esp+192], ecx
	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR __real@c0400000
	mov	ecx, edi
	sub	ecx, esi
	addss	xmm1, xmm7
	lea	edx, DWORD PTR [esi+4]
	mov	esi, DWORD PTR _m2$127776[esp+192]
	addss	xmm1, xmm5
	movss	xmm5, DWORD PTR __real@3f000000
	addss	xmm3, xmm6
	addss	xmm3, xmm4
	mov	DWORD PTR tv1639[esp+192], ecx
	mulss	xmm1, xmm5
	mulss	xmm3, xmm5
	mov	DWORD PTR tv1444[esp+192], edi
	sub	esi, edi
	mov	DWORD PTR tv509[esp+192], 4
	mov	ecx, edi
	npad	6
$LL3@ProcessCam@3:
	movss	xmm5, DWORD PTR [eax-4]
	mov	edi, DWORD PTR tv1634[esp+192]
	movss	xmm6, DWORD PTR [edx]
	movss	DWORD PTR _v$127779[esp+196], xmm5
	movss	xmm5, DWORD PTR [eax]
	movss	DWORD PTR _v$127779[esp+200], xmm5
	movss	xmm5, DWORD PTR [esi+ecx]
	movss	DWORD PTR _v$127779[esp+204], xmm5
	movss	xmm5, DWORD PTR [edi+edx]
	mov	edi, DWORD PTR tv1603[esp+192]
	movss	xmm4, DWORD PTR [eax-8]
	movss	DWORD PTR _v$127779[esp+208], xmm5
	movss	xmm5, DWORD PTR [edi+eax]
	mov	edi, DWORD PTR tv1608[esp+192]
	movss	DWORD PTR _v$127779[esp+212], xmm5
	movss	xmm5, DWORD PTR [edx-4]
	movss	DWORD PTR _v$127779[esp+220], xmm6
	movss	xmm6, DWORD PTR [edi+eax]
	mov	edi, DWORD PTR tv1639[esp+192]
	movss	xmm7, DWORD PTR [edi+edx]
	mov	edi, DWORD PTR tv1613[esp+192]
	movss	DWORD PTR _v$127779[esp+232], xmm7
	movss	xmm7, DWORD PTR [edi+eax]
	mov	edi, DWORD PTR tv1618[esp+192]
	movss	DWORD PTR _v$127779[esp+236], xmm7
	movss	DWORD PTR _v$127779[esp+224], xmm6
	movss	xmm6, DWORD PTR [ecx]
	movaps	xmm7, xmm3
	mulss	xmm7, xmm6
	movaps	xmm6, xmm1
	mulss	xmm6, xmm5
	addss	xmm7, xmm6
	movaps	xmm5, xmm0
	mulss	xmm5, DWORD PTR _v$127779[esp+204]
	addss	xmm7, xmm5
	movaps	xmm5, xmm2
	mulss	xmm5, xmm4
	addss	xmm7, xmm5
	movaps	xmm4, xmm3
	mulss	xmm4, DWORD PTR _v$127779[esp+232]
	movaps	xmm5, xmm1
	mulss	xmm5, DWORD PTR _v$127779[esp+220]
	addss	xmm4, xmm5
	movaps	xmm5, xmm0
	mulss	xmm5, DWORD PTR _v$127779[esp+208]
	addss	xmm4, xmm5
	movaps	xmm5, xmm2
	mulss	xmm5, DWORD PTR _v$127779[esp+196]
	addss	xmm4, xmm5
	movss	DWORD PTR [edi+eax], xmm4
	mov	edi, DWORD PTR tv1622[esp+192]
	movaps	xmm4, xmm3
	mulss	xmm4, DWORD PTR _v$127779[esp+236]
	movaps	xmm5, xmm1
	mulss	xmm5, DWORD PTR _v$127779[esp+224]
	addss	xmm4, xmm5
	movaps	xmm5, xmm0
	mulss	xmm5, DWORD PTR _v$127779[esp+212]
	addss	xmm4, xmm5
	movaps	xmm5, xmm2
	mulss	xmm5, DWORD PTR _v$127779[esp+200]
	addss	xmm4, xmm5
	movss	DWORD PTR [ebx+eax], xmm7
	movss	DWORD PTR [edi+eax], xmm4
	add	eax, 16					; 00000010H
	add	edx, 16					; 00000010H
	add	ecx, 16					; 00000010H
	sub	DWORD PTR tv509[esp+192], 1
	jne	$LL3@ProcessCam@3

; 286  : 		}
; 287  : 		
; 288  : 		Fmatrix mInvCamera;
; 289  : 		mInvCamera.invert(Device.mView);

	mov	ecx, OFFSET ?Device@@3VCRenderDevice@@A+96
	lea	eax, DWORD PTR _mInvCamera$127789[esp+192]
	call	?invert@?$_matrix@M@@QAEAAU1@ABU1@@Z	; _matrix<float>::invert

; 290  : 		info.n.set( mInvCamera._21, mInvCamera._22, mInvCamera._23 );

	mov	eax, DWORD PTR _info$[ebp]
	movss	xmm0, DWORD PTR _mInvCamera$127789[esp+208]
	movss	DWORD PTR [eax+24], xmm0
	movss	xmm0, DWORD PTR _mInvCamera$127789[esp+212]
	movss	DWORD PTR [eax+28], xmm0
	movss	xmm0, DWORD PTR _mInvCamera$127789[esp+216]
	movss	DWORD PTR [eax+32], xmm0

; 291  : 		info.d.set( mInvCamera._31, mInvCamera._32, mInvCamera._33 );

	movss	xmm0, DWORD PTR _mInvCamera$127789[esp+224]
	movss	DWORD PTR [eax+12], xmm0
	movss	xmm0, DWORD PTR _mInvCamera$127789[esp+228]
	movss	DWORD PTR [eax+16], xmm0
	movss	xmm0, DWORD PTR _mInvCamera$127789[esp+232]
	movss	DWORD PTR [eax+20], xmm0

; 292  : 		info.p.set( mInvCamera._41, mInvCamera._42, mInvCamera._43 );

	movss	xmm0, DWORD PTR _mInvCamera$127789[esp+240]
	movss	DWORD PTR [eax], xmm0
	movss	xmm0, DWORD PTR _mInvCamera$127789[esp+244]
	movss	DWORD PTR [eax+4], xmm0
	movss	xmm0, DWORD PTR _mInvCamera$127789[esp+248]
	movss	DWORD PTR [eax+8], xmm0

; 293  : 		
; 294  : 		fLifeTime-=Device.fTimeDelta;

	mov	eax, DWORD PTR _this$[esp+192]
	movss	xmm0, DWORD PTR [eax+16]
	subss	xmm0, DWORD PTR ?Device@@3VCRenderDevice@@A+28
	movss	DWORD PTR [eax+16], xmm0
$LN18@ProcessCam@3:

; 297  : }

	pop	edi
	pop	esi
	mov	eax, 1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ProcessCam@CDemoPlay@@UAEHAAUSCamEffectorInfo@@@Z ENDP	; CDemoPlay::ProcessCam
END

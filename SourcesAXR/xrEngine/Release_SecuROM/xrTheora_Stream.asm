; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	D:\CLEARSKY\sources\engine\xrEngine\xrTheora_Stream.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_ECTheoraStream@@UAEPAXI@Z			; CTheoraStream::`vector deleting destructor'
PUBLIC	??_R4CTheoraStream@@6B@				; CTheoraStream::`RTTI Complete Object Locator'
PUBLIC	??_R3CTheoraStream@@8				; CTheoraStream::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CTheoraStream@@8				; CTheoraStream::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CTheoraStream@@8			; CTheoraStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCTheoraStream@@@8			; CTheoraStream `RTTI Type Descriptor'
PUBLIC	??_C@_0DG@KBFPEDPM@Error?5parsing?5Theora?5stream?5head@ ; `string'
PUBLIC	??_C@_0CP@JMOPMEJE@End?5of?5file?5while?5searching?5for?5@ ; `string'
PUBLIC	??_C@_0BM@NLDCJONH@CTheoraStream?3?3ParseHeaders?$AA@ ; `string'
PUBLIC	??_C@_0DI@KNAMDIEA@D?3?2CLEARSKY?2sources?2engine?2xrEng@ ; `string'
PUBLIC	??_7CTheoraStream@@6B@				; CTheoraStream::`vftable'
EXTRN	__imp_?r_close@CLocatorAPI@@QAEXAAPAVCStreamReader@@@Z:PROC
EXTRN	_ogg_sync_clear:PROC
EXTRN	_ogg_sync_reset:PROC
EXTRN	_ogg_stream_reset:PROC
EXTRN	__imp_?seek@CStreamReader@@QAEXABH@Z:PROC
EXTRN	_ogg_sync_buffer:PROC
EXTRN	_ogg_sync_wrote:PROC
EXTRN	__imp_?r@CStreamReader@@QAEXPAXI@Z:PROC
EXTRN	__imp____iob_func:PROC
EXTRN	__imp__fprintf:PROC
EXTRN	__imp__printf:PROC
EXTRN	_ogg_stream_init:PROC
EXTRN	_ogg_stream_clear:PROC
EXTRN	_ogg_page_bos:PROC
EXTRN	_ogg_page_serialno:PROC
EXTRN	__imp_?impl@?$IReaderBase@VCStreamReader@@@@QBEABVCStreamReader@@XZ:PROC
EXTRN	__imp_?tell@CStreamReader@@QBEIXZ:PROC
EXTRN	__imp_?elapsed@CStreamReader@@QBEIXZ:PROC
EXTRN	__imp_?eof@?$IReaderBase@VCStreamReader@@@@QBEHXZ:PROC
EXTRN	_ogg_sync_pageout:PROC
EXTRN	_ogg_stream_pagein:PROC
EXTRN	_ogg_stream_packetout:PROC
EXTRN	__imp_?rs_open@CLocatorAPI@@QAEPAVCStreamReader@@PBD0@Z:PROC
EXTRN	_ogg_sync_init:PROC
;	COMDAT ??_7CTheoraStream@@6B@
CONST	SEGMENT
??_7CTheoraStream@@6B@ DD FLAT:??_R4CTheoraStream@@6B@	; CTheoraStream::`vftable'
	DD	FLAT:??_ECTheoraStream@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4CTheoraStream@@6B@
rdata$r	SEGMENT
??_R4CTheoraStream@@6B@ DD 00H				; CTheoraStream::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCTheoraStream@@@8
	DD	FLAT:??_R3CTheoraStream@@8
rdata$r	ENDS
;	COMDAT ??_R3CTheoraStream@@8
rdata$r	SEGMENT
??_R3CTheoraStream@@8 DD 00H				; CTheoraStream::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CTheoraStream@@8
rdata$r	ENDS
;	COMDAT ??_R2CTheoraStream@@8
rdata$r	SEGMENT
??_R2CTheoraStream@@8 DD FLAT:??_R1A@?0A@EA@CTheoraStream@@8 ; CTheoraStream::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CTheoraStream@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CTheoraStream@@8 DD FLAT:??_R0?AVCTheoraStream@@@8 ; CTheoraStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CTheoraStream@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCTheoraStream@@@8
_DATA	SEGMENT
??_R0?AVCTheoraStream@@@8 DD FLAT:??_7type_info@@6B@	; CTheoraStream `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCTheoraStream@@', 00H
_DATA	ENDS
;	COMDAT ??_C@_0DI@KNAMDIEA@D?3?2CLEARSKY?2sources?2engine?2xrEng@
CONST	SEGMENT
??_C@_0DI@KNAMDIEA@D?3?2CLEARSKY?2sources?2engine?2xrEng@ DB 'D:\CLEARSKY'
	DB	'\sources\engine\xrEngine\xrTheora_Stream.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@NLDCJONH@CTheoraStream?3?3ParseHeaders?$AA@
CONST	SEGMENT
??_C@_0BM@NLDCJONH@CTheoraStream?3?3ParseHeaders?$AA@ DB 'CTheoraStream::'
	DB	'ParseHeaders', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@JMOPMEJE@End?5of?5file?5while?5searching?5for?5@
CONST	SEGMENT
??_C@_0CP@JMOPMEJE@End?5of?5file?5while?5searching?5for?5@ DB 'End of fil'
	DB	'e while searching for codec headers.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@KBFPEDPM@Error?5parsing?5Theora?5stream?5head@
CONST	SEGMENT
??_C@_0DG@KBFPEDPM@Error?5parsing?5Theora?5stream?5head@ DB 'Error parsin'
	DB	'g Theora stream headers; corrupt stream?', 0aH, 00H ; `string'
PUBLIC	?ReadData@CTheoraStream@@IAEHXZ			; CTheoraStream::ReadData
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\xrtheora_stream.cpp
;	COMDAT ?ReadData@CTheoraStream@@IAEHXZ
_TEXT	SEGMENT
?ReadData@CTheoraStream@@IAEHXZ PROC			; CTheoraStream::ReadData, COMDAT
; _this$ = ecx

; 49   : {

	push	esi
	push	edi
	mov	esi, ecx

; 50   : 	char *buffer		= ogg_sync_buffer(&o_sync_state,4096);

	lea	edi, DWORD PTR [esi+8]
	push	4096					; 00001000H
	push	edi
	call	_ogg_sync_buffer

; 51   : 	long bytes			= 4096>(size_t)source->elapsed()?source->elapsed():4096;

	mov	ecx, DWORD PTR [esi+560]
	mov	edx, DWORD PTR [ecx+40]
	sub	edx, DWORD PTR [ecx+44]
	add	esp, 8
	sub	edx, DWORD PTR [ecx+28]
	add	edx, DWORD PTR [ecx+16]
	cmp	edx, 4096				; 00001000H
	jae	SHORT $LN3@ReadData
	mov	esi, DWORD PTR [ecx+40]
	sub	esi, DWORD PTR [ecx+44]
	sub	esi, DWORD PTR [ecx+28]
	add	esi, DWORD PTR [ecx+16]
	jmp	SHORT $LN4@ReadData
$LN3@ReadData:
	mov	esi, 4096				; 00001000H
$LN4@ReadData:

; 52   : 	source->r			(buffer, bytes);	

	push	esi
	push	eax
	call	DWORD PTR __imp_?r@CStreamReader@@QAEXPAXI@Z

; 53   : 	ogg_sync_wrote		(&o_sync_state,bytes);

	push	esi
	push	edi
	call	_ogg_sync_wrote
	add	esp, 8
	pop	edi

; 54   : 	return bytes;

	mov	eax, esi
	pop	esi

; 55   : }

	ret	0
?ReadData@CTheoraStream@@IAEHXZ ENDP			; CTheoraStream::ReadData
_TEXT	ENDS
PUBLIC	?Reset@CTheoraStream@@QAEXXZ			; CTheoraStream::Reset
; Function compile flags: /Ogtpy
;	COMDAT ?Reset@CTheoraStream@@QAEXXZ
_TEXT	SEGMENT
$T213626 = -4						; size = 4
?Reset@CTheoraStream@@QAEXXZ PROC			; CTheoraStream::Reset, COMDAT
; _this$ = ecx

; 40   : {

	push	ecx
	push	esi
	mov	esi, ecx

; 41   : 	source->seek		(0);

	mov	ecx, DWORD PTR [esi+560]
	lea	eax, DWORD PTR $T213626[esp+8]
	push	eax
	mov	DWORD PTR $T213626[esp+12], 0
	call	DWORD PTR __imp_?seek@CStreamReader@@QAEXABH@Z

; 42   : 	ogg_stream_reset	(&o_stream_state);

	lea	ecx, DWORD PTR [esi+56]
	push	ecx
	call	_ogg_stream_reset

; 43   : 	ogg_sync_reset		(&o_sync_state);

	lea	edx, DWORD PTR [esi+8]
	push	edx
	call	_ogg_sync_reset
	add	esp, 8

; 44   : 	t_state.granulepos	= -1;

	or	eax, -1
	mov	DWORD PTR [esi+544], eax
	mov	DWORD PTR [esi+548], eax

; 45   : 	d_frame				= -1;

	mov	DWORD PTR [esi+600], eax
	mov	DWORD PTR [esi+604], eax
	pop	esi

; 46   : }

	pop	ecx
	ret	0
?Reset@CTheoraStream@@QAEXXZ ENDP			; CTheoraStream::Reset
_TEXT	ENDS
PUBLIC	??0CTheoraStream@@QAE@XZ			; CTheoraStream::CTheoraStream
; Function compile flags: /Ogtpy
;	COMDAT ??0CTheoraStream@@QAE@XZ
_TEXT	SEGMENT
??0CTheoraStream@@QAE@XZ PROC				; CTheoraStream::CTheoraStream, COMDAT
; _this$ = ecx

; 11   : 	// clear self
; 12   : 	source				= 0;
; 13   : 	fpms				= 0.f;

	xorps	xmm0, xmm0

; 14   : 	d_frame				= -1;

	or	eax, -1
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi+600], eax
	mov	DWORD PTR [esi+604], eax

; 15   : 	tm_total			= 0;
; 16   : 	key_rate			= 0;
; 17   : 	// start up Ogg stream synchronization layer
; 18   : 	ogg_sync_init		(&o_sync_state);

	lea	eax, DWORD PTR [esi+8]
	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7CTheoraStream@@6B@
	mov	DWORD PTR [esi+560], 0
	movss	DWORD PTR [esi+616], xmm0
	mov	DWORD PTR [esi+608], 0
	mov	DWORD PTR [esi+612], 0
	call	_ogg_sync_init

; 19   : 	// init supporting Theora structures needed in header parsing
; 20   : 	theora_comment_init	(&t_comment);

	xor	eax, eax
	mov	DWORD PTR [esi+520], eax

; 21   : 	theora_info_init	(&t_info);

	push	104					; 00000068H
	mov	DWORD PTR [esi+524], eax
	push	eax
	lea	ecx, DWORD PTR [esi+416]
	mov	DWORD PTR [esi+528], eax
	push	ecx
	mov	DWORD PTR [esi+532], eax
	call	_memset

; 22   : 	// clear struct
; 23   : 	Memory.mem_fill		(&o_stream_state,0,sizeof(o_stream_state));

	mov	eax, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ecx, DWORD PTR [eax+12]
	add	esp, 16					; 00000010H
	push	360					; 00000168H
	push	0
	lea	edx, DWORD PTR [esi+56]
	push	edx
	call	ecx

; 24   : 	Memory.mem_fill		(&o_page,0,sizeof(o_page));

	mov	eax, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ecx, DWORD PTR [eax+12]
	push	16					; 00000010H
	push	0
	lea	edx, DWORD PTR [esi+36]
	push	edx
	call	ecx

; 25   : 	Memory.mem_fill		(&t_state,0,sizeof(t_state));

	mov	eax, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ecx, DWORD PTR [eax+12]
	push	24					; 00000018H
	push	0
	lea	edx, DWORD PTR [esi+536]
	push	edx
	call	ecx

; 26   : 	Memory.mem_fill		(&t_yuv_buffer,0,sizeof(t_yuv_buffer));

	mov	eax, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ecx, DWORD PTR [eax+12]
	push	36					; 00000024H
	push	0
	lea	edx, DWORD PTR [esi+564]
	push	edx
	call	ecx

; 27   : }

	mov	eax, esi
	pop	esi
	ret	0
??0CTheoraStream@@QAE@XZ ENDP				; CTheoraStream::CTheoraStream
_TEXT	ENDS
PUBLIC	??4CTheoraStream@@QAEAAV0@ABV0@@Z		; CTheoraStream::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4CTheoraStream@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4CTheoraStream@@QAEAAV0@ABV0@@Z PROC			; CTheoraStream::operator=, COMDAT
; _this$ = ecx
	mov	edx, DWORD PTR ___that$[esp-4]
	mov	eax, ecx
	push	esi
	push	edi
	lea	esi, DWORD PTR [edx+8]
	lea	edi, DWORD PTR [eax+8]
	mov	ecx, 7
	rep movsd
	mov	ecx, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+36], ecx
	mov	ecx, DWORD PTR [edx+40]
	mov	DWORD PTR [eax+40], ecx
	mov	ecx, DWORD PTR [edx+44]
	mov	DWORD PTR [eax+44], ecx
	mov	ecx, DWORD PTR [edx+48]
	mov	DWORD PTR [eax+48], ecx
	lea	esi, DWORD PTR [edx+56]
	lea	edi, DWORD PTR [eax+56]
	mov	ecx, 90					; 0000005aH
	rep movsd
	lea	esi, DWORD PTR [edx+416]
	lea	edi, DWORD PTR [eax+416]
	mov	ecx, 26					; 0000001aH
	rep movsd
	mov	ecx, DWORD PTR [edx+520]
	mov	DWORD PTR [eax+520], ecx
	mov	ecx, DWORD PTR [edx+524]
	mov	DWORD PTR [eax+524], ecx
	mov	ecx, DWORD PTR [edx+528]
	mov	DWORD PTR [eax+528], ecx
	mov	ecx, DWORD PTR [edx+532]
	mov	DWORD PTR [eax+532], ecx
	mov	ecx, DWORD PTR [edx+536]
	mov	DWORD PTR [eax+536], ecx
	mov	ecx, DWORD PTR [edx+540]
	mov	DWORD PTR [eax+540], ecx
	mov	ecx, DWORD PTR [edx+544]
	mov	DWORD PTR [eax+544], ecx
	mov	ecx, DWORD PTR [edx+548]
	mov	DWORD PTR [eax+548], ecx
	mov	ecx, DWORD PTR [edx+552]
	mov	DWORD PTR [eax+552], ecx
	mov	ecx, DWORD PTR [edx+556]
	mov	DWORD PTR [eax+556], ecx
	mov	ecx, DWORD PTR [edx+560]
	mov	DWORD PTR [eax+560], ecx
	lea	esi, DWORD PTR [edx+564]
	lea	edi, DWORD PTR [eax+564]
	mov	ecx, 9
	rep movsd
	mov	ecx, DWORD PTR [edx+600]
	mov	DWORD PTR [eax+600], ecx
	mov	ecx, DWORD PTR [edx+604]
	mov	DWORD PTR [eax+604], ecx
	mov	ecx, DWORD PTR [edx+608]
	mov	DWORD PTR [eax+608], ecx
	mov	ecx, DWORD PTR [edx+612]
	mov	DWORD PTR [eax+612], ecx
	pop	edi
	fld	DWORD PTR [edx+616]
	pop	esi
	fstp	DWORD PTR [eax+616]
	ret	4
??4CTheoraStream@@QAEAAV0@ABV0@@Z ENDP			; CTheoraStream::operator=
_TEXT	ENDS
PUBLIC	??0CTheoraStream@@QAE@ABV0@@Z			; CTheoraStream::CTheoraStream
; Function compile flags: /Ogtpy
;	COMDAT ??0CTheoraStream@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0CTheoraStream@@QAE@ABV0@@Z PROC			; CTheoraStream::CTheoraStream, COMDAT
; _this$ = ecx
	mov	edx, DWORD PTR ___that$[esp-4]
	mov	eax, ecx
	mov	DWORD PTR [eax], OFFSET ??_7CTheoraStream@@6B@
	push	esi
	push	edi
	lea	esi, DWORD PTR [edx+8]
	lea	edi, DWORD PTR [eax+8]
	mov	ecx, 7
	rep movsd
	mov	ecx, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+36], ecx
	mov	ecx, DWORD PTR [edx+40]
	mov	DWORD PTR [eax+40], ecx
	mov	ecx, DWORD PTR [edx+44]
	mov	DWORD PTR [eax+44], ecx
	mov	ecx, DWORD PTR [edx+48]
	mov	DWORD PTR [eax+48], ecx
	lea	esi, DWORD PTR [edx+56]
	lea	edi, DWORD PTR [eax+56]
	mov	ecx, 90					; 0000005aH
	rep movsd
	lea	esi, DWORD PTR [edx+416]
	lea	edi, DWORD PTR [eax+416]
	mov	ecx, 26					; 0000001aH
	rep movsd
	mov	ecx, DWORD PTR [edx+520]
	mov	DWORD PTR [eax+520], ecx
	mov	ecx, DWORD PTR [edx+524]
	mov	DWORD PTR [eax+524], ecx
	mov	ecx, DWORD PTR [edx+528]
	mov	DWORD PTR [eax+528], ecx
	mov	ecx, DWORD PTR [edx+532]
	mov	DWORD PTR [eax+532], ecx
	mov	ecx, DWORD PTR [edx+536]
	mov	DWORD PTR [eax+536], ecx
	mov	ecx, DWORD PTR [edx+540]
	mov	DWORD PTR [eax+540], ecx
	mov	ecx, DWORD PTR [edx+544]
	mov	DWORD PTR [eax+544], ecx
	mov	ecx, DWORD PTR [edx+548]
	mov	DWORD PTR [eax+548], ecx
	mov	ecx, DWORD PTR [edx+552]
	mov	DWORD PTR [eax+552], ecx
	mov	ecx, DWORD PTR [edx+556]
	mov	DWORD PTR [eax+556], ecx
	mov	ecx, DWORD PTR [edx+560]
	mov	DWORD PTR [eax+560], ecx
	lea	esi, DWORD PTR [edx+564]
	lea	edi, DWORD PTR [eax+564]
	mov	ecx, 9
	rep movsd
	mov	ecx, DWORD PTR [edx+600]
	mov	DWORD PTR [eax+600], ecx
	mov	ecx, DWORD PTR [edx+604]
	mov	DWORD PTR [eax+604], ecx
	mov	ecx, DWORD PTR [edx+608]
	mov	DWORD PTR [eax+608], ecx
	mov	ecx, DWORD PTR [edx+612]
	mov	DWORD PTR [eax+612], ecx
	pop	edi
	fld	DWORD PTR [edx+616]
	pop	esi
	fstp	DWORD PTR [eax+616]
	ret	4
??0CTheoraStream@@QAE@ABV0@@Z ENDP			; CTheoraStream::CTheoraStream
_TEXT	ENDS
PUBLIC	?CurrentFrame@CTheoraStream@@QAEPAUyuv_buffer@@XZ ; CTheoraStream::CurrentFrame
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\xrtheora_stream.h
;	COMDAT ?CurrentFrame@CTheoraStream@@QAEPAUyuv_buffer@@XZ
_TEXT	SEGMENT
?CurrentFrame@CTheoraStream@@QAEPAUyuv_buffer@@XZ PROC	; CTheoraStream::CurrentFrame, COMDAT
; _this$ = ecx

; 42   : 	yuv_buffer*			CurrentFrame		()					{return &t_yuv_buffer;}

	lea	eax, DWORD PTR [ecx+564]
	ret	0
?CurrentFrame@CTheoraStream@@QAEPAUyuv_buffer@@XZ ENDP	; CTheoraStream::CurrentFrame
PUBLIC	??1CTheoraStream@@UAE@XZ			; CTheoraStream::~CTheoraStream
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\xrtheora_stream.cpp
;	COMDAT ??1CTheoraStream@@UAE@XZ
_TEXT	SEGMENT
??1CTheoraStream@@UAE@XZ PROC				; CTheoraStream::~CTheoraStream, COMDAT
; _this$ = ecx

; 30   : {

	push	esi
	push	edi
	mov	edi, ecx

; 31   : 	ogg_sync_clear		(&o_sync_state);

	lea	eax, DWORD PTR [edi+8]
	push	eax
	mov	DWORD PTR [edi], OFFSET ??_7CTheoraStream@@6B@
	call	_ogg_sync_clear

; 32   : 	ogg_stream_clear	(&o_stream_state);

	lea	ecx, DWORD PTR [edi+56]
	push	ecx
	call	_ogg_stream_clear

; 33   : 	theora_clear		(&t_state);

	lea	esi, DWORD PTR [edi+536]
	call	_theora_clear

; 34   : 	theora_comment_clear(&t_comment);

	lea	esi, DWORD PTR [edi+520]
	call	_th_comment_clear

; 35   : 	theora_info_clear	(&t_info);

	mov	esi, DWORD PTR [edi+476]
	push	104					; 00000068H
	lea	eax, DWORD PTR [edi+416]
	push	0
	push	eax
	call	_memset
	add	esp, 20					; 00000014H
	test	esi, esi
	je	SHORT $LN6@CTheoraStr
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN5@CTheoraStr
	push	esi
	call	eax
	add	esp, 4
$LN5@CTheoraStr:
	push	esi
	call	DWORD PTR __imp__free
	add	esp, 4
$LN6@CTheoraStr:

; 36   : 	FS.r_close			(source);

	mov	edx, DWORD PTR __imp_?xr_FS@@3PAVCLocatorAPI@@A
	mov	ecx, DWORD PTR [edx]
	add	edi, 560				; 00000230H
	push	edi
	call	DWORD PTR __imp_?r_close@CLocatorAPI@@QAEXAAPAVCStreamReader@@@Z
	pop	edi
	pop	esi

; 37   : }

	ret	0
??1CTheoraStream@@UAE@XZ ENDP				; CTheoraStream::~CTheoraStream
_TEXT	ENDS
PUBLIC	??_GCTheoraStream@@UAEPAXI@Z			; CTheoraStream::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GCTheoraStream@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCTheoraStream@@UAEPAXI@Z PROC			; CTheoraStream::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CTheoraStream@@UAE@XZ		; CTheoraStream::~CTheoraStream
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN10@scalar@4
	test	esi, esi
	je	SHORT $LN10@scalar@4
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN10@scalar@4:
	mov	eax, esi
	pop	esi
	ret	4
??_GCTheoraStream@@UAEPAXI@Z ENDP			; CTheoraStream::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_ECTheoraStream@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_ECTheoraStream@@UAEPAXI@Z PROC			; CTheoraStream::`vector deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 2
	push	ebp
	mov	ebp, ecx
	je	SHORT $LN3@vector@24
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR [ebp-4]
	lea	ebx, DWORD PTR [ebp-4]
	mov	esi, edi
	imul	esi, 624				; 00000270H
	add	esi, ebp
	sub	edi, 1
	js	SHORT $LN6@vector@24
$LL7@vector@24:
	sub	esi, 624				; 00000270H
	mov	ecx, esi
	call	??1CTheoraStream@@UAE@XZ		; CTheoraStream::~CTheoraStream
	sub	edi, 1
	jns	SHORT $LL7@vector@24
$LN6@vector@24:
	test	BYTE PTR ___flags$[esp+12], 1
	je	SHORT $LN12@vector@24
	test	ebx, ebx
	je	SHORT $LN12@vector@24
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	ebx
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN12@vector@24:
	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx
	pop	ebp
	ret	4
$LN3@vector@24:
	call	??1CTheoraStream@@UAE@XZ		; CTheoraStream::~CTheoraStream
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN17@vector@24
	test	ebp, ebp
	je	SHORT $LN17@vector@24
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	ebp
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN17@vector@24:
	mov	eax, ebp
	pop	ebp
	ret	4
??_ECTheoraStream@@UAEPAXI@Z ENDP			; CTheoraStream::`vector deleting destructor'
PUBLIC	?Decode@CTheoraStream@@QAEHI@Z			; CTheoraStream::Decode
EXTRN	__allrem:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?Decode@CTheoraStream@@QAEHI@Z
_TEXT	SEGMENT
tv438 = -60						; size = 4
_a$436441 = -60						; size = 4
_result$115583 = -60					; size = 4
_t_frame$ = -56						; size = 8
_k_frame$ = -48						; size = 8
_gp$436484 = -40					; size = 8
_o_packet$115584 = -32					; size = 32
_in_tm_play$ = 8					; size = 4
?Decode@CTheoraStream@@QAEHI@Z PROC			; CTheoraStream::Decode, COMDAT
; _this$ = ecx

; 162  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 163  : 	VERIFY				(in_tm_play<tm_total);
; 164  : 	ogg_int64_t			t_frame;
; 165  : 	t_frame				= iFloor(in_tm_play*fpms);

	mov	eax, DWORD PTR _in_tm_play$[ebp]
	fild	DWORD PTR _in_tm_play$[ebp]
	sub	esp, 60					; 0000003cH
	test	eax, eax
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx
	jge	SHORT $LN105@Decode@2
	fadd	DWORD PTR __real@4f800000
$LN105@Decode@2:
	fmul	DWORD PTR [edi+616]
	mov	ecx, 158				; 0000009eH

; 166  : 	ogg_int64_t	k_frame	= t_frame-t_frame%key_rate;

	push	0
	fstp	DWORD PTR _a$436441[esp+76]
	mov	esi, DWORD PTR _a$436441[esp+76]
	mov	edx, esi
	sar	edx, 23					; 00000017H
	and	edx, 255				; 000000ffH
	sub	ecx, edx
	mov	eax, esi
	or	eax, -8388608				; ff800000H
	shl	eax, 8
	shr	eax, cl
	sub	ecx, 96					; 00000060H
	mov	edx, 1
	shl	edx, cl
	sub	edx, 1
	sar	edx, 8
	and	edx, esi
	neg	edx
	sbb	edx, edx
	add	edx, 1
	sar	esi, 31					; 0000001fH
	and	edx, esi
	sub	eax, edx
	add	ecx, 64					; 00000040H
	sar	ecx, 31					; 0000001fH
	and	eax, ecx
	xor	eax, esi
	cdq
	mov	esi, eax
	mov	eax, DWORD PTR [edi+612]
	mov	ebx, edx
	push	eax
	push	ebx
	push	esi
	mov	DWORD PTR _t_frame$[esp+88], esi
	mov	DWORD PTR _t_frame$[esp+92], ebx
	call	__allrem
	mov	ecx, esi
	sub	ecx, eax
	mov	DWORD PTR _k_frame$[esp+72], ecx

; 167  : 
; 168  : 	if (d_frame<t_frame){

	mov	ecx, DWORD PTR [edi+604]
	mov	eax, ebx
	sbb	eax, edx
	cmp	ecx, ebx
	mov	DWORD PTR _k_frame$[esp+76], eax
	jg	$LN31@Decode@2
	jl	SHORT $LN98@Decode@2
	mov	edx, DWORD PTR [edi+600]
	cmp	edx, esi
	jae	$LN31@Decode@2
$LN98@Decode@2:

; 169  : 		BOOL result		= FALSE;

	mov	DWORD PTR _result$115583[esp+72], 0
$LN30@Decode@2:

; 172  : 			while(FALSE==result){

	cmp	DWORD PTR _result$115583[esp+72], 0
	jne	$LN7@Decode@2
$LN28@Decode@2:

; 173  : 				// theora is one in, one out... 
; 174  : 				if(ogg_stream_packetout(&o_stream_state,&o_packet)>0 && !theora_packet_isheader(&o_packet)){

	lea	eax, DWORD PTR _o_packet$115584[esp+72]
	push	eax
	lea	eax, DWORD PTR [edi+56]
	push	eax
	call	_ogg_stream_packetout
	add	esp, 8
	test	eax, eax
	jle	$LN96@Decode@2
	cmp	DWORD PTR _o_packet$115584[esp+76], 0
	jle	SHORT $LN93@Decode@2
	mov	ecx, DWORD PTR _o_packet$115584[esp+72]
	movzx	eax, BYTE PTR [ecx]
	shr	eax, 7
	jne	$LN96@Decode@2
$LN93@Decode@2:

; 175  : 					d_frame++; 

	add	DWORD PTR [edi+600], 1
	adc	DWORD PTR [edi+604], 0

; 176  : 					//. hack preroll
; 177  : 					if (d_frame<k_frame){		

	mov	edx, DWORD PTR [edi+604]
	cmp	edx, DWORD PTR _k_frame$[esp+76]
	jl	SHORT $LN28@Decode@2
	jg	SHORT $LN99@Decode@2
	mov	eax, DWORD PTR [edi+600]
	cmp	eax, DWORD PTR _k_frame$[esp+72]
	jb	SHORT $LN28@Decode@2
$LN99@Decode@2:

; 178  : //.						dbg_log				((stderr,"%04d: preroll\n",d_frame));
; 179  : 						VERIFY				((0!=d_frame%key_rate)||(0==d_frame%key_rate)&&theora_packet_iskeyframe(&o_packet));
; 180  : 						continue; 
; 181  : 					}
; 182  : 					BOOL is_key				= theora_packet_iskeyframe(&o_packet);
; 183  : 					VERIFY					( (d_frame!=k_frame) || ((d_frame==k_frame) && is_key) );
; 184  : 					// real decode
; 185  : //.					dbg_log					((stderr,"%04d: decode\n",d_frame)); 
; 186  : 					int res					= theora_decode_packetin(&t_state,&o_packet);

	lea	esi, DWORD PTR [edi+536]
	test	esi, esi
	je	SHORT $LN18@Decode@2
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN18@Decode@2
	mov	eax, DWORD PTR [eax+60]
	test	eax, eax
	je	SHORT $LN18@Decode@2
	mov	edx, DWORD PTR [eax+8]
	lea	ecx, DWORD PTR _gp$436484[esp+72]
	push	ecx
	push	edx
	lea	eax, DWORD PTR _o_packet$115584[esp+80]
	call	_th_decode_packetin
	add	esp, 8
	test	eax, eax
	jl	SHORT $LN18@Decode@2
	mov	eax, DWORD PTR _gp$436484[esp+72]
	mov	ecx, DWORD PTR _gp$436484[esp+76]
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], ecx
$LN18@Decode@2:

; 187  : 					VERIFY					(res!=OC_BADPACKET);
; 188  : //.					dbg_log					((stderr,"%04d: granule frame\n",theora_granule_frame(&t_state,t_state.granulepos)));
; 189  : 					if (d_frame>=t_frame)	result = TRUE;

	mov	edx, DWORD PTR [edi+604]
	cmp	edx, ebx
	jl	$LN28@Decode@2
	jg	SHORT $LN100@Decode@2
	mov	eax, DWORD PTR [edi+600]
	cmp	eax, DWORD PTR _t_frame$[esp+72]
	jb	$LN28@Decode@2
$LN100@Decode@2:
	mov	DWORD PTR _result$115583[esp+72], 1

; 190  : 				}else						break;
; 191  : 			}
; 192  : 			// check eof
; 193  : 			VERIFY(!(FALSE==result&&source->eof()));
; 194  : 			if(FALSE==result){

	jmp	$LN7@Decode@2
$LN96@Decode@2:

; 195  : 				// no data yet for somebody.  Grab another page 
; 196  : 				if (ReadData()){

	lea	ebx, DWORD PTR [edi+8]
	push	4096					; 00001000H
	push	ebx
	call	_ogg_sync_buffer
	mov	ecx, DWORD PTR [edi+560]
	mov	edx, DWORD PTR [ecx+40]
	sub	edx, DWORD PTR [ecx+44]
	add	esp, 8
	sub	edx, DWORD PTR [ecx+28]
	add	edx, DWORD PTR [ecx+16]
	cmp	edx, 4096				; 00001000H
	jae	SHORT $LN60@Decode@2
	mov	esi, DWORD PTR [ecx+40]
	sub	esi, DWORD PTR [ecx+44]
	sub	esi, DWORD PTR [ecx+28]
	add	esi, DWORD PTR [ecx+16]
	jmp	SHORT $LN61@Decode@2
$LN60@Decode@2:
	mov	esi, 4096				; 00001000H
$LN61@Decode@2:
	push	esi
	push	eax
	call	DWORD PTR __imp_?r@CStreamReader@@QAEXPAXI@Z
	push	esi
	push	ebx
	call	_ogg_sync_wrote
	add	esp, 8
	test	esi, esi
	je	SHORT $LN102@Decode@2

; 197  : 					while(ogg_sync_pageout(&o_sync_state,&o_page)>0)

	lea	esi, DWORD PTR [edi+36]
	push	esi
	push	ebx
	call	_ogg_sync_pageout
	add	esp, 8
	test	eax, eax
	jle	SHORT $LN102@Decode@2
	npad	6
$LL8@Decode@2:

; 198  : 						ogg_stream_pagein	(&o_stream_state,&o_page);

	lea	eax, DWORD PTR [edi+56]
	push	esi
	push	eax
	call	_ogg_stream_pagein
	push	esi
	push	ebx
	call	_ogg_sync_pageout
	add	esp, 16					; 00000010H
	test	eax, eax
	jg	SHORT $LL8@Decode@2
$LN102@Decode@2:

; 197  : 					while(ogg_sync_pageout(&o_sync_state,&o_page)>0)

	mov	ebx, DWORD PTR _t_frame$[esp+76]
$LN7@Decode@2:

; 170  : 		ogg_packet		o_packet;
; 171  : 		while (d_frame<t_frame){

	mov	eax, DWORD PTR [edi+604]
	cmp	eax, ebx
	jl	$LN30@Decode@2
	jg	SHORT $LN101@Decode@2
	mov	ecx, DWORD PTR [edi+600]
	cmp	ecx, DWORD PTR _t_frame$[esp+72]
	jb	$LN30@Decode@2
$LN101@Decode@2:

; 199  : 				}
; 200  : 			}
; 201  : 		}
; 202  : 		// all right - get yuv buffer
; 203  : 		VERIFY								(TRUE==result);
; 204  : 		VERIFY								(d_frame==t_frame);
; 205  : 		theora_decode_YUVout				(&t_state,&t_yuv_buffer);

	lea	esi, DWORD PTR [edi+564]
	lea	eax, DWORD PTR [edi+536]
	call	_theora_decode_YUVout

; 206  : //.		dbg_log								((stderr,"%04d: yuv out\n",d_frame));
; 207  : 		return TRUE;

	mov	eax, 1

; 208  : 	}
; 209  : 	return FALSE;
; 210  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN31@Decode@2:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Decode@CTheoraStream@@QAEHI@Z ENDP			; CTheoraStream::Decode
PUBLIC	?ParseHeaders@CTheoraStream@@IAEHXZ		; CTheoraStream::ParseHeaders
; Function compile flags: /Ogtpy
;	COMDAT ?ParseHeaders@CTheoraStream@@IAEHXZ
_TEXT	SEGMENT
tv863 = -504						; size = 4
tv861 = -504						; size = 4
tv408 = -504						; size = 4
_a$528546 = -504					; size = 4
_p_key$ = -504						; size = 8
_header_count$ = -504					; size = 4
_frame_count$ = -496					; size = 8
_opb$528319 = -484					; size = 20
_opb$528288 = -484					; size = 20
_c_key$ = -464						; size = 8
_o_packet$ = -456					; size = 32
_info$528312 = -424					; size = 64
_info$528281 = -424					; size = 64
_test$115531 = -360					; size = 360
?ParseHeaders@CTheoraStream@@IAEHXZ PROC		; CTheoraStream::ParseHeaders, COMDAT
; _this$ = ecx

; 58   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 504				; 000001f8H
	push	ebx
	push	ebp
	push	esi
	mov	ebx, ecx
	push	edi

; 59   : 	ogg_packet			o_packet;
; 60   : 	int header_count	= 0;

	mov	DWORD PTR _header_count$[esp+520], 0
	lea	edi, DWORD PTR [ebx+8]
$LN29@ParseHeade@4:

; 65   : 		int ret			= ReadData(); 

	push	4096					; 00001000H
	push	edi
	call	_ogg_sync_buffer
	mov	ecx, DWORD PTR [ebx+560]
	mov	edx, DWORD PTR [ecx+40]
	sub	edx, DWORD PTR [ecx+44]
	add	esp, 8
	sub	edx, DWORD PTR [ecx+28]
	add	edx, DWORD PTR [ecx+16]
	cmp	edx, 4096				; 00001000H
	jae	SHORT $LN34@ParseHeade@4
	mov	esi, DWORD PTR [ecx+40]
	sub	esi, DWORD PTR [ecx+44]
	sub	esi, DWORD PTR [ecx+28]
	add	esi, DWORD PTR [ecx+16]
	jmp	SHORT $LN35@ParseHeade@4
$LN34@ParseHeade@4:
	mov	esi, 4096				; 00001000H
$LN35@ParseHeade@4:
	push	esi
	push	eax
	call	DWORD PTR __imp_?r@CStreamReader@@QAEXPAXI@Z
	push	esi
	push	edi
	call	_ogg_sync_wrote
	add	esp, 8

; 66   : 		if (ret==0)		break;

	test	esi, esi
	je	$LN172@ParseHeade@4

; 67   : 		while(ogg_sync_pageout(&o_sync_state,&o_page)>0){

	lea	ebp, DWORD PTR [ebx+36]
	push	ebp
	push	edi
	call	_ogg_sync_pageout
	add	esp, 8
	test	eax, eax
	jle	SHORT $LN29@ParseHeade@4
$LL26@ParseHeade@4:

; 68   : 			ogg_stream_state test;
; 69   : 
; 70   : 			// is this a mandated initial header? If not, stop parsing
; 71   : 			if(!ogg_page_bos(&o_page)){

	push	ebp
	call	_ogg_page_bos
	add	esp, 4
	test	eax, eax
	je	$LN171@ParseHeade@4

; 74   : 				stateflag			= 1;
; 75   : 				break;
; 76   : 			}
; 77   : 
; 78   : 			ogg_stream_init		(&test,ogg_page_serialno(&o_page));

	push	ebp
	call	_ogg_page_serialno
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _test$115531[esp+524]
	push	eax
	call	_ogg_stream_init

; 79   : 			ogg_stream_pagein	(&test,&o_page);

	lea	ecx, DWORD PTR _test$115531[esp+528]
	push	ebp
	push	ecx
	call	_ogg_stream_pagein

; 80   : 			ogg_stream_packetout(&test,&o_packet);

	lea	edx, DWORD PTR _o_packet$[esp+536]
	push	edx
	lea	eax, DWORD PTR _test$115531[esp+540]
	push	eax
	call	_ogg_stream_packetout
	add	esp, 24					; 00000018H

; 81   : 
; 82   : 			// identify the codec: try theora 
; 83   : 			if(!header_count && theora_decode_header(&t_info,&t_comment,&o_packet)>=0){

	cmp	DWORD PTR _header_count$[esp+520], 0
	jne	$LN23@ParseHeade@4
	mov	edi, DWORD PTR [ebx+476]
	test	edi, edi
	lea	esi, DWORD PTR [ebx+416]
	jne	SHORT $LN64@ParseHeade@4
	push	16					; 00000010H
	push	1
	call	DWORD PTR __imp__calloc
	add	esp, 8
	test	eax, eax
	mov	DWORD PTR [esi+60], eax
	je	$LN23@ParseHeade@4
	mov	edi, eax
	mov	DWORD PTR [edi], OFFSET _th_dec_api_clear
$LN64@ParseHeade@4:
	mov	ecx, esi
	lea	eax, DWORD PTR _info$528281[esp+520]
	call	_oc_theora_info2th_info
	mov	ecx, DWORD PTR _o_packet$[esp+524]
	xor	eax, eax
	mov	DWORD PTR _opb$528288[esp+524], eax
	mov	DWORD PTR _opb$528288[esp+528], eax
	mov	DWORD PTR _opb$528288[esp+520], eax
	mov	DWORD PTR _opb$528288[esp+532], eax
	mov	DWORD PTR _opb$528288[esp+536], eax
	mov	eax, DWORD PTR _o_packet$[esp+520]
	add	ecx, eax
	lea	edx, DWORD PTR _o_packet$[esp+520]
	push	edx
	mov	DWORD PTR _opb$528288[esp+532], ecx
	add	edi, 4
	lea	ecx, DWORD PTR _info$528281[esp+524]
	push	edi
	mov	DWORD PTR _opb$528288[esp+532], eax
	push	ecx
	lea	eax, DWORD PTR [ebx+520]
	lea	ecx, DWORD PTR _opb$528288[esp+532]
	call	_oc_dec_headerin
	add	esp, 12					; 0000000cH
	test	eax, eax
	jl	SHORT $LN23@ParseHeade@4
	lea	ecx, DWORD PTR _info$528281[esp+520]
	mov	eax, esi
	call	_th_info2theora_info

; 84   : 				// it is theora 
; 85   : 				CopyMemory	(&o_stream_state,&test,sizeof(test));

	lea	edi, DWORD PTR [ebx+56]
	mov	ecx, 90					; 0000005aH
	lea	esi, DWORD PTR _test$115531[esp+520]
	rep movsd

; 86   : 				header_count	= 1;

	mov	DWORD PTR _header_count$[esp+520], 1

; 87   : 			}else{

	jmp	SHORT $LN22@ParseHeade@4
$LN23@ParseHeade@4:

; 88   : 				// whatever it is, we don't care about it 
; 89   : 				ogg_stream_clear(&test);

	lea	edx, DWORD PTR _test$115531[esp+520]
	push	edx
	call	_ogg_stream_clear
	add	esp, 4
$LN22@ParseHeade@4:
	push	ebp
	lea	edi, DWORD PTR [ebx+8]
	push	edi
	call	_ogg_sync_pageout
	add	esp, 8
	test	eax, eax
	jg	$LL26@ParseHeade@4

; 61   : 	BOOL stateflag		= FALSE;
; 62   : 
; 63   : 	// find Theora stream
; 64   : 	while(!stateflag){

	jmp	$LN29@ParseHeade@4
$LN171@ParseHeade@4:

; 72   : 				// don't leak the page; get it into the appropriate stream
; 73   : 				ogg_stream_pagein	(&o_stream_state,&o_page);

	lea	eax, DWORD PTR [ebx+36]
	push	eax
	lea	ecx, DWORD PTR [ebx+56]
	push	ecx
$LN220@ParseHeade@4:
	call	_ogg_stream_pagein
	add	esp, 8
$LN172@ParseHeade@4:

; 90   : 			}
; 91   : 		}
; 92   : 		// fall through to non-bos page parsing 
; 93   : 	}
; 94   : 
; 95   : 	// fail if theora stream not found in source
; 96   : 	if (0==header_count)		return FALSE;

	cmp	DWORD PTR _header_count$[esp+520], 0
	jne	SHORT $LL20@ParseHeade@4
$LN188@ParseHeade@4:
	xor	eax, eax

; 157  : 
; 158  : 	return TRUE;
; 159  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LL20@ParseHeade@4:

; 97   : 
; 98   : 	// we're expecting more header packets. 
; 99   : 	while((header_count && header_count<3)){

	mov	eax, DWORD PTR _header_count$[esp+520]
	cmp	eax, 3
	jge	$LN218@ParseHeade@4
$LN18@ParseHeade@4:

; 100  : 		int ret;
; 101  : 
; 102  : 		// look for further theora headers 
; 103  : 		while(header_count && (header_count<3) && 0!=(ret=ogg_stream_packetout(&o_stream_state,&o_packet))){

	cmp	DWORD PTR _header_count$[esp+520], 3
	jge	$LN175@ParseHeade@4
	lea	edx, DWORD PTR _o_packet$[esp+520]
	push	edx
	lea	eax, DWORD PTR [ebx+56]
	push	eax
	call	_ogg_stream_packetout
	add	esp, 8
	test	eax, eax
	je	$LN175@ParseHeade@4

; 104  : 			if(ret<0){

	jl	$LN173@ParseHeade@4

; 107  : 			}
; 108  : 			if(theora_decode_header(&t_info,&t_comment,&o_packet)){

	mov	edi, DWORD PTR [ebx+476]
	test	edi, edi
	lea	esi, DWORD PTR [ebx+416]
	jne	SHORT $LN75@ParseHeade@4
	push	16					; 00000010H
	push	1
	call	DWORD PTR __imp__calloc
	add	esp, 8
	test	eax, eax
	mov	DWORD PTR [esi+60], eax
	je	$LN174@ParseHeade@4
	mov	edi, eax
	mov	DWORD PTR [edi], OFFSET _th_dec_api_clear
$LN75@ParseHeade@4:
	mov	ecx, esi
	lea	eax, DWORD PTR _info$528312[esp+520]
	call	_oc_theora_info2th_info
	mov	ecx, DWORD PTR _o_packet$[esp+524]
	xor	eax, eax
	mov	DWORD PTR _opb$528319[esp+524], eax
	mov	DWORD PTR _opb$528319[esp+528], eax
	mov	DWORD PTR _opb$528319[esp+520], eax
	mov	DWORD PTR _opb$528319[esp+532], eax
	mov	DWORD PTR _opb$528319[esp+536], eax
	mov	eax, DWORD PTR _o_packet$[esp+520]
	add	ecx, eax
	lea	edx, DWORD PTR _o_packet$[esp+520]
	push	edx
	mov	DWORD PTR _opb$528319[esp+532], ecx
	add	edi, 4
	lea	ecx, DWORD PTR _info$528312[esp+524]
	push	edi
	mov	DWORD PTR _opb$528319[esp+532], eax
	push	ecx
	lea	eax, DWORD PTR [ebx+520]
	lea	ecx, DWORD PTR _opb$528319[esp+532]
	call	_oc_dec_headerin
	add	esp, 12					; 0000000cH
	test	eax, eax
	jl	$LN174@ParseHeade@4
	lea	ecx, DWORD PTR _info$528312[esp+520]
	mov	eax, esi
	call	_th_info2theora_info

; 111  : 			}
; 112  : 			header_count++;

	mov	eax, DWORD PTR _header_count$[esp+520]
	add	eax, 1

; 113  : 			if(header_count==3)break;

	cmp	eax, 3
	mov	DWORD PTR _header_count$[esp+520], eax
	je	SHORT $LN175@ParseHeade@4

; 100  : 		int ret;
; 101  : 
; 102  : 		// look for further theora headers 
; 103  : 		while(header_count && (header_count<3) && 0!=(ret=ogg_stream_packetout(&o_stream_state,&o_packet))){

	test	eax, eax
	jne	$LN18@ParseHeade@4
$LN175@ParseHeade@4:

; 114  : 		}
; 115  : 
; 116  : 		// The header pages/packets will arrive before anything else we
; 117  : 		// care about, or the stream is not obeying spec
; 118  : 		if(ogg_sync_pageout(&o_sync_state,&o_page)>0){

	lea	esi, DWORD PTR [ebx+36]
	push	esi
	lea	ebp, DWORD PTR [ebx+8]
	push	ebp
	call	_ogg_sync_pageout
	add	esp, 8
	test	eax, eax
	jle	SHORT $LN13@ParseHeade@4

; 119  : 			ogg_stream_pagein	(&o_stream_state,&o_page);

	push	esi
	lea	edx, DWORD PTR [ebx+56]
	push	edx

; 120  : 		}else{

	jmp	$LN220@ParseHeade@4
$LN13@ParseHeade@4:

; 121  : 			int ret=ReadData(); // someone needs more data

	push	4096					; 00001000H
	push	ebp
	call	_ogg_sync_buffer
	mov	esi, DWORD PTR [ebx+560]
	add	esp, 8
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_?tell@CStreamReader@@QBEIXZ
	mov	ecx, DWORD PTR [esi+16]
	sub	ecx, eax
	cmp	ecx, 4096				; 00001000H
	jae	SHORT $LN86@ParseHeade@4
	mov	eax, DWORD PTR [ebx+560]
	mov	esi, DWORD PTR [eax+40]
	sub	esi, DWORD PTR [eax+44]
	sub	esi, DWORD PTR [eax+28]
	add	esi, DWORD PTR [eax+16]
	jmp	SHORT $LN87@ParseHeade@4
$LN86@ParseHeade@4:
	mov	esi, 4096				; 00001000H
$LN87@ParseHeade@4:
	mov	ecx, DWORD PTR [ebx+560]
	push	esi
	push	edi
	call	DWORD PTR __imp_?r@CStreamReader@@QAEXPAXI@Z
	push	esi
	push	ebp
	call	_ogg_sync_wrote
	add	esp, 8

; 122  : 			if(ret==0) FATAL	("End of file while searching for codec headers.");

	test	esi, esi
	jne	$LN172@ParseHeade@4
	mov	edx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ??_C@_0CP@JMOPMEJE@End?5of?5file?5while?5searching?5for?5@
	push	OFFSET ??_C@_0BM@NLDCJONH@CTheoraStream?3?3ParseHeaders?$AA@
	push	122					; 0000007aH
	push	OFFSET ??_C@_0DI@KNAMDIEA@D?3?2CLEARSKY?2sources?2engine?2xrEng@
	push	edx
	call	DWORD PTR __imp_?fatal@xrDebug@@QAAXPBDH00ZZ
	add	esp, 20					; 00000014H
	jmp	$LN172@ParseHeade@4
$LN173@ParseHeade@4:

; 105  : 				fprintf(stderr,"Error parsing Theora stream headers; corrupt stream?\n");

	push	OFFSET ??_C@_0DG@KBFPEDPM@Error?5parsing?5Theora?5stream?5head@
	call	DWORD PTR __imp____iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8

; 106  : 				exit(1);

	push	1
	call	DWORD PTR __imp__exit
$LN221@ParseHeade@4:
$LN174@ParseHeade@4:

; 109  : 				printf("Error parsing Theora stream headers; corrupt stream?\n");

	push	OFFSET ??_C@_0DG@KBFPEDPM@Error?5parsing?5Theora?5stream?5head@
	call	DWORD PTR __imp__printf
	add	esp, 4

; 110  : 				exit(1);

	push	1
	call	DWORD PTR __imp__exit
$LN222@ParseHeade@4:
$LN218@ParseHeade@4:

; 123  : 		}
; 124  : 	}
; 125  : 
; 126  : 	if (3!=header_count)	return FALSE;

	jne	$LN188@ParseHeade@4

; 127  : 	
; 128  : 	// init decode
; 129  : 	theora_decode_init		(&t_state,&t_info);

	lea	ecx, DWORD PTR [ebx+536]
	lea	eax, DWORD PTR [ebx+416]
	push	ecx
	call	_theora_decode_init

; 130  : 	// calculate frame per ms
; 131  : 	fpms					= ((float)t_info.fps_numerator/(float)t_info.fps_denominator)/1000.f;

	fild	DWORD PTR [ebx+440]
	mov	edx, DWORD PTR [ebx+440]
	add	esp, 4
	test	edx, edx
	jge	SHORT $LN215@ParseHeade@4
	fadd	DWORD PTR __real@4f800000
$LN215@ParseHeade@4:
	mov	eax, DWORD PTR [ebx+444]
	fild	DWORD PTR [ebx+444]
	test	eax, eax
	jge	SHORT $LN216@ParseHeade@4
	fadd	DWORD PTR __real@4f800000
$LN216@ParseHeade@4:
	fdivp	ST(1), ST(0)

; 132  : 
; 133  : 	//. XXX hack (maybe slow)
; 134  : 	// calculate frame count & total length in ms & key rate
; 135  : 	ogg_int64_t	frame_count	= 0;

	xor	edi, edi
	xor	ebp, ebp

; 136  : 	ogg_int64_t p_key=0, c_key=0;

	xor	eax, eax
	mov	DWORD PTR _frame_count$[esp+520], edi
	mov	DWORD PTR _frame_count$[esp+524], ebp
	mov	DWORD PTR _c_key$[esp+520], eax
	mov	DWORD PTR _c_key$[esp+524], eax
	fmul	DWORD PTR _EPS_L
	fstp	DWORD PTR [ebx+616]
$LN9@ParseHeade@4:

; 137  : 	while (TRUE){
; 138  : 		while(ogg_stream_packetout(&o_stream_state,&o_packet)>0){

	lea	ecx, DWORD PTR _o_packet$[esp+520]
	push	ecx
	lea	esi, DWORD PTR [ebx+56]
	push	esi
	call	_ogg_stream_packetout
	add	esp, 8
	test	eax, eax
	jle	SHORT $LN6@ParseHeade@4
$LL7@ParseHeade@4:

; 139  : 			if ((0==key_rate)&&theora_packet_iskeyframe(&o_packet)){

	cmp	DWORD PTR [ebx+612], 0
	jne	SHORT $LN5@ParseHeade@4
	cmp	DWORD PTR _o_packet$[esp+524], 0
	jle	SHORT $LN5@ParseHeade@4
	mov	edx, DWORD PTR _o_packet$[esp+520]
	movzx	eax, BYTE PTR [edx]
	test	al, al
	js	SHORT $LN189@ParseHeade@4
	shr	eax, 6
	not	eax
	and	eax, 1
	je	SHORT $LN5@ParseHeade@4
$LN189@ParseHeade@4:

; 140  : 				p_key		= c_key;

	mov	eax, DWORD PTR _c_key$[esp+520]
	mov	ecx, DWORD PTR _c_key$[esp+524]

; 141  : 				c_key		= frame_count;
; 142  : 				key_rate	= (u32)(c_key-p_key);

	mov	edx, edi
	sub	edx, eax
	mov	DWORD PTR _p_key$[esp+524], ecx
	mov	DWORD PTR _c_key$[esp+520], edi
	mov	DWORD PTR _c_key$[esp+524], ebp
	mov	DWORD PTR [ebx+612], edx
$LN5@ParseHeade@4:
	lea	eax, DWORD PTR _o_packet$[esp+520]
	push	eax

; 143  : 			}
; 144  : 			frame_count++;

	add	edi, 1
	push	esi
	adc	ebp, 0
	call	_ogg_stream_packetout
	add	esp, 8
	test	eax, eax
	jg	SHORT $LL7@ParseHeade@4
$LN6@ParseHeade@4:

; 145  : 		}
; 146  : 		// check eof
; 147  : 		if (source->eof())	break;

	mov	eax, DWORD PTR [ebx+560]
	mov	ecx, DWORD PTR [eax+40]
	sub	ecx, DWORD PTR [eax+44]
	sub	ecx, DWORD PTR [eax+28]
	add	ecx, DWORD PTR [eax+16]
	je	$LN214@ParseHeade@4

; 148  : 		// no data yet for somebody.  Grab another page 
; 149  : 		if (0==ReadData())	break;

	lea	eax, DWORD PTR [ebx+8]
	push	4096					; 00001000H
	push	eax
	call	_ogg_sync_buffer
	mov	ecx, DWORD PTR [ebx+560]
	mov	edx, DWORD PTR [ecx+40]
	sub	edx, DWORD PTR [ecx+44]
	add	esp, 8
	sub	edx, DWORD PTR [ecx+28]
	add	edx, DWORD PTR [ecx+16]
	cmp	edx, 4096				; 00001000H
	jae	SHORT $LN133@ParseHeade@4
	mov	esi, DWORD PTR [ecx+40]
	sub	esi, DWORD PTR [ecx+44]
	sub	esi, DWORD PTR [ecx+28]
	add	esi, DWORD PTR [ecx+16]
	jmp	SHORT $LN134@ParseHeade@4
$LN133@ParseHeade@4:
	mov	esi, 4096				; 00001000H
$LN134@ParseHeade@4:
	push	esi
	push	eax
	call	DWORD PTR __imp_?r@CStreamReader@@QAEXPAXI@Z
	lea	eax, DWORD PTR [ebx+8]
	push	esi
	push	eax
	call	_ogg_sync_wrote
	add	esp, 8
	test	esi, esi
	je	SHORT $LN214@ParseHeade@4

; 150  : 		while(ogg_sync_pageout(&o_sync_state,&o_page)>0)

	lea	esi, DWORD PTR [ebx+36]
	lea	eax, DWORD PTR [ebx+8]
	push	esi
	push	eax
	call	_ogg_sync_pageout
	add	esp, 8
	test	eax, eax
	jle	$LN9@ParseHeade@4
$LL2@ParseHeade@4:

; 151  : 			ogg_stream_pagein(&o_stream_state,&o_page);

	lea	eax, DWORD PTR [ebx+56]
	push	esi
	push	eax
	call	_ogg_stream_pagein
	lea	eax, DWORD PTR [ebx+8]
	push	esi
	push	eax
	call	_ogg_sync_pageout
	add	esp, 16					; 00000010H
	test	eax, eax
	jg	SHORT $LL2@ParseHeade@4

; 152  : 	}

	jmp	$LN9@ParseHeade@4
$LN214@ParseHeade@4:

; 143  : 			}
; 144  : 			frame_count++;

	mov	DWORD PTR _frame_count$[esp+520], edi
	mov	DWORD PTR _frame_count$[esp+524], ebp

; 153  : 	tm_total				= iFloor(frame_count/fpms);

	fild	QWORD PTR _frame_count$[esp+520]
	mov	ecx, 158				; 0000009eH
	fdiv	DWORD PTR [ebx+616]
	fstp	DWORD PTR _a$528546[esp+520]
	mov	esi, DWORD PTR _a$528546[esp+520]
	mov	eax, esi
	sar	eax, 23					; 00000017H
	and	eax, 255				; 000000ffH
	sub	ecx, eax
	mov	edx, esi
	or	edx, -8388608				; ff800000H
	shl	edx, 8
	shr	edx, cl
	sub	ecx, 96					; 00000060H
	mov	eax, 1
	shl	eax, cl
	sub	eax, 1
	sar	eax, 8
	and	eax, esi
	neg	eax
	sbb	eax, eax
	sar	esi, 31					; 0000001fH
	add	eax, 1
	add	ecx, 64					; 00000040H
	and	eax, esi
	sub	edx, eax
	sar	ecx, 31					; 0000001fH
	and	edx, ecx
	xor	edx, esi

; 154  : 
; 155  : 	// seek to 0
; 156  : 	Reset					();

	mov	ecx, ebx
	mov	DWORD PTR [ebx+608], edx
	call	?Reset@CTheoraStream@@QAEXXZ		; CTheoraStream::Reset

; 157  : 
; 158  : 	return TRUE;
; 159  : }

	pop	edi
	mov	eax, 1
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN217@ParseHeade@4:
?ParseHeaders@CTheoraStream@@IAEHXZ ENDP		; CTheoraStream::ParseHeaders
PUBLIC	?Load@CTheoraStream@@QAEHPBD@Z			; CTheoraStream::Load
; Function compile flags: /Ogtpy
;	COMDAT ?Load@CTheoraStream@@QAEHPBD@Z
_TEXT	SEGMENT
$T543612 = 8						; size = 4
_fname$ = 8						; size = 4
?Load@CTheoraStream@@QAEHPBD@Z PROC			; CTheoraStream::Load, COMDAT
; _this$ = ecx

; 214  : 	VERIFY				(0==source);
; 215  : 	// open source
; 216  : #ifdef _EDITOR
; 217  : 	source				= FS.r_open(0,fname);
; 218  : #else
; 219  : 	source				= FS.rs_open(0,fname);

	mov	eax, DWORD PTR _fname$[esp-4]
	push	esi
	push	edi
	mov	esi, ecx
	mov	ecx, DWORD PTR __imp_?xr_FS@@3PAVCLocatorAPI@@A
	mov	ecx, DWORD PTR [ecx]
	push	eax
	push	0
	call	DWORD PTR __imp_?rs_open@CLocatorAPI@@QAEPAVCStreamReader@@PBD0@Z

; 220  : #endif
; 221  : 	VERIFY				(source);
; 222  : 
; 223  : 	// parse headers
; 224  : 	BOOL res			= ParseHeaders();

	mov	ecx, esi
	mov	DWORD PTR [esi+560], eax
	call	?ParseHeaders@CTheoraStream@@IAEHXZ	; CTheoraStream::ParseHeaders

; 225  : 	// seek to start
; 226  : 	Reset				();

	mov	ecx, DWORD PTR [esi+560]
	lea	edx, DWORD PTR $T543612[esp+4]
	push	edx
	mov	edi, eax
	mov	DWORD PTR $T543612[esp+8], 0
	call	DWORD PTR __imp_?seek@CStreamReader@@QAEXABH@Z
	lea	eax, DWORD PTR [esi+56]
	push	eax
	call	_ogg_stream_reset
	lea	ecx, DWORD PTR [esi+8]
	push	ecx
	call	_ogg_sync_reset
	or	eax, -1
	add	esp, 8
	mov	DWORD PTR [esi+544], eax
	mov	DWORD PTR [esi+548], eax
	mov	DWORD PTR [esi+600], eax
	mov	DWORD PTR [esi+604], eax

; 227  : 	return				res;

	mov	eax, edi
	pop	edi
	pop	esi

; 228  : }

	ret	4
?Load@CTheoraStream@@QAEHPBD@Z ENDP			; CTheoraStream::Load
END

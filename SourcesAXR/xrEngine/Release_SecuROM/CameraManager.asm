; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	D:\CLEARSKY\sources\engine\xrEngine\CameraManager.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	?Stop@CEffectorPP@@UAEXM@Z			; CEffectorPP::Stop
PUBLIC	?Valid@CEffectorPP@@UAEHXZ			; CEffectorPP::Valid
PUBLIC	??_ECEffectorPP@@UAEPAXI@Z			; CEffectorPP::`vector deleting destructor'
PUBLIC	??_R4CEffectorPP@@6B@				; CEffectorPP::`RTTI Complete Object Locator'
PUBLIC	??_R3CEffectorPP@@8				; CEffectorPP::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CEffectorPP@@8				; CEffectorPP::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CEffectorPP@@8			; CEffectorPP::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCEffectorPP@@@8				; CEffectorPP `RTTI Type Descriptor'
PUBLIC	?AbsolutePositioning@CEffectorCam@@UAE_NXZ	; CEffectorCam::AbsolutePositioning
PUBLIC	?AllowProcessingIfInvalid@CEffectorCam@@UAEHXZ	; CEffectorCam::AllowProcessingIfInvalid
PUBLIC	?ProcessIfInvalid@CEffectorCam@@UAEXAAUSCamEffectorInfo@@@Z ; CEffectorCam::ProcessIfInvalid
PUBLIC	?ProcessCam@CEffectorCam@@UAEHAAUSCamEffectorInfo@@@Z ; CEffectorCam::ProcessCam
PUBLIC	?Valid@CEffectorCam@@UAEHXZ			; CEffectorCam::Valid
PUBLIC	??_ECEffectorCam@@UAEPAXI@Z			; CEffectorCam::`vector deleting destructor'
PUBLIC	??_R4CEffectorCam@@6B@				; CEffectorCam::`RTTI Complete Object Locator'
PUBLIC	??_R3CEffectorCam@@8				; CEffectorCam::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CEffectorCam@@8				; CEffectorCam::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CEffectorCam@@8			; CEffectorCam::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCEffectorCam@@@8			; CEffectorCam `RTTI Type Descriptor'
PUBLIC	?ProcessCameraEffector@CCameraManager@@MAE_NPAVCEffectorCam@@@Z ; CCameraManager::ProcessCameraEffector
PUBLIC	?UpdatePPEffectors@CCameraManager@@MAEXXZ	; CCameraManager::UpdatePPEffectors
PUBLIC	?UpdateCamEffectors@CCameraManager@@MAEXXZ	; CCameraManager::UpdateCamEffectors
PUBLIC	?to_value_type_ref@?$_CastTraits@PAXPAVCEffectorPP@@@priv@stlp_std@@SAAAPAVCEffectorPP@@AAPAX@Z ; stlp_std::priv::_CastTraits<void *,CEffectorPP *>::to_value_type_ref
PUBLIC	?back@?$vector@PAVCEffectorPP@@V?$xalloc@PAVCEffectorPP@@@@@stlp_std@@QAEAAPAVCEffectorPP@@XZ ; stlp_std::vector<CEffectorPP *,xalloc<CEffectorPP *> >::back
PUBLIC	?to_storage_type_cref@?$_CastTraits@PAXPAVCEffectorPP@@@priv@stlp_std@@SAABQAXABQAVCEffectorPP@@@Z ; stlp_std::priv::_CastTraits<void *,CEffectorPP *>::to_storage_type_cref
PUBLIC	?push_back@?$vector@PAVCEffectorPP@@V?$xalloc@PAVCEffectorPP@@@@@stlp_std@@QAEXABQAVCEffectorPP@@@Z ; stlp_std::vector<CEffectorPP *,xalloc<CEffectorPP *> >::push_back
PUBLIC	?to_storage_type_ptr@?$_CastTraits@PAXPAVCEffectorPP@@@priv@stlp_std@@SAPAPAXPAPAVCEffectorPP@@@Z ; stlp_std::priv::_CastTraits<void *,CEffectorPP *>::to_storage_type_ptr
PUBLIC	?erase@?$vector@PAVCEffectorPP@@V?$xalloc@PAVCEffectorPP@@@@@stlp_std@@QAEPAPAVCEffectorPP@@PAPAV3@@Z ; stlp_std::vector<CEffectorPP *,xalloc<CEffectorPP *> >::erase
PUBLIC	?GetClosureThis@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AGXXZP6GXXZP6GXXZ@detail@fastdelegate@@QBEPAVGenericClass@23@XZ ; fastdelegate::detail::ClosurePtr<void (__stdcall fastdelegate::detail::GenericClass::*)(void),void (__stdcall*)(void),void (__stdcall*)(void)>::GetClosureThis
PUBLIC	?GetClosureMemPtr@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AGXXZP6GXXZP6GXXZ@detail@fastdelegate@@QBEP8GenericClass@23@AGXXZXZ ; fastdelegate::detail::ClosurePtr<void (__stdcall fastdelegate::detail::GenericClass::*)(void),void (__stdcall*)(void),void (__stdcall*)(void)>::GetClosureMemPtr
PUBLIC	??R?$FastDelegate0@X@fastdelegate@@QBEXXZ	; fastdelegate::FastDelegate0<void>::operator()
PUBLIC	??7DelegateMemento@fastdelegate@@QBE_NXZ	; fastdelegate::DelegateMemento::operator!
PUBLIC	?empty@?$FastDelegate0@X@fastdelegate@@QBE_NXZ	; fastdelegate::FastDelegate0<void>::empty
PUBLIC	??R?$xr_special_free@$00USBaseEffector@@@@QAEXAAPAUSBaseEffector@@@Z ; xr_special_free<1,SBaseEffector>::operator()
PUBLIC	??$xr_delete@USBaseEffector@@@@YAXAAPAUSBaseEffector@@@Z ; xr_delete<SBaseEffector>
PUBLIC	?inertion@?$_vector3@M@@QAEAAU1@ABU1@M@Z	; _vector3<float>::inertion
PUBLIC	?build_projection_HAT@?$_matrix@M@@QAEAAU1@MMMM@Z ; _matrix<float>::build_projection_HAT
PUBLIC	?build_projection@?$_matrix@M@@QAEAAU1@MMMM@Z	; _matrix<float>::build_projection
PUBLIC	?build_camera_dir@?$_matrix@M@@QAEAAU1@ABU?$_vector3@M@@00@Z ; _matrix<float>::build_camera_dir
PUBLIC	?color_argb@@YAIIIII@Z				; color_argb
PUBLIC	?color_rgba@@YAIIIII@Z				; color_rgba
PUBLIC	??$clampr@H@@YAHABH00@Z				; clampr<int>
PUBLIC	??BSColor@SPPInfo@@QAEIXZ			; SPPInfo::SColor::operator unsigned int
PUBLIC	??BSColor@SPPInfo@@QAEABU?$_vector3@M@@XZ	; SPPInfo::SColor::operator _vector3<float> const &
PUBLIC	?invert@?$_matrix@M@@QAEAAU1@ABU1@@Z		; _matrix<float>::invert
PUBLIC	??YSColor@SPPInfo@@QAEAAU01@ABU01@@Z		; SPPInfo::SColor::operator+=
PUBLIC	??ZSColor@SPPInfo@@QAEAAU01@ABU01@@Z		; SPPInfo::SColor::operator-=
PUBLIC	??0SColor@SPPInfo@@QAE@XZ			; SPPInfo::SColor::SColor
PUBLIC	??0SDuality@SPPInfo@@QAE@XZ			; SPPInfo::SDuality::SDuality
PUBLIC	??0SNoise@SPPInfo@@QAE@XZ			; SPPInfo::SNoise::SNoise
PUBLIC	??0?$xalloc@PAVCEffectorCam@@@@QAE@XZ		; xalloc<CEffectorCam *>::xalloc<CEffectorCam *>
PUBLIC	??0?$_Impl_list@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAE@ABV?$xalloc@PAX@@@Z ; stlp_std::priv::_Impl_list<void *,xalloc<void *> >::_Impl_list<void *,xalloc<void *> >
PUBLIC	??$?0PAVCEffectorCam@@@?$xalloc@PAX@@QAE@ABV?$xalloc@PAVCEffectorCam@@@@@Z ; xalloc<void *>::xalloc<void *><CEffectorCam *>
PUBLIC	??0?$list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@stlp_std@@QAE@ABV?$xalloc@PAVCEffectorCam@@@@@Z ; stlp_std::list<CEffectorCam *,xalloc<CEffectorCam *> >::list<CEffectorCam *,xalloc<CEffectorCam *> >
PUBLIC	??0?$xr_list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@@QAE@XZ ; xr_list<CEffectorCam *,xalloc<CEffectorCam *> >::xr_list<CEffectorCam *,xalloc<CEffectorCam *> >
PUBLIC	??0?$xalloc@PAVCEffectorPP@@@@QAE@XZ		; xalloc<CEffectorPP *>::xalloc<CEffectorPP *>
PUBLIC	??$?0PAVCEffectorPP@@@?$xalloc@PAX@@QAE@ABV?$xalloc@PAVCEffectorPP@@@@@Z ; xalloc<void *>::xalloc<void *><CEffectorPP *>
PUBLIC	??0?$vector@PAVCEffectorPP@@V?$xalloc@PAVCEffectorPP@@@@@stlp_std@@QAE@ABV?$xalloc@PAVCEffectorPP@@@@@Z ; stlp_std::vector<CEffectorPP *,xalloc<CEffectorPP *> >::vector<CEffectorPP *,xalloc<CEffectorPP *> >
PUBLIC	??0?$xr_vector@PAVCEffectorPP@@V?$xalloc@PAVCEffectorPP@@@@@@QAE@XZ ; xr_vector<CEffectorPP *,xalloc<CEffectorPP *> >::xr_vector<CEffectorPP *,xalloc<CEffectorPP *> >
PUBLIC	?set@SColor@SPPInfo@@QAEAAU12@MMM@Z		; SPPInfo::SColor::set
PUBLIC	??R?$xr_special_free@$00VCEffectorCam@@@@QAEXAAPAVCEffectorCam@@@Z ; xr_special_free<1,CEffectorCam>::operator()
PUBLIC	??$xr_delete@VCEffectorCam@@@@YAXAAPAVCEffectorCam@@@Z ; xr_delete<CEffectorCam>
PUBLIC	??R?$xr_special_free@$00VCEffectorPP@@@@QAEXAAPAVCEffectorPP@@@Z ; xr_special_free<1,CEffectorPP>::operator()
PUBLIC	??$xr_delete@VCEffectorPP@@@@YAXAAPAVCEffectorPP@@@Z ; xr_delete<CEffectorPP>
PUBLIC	?back@?$list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@stlp_std@@QAEAAPAVCEffectorCam@@XZ ; stlp_std::list<CEffectorCam *,xalloc<CEffectorCam *> >::back
PUBLIC	?clear@?$list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@stlp_std@@QAEXXZ ; stlp_std::list<CEffectorCam *,xalloc<CEffectorCam *> >::clear
PUBLIC	?push_front@?$_Impl_list@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEXABQAX@Z ; stlp_std::priv::_Impl_list<void *,xalloc<void *> >::push_front
PUBLIC	?push_front@?$list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@stlp_std@@QAEXABQAVCEffectorCam@@@Z ; stlp_std::list<CEffectorCam *,xalloc<CEffectorCam *> >::push_front
PUBLIC	?push_back@?$_Impl_list@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEXABQAX@Z ; stlp_std::priv::_Impl_list<void *,xalloc<void *> >::push_back
PUBLIC	?to_storage_type_cref@?$_CastTraits@PAXPAVCEffectorCam@@@priv@stlp_std@@SAABQAXABQAVCEffectorCam@@@Z ; stlp_std::priv::_CastTraits<void *,CEffectorCam *>::to_storage_type_cref
PUBLIC	?push_back@?$list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@stlp_std@@QAEXABQAVCEffectorCam@@@Z ; stlp_std::list<CEffectorCam *,xalloc<CEffectorCam *> >::push_back
PUBLIC	??E?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@QAE?AU012@H@Z ; stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> >::operator++
PUBLIC	?erase@?$list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@stlp_std@@QAE?AU?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@2@U342@@Z ; stlp_std::list<CEffectorCam *,xalloc<CEffectorCam *> >::erase
PUBLIC	??E?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@QAEAAU012@XZ ; stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> >::operator++
PUBLIC	??9?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@QBE_NU?$_List_iterator@PAVCEffectorCam@@U?$_Const_traits@PAVCEffectorCam@@@stlp_std@@@12@@Z ; stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> >::operator!=
PUBLIC	??$__find@U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@PAVCEffectorCam@@@priv@stlp_std@@YA?AU?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@01@U201@0ABQAVCEffectorCam@@ABUinput_iterator_tag@1@@Z ; stlp_std::priv::__find<stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> >,CEffectorCam *>
PUBLIC	??$find@U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@PAVCEffectorCam@@@stlp_std@@YA?AU?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@0@U120@0ABQAVCEffectorCam@@@Z ; stlp_std::find<stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> >,CEffectorCam *>
PUBLIC	?end@?$vector@PAVCEffectorPP@@V?$xalloc@PAVCEffectorPP@@@@@stlp_std@@QAEPAPAVCEffectorPP@@XZ ; stlp_std::vector<CEffectorPP *,xalloc<CEffectorPP *> >::end
PUBLIC	?positive@@YAHABM@Z				; positive
PUBLIC	?size@?$vector@PAVCEffectorPP@@V?$xalloc@PAVCEffectorPP@@@@@stlp_std@@QBEIXZ ; stlp_std::vector<CEffectorPP *,xalloc<CEffectorPP *> >::size
PUBLIC	?size@?$xr_vector@PAVCEffectorPP@@V?$xalloc@PAVCEffectorPP@@@@@@QBEIXZ ; xr_vector<CEffectorPP *,xalloc<CEffectorPP *> >::size
PUBLIC	?to_value_type_ptr@?$_CastTraits@PAXPAVCEffectorPP@@@priv@stlp_std@@SAPAPAVCEffectorPP@@PAPAX@Z ; stlp_std::priv::_CastTraits<void *,CEffectorPP *>::to_value_type_ptr
PUBLIC	?begin@?$vector@PAVCEffectorPP@@V?$xalloc@PAVCEffectorPP@@@@@stlp_std@@QAEPAPAVCEffectorPP@@XZ ; stlp_std::vector<CEffectorPP *,xalloc<CEffectorPP *> >::begin
PUBLIC	??A?$xr_vector@PAVCEffectorPP@@V?$xalloc@PAVCEffectorPP@@@@@@QAEAAPAVCEffectorPP@@I@Z ; xr_vector<CEffectorPP *,xalloc<CEffectorPP *> >::operator[]
PUBLIC	?end@?$list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@stlp_std@@QAE?AU?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@2@XZ ; stlp_std::list<CEffectorCam *,xalloc<CEffectorCam *> >::end
PUBLIC	?rbegin@?$list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@stlp_std@@QAE?AV?$reverse_iterator@U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@@2@XZ ; stlp_std::list<CEffectorCam *,xalloc<CEffectorCam *> >::rbegin
PUBLIC	??0?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@QAE@PAU_List_node_base@12@@Z ; stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> >::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> >
PUBLIC	?begin@?$list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@stlp_std@@QAE?AU?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@2@XZ ; stlp_std::list<CEffectorCam *,xalloc<CEffectorCam *> >::begin
PUBLIC	??0?$reverse_iterator@U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@@stlp_std@@QAE@U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@1@@Z ; stlp_std::reverse_iterator<stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> > >::reverse_iterator<stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> > >
PUBLIC	?rend@?$list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@stlp_std@@QAE?AV?$reverse_iterator@U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@@2@XZ ; stlp_std::list<CEffectorCam *,xalloc<CEffectorCam *> >::rend
PUBLIC	?empty@?$list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@stlp_std@@QBE_NXZ ; stlp_std::list<CEffectorCam *,xalloc<CEffectorCam *> >::empty
PUBLIC	??D?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@QBEAAPAVCEffectorCam@@XZ ; stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> >::operator*
PUBLIC	??D?$reverse_iterator@U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@@stlp_std@@QBEAAPAVCEffectorCam@@XZ ; stlp_std::reverse_iterator<stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> > >::operator*
PUBLIC	?_M_decr@_List_iterator_base@priv@stlp_std@@QAEXXZ ; stlp_std::priv::_List_iterator_base::_M_decr
PUBLIC	??F?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@QAEAAU012@XZ ; stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> >::operator--
PUBLIC	??E?$reverse_iterator@U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@@stlp_std@@QAEAAV01@XZ ; stlp_std::reverse_iterator<stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> > >::operator++
PUBLIC	??8?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@QBE_NU?$_List_iterator@PAVCEffectorCam@@U?$_Const_traits@PAVCEffectorCam@@@stlp_std@@@12@@Z ; stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> >::operator==
PUBLIC	??0?$_List_iterator@PAVCEffectorCam@@U?$_Const_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@QAE@ABU?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@12@@Z ; stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Const_traits<CEffectorCam *> >::_List_iterator<CEffectorCam *,stlp_std::_Const_traits<CEffectorCam *> >
PUBLIC	??0?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@QAE@ABU012@@Z ; stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> >::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> >
PUBLIC	?base@?$reverse_iterator@U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@@stlp_std@@QBE?AU?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@2@XZ ; stlp_std::reverse_iterator<stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> > >::base
PUBLIC	??$?8U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@@stlp_std@@YA_NABV?$reverse_iterator@U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@@0@0@Z ; stlp_std::operator==<stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> > >
PUBLIC	??$?9U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@@stlp_std@@YA_NABV?$reverse_iterator@U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@@0@0@Z ; stlp_std::operator!=<stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> > >
PUBLIC	?psCamInert@@3MA				; psCamInert
PUBLIC	?psCamSlideInert@@3MA				; psCamSlideInert
PUBLIC	??_C@_0BD@CBLELFAD@before?5applying?5pp?$AA@	; `string'
PUBLIC	??_C@_08OJJMFNLK@in?5cycle?$AA@			; `string'
PUBLIC	??_C@_0BC@OINHOLDA@after?5applying?5pp?$AA@	; `string'
PUBLIC	??_C@_0N@NCEMCLOF@apply?5device?$AA@		; `string'
PUBLIC	??_C@_0CE@EPEEGAIB@CCameraManager?3?3Dump?3?3vPosition?5@ ; `string'
PUBLIC	??_C@_0CE@GPCFDNJG@CCameraManager?3?3Dump?3?3vDirection@ ; `string'
PUBLIC	??_C@_0CE@OAGGNCIH@CCameraManager?3?3Dump?3?3vNormal?5?5?5@ ; `string'
PUBLIC	??_C@_0CE@IAALBLBH@CCameraManager?3?3Dump?3?3vRight?5?5?5?5@ ; `string'
PUBLIC	??_7CEffectorCam@@6B@				; CEffectorCam::`vftable'
PUBLIC	??_7CEffectorPP@@6B@				; CEffectorPP::`vftable'
EXTRN	__imp_?Log@@YAXPBDABU?$_vector3@M@@@Z:PROC
EXTRN	_atexit:PROC
?psCamInert@@3MA DD 01H DUP (?)				; psCamInert
;	COMDAT ??_7CEffectorPP@@6B@
CONST	SEGMENT
??_7CEffectorPP@@6B@ DD FLAT:??_R4CEffectorPP@@6B@	; CEffectorPP::`vftable'
	DD	FLAT:??_ECEffectorPP@@UAEPAXI@Z
	DD	FLAT:?Process@CEffectorPP@@UAEHAAUSPPInfo@@@Z
	DD	FLAT:?Valid@CEffectorPP@@UAEHXZ
	DD	FLAT:?Stop@CEffectorPP@@UAEXM@Z
CONST	ENDS
;	COMDAT ??_R4CEffectorPP@@6B@
rdata$r	SEGMENT
??_R4CEffectorPP@@6B@ DD 00H				; CEffectorPP::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCEffectorPP@@@8
	DD	FLAT:??_R3CEffectorPP@@8
rdata$r	ENDS
;	COMDAT ??_R3CEffectorPP@@8
rdata$r	SEGMENT
??_R3CEffectorPP@@8 DD 00H				; CEffectorPP::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CEffectorPP@@8
rdata$r	ENDS
;	COMDAT ??_R2CEffectorPP@@8
rdata$r	SEGMENT
??_R2CEffectorPP@@8 DD FLAT:??_R1A@?0A@EA@CEffectorPP@@8 ; CEffectorPP::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@SBaseEffector@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CEffectorPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CEffectorPP@@8 DD FLAT:??_R0?AVCEffectorPP@@@8 ; CEffectorPP::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CEffectorPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCEffectorPP@@@8
_DATA	SEGMENT
??_R0?AVCEffectorPP@@@8 DD FLAT:??_7type_info@@6B@	; CEffectorPP `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCEffectorPP@@', 00H
_DATA	ENDS
;	COMDAT ??_7CEffectorCam@@6B@
CONST	SEGMENT
??_7CEffectorCam@@6B@ DD FLAT:??_R4CEffectorCam@@6B@	; CEffectorCam::`vftable'
	DD	FLAT:??_ECEffectorCam@@UAEPAXI@Z
	DD	FLAT:?Valid@CEffectorCam@@UAEHXZ
	DD	FLAT:?ProcessCam@CEffectorCam@@UAEHAAUSCamEffectorInfo@@@Z
	DD	FLAT:?ProcessIfInvalid@CEffectorCam@@UAEXAAUSCamEffectorInfo@@@Z
	DD	FLAT:?AllowProcessingIfInvalid@CEffectorCam@@UAEHXZ
	DD	FLAT:?AbsolutePositioning@CEffectorCam@@UAE_NXZ
CONST	ENDS
;	COMDAT ??_R4CEffectorCam@@6B@
rdata$r	SEGMENT
??_R4CEffectorCam@@6B@ DD 00H				; CEffectorCam::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCEffectorCam@@@8
	DD	FLAT:??_R3CEffectorCam@@8
rdata$r	ENDS
;	COMDAT ??_R3CEffectorCam@@8
rdata$r	SEGMENT
??_R3CEffectorCam@@8 DD 00H				; CEffectorCam::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CEffectorCam@@8
rdata$r	ENDS
;	COMDAT ??_R2CEffectorCam@@8
rdata$r	SEGMENT
??_R2CEffectorCam@@8 DD FLAT:??_R1A@?0A@EA@CEffectorCam@@8 ; CEffectorCam::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@SBaseEffector@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CEffectorCam@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CEffectorCam@@8 DD FLAT:??_R0?AVCEffectorCam@@@8 ; CEffectorCam::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CEffectorCam@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCEffectorCam@@@8
_DATA	SEGMENT
??_R0?AVCEffectorCam@@@8 DD FLAT:??_7type_info@@6B@	; CEffectorCam `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCEffectorCam@@', 00H
_DATA	ENDS
;	COMDAT ??_C@_0CE@IAALBLBH@CCameraManager?3?3Dump?3?3vRight?5?5?5?5@
CONST	SEGMENT
??_C@_0CE@IAALBLBH@CCameraManager?3?3Dump?3?3vRight?5?5?5?5@ DB 'CCameraM'
	DB	'anager::Dump::vRight     = ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@OAGGNCIH@CCameraManager?3?3Dump?3?3vNormal?5?5?5@
CONST	SEGMENT
??_C@_0CE@OAGGNCIH@CCameraManager?3?3Dump?3?3vNormal?5?5?5@ DB 'CCameraMa'
	DB	'nager::Dump::vNormal    = ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GPCFDNJG@CCameraManager?3?3Dump?3?3vDirection@
CONST	SEGMENT
??_C@_0CE@GPCFDNJG@CCameraManager?3?3Dump?3?3vDirection@ DB 'CCameraManag'
	DB	'er::Dump::vDirection = ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@EPEEGAIB@CCameraManager?3?3Dump?3?3vPosition?5@
CONST	SEGMENT
??_C@_0CE@EPEEGAIB@CCameraManager?3?3Dump?3?3vPosition?5@ DB 'CCameraMana'
	DB	'ger::Dump::vPosition  = ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NCEMCLOF@apply?5device?$AA@
CONST	SEGMENT
??_C@_0N@NCEMCLOF@apply?5device?$AA@ DB 'apply device', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OINHOLDA@after?5applying?5pp?$AA@
CONST	SEGMENT
??_C@_0BC@OINHOLDA@after?5applying?5pp?$AA@ DB 'after applying pp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08OJJMFNLK@in?5cycle?$AA@
CONST	SEGMENT
??_C@_08OJJMFNLK@in?5cycle?$AA@ DB 'in cycle', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CBLELFAD@before?5applying?5pp?$AA@
CONST	SEGMENT
??_C@_0BD@CBLELFAD@before?5applying?5pp?$AA@ DB 'before applying pp', 00H ; `string'
?psCamSlideInert@@3MA DD 03e800000r		; 0.25	; psCamSlideInert
_EPS_L	DD	03a83126fr			; 0.001
_M_PI	DD	040490fdbr			; 3.14159
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\vector.h
;	COMDAT ??$clampr@H@@YAHABH00@Z
_TEXT	SEGMENT
??$clampr@H@@YAHABH00@Z PROC				; clampr<int>, COMDAT
; _val$ = eax
; __high$ = ecx

; 102  : 	if		( val<_low	)	return _low; 
; 103  : 	else if	( val>_high )	return _high;

	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	cmp	eax, ecx
	jle	SHORT $LN8@clampr
	mov	eax, ecx
$LN8@clampr:

; 104  : 	else					return val;
; 105  : };

	ret	0
??$clampr@H@@YAHABH00@Z ENDP				; clampr<int>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_color.h
_TEXT	ENDS
;	COMDAT ?color_argb@@YAIIIII@Z
_TEXT	SEGMENT
_r$ = 8							; size = 4
_g$ = 12						; size = 4
_b$ = 16						; size = 4
?color_argb@@YAIIIII@Z PROC				; color_argb, COMDAT
; _a$ = ecx

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	movzx	eax, BYTE PTR _r$[esp-4]
	movzx	edx, BYTE PTR _b$[esp-4]
	shl	ecx, 8
	or	eax, ecx
	movzx	ecx, BYTE PTR _g$[esp-4]
	shl	eax, 8
	or	eax, ecx
	shl	eax, 8
	or	eax, edx
	ret	0
?color_argb@@YAIIIII@Z ENDP				; color_argb
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?color_rgba@@YAIIIII@Z
_TEXT	SEGMENT
_r$ = 8							; size = 4
_g$ = 12						; size = 4
_b$ = 16						; size = 4
?color_rgba@@YAIIIII@Z PROC				; color_rgba, COMDAT
; _a$ = ecx

; 6    : ICF u32	color_rgba	(u32 r, u32 g, u32 b, u32 a)	{	return color_argb(a,r,g,b);		}

	movzx	eax, BYTE PTR _r$[esp-4]
	movzx	edx, BYTE PTR _b$[esp-4]
	shl	ecx, 8
	or	eax, ecx
	movzx	ecx, BYTE PTR _g$[esp-4]
	shl	eax, 8
	or	eax, ecx
	shl	eax, 8
	or	eax, edx
	ret	0
?color_rgba@@YAIIIII@Z ENDP				; color_rgba
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_bitwise.h
_TEXT	ENDS
;	COMDAT ?positive@@YAHABM@Z
_TEXT	SEGMENT
?positive@@YAHABM@Z PROC				; positive, COMDAT
; _f$ = eax

; 26   : 	IC BOOL positive(const float &f)	{ return (*((unsigned*)(&f))&fdSGN)==0;	}

	mov	eax, DWORD PTR [eax]
	shr	eax, 31					; 0000001fH
	not	eax
	and	eax, 1
	ret	0
?positive@@YAHABM@Z ENDP				; positive
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\fastdelegate.h
_TEXT	ENDS
;	COMDAT ??7DelegateMemento@fastdelegate@@QBE_NXZ
_TEXT	SEGMENT
??7DelegateMemento@fastdelegate@@QBE_NXZ PROC		; fastdelegate::DelegateMemento::operator!, COMDAT
; _this$ = eax

; 624  : 	{ return m_pthis==0 && m_pFunction==0; }

	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN3@operator
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN3@operator
	mov	eax, 1
	ret	0
$LN3@operator:
	xor	eax, eax
	ret	0
??7DelegateMemento@fastdelegate@@QBE_NXZ ENDP		; fastdelegate::DelegateMemento::operator!
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_list.h
_TEXT	ENDS
;	COMDAT ?_M_decr@_List_iterator_base@priv@stlp_std@@QAEXXZ
_TEXT	SEGMENT
?_M_decr@_List_iterator_base@priv@stlp_std@@QAEXXZ PROC	; stlp_std::priv::_List_iterator_base::_M_decr, COMDAT
; _this$ = eax

; 92   :   void _M_decr() { _M_node = _M_node->_M_prev; }

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	ret	0
?_M_decr@_List_iterator_base@priv@stlp_std@@QAEXXZ ENDP	; stlp_std::priv::_List_iterator_base::_M_decr
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??8?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@QBE_NU?$_List_iterator@PAVCEffectorCam@@U?$_Const_traits@PAVCEffectorCam@@@stlp_std@@@12@@Z
_TEXT	SEGMENT
___y$ = 8						; size = 4
??8?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@QBE_NU?$_List_iterator@PAVCEffectorCam@@U?$_Const_traits@PAVCEffectorCam@@@stlp_std@@@12@@Z PROC ; stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> >::operator==, COMDAT
; _this$ = ecx

; 141  :     return this->_M_node == __y._M_node;

	mov	edx, DWORD PTR [ecx]
	xor	eax, eax
	cmp	edx, DWORD PTR ___y$[esp-4]
	sete	al

; 142  :   }

	ret	4
??8?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@QBE_NU?$_List_iterator@PAVCEffectorCam@@U?$_Const_traits@PAVCEffectorCam@@@stlp_std@@@12@@Z ENDP ; stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> >::operator==
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\xrmemory_subst_msvc.h
_TEXT	ENDS
;	COMDAT ??R?$xr_special_free@$00USBaseEffector@@@@QAEXAAPAUSBaseEffector@@@Z
_TEXT	SEGMENT
??R?$xr_special_free@$00USBaseEffector@@@@QAEXAAPAUSBaseEffector@@@Z PROC ; xr_special_free<1,SBaseEffector>::operator(), COMDAT
; _ptr$ = esi

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	mov	eax, DWORD PTR [esi]
	push	edi
	push	eax
	call	___RTCastToVoid

; 133  : 		ptr->~T			();

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	add	esp, 4
	mov	edi, eax
	mov	eax, DWORD PTR [edx]
	push	0
	call	eax

; 134  : 		Memory.mem_free	(_real_ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	pop	edi

; 135  : 	}

	ret	0
??R?$xr_special_free@$00USBaseEffector@@@@QAEXAAPAUSBaseEffector@@@Z ENDP ; xr_special_free<1,SBaseEffector>::operator()
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??R?$xr_special_free@$00VCEffectorPP@@@@QAEXAAPAVCEffectorPP@@@Z
_TEXT	SEGMENT
??R?$xr_special_free@$00VCEffectorPP@@@@QAEXAAPAVCEffectorPP@@@Z PROC ; xr_special_free<1,CEffectorPP>::operator(), COMDAT
; _ptr$ = esi

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	mov	eax, DWORD PTR [esi]
	push	edi
	push	eax
	call	___RTCastToVoid

; 133  : 		ptr->~T			();

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	add	esp, 4
	mov	edi, eax
	mov	eax, DWORD PTR [edx]
	push	0
	call	eax

; 134  : 		Memory.mem_free	(_real_ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	pop	edi

; 135  : 	}

	ret	0
??R?$xr_special_free@$00VCEffectorPP@@@@QAEXAAPAVCEffectorPP@@@Z ENDP ; xr_special_free<1,CEffectorPP>::operator()
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??R?$xr_special_free@$00VCEffectorCam@@@@QAEXAAPAVCEffectorCam@@@Z
_TEXT	SEGMENT
??R?$xr_special_free@$00VCEffectorCam@@@@QAEXAAPAVCEffectorCam@@@Z PROC ; xr_special_free<1,CEffectorCam>::operator(), COMDAT
; _ptr$ = esi

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	mov	eax, DWORD PTR [esi]
	push	edi
	push	eax
	call	___RTCastToVoid

; 133  : 		ptr->~T			();

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	add	esp, 4
	mov	edi, eax
	mov	eax, DWORD PTR [edx]
	push	0
	call	eax

; 134  : 		Memory.mem_free	(_real_ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	pop	edi

; 135  : 	}

	ret	0
??R?$xr_special_free@$00VCEffectorCam@@@@QAEXAAPAVCEffectorCam@@@Z ENDP ; xr_special_free<1,CEffectorCam>::operator()
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ??$?0PAVCEffectorPP@@@?$xalloc@PAX@@QAE@ABV?$xalloc@PAVCEffectorPP@@@@@Z
_TEXT	SEGMENT
??$?0PAVCEffectorPP@@@?$xalloc@PAX@@QAE@ABV?$xalloc@PAVCEffectorPP@@@@@Z PROC ; xalloc<void *>::xalloc<void *><CEffectorPP *>, COMDAT
; _this$ = eax

; 79   : 	template<class _Other>							xalloc			(const xalloc<_Other>&)					{	}

	ret	0
??$?0PAVCEffectorPP@@@?$xalloc@PAX@@QAE@ABV?$xalloc@PAVCEffectorPP@@@@@Z ENDP ; xalloc<void *>::xalloc<void *><CEffectorPP *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0PAVCEffectorCam@@@?$xalloc@PAX@@QAE@ABV?$xalloc@PAVCEffectorCam@@@@@Z
_TEXT	SEGMENT
??$?0PAVCEffectorCam@@@?$xalloc@PAX@@QAE@ABV?$xalloc@PAVCEffectorCam@@@@@Z PROC ; xalloc<void *>::xalloc<void *><CEffectorCam *>, COMDAT
; _this$ = eax

; 79   : 	template<class _Other>							xalloc			(const xalloc<_Other>&)					{	}

	ret	0
??$?0PAVCEffectorCam@@@?$xalloc@PAX@@QAE@ABV?$xalloc@PAVCEffectorCam@@@@@Z ENDP ; xalloc<void *>::xalloc<void *><CEffectorCam *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\xrmemory_subst_msvc.h
_TEXT	ENDS
;	COMDAT ??$xr_delete@USBaseEffector@@@@YAXAAPAUSBaseEffector@@@Z
_TEXT	SEGMENT
??$xr_delete@USBaseEffector@@@@YAXAAPAUSBaseEffector@@@Z PROC ; xr_delete<SBaseEffector>, COMDAT
; _ptr$ = esi

; 151  : 	if (ptr) 

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN1@xr_delete@11
	push	edi

; 152  : 	{
; 153  : 		xr_special_free<is_polymorphic<T>::result,T>()(ptr);

	push	eax
	call	___RTCastToVoid
	mov	ecx, DWORD PTR [esi]
	mov	edi, eax
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	add	esp, 4
	push	0
	call	edx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 154  : 		ptr = NULL;

	mov	DWORD PTR [esi], 0
	pop	edi
$LN1@xr_delete@11:

; 155  : 	}
; 156  : }

	ret	0
??$xr_delete@USBaseEffector@@@@YAXAAPAUSBaseEffector@@@Z ENDP ; xr_delete<SBaseEffector>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$xr_delete@VCEffectorPP@@@@YAXAAPAVCEffectorPP@@@Z
_TEXT	SEGMENT
??$xr_delete@VCEffectorPP@@@@YAXAAPAVCEffectorPP@@@Z PROC ; xr_delete<CEffectorPP>, COMDAT
; _ptr$ = esi

; 151  : 	if (ptr) 

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN1@xr_delete@12
	push	edi

; 152  : 	{
; 153  : 		xr_special_free<is_polymorphic<T>::result,T>()(ptr);

	push	eax
	call	___RTCastToVoid
	mov	ecx, DWORD PTR [esi]
	mov	edi, eax
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	add	esp, 4
	push	0
	call	edx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 154  : 		ptr = NULL;

	mov	DWORD PTR [esi], 0
	pop	edi
$LN1@xr_delete@12:

; 155  : 	}
; 156  : }

	ret	0
??$xr_delete@VCEffectorPP@@@@YAXAAPAVCEffectorPP@@@Z ENDP ; xr_delete<CEffectorPP>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$xr_delete@VCEffectorCam@@@@YAXAAPAVCEffectorCam@@@Z
_TEXT	SEGMENT
??$xr_delete@VCEffectorCam@@@@YAXAAPAVCEffectorCam@@@Z PROC ; xr_delete<CEffectorCam>, COMDAT
; _ptr$ = esi

; 151  : 	if (ptr) 

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN1@xr_delete@13
	push	edi

; 152  : 	{
; 153  : 		xr_special_free<is_polymorphic<T>::result,T>()(ptr);

	push	eax
	call	___RTCastToVoid
	mov	ecx, DWORD PTR [esi]
	mov	edi, eax
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	add	esp, 4
	push	0
	call	edx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 154  : 		ptr = NULL;

	mov	DWORD PTR [esi], 0
	pop	edi
$LN1@xr_delete@13:

; 155  : 	}
; 156  : }

	ret	0
??$xr_delete@VCEffectorCam@@@@YAXAAPAVCEffectorCam@@@Z ENDP ; xr_delete<CEffectorCam>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_list.h
_TEXT	ENDS
;	COMDAT ??F?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@QAEAAU012@XZ
_TEXT	SEGMENT
??F?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@QAEAAU012@XZ PROC ; stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> >::operator--, COMDAT
; _this$ = eax

; 132  :     this->_M_decr();

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 133  :     return *this;
; 134  :   }

	ret	0
??F?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@QAEAAU012@XZ ENDP ; stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> >::operator--
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ??0?$xalloc@PAVCEffectorPP@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@PAVCEffectorPP@@@@QAE@XZ PROC		; xalloc<CEffectorPP *>::xalloc<CEffectorPP *>, COMDAT
; _this$ = eax

; 77   : 													xalloc			()										{	}

	ret	0
??0?$xalloc@PAVCEffectorPP@@@@QAE@XZ ENDP		; xalloc<CEffectorPP *>::xalloc<CEffectorPP *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\fastdelegate.h
_TEXT	ENDS
;	COMDAT ?GetClosureMemPtr@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AGXXZP6GXXZP6GXXZ@detail@fastdelegate@@QBEP8GenericClass@23@AGXXZXZ
_TEXT	SEGMENT
?GetClosureMemPtr@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AGXXZP6GXXZP6GXXZ@detail@fastdelegate@@QBEP8GenericClass@23@AGXXZXZ PROC ; fastdelegate::detail::ClosurePtr<void (__stdcall fastdelegate::detail::GenericClass::*)(void),void (__stdcall*)(void),void (__stdcall*)(void)>::GetClosureMemPtr, COMDAT
; _this$ = eax

; 711  : 	inline GenericMemFunc GetClosureMemPtr() const { return reinterpret_cast<GenericMemFunc>(m_pFunction); }

	mov	eax, DWORD PTR [eax+4]
	ret	0
?GetClosureMemPtr@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AGXXZP6GXXZP6GXXZ@detail@fastdelegate@@QBEP8GenericClass@23@AGXXZXZ ENDP ; fastdelegate::detail::ClosurePtr<void (__stdcall fastdelegate::detail::GenericClass::*)(void),void (__stdcall*)(void),void (__stdcall*)(void)>::GetClosureMemPtr
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetClosureThis@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AGXXZP6GXXZP6GXXZ@detail@fastdelegate@@QBEPAVGenericClass@23@XZ
_TEXT	SEGMENT
?GetClosureThis@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AGXXZP6GXXZP6GXXZ@detail@fastdelegate@@QBEPAVGenericClass@23@XZ PROC ; fastdelegate::detail::ClosurePtr<void (__stdcall fastdelegate::detail::GenericClass::*)(void),void (__stdcall*)(void),void (__stdcall*)(void)>::GetClosureThis, COMDAT
; _this$ = eax

; 710  : 	inline GenericClass *GetClosureThis() const { return m_pthis; }

	mov	eax, DWORD PTR [eax]
	ret	0
?GetClosureThis@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AGXXZP6GXXZP6GXXZ@detail@fastdelegate@@QBEPAVGenericClass@23@XZ ENDP ; fastdelegate::detail::ClosurePtr<void (__stdcall fastdelegate::detail::GenericClass::*)(void),void (__stdcall*)(void),void (__stdcall*)(void)>::GetClosureThis
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_matrix.h
_TEXT	ENDS
;	COMDAT ?build_projection_HAT@?$_matrix@M@@QAEAAU1@MMMM@Z
_TEXT	SEGMENT
_HAT$ = 8						; size = 4
_fAspect$ = 12						; size = 4
?build_projection_HAT@?$_matrix@M@@QAEAAU1@MMMM@Z PROC	; _matrix<float>::build_projection_HAT, COMDAT
; _this$ = eax
; _fNearPlane$ = xmm4s
; _fFarPlane$ = xmm2s

; 402  : 		VERIFY( _abs(fFarPlane-fNearPlane) > EPS_S );
; 403  : 		VERIFY( _abs(HAT) > EPS_S );
; 404  : 		
; 405  : 		T cot	= T(1)/HAT;

	movss	xmm3, DWORD PTR __real@3f800000

; 406  : 		T w		= fAspect * cot;
; 407  : 		T h		= T(1)    * cot;
; 408  : 		T Q		= fFarPlane / ( fFarPlane - fNearPlane );

	movaps	xmm0, xmm2
	subss	xmm0, xmm4
	divss	xmm2, xmm0
	movaps	xmm1, xmm3
	divss	xmm1, DWORD PTR _HAT$[esp-4]
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR _fAspect$[esp-4]

; 409  : 		
; 410  : 		_11		= w;	_12 = 0;	_13 = 0;			_14 = 0;
; 411  : 		_21		= 0;	_22	= h;	_23 = 0;			_24 = 0;

	movss	DWORD PTR [eax+20], xmm1

; 412  : 		_31		= 0;	_32 = 0;	_33 = Q;			_34 = 1.0f;
; 413  : 		_41		= 0;	_42 = 0;	_43	= -Q*fNearPlane;_44 = 0;

	movss	xmm1, DWORD PTR __real@80000000
	movss	DWORD PTR [eax+40], xmm2
	movss	DWORD PTR [eax], xmm0
	xorps	xmm0, xmm0
	mulss	xmm2, xmm4
	subss	xmm1, xmm2
	movss	DWORD PTR [eax+4], xmm0
	movss	DWORD PTR [eax+8], xmm0
	movss	DWORD PTR [eax+12], xmm0
	movss	DWORD PTR [eax+16], xmm0
	movss	DWORD PTR [eax+24], xmm0
	movss	DWORD PTR [eax+28], xmm0
	movss	DWORD PTR [eax+32], xmm0
	movss	DWORD PTR [eax+36], xmm0
	movss	DWORD PTR [eax+44], xmm3
	movss	DWORD PTR [eax+48], xmm0
	movss	DWORD PTR [eax+52], xmm0
	movss	DWORD PTR [eax+56], xmm1
	movss	DWORD PTR [eax+60], xmm0

; 414  : 		return *this; 
; 415  : 	}

	ret	8
?build_projection_HAT@?$_matrix@M@@QAEAAU1@MMMM@Z ENDP	; _matrix<float>::build_projection_HAT
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_iterator.h
_TEXT	ENDS
;	COMDAT ??E?$reverse_iterator@U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@@stlp_std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$reverse_iterator@U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@@stlp_std@@QAEAAV01@XZ PROC ; stlp_std::reverse_iterator<stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> > >::operator++, COMDAT
; _this$ = eax

; 82   :     --current;

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 83   :     return *this;
; 84   :   }

	ret	0
??E?$reverse_iterator@U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@@stlp_std@@QAEAAV01@XZ ENDP ; stlp_std::reverse_iterator<stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> > >::operator++
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_list.h
_TEXT	ENDS
;	COMDAT ??9?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@QBE_NU?$_List_iterator@PAVCEffectorCam@@U?$_Const_traits@PAVCEffectorCam@@@stlp_std@@@12@@Z
_TEXT	SEGMENT
___y$ = 8						; size = 4
??9?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@QBE_NU?$_List_iterator@PAVCEffectorCam@@U?$_Const_traits@PAVCEffectorCam@@@stlp_std@@@12@@Z PROC ; stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> >::operator!=, COMDAT
; _this$ = ecx

; 144  :     return this->_M_node != __y._M_node;

	mov	edx, DWORD PTR [ecx]
	xor	eax, eax
	cmp	edx, DWORD PTR ___y$[esp-4]
	setne	al

; 145  :   }

	ret	4
??9?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@QBE_NU?$_List_iterator@PAVCEffectorCam@@U?$_Const_traits@PAVCEffectorCam@@@stlp_std@@@12@@Z ENDP ; stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> >::operator!=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??D?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@QBEAAPAVCEffectorCam@@XZ
_TEXT	SEGMENT
??D?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@QBEAAPAVCEffectorCam@@XZ PROC ; stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> >::operator*, COMDAT
; _this$ = eax

; 118  :   reference operator*() const { return __STATIC_CAST(_Node*, this->_M_node)->_M_data; }

	mov	eax, DWORD PTR [eax]
	add	eax, 8
	ret	0
??D?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@QBEAAPAVCEffectorCam@@XZ ENDP ; stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> >::operator*
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ??0?$xalloc@PAVCEffectorCam@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@PAVCEffectorCam@@@@QAE@XZ PROC		; xalloc<CEffectorCam *>::xalloc<CEffectorCam *>, COMDAT
; _this$ = eax

; 77   : 													xalloc			()										{	}

	ret	0
??0?$xalloc@PAVCEffectorCam@@@@QAE@XZ ENDP		; xalloc<CEffectorCam *>::xalloc<CEffectorCam *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\fastdelegate.h
_TEXT	ENDS
;	COMDAT ?empty@?$FastDelegate0@X@fastdelegate@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$FastDelegate0@X@fastdelegate@@QBE_NXZ PROC	; fastdelegate::FastDelegate0<void>::empty, COMDAT
; _this$ = eax

; 935  : 		return !m_Closure; }

	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN5@empty
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN5@empty
	mov	eax, 1
	ret	0
$LN5@empty:
	xor	eax, eax
	ret	0
?empty@?$FastDelegate0@X@fastdelegate@@QBE_NXZ ENDP	; fastdelegate::FastDelegate0<void>::empty
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??R?$FastDelegate0@X@fastdelegate@@QBEXXZ
_TEXT	SEGMENT
??R?$FastDelegate0@X@fastdelegate@@QBEXXZ PROC		; fastdelegate::FastDelegate0<void>::operator(), COMDAT
; _this$ = eax

; 915  : 						return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(); }

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	push	ecx
	call	edx
	ret	0
??R?$FastDelegate0@X@fastdelegate@@QBEXXZ ENDP		; fastdelegate::FastDelegate0<void>::operator()
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_matrix.h
_TEXT	ENDS
;	COMDAT ?invert@?$_matrix@M@@QAEAAU1@ABU1@@Z
_TEXT	SEGMENT
?invert@?$_matrix@M@@QAEAAU1@ABU1@@Z PROC		; _matrix<float>::invert, COMDAT
; _this$ = eax
; _a$ = ecx

; 153  : 		// faster than self-invert
; 154  : 		T fDetInv = ( a._11 * ( a._22 * a._33 - a._23 * a._32 ) -
; 155  : 			a._12 * ( a._21 * a._33 - a._23 * a._31 ) +
; 156  : 			a._13 * ( a._21 * a._32 - a._22 * a._31 ) );

	movss	xmm5, DWORD PTR [ecx+24]
	movss	xmm4, DWORD PTR [ecx+20]
	movss	xmm3, DWORD PTR [ecx+40]
	movss	xmm0, DWORD PTR [ecx+36]
	movaps	xmm1, xmm4
	movaps	xmm2, xmm5
	mulss	xmm2, xmm0
	movss	xmm0, DWORD PTR [ecx+16]
	mulss	xmm1, xmm3
	subss	xmm1, xmm2
	movss	xmm2, DWORD PTR [ecx+32]
	movaps	xmm7, xmm0
	mulss	xmm7, xmm3
	movaps	xmm3, xmm2
	mulss	xmm2, xmm4
	mulss	xmm3, xmm5
	movaps	xmm6, xmm1
	mulss	xmm6, DWORD PTR [ecx]
	subss	xmm7, xmm3
	movss	xmm3, DWORD PTR [ecx+36]
	mulss	xmm7, DWORD PTR [ecx+4]
	mulss	xmm0, xmm3

; 157  : 
; 158  : 		VERIFY(_abs(fDetInv)>flt_zero);
; 159  : 		fDetInv=1.0f/fDetInv;

	movss	xmm3, DWORD PTR __real@3f800000
	subss	xmm0, xmm2
	mulss	xmm0, DWORD PTR [ecx+8]
	subss	xmm6, xmm7
	addss	xmm6, xmm0
	movaps	xmm0, xmm3
	divss	xmm0, xmm6

; 160  : 
; 161  : 		_11 =  fDetInv * ( a._22 * a._33 - a._23 * a._32 );

	mulss	xmm1, xmm0
	movss	DWORD PTR [eax], xmm1

; 162  : 		_12 = -fDetInv * ( a._12 * a._33 - a._13 * a._32 );

	movss	xmm2, DWORD PTR [ecx+4]
	mulss	xmm2, DWORD PTR [ecx+40]
	movss	xmm1, DWORD PTR [ecx+36]
	mulss	xmm1, DWORD PTR [ecx+8]
	subss	xmm2, xmm1
	movss	xmm1, DWORD PTR __real@80000000
	mulss	xmm2, xmm0
	movaps	xmm4, xmm1
	subss	xmm4, xmm2
	movss	DWORD PTR [eax+4], xmm4

; 163  : 		_13 =  fDetInv * ( a._12 * a._23 - a._13 * a._22 );

	movss	xmm2, DWORD PTR [ecx+24]
	mulss	xmm2, DWORD PTR [ecx+4]
	movss	xmm4, DWORD PTR [ecx+20]
	mulss	xmm4, DWORD PTR [ecx+8]
	subss	xmm2, xmm4
	mulss	xmm2, xmm0
	movss	DWORD PTR [eax+8], xmm2

; 164  : 		_14 = 0.0f;

	xorps	xmm2, xmm2
	movss	DWORD PTR [eax+12], xmm2

; 165  : 
; 166  : 		_21 = -fDetInv * ( a._21 * a._33 - a._23 * a._31 );

	movss	xmm4, DWORD PTR [ecx+16]
	mulss	xmm4, DWORD PTR [ecx+40]
	movss	xmm5, DWORD PTR [ecx+32]
	mulss	xmm5, DWORD PTR [ecx+24]
	subss	xmm4, xmm5
	mulss	xmm4, xmm0
	movaps	xmm5, xmm1
	subss	xmm5, xmm4
	movss	DWORD PTR [eax+16], xmm5

; 167  : 		_22 =  fDetInv * ( a._11 * a._33 - a._13 * a._31 );

	movss	xmm4, DWORD PTR [ecx]
	mulss	xmm4, DWORD PTR [ecx+40]
	movss	xmm5, DWORD PTR [ecx+32]
	mulss	xmm5, DWORD PTR [ecx+8]
	subss	xmm4, xmm5
	mulss	xmm4, xmm0
	movss	DWORD PTR [eax+20], xmm4

; 168  : 		_23 = -fDetInv * ( a._11 * a._23 - a._13 * a._21 );

	movss	xmm4, DWORD PTR [ecx+24]
	mulss	xmm4, DWORD PTR [ecx]
	movss	xmm5, DWORD PTR [ecx+16]
	mulss	xmm5, DWORD PTR [ecx+8]
	subss	xmm4, xmm5
	mulss	xmm4, xmm0

; 169  : 		_24 = 0.0f;

	movss	DWORD PTR [eax+28], xmm2
	movaps	xmm5, xmm1
	subss	xmm5, xmm4
	movss	DWORD PTR [eax+24], xmm5

; 170  : 
; 171  : 		_31 =  fDetInv * ( a._21 * a._32 - a._22 * a._31 );

	movss	xmm4, DWORD PTR [ecx+36]
	movss	xmm5, DWORD PTR [ecx+32]
	mulss	xmm4, DWORD PTR [ecx+16]
	mulss	xmm5, DWORD PTR [ecx+20]
	subss	xmm4, xmm5
	mulss	xmm4, xmm0
	movss	DWORD PTR [eax+32], xmm4

; 172  : 		_32 = -fDetInv * ( a._11 * a._32 - a._12 * a._31 );

	movss	xmm4, DWORD PTR [ecx+36]
	mulss	xmm4, DWORD PTR [ecx]
	movss	xmm5, DWORD PTR [ecx+32]
	mulss	xmm5, DWORD PTR [ecx+4]
	subss	xmm4, xmm5
	mulss	xmm4, xmm0
	movaps	xmm5, xmm1
	subss	xmm5, xmm4
	movss	DWORD PTR [eax+36], xmm5

; 173  : 		_33 =  fDetInv * ( a._11 * a._22 - a._12 * a._21 );

	movss	xmm4, DWORD PTR [ecx+20]
	mulss	xmm4, DWORD PTR [ecx]
	movss	xmm5, DWORD PTR [ecx+16]
	mulss	xmm5, DWORD PTR [ecx+4]

; 174  : 		_34 = 0.0f;

	movss	DWORD PTR [eax+44], xmm2
	subss	xmm4, xmm5
	mulss	xmm4, xmm0

; 175  : 
; 176  : 		_41 = -( a._41 * _11 + a._42 * _21 + a._43 * _31 );

	movss	xmm0, DWORD PTR [eax+32]
	movss	DWORD PTR [eax+40], xmm4
	mulss	xmm0, DWORD PTR [ecx+56]
	movss	xmm2, DWORD PTR [ecx+48]
	mulss	xmm2, DWORD PTR [eax]
	addss	xmm0, xmm2
	movss	xmm2, DWORD PTR [ecx+52]
	mulss	xmm2, DWORD PTR [eax+16]
	addss	xmm0, xmm2
	movaps	xmm2, xmm1
	subss	xmm2, xmm0
	movss	DWORD PTR [eax+48], xmm2

; 177  : 		_42 = -( a._41 * _12 + a._42 * _22 + a._43 * _32 );

	movss	xmm0, DWORD PTR [ecx+52]
	mulss	xmm0, DWORD PTR [eax+20]
	movss	xmm2, DWORD PTR [eax+36]
	mulss	xmm2, DWORD PTR [ecx+56]
	addss	xmm0, xmm2
	movss	xmm2, DWORD PTR [eax+4]
	mulss	xmm2, DWORD PTR [ecx+48]
	addss	xmm0, xmm2
	movaps	xmm2, xmm1
	subss	xmm2, xmm0
	movss	DWORD PTR [eax+52], xmm2

; 178  : 		_43 = -( a._41 * _13 + a._42 * _23 + a._43 * _33 );

	movss	xmm0, DWORD PTR [ecx+52]
	movss	xmm2, DWORD PTR [ecx+48]
	mulss	xmm2, DWORD PTR [eax+8]
	mulss	xmm0, DWORD PTR [eax+24]
	addss	xmm0, xmm2
	movss	xmm2, DWORD PTR [ecx+56]
	mulss	xmm2, xmm4
	addss	xmm0, xmm2
	subss	xmm1, xmm0
	movss	DWORD PTR [eax+56], xmm1

; 179  : 		_44 = 1.0f;

	movss	DWORD PTR [eax+60], xmm3

; 180  : 		return *this;
; 181  : 	}

	ret	0
?invert@?$_matrix@M@@QAEAAU1@ABU1@@Z ENDP		; _matrix<float>::invert
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_vector3d.h
_TEXT	ENDS
;	COMDAT ?inertion@?$_vector3@M@@QAEAAU1@ABU1@M@Z
_TEXT	SEGMENT
?inertion@?$_vector3@M@@QAEAAU1@ABU1@M@Z PROC		; _vector3<float>::inertion, COMDAT
; _this$ = eax
; _p$ = ecx

; 104  : 	{

	movss	xmm1, DWORD PTR ?psCamInert@@3MA

; 105  : 		T inv = 1.f-v;
; 106  : 		x = v*x + inv*p.x;

	movss	xmm2, DWORD PTR [ecx]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	xmm3, DWORD PTR [eax]
	subss	xmm0, xmm1
	mulss	xmm2, xmm0
	mulss	xmm3, xmm1
	addss	xmm2, xmm3
	movss	DWORD PTR [eax], xmm2

; 107  : 		y = v*y + inv*p.y;

	movss	xmm2, DWORD PTR [ecx+4]
	mulss	xmm2, xmm0
	movaps	xmm3, xmm1
	mulss	xmm3, DWORD PTR [eax+4]
	addss	xmm2, xmm3
	movss	DWORD PTR [eax+4], xmm2

; 108  : 		z = v*z + inv*p.z;

	movss	xmm2, DWORD PTR [ecx+8]
	mulss	xmm2, xmm0
	movss	xmm0, DWORD PTR [eax+8]
	mulss	xmm0, xmm1
	addss	xmm2, xmm0
	movss	DWORD PTR [eax+8], xmm2

; 109  : 		return *this;	
; 110  : 	}

	ret	0
?inertion@?$_vector3@M@@QAEAAU1@ABU1@M@Z ENDP		; _vector3<float>::inertion
_TEXT	ENDS
PUBLIC	?OnEffectorReleased@CCameraManager@@IAEXPAUSBaseEffector@@@Z ; CCameraManager::OnEffectorReleased
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\cameramanager.cpp
;	COMDAT ?OnEffectorReleased@CCameraManager@@IAEXPAUSBaseEffector@@@Z
_TEXT	SEGMENT
_e$ = 8							; size = 4
?OnEffectorReleased@CCameraManager@@IAEXPAUSBaseEffector@@@Z PROC ; CCameraManager::OnEffectorReleased, COMDAT
; _this$ = ecx

; 268  : {

	push	esi

; 269  : 	if(!e->m_on_b_remove_callback.empty())

	mov	esi, DWORD PTR _e$[esp]
	cmp	DWORD PTR [esi+4], 0
	jne	SHORT $LN8@OnEffector
	cmp	DWORD PTR [esi+8], 0
	je	SHORT $LN10@OnEffector
$LN8@OnEffector:

; 270  : 		e->m_on_b_remove_callback();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	push	eax
	call	ecx
$LN10@OnEffector:

; 271  : 
; 272  : 	xr_delete(e);

	test	esi, esi
	je	SHORT $LN16@OnEffector
	push	edi
	push	esi
	call	___RTCastToVoid
	mov	edx, DWORD PTR [esi]
	add	esp, 4
	mov	edi, eax
	mov	eax, DWORD PTR [edx]
	push	0
	mov	ecx, esi
	call	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	pop	edi
$LN16@OnEffector:
	pop	esi

; 273  : }

	ret	4
?OnEffectorReleased@CCameraManager@@IAEXPAUSBaseEffector@@@Z ENDP ; CCameraManager::OnEffectorReleased
_TEXT	ENDS
PUBLIC	?validate@SPPInfo@@QAEXPBD@Z			; SPPInfo::validate
; Function compile flags: /Ogtpy
;	COMDAT ?validate@SPPInfo@@QAEXPBD@Z
_TEXT	SEGMENT
_str$ = 8						; size = 4
?validate@SPPInfo@@QAEXPBD@Z PROC			; SPPInfo::validate, COMDAT
; _this$ = ecx

; 83   : 	VERIFY2(_valid(duality.h),str);
; 84   : 	VERIFY2(_valid(duality.v),str);
; 85   : 	VERIFY2(_valid(blur),str);
; 86   : 	VERIFY2(_valid(gray),str);
; 87   : 	VERIFY2(_valid(noise.intensity),str);
; 88   : 	VERIFY2(_valid(noise.grain),str);
; 89   : 	VERIFY2(_valid(noise.fps),str);
; 90   : 	VERIFY2(_valid(color_base.r),str);
; 91   : 	VERIFY2(_valid(color_base.g),str);
; 92   : 	VERIFY2(_valid(color_base.b),str);
; 93   : 	VERIFY2(_valid(color_gray.r),str);
; 94   : 	VERIFY2(_valid(color_gray.g),str);
; 95   : 	VERIFY2(_valid(color_gray.b),str);
; 96   : 	VERIFY2(_valid(color_add.r),str);
; 97   : 	VERIFY2(_valid(color_add.g),str);
; 98   : 	VERIFY2(_valid(color_add.b),str);
; 99   : }

	ret	4
?validate@SPPInfo@@QAEXPBD@Z ENDP			; SPPInfo::validate
_TEXT	ENDS
PUBLIC	?normalize@SPPInfo@@QAEXXZ			; SPPInfo::normalize
; Function compile flags: /Ogtpy
;	COMDAT ?normalize@SPPInfo@@QAEXXZ
_TEXT	SEGMENT
?normalize@SPPInfo@@QAEXXZ PROC				; SPPInfo::normalize, COMDAT
; _this$ = ecx

; 79   : {}

	ret	0
?normalize@SPPInfo@@QAEXXZ ENDP				; SPPInfo::normalize
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\effectorpp.h
_TEXT	ENDS
;	COMDAT ?Stop@CEffectorPP@@UAEXM@Z
_TEXT	SEGMENT
_speed$ = 8						; size = 4
?Stop@CEffectorPP@@UAEXM@Z PROC				; CEffectorPP::Stop, COMDAT
; _this$ = ecx

; 23   : 	virtual void		Stop            (float speed)				{fLifeTime=0.0f;};

	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+20], xmm0
	ret	4
?Stop@CEffectorPP@@UAEXM@Z ENDP				; CEffectorPP::Stop
_TEXT	ENDS
PUBLIC	?SetType@CEffectorPP@@QAEXW4EEffectorPPType@@@Z	; CEffectorPP::SetType
; Function compile flags: /Ogtpy
;	COMDAT ?SetType@CEffectorPP@@QAEXW4EEffectorPPType@@@Z
_TEXT	SEGMENT
_t$ = 8							; size = 4
?SetType@CEffectorPP@@QAEXW4EEffectorPPType@@@Z PROC	; CEffectorPP::SetType, COMDAT
; _this$ = ecx

; 22   : 	IC void				SetType			(EEffectorPPType t)			{eType=t;}

	mov	eax, DWORD PTR _t$[esp-4]
	mov	DWORD PTR [ecx+12], eax
	ret	4
?SetType@CEffectorPP@@QAEXW4EEffectorPPType@@@Z ENDP	; CEffectorPP::SetType
_TEXT	ENDS
PUBLIC	?FreeOnRemove@CEffectorPP@@QBE_NXZ		; CEffectorPP::FreeOnRemove
; Function compile flags: /Ogtpy
;	COMDAT ?FreeOnRemove@CEffectorPP@@QBE_NXZ
_TEXT	SEGMENT
?FreeOnRemove@CEffectorPP@@QBE_NXZ PROC			; CEffectorPP::FreeOnRemove, COMDAT
; _this$ = ecx

; 21   : 	IC bool				FreeOnRemove	()	const					{return bFreeOnRemove;}

	mov	al, BYTE PTR [ecx+16]
	ret	0
?FreeOnRemove@CEffectorPP@@QBE_NXZ ENDP			; CEffectorPP::FreeOnRemove
_TEXT	ENDS
PUBLIC	?Type@CEffectorPP@@QBE?AW4EEffectorPPType@@XZ	; CEffectorPP::Type
; Function compile flags: /Ogtpy
;	COMDAT ?Type@CEffectorPP@@QBE?AW4EEffectorPPType@@XZ
_TEXT	SEGMENT
?Type@CEffectorPP@@QBE?AW4EEffectorPPType@@XZ PROC	; CEffectorPP::Type, COMDAT
; _this$ = ecx

; 20   : 	IC EEffectorPPType	Type			()	const					{return eType;}

	mov	eax, DWORD PTR [ecx+12]
	ret	0
?Type@CEffectorPP@@QBE?AW4EEffectorPPType@@XZ ENDP	; CEffectorPP::Type
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Valid@CEffectorPP@@UAEHXZ
_TEXT	SEGMENT
?Valid@CEffectorPP@@UAEHXZ PROC				; CEffectorPP::Valid, COMDAT
; _this$ = ecx

; 19   : 	virtual	BOOL		Valid			()							{return fLifeTime>0.0f;}

	movss	xmm0, DWORD PTR [ecx+20]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN3@Valid
	mov	eax, 1
	ret	0
$LN3@Valid:
	xor	eax, eax
	ret	0
?Valid@CEffectorPP@@UAEHXZ ENDP				; CEffectorPP::Valid
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\effector.h
_TEXT	ENDS
;	COMDAT ?AbsolutePositioning@CEffectorCam@@UAE_NXZ
_TEXT	SEGMENT
?AbsolutePositioning@CEffectorCam@@UAE_NXZ PROC		; CEffectorCam::AbsolutePositioning, COMDAT
; _this$ = ecx

; 32   : 	virtual bool		AbsolutePositioning()								{return false;}		

	xor	al, al
	ret	0
?AbsolutePositioning@CEffectorCam@@UAE_NXZ ENDP		; CEffectorCam::AbsolutePositioning
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?AllowProcessingIfInvalid@CEffectorCam@@UAEHXZ
_TEXT	SEGMENT
?AllowProcessingIfInvalid@CEffectorCam@@UAEHXZ PROC	; CEffectorCam::AllowProcessingIfInvalid, COMDAT
; _this$ = ecx

; 31   : 	virtual BOOL		AllowProcessingIfInvalid()							{return FALSE;}

	xor	eax, eax
	ret	0
?AllowProcessingIfInvalid@CEffectorCam@@UAEHXZ ENDP	; CEffectorCam::AllowProcessingIfInvalid
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?ProcessIfInvalid@CEffectorCam@@UAEXAAUSCamEffectorInfo@@@Z
_TEXT	SEGMENT
_info$ = 8						; size = 4
?ProcessIfInvalid@CEffectorCam@@UAEXAAUSCamEffectorInfo@@@Z PROC ; CEffectorCam::ProcessIfInvalid, COMDAT
; _this$ = ecx

; 30   : 	virtual	void		ProcessIfInvalid(SCamEffectorInfo& info)			{};

	ret	4
?ProcessIfInvalid@CEffectorCam@@UAEXAAUSCamEffectorInfo@@@Z ENDP ; CEffectorCam::ProcessIfInvalid
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?ProcessCam@CEffectorCam@@UAEHAAUSCamEffectorInfo@@@Z
_TEXT	SEGMENT
_info$ = 8						; size = 4
?ProcessCam@CEffectorCam@@UAEHAAUSCamEffectorInfo@@@Z PROC ; CEffectorCam::ProcessCam, COMDAT
; _this$ = ecx

; 28   : 	virtual BOOL		ProcessCam		(SCamEffectorInfo& info)			{fLifeTime-=Device.fTimeDelta; return Valid();};;

	movss	xmm0, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [ecx]
	subss	xmm0, DWORD PTR ?Device@@3VCRenderDevice@@A+28
	mov	edx, DWORD PTR [eax+4]
	movss	DWORD PTR [ecx+16], xmm0
	call	edx
	ret	4
?ProcessCam@CEffectorCam@@UAEHAAUSCamEffectorInfo@@@Z ENDP ; CEffectorCam::ProcessCam
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Valid@CEffectorCam@@UAEHXZ
_TEXT	SEGMENT
?Valid@CEffectorCam@@UAEHXZ PROC			; CEffectorCam::Valid, COMDAT
; _this$ = ecx

; 24   : 	virtual	BOOL		Valid			()									{return fLifeTime>0.0f;}

	movss	xmm0, DWORD PTR [ecx+16]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN3@Valid@2
	mov	eax, 1
	ret	0
$LN3@Valid@2:
	xor	eax, eax
	ret	0
?Valid@CEffectorCam@@UAEHXZ ENDP			; CEffectorCam::Valid
_TEXT	ENDS
PUBLIC	?GetType@CEffectorCam@@QAE?AW4ECamEffectorType@@XZ ; CEffectorCam::GetType
; Function compile flags: /Ogtpy
;	COMDAT ?GetType@CEffectorCam@@QAE?AW4ECamEffectorType@@XZ
_TEXT	SEGMENT
?GetType@CEffectorCam@@QAE?AW4ECamEffectorType@@XZ PROC	; CEffectorCam::GetType, COMDAT
; _this$ = ecx

; 23   : 	IC ECamEffectorType	GetType			()									{return eType;}

	mov	eax, DWORD PTR [ecx+12]
	ret	0
?GetType@CEffectorCam@@QAE?AW4ECamEffectorType@@XZ ENDP	; CEffectorCam::GetType
_TEXT	ENDS
PUBLIC	?GetHudAffect@CEffectorCam@@QAE_NXZ		; CEffectorCam::GetHudAffect
; Function compile flags: /Ogtpy
;	COMDAT ?GetHudAffect@CEffectorCam@@QAE_NXZ
_TEXT	SEGMENT
?GetHudAffect@CEffectorCam@@QAE_NXZ PROC		; CEffectorCam::GetHudAffect, COMDAT
; _this$ = ecx

; 21   : 			bool		GetHudAffect	()									{return bHudAffect;}

	mov	al, BYTE PTR [ecx+20]
	ret	0
?GetHudAffect@CEffectorCam@@QAE_NXZ ENDP		; CEffectorCam::GetHudAffect
_TEXT	ENDS
PUBLIC	?SetHudAffect@CEffectorCam@@QAEX_N@Z		; CEffectorCam::SetHudAffect
; Function compile flags: /Ogtpy
;	COMDAT ?SetHudAffect@CEffectorCam@@QAEX_N@Z
_TEXT	SEGMENT
_val$ = 8						; size = 1
?SetHudAffect@CEffectorCam@@QAEX_N@Z PROC		; CEffectorCam::SetHudAffect, COMDAT
; _this$ = ecx

; 20   : 			void		SetHudAffect	(bool val)							{bHudAffect=val;}

	mov	al, BYTE PTR _val$[esp-4]
	mov	BYTE PTR [ecx+20], al
	ret	4
?SetHudAffect@CEffectorCam@@QAEX_N@Z ENDP		; CEffectorCam::SetHudAffect
_TEXT	ENDS
PUBLIC	?SetType@CEffectorCam@@QAEXW4ECamEffectorType@@@Z ; CEffectorCam::SetType
; Function compile flags: /Ogtpy
;	COMDAT ?SetType@CEffectorCam@@QAEXW4ECamEffectorType@@@Z
_TEXT	SEGMENT
_type$ = 8						; size = 4
?SetType@CEffectorCam@@QAEXW4ECamEffectorType@@@Z PROC	; CEffectorCam::SetType, COMDAT
; _this$ = ecx

; 19   : 			void		SetType			(ECamEffectorType type)				{eType=type;}

	mov	eax, DWORD PTR _type$[esp-4]
	mov	DWORD PTR [ecx+12], eax
	ret	4
?SetType@CEffectorCam@@QAEXW4ECamEffectorType@@@Z ENDP	; CEffectorCam::SetType
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\cameramanager.h
_TEXT	ENDS
;	COMDAT ??0SNoise@SPPInfo@@QAE@XZ
_TEXT	SEGMENT
??0SNoise@SPPInfo@@QAE@XZ PROC				; SPPInfo::SNoise::SNoise, COMDAT
; _this$ = eax

; 47   : 		SNoise					(){}

	ret	0
??0SNoise@SPPInfo@@QAE@XZ ENDP				; SPPInfo::SNoise::SNoise
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0SDuality@SPPInfo@@QAE@XZ
_TEXT	SEGMENT
??0SDuality@SPPInfo@@QAE@XZ PROC			; SPPInfo::SDuality::SDuality, COMDAT
; _this$ = eax

; 37   : 		SDuality				(){}

	ret	0
??0SDuality@SPPInfo@@QAE@XZ ENDP			; SPPInfo::SDuality::SDuality
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?set@SColor@SPPInfo@@QAEAAU12@MMM@Z
_TEXT	SEGMENT
__g$ = 8						; size = 4
__b$ = 12						; size = 4
?set@SColor@SPPInfo@@QAEAAU12@MMM@Z PROC		; SPPInfo::SColor::set, COMDAT
; _this$ = eax
; __r$ = xmm0s

; 30   : 			r=_r;g=_g;b=_b;

	movss	DWORD PTR [eax], xmm0
	movss	xmm0, DWORD PTR __g$[esp-4]
	movss	DWORD PTR [eax+4], xmm0
	movss	xmm0, DWORD PTR __b$[esp-4]
	movss	DWORD PTR [eax+8], xmm0

; 31   : 			return *this;
; 32   : 		}

	ret	8
?set@SColor@SPPInfo@@QAEAAU12@MMM@Z ENDP		; SPPInfo::SColor::set
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??ZSColor@SPPInfo@@QAEAAU01@ABU01@@Z
_TEXT	SEGMENT
??ZSColor@SPPInfo@@QAEAAU01@ABU01@@Z PROC		; SPPInfo::SColor::operator-=, COMDAT
; _this$ = eax
; _ppi$ = ecx

; 26   : 			r -= ppi.r; g -= ppi.g; b -= ppi.b; 

	movss	xmm0, DWORD PTR [eax]
	subss	xmm0, DWORD PTR [ecx]
	movss	DWORD PTR [eax], xmm0
	movss	xmm0, DWORD PTR [eax+4]
	subss	xmm0, DWORD PTR [ecx+4]
	movss	DWORD PTR [eax+4], xmm0
	movss	xmm0, DWORD PTR [eax+8]
	subss	xmm0, DWORD PTR [ecx+8]
	movss	DWORD PTR [eax+8], xmm0

; 27   : 			return *this;
; 28   : 		}

	ret	0
??ZSColor@SPPInfo@@QAEAAU01@ABU01@@Z ENDP		; SPPInfo::SColor::operator-=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??YSColor@SPPInfo@@QAEAAU01@ABU01@@Z
_TEXT	SEGMENT
??YSColor@SPPInfo@@QAEAAU01@ABU01@@Z PROC		; SPPInfo::SColor::operator+=, COMDAT
; _this$ = eax
; _ppi$ = ecx

; 22   : 			r += ppi.r; g += ppi.g; b += ppi.b; 

	movss	xmm0, DWORD PTR [ecx]
	addss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [eax], xmm0
	movss	xmm0, DWORD PTR [ecx+4]
	addss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR [eax+4], xmm0
	movss	xmm0, DWORD PTR [ecx+8]
	addss	xmm0, DWORD PTR [eax+8]
	movss	DWORD PTR [eax+8], xmm0

; 23   : 			return *this;
; 24   : 		}

	ret	0
??YSColor@SPPInfo@@QAEAAU01@ABU01@@Z ENDP		; SPPInfo::SColor::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??BSColor@SPPInfo@@QAEABU?$_vector3@M@@XZ
_TEXT	SEGMENT
??BSColor@SPPInfo@@QAEABU?$_vector3@M@@XZ PROC		; SPPInfo::SColor::operator _vector3<float> const &, COMDAT
; _this$ = eax

; 18   : 			return *((Fvector*)this);
; 19   : 		}

	ret	0
??BSColor@SPPInfo@@QAEABU?$_vector3@M@@XZ ENDP		; SPPInfo::SColor::operator _vector3<float> const &
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0SColor@SPPInfo@@QAE@XZ
_TEXT	SEGMENT
??0SColor@SPPInfo@@QAE@XZ PROC				; SPPInfo::SColor::SColor, COMDAT
; _this$ = eax

; 8    : 		SColor					(){}

	ret	0
??0SColor@SPPInfo@@QAE@XZ ENDP				; SPPInfo::SColor::SColor
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_tools.h
;	COMDAT ?to_storage_type_cref@?$_CastTraits@PAXPAVCEffectorPP@@@priv@stlp_std@@SAABQAXABQAVCEffectorPP@@@Z
_TEXT	SEGMENT
?to_storage_type_cref@?$_CastTraits@PAXPAVCEffectorPP@@@priv@stlp_std@@SAABQAXABQAVCEffectorPP@@@Z PROC ; stlp_std::priv::_CastTraits<void *,CEffectorPP *>::to_storage_type_cref, COMDAT
; ___ref$ = eax

; 224  :   { return cv_traits::uncv_cref(__REINTERPRET_CAST(void_cv_type const&, __ref)); }

	ret	0
?to_storage_type_cref@?$_CastTraits@PAXPAVCEffectorPP@@@priv@stlp_std@@SAABQAXABQAVCEffectorPP@@@Z ENDP ; stlp_std::priv::_CastTraits<void *,CEffectorPP *>::to_storage_type_cref
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?to_storage_type_ptr@?$_CastTraits@PAXPAVCEffectorPP@@@priv@stlp_std@@SAPAPAXPAPAVCEffectorPP@@@Z
_TEXT	SEGMENT
?to_storage_type_ptr@?$_CastTraits@PAXPAVCEffectorPP@@@priv@stlp_std@@SAPAPAXPAPAVCEffectorPP@@@Z PROC ; stlp_std::priv::_CastTraits<void *,CEffectorPP *>::to_storage_type_ptr, COMDAT
; ___ptr$ = eax

; 218  :   { return cv_traits::uncv_ptr(__REINTERPRET_CAST(void_cv_type *, __ptr)); }

	ret	0
?to_storage_type_ptr@?$_CastTraits@PAXPAVCEffectorPP@@@priv@stlp_std@@SAPAPAXPAPAVCEffectorPP@@@Z ENDP ; stlp_std::priv::_CastTraits<void *,CEffectorPP *>::to_storage_type_ptr
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?to_value_type_ref@?$_CastTraits@PAXPAVCEffectorPP@@@priv@stlp_std@@SAAAPAVCEffectorPP@@AAPAX@Z
_TEXT	SEGMENT
?to_value_type_ref@?$_CastTraits@PAXPAVCEffectorPP@@@priv@stlp_std@@SAAAPAVCEffectorPP@@AAPAX@Z PROC ; stlp_std::priv::_CastTraits<void *,CEffectorPP *>::to_value_type_ref, COMDAT
; ___ref$ = eax

; 213  :   { return __REINTERPRET_CAST(value_type &, cv_traits::cv_ref(__ref)); }

	ret	0
?to_value_type_ref@?$_CastTraits@PAXPAVCEffectorPP@@@priv@stlp_std@@SAAAPAVCEffectorPP@@AAPAX@Z ENDP ; stlp_std::priv::_CastTraits<void *,CEffectorPP *>::to_value_type_ref
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?to_value_type_ptr@?$_CastTraits@PAXPAVCEffectorPP@@@priv@stlp_std@@SAPAPAVCEffectorPP@@PAPAX@Z
_TEXT	SEGMENT
?to_value_type_ptr@?$_CastTraits@PAXPAVCEffectorPP@@@priv@stlp_std@@SAPAPAVCEffectorPP@@PAPAX@Z PROC ; stlp_std::priv::_CastTraits<void *,CEffectorPP *>::to_value_type_ptr, COMDAT
; ___ptr$ = eax

; 207  :   { return __REINTERPRET_CAST(value_type *, cv_traits::cv_ptr(__ptr)); }

	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 4
	ret	0
?to_value_type_ptr@?$_CastTraits@PAXPAVCEffectorPP@@@priv@stlp_std@@SAPAPAVCEffectorPP@@PAPAX@Z ENDP ; stlp_std::priv::_CastTraits<void *,CEffectorPP *>::to_value_type_ptr
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?to_storage_type_cref@?$_CastTraits@PAXPAVCEffectorCam@@@priv@stlp_std@@SAABQAXABQAVCEffectorCam@@@Z
_TEXT	SEGMENT
?to_storage_type_cref@?$_CastTraits@PAXPAVCEffectorCam@@@priv@stlp_std@@SAABQAXABQAVCEffectorCam@@@Z PROC ; stlp_std::priv::_CastTraits<void *,CEffectorCam *>::to_storage_type_cref, COMDAT
; ___ref$ = eax

; 224  :   { return cv_traits::uncv_cref(__REINTERPRET_CAST(void_cv_type const&, __ref)); }

	ret	0
?to_storage_type_cref@?$_CastTraits@PAXPAVCEffectorCam@@@priv@stlp_std@@SAABQAXABQAVCEffectorCam@@@Z ENDP ; stlp_std::priv::_CastTraits<void *,CEffectorCam *>::to_storage_type_cref
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_list.h
_TEXT	ENDS
;	COMDAT ??0?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@QAE@PAU_List_node_base@12@@Z
_TEXT	SEGMENT
??0?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@QAE@PAU_List_node_base@12@@Z PROC ; stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> >::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> >, COMDAT
; _this$ = eax
; ___x$ = ecx

; 113  :   explicit _List_iterator(_List_node_base* __x) : _List_iterator_base(__x) {}

	mov	DWORD PTR [eax], ecx
	ret	0
??0?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@QAE@PAU_List_node_base@12@@Z ENDP ; stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> >::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVCEffectorPP@@V?$xalloc@PAVCEffectorPP@@@@@stlp_std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCEffectorPP@@V?$xalloc@PAVCEffectorPP@@@@@stlp_std@@QBEIXZ PROC ; stlp_std::vector<CEffectorPP *,xalloc<CEffectorPP *> >::size, COMDAT
; _this$ = ecx

; 89   :   size_type size() const        { return _M_impl.size(); }

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	ret	0
?size@?$vector@PAVCEffectorPP@@V?$xalloc@PAVCEffectorPP@@@@@stlp_std@@QBEIXZ ENDP ; stlp_std::vector<CEffectorPP *,xalloc<CEffectorPP *> >::size
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_list.h
_TEXT	ENDS
;	COMDAT ??0?$_List_iterator@PAVCEffectorCam@@U?$_Const_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@QAE@ABU?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@12@@Z
_TEXT	SEGMENT
??0?$_List_iterator@PAVCEffectorCam@@U?$_Const_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@QAE@ABU?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@12@@Z PROC ; stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Const_traits<CEffectorCam *> >::_List_iterator<CEffectorCam *,stlp_std::_Const_traits<CEffectorCam *> >, COMDAT
; _this$ = eax
; ___x$ = ecx

; 116  :   _List_iterator(const iterator& __x) :  _List_iterator_base(__x._M_node) {}

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	ret	0
??0?$_List_iterator@PAVCEffectorCam@@U?$_Const_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@QAE@ABU?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@12@@Z ENDP ; stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Const_traits<CEffectorCam *> >::_List_iterator<CEffectorCam *,stlp_std::_Const_traits<CEffectorCam *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@QAEAAU012@XZ
_TEXT	SEGMENT
??E?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@QAEAAU012@XZ PROC ; stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> >::operator++, COMDAT
; _this$ = eax

; 123  :     this->_M_incr();

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 124  :     return *this;
; 125  :   }

	ret	0
??E?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@QAEAAU012@XZ ENDP ; stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@QAE@ABU012@@Z
_TEXT	SEGMENT
??0?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@QAE@ABU012@@Z PROC ; stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> >::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> >, COMDAT
; _this$ = eax
; ___x$ = ecx

; 116  :   _List_iterator(const iterator& __x) :  _List_iterator_base(__x._M_node) {}

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	ret	0
??0?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@QAE@ABU012@@Z ENDP ; stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> >::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVCEffectorPP@@V?$xalloc@PAVCEffectorPP@@@@@stlp_std@@QAEPAPAVCEffectorPP@@XZ
_TEXT	SEGMENT
?end@?$vector@PAVCEffectorPP@@V?$xalloc@PAVCEffectorPP@@@@@stlp_std@@QAEPAPAVCEffectorPP@@XZ PROC ; stlp_std::vector<CEffectorPP *,xalloc<CEffectorPP *> >::end, COMDAT
; _this$ = eax

; 81   :   iterator end()               { return cast_traits::to_value_type_ptr(_M_impl.end()); }

	mov	eax, DWORD PTR [eax+4]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 4
	ret	0
?end@?$vector@PAVCEffectorPP@@V?$xalloc@PAVCEffectorPP@@@@@stlp_std@@QAEPAPAVCEffectorPP@@XZ ENDP ; stlp_std::vector<CEffectorPP *,xalloc<CEffectorPP *> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@PAVCEffectorPP@@V?$xalloc@PAVCEffectorPP@@@@@stlp_std@@QAEPAPAVCEffectorPP@@XZ
_TEXT	SEGMENT
?begin@?$vector@PAVCEffectorPP@@V?$xalloc@PAVCEffectorPP@@@@@stlp_std@@QAEPAPAVCEffectorPP@@XZ PROC ; stlp_std::vector<CEffectorPP *,xalloc<CEffectorPP *> >::begin, COMDAT
; _this$ = eax

; 79   :   iterator begin()             { return cast_traits::to_value_type_ptr(_M_impl.begin()); }

	mov	eax, DWORD PTR [eax]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 4
	ret	0
?begin@?$vector@PAVCEffectorPP@@V?$xalloc@PAVCEffectorPP@@@@@stlp_std@@QAEPAPAVCEffectorPP@@XZ ENDP ; stlp_std::vector<CEffectorPP *,xalloc<CEffectorPP *> >::begin
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ??A?$xr_vector@PAVCEffectorPP@@V?$xalloc@PAVCEffectorPP@@@@@@QAEAAPAVCEffectorPP@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$xr_vector@PAVCEffectorPP@@V?$xalloc@PAVCEffectorPP@@@@@@QAEAAPAVCEffectorPP@@I@Z PROC ; xr_vector<CEffectorPP *,xalloc<CEffectorPP *> >::operator[], COMDAT
; _this$ = eax

; 139  : 	reference operator[]		(size_type _Pos)					{ {VERIFY2(_Pos<size(),make_string("index is out of range: index requested[%d], size of container[%d]", _Pos, size()).c_str());} return (*(begin() + _Pos)); }

	mov	eax, DWORD PTR [eax]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	mov	ecx, DWORD PTR __Pos$[esp]
	add	esp, 4
	lea	eax, DWORD PTR [eax+ecx*4]
	ret	4
??A?$xr_vector@PAVCEffectorPP@@V?$xalloc@PAVCEffectorPP@@@@@@QAEAAPAVCEffectorPP@@I@Z ENDP ; xr_vector<CEffectorPP *,xalloc<CEffectorPP *> >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$xr_vector@PAVCEffectorPP@@V?$xalloc@PAVCEffectorPP@@@@@@QBEIXZ
_TEXT	SEGMENT
?size@?$xr_vector@PAVCEffectorPP@@V?$xalloc@PAVCEffectorPP@@@@@@QBEIXZ PROC ; xr_vector<CEffectorPP *,xalloc<CEffectorPP *> >::size, COMDAT
; _this$ = ecx

; 126  : 	u32		size				() const							{ return (u32)inherited::size();} 

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	ret	0
?size@?$xr_vector@PAVCEffectorPP@@V?$xalloc@PAVCEffectorPP@@@@@@QBEIXZ ENDP ; xr_vector<CEffectorPP *,xalloc<CEffectorPP *> >::size
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_list.h
_TEXT	ENDS
;	COMDAT ?empty@?$list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@stlp_std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@stlp_std@@QBE_NXZ PROC ; stlp_std::list<CEffectorCam *,xalloc<CEffectorCam *> >::empty, COMDAT
; _this$ = eax

; 162  :   bool empty() const         { return _M_impl.empty(); }

	xor	ecx, ecx
	cmp	DWORD PTR [eax], eax
	sete	cl
	mov	al, cl
	ret	0
?empty@?$list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@stlp_std@@QBE_NXZ ENDP ; stlp_std::list<CEffectorCam *,xalloc<CEffectorCam *> >::empty
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@stlp_std@@QAE?AU?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@2@XZ
_TEXT	SEGMENT
?begin@?$list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@stlp_std@@QAE?AU?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@2@XZ PROC ; stlp_std::list<CEffectorCam *,xalloc<CEffectorCam *> >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 150  :   iterator begin()             { return iterator(_M_impl.begin()._M_node); }

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	ret	0
?begin@?$list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@stlp_std@@QAE?AU?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@2@XZ ENDP ; stlp_std::list<CEffectorCam *,xalloc<CEffectorCam *> >::begin
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_matrix.h
_TEXT	ENDS
;	COMDAT ?build_projection@?$_matrix@M@@QAEAAU1@MMMM@Z
_TEXT	SEGMENT
_fFOV$ = 8						; size = 4
_fAspect$ = 12						; size = 4
?build_projection@?$_matrix@M@@QAEAAU1@MMMM@Z PROC	; _matrix<float>::build_projection, COMDAT
; _this$ = eax
; _fNearPlane$ = xmm2s
; _fFarPlane$ = xmm1s

; 397  : 		return build_projection_HAT		(tanf(fFOV/2.f),fAspect,fNearPlane,fFarPlane);

	fld	DWORD PTR _fFOV$[esp-4]
	movss	xmm3, DWORD PTR __real@3f800000
	fmul	DWORD PTR __real@3f000000
	movaps	xmm0, xmm1
	subss	xmm0, xmm2
	divss	xmm1, xmm0
	fptan
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+40], xmm1
	mulss	xmm1, xmm2
	movss	xmm2, DWORD PTR __real@80000000
	subss	xmm2, xmm1
	movss	DWORD PTR [eax+4], xmm0
	movss	DWORD PTR [eax+8], xmm0
	movss	DWORD PTR [eax+12], xmm0
	movss	DWORD PTR [eax+16], xmm0
	movss	DWORD PTR [eax+24], xmm0
	movss	DWORD PTR [eax+28], xmm0
	movss	DWORD PTR [eax+32], xmm0
	movss	DWORD PTR [eax+36], xmm0
	movss	DWORD PTR [eax+44], xmm3
	movss	DWORD PTR [eax+48], xmm0
	movss	DWORD PTR [eax+52], xmm0
	movss	DWORD PTR [eax+56], xmm2
	movss	DWORD PTR [eax+60], xmm0
	fstp	ST(0)
	fld1
	fdivrp	ST(1), ST(0)
	fld	DWORD PTR _fAspect$[esp-4]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR [eax]
	fstp	DWORD PTR [eax+20]

; 398  : 	}

	ret	8
?build_projection@?$_matrix@M@@QAEAAU1@MMMM@Z ENDP	; _matrix<float>::build_projection
_TEXT	ENDS
PUBLIC	?Dump@CCameraManager@@QAEXXZ			; CCameraManager::Dump
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\cameramanager.cpp
;	COMDAT ?Dump@CCameraManager@@QAEXXZ
_TEXT	SEGMENT
__P$ = -112						; size = 12
__T$ = -100						; size = 12
__U$ = -88						; size = 12
__R$ = -76						; size = 12
_mInvCamera$ = -64					; size = 64
?Dump@CCameraManager@@QAEXXZ PROC			; CCameraManager::Dump, COMDAT
; _this$ = ecx

; 470  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 116				; 00000074H
	push	esi

; 471  : 	Fmatrix mInvCamera;
; 472  : 	Fvector _R,_U,_T,_P;
; 473  : 	
; 474  : 	mInvCamera.invert(Device.mView);

	mov	ecx, OFFSET ?Device@@3VCRenderDevice@@A+96
	lea	eax, DWORD PTR _mInvCamera$[esp+120]
	call	?invert@?$_matrix@M@@QAEAAU1@ABU1@@Z	; _matrix<float>::invert

; 475  : 	_R.set( mInvCamera._11, mInvCamera._12, mInvCamera._13 );

	movss	xmm0, DWORD PTR _mInvCamera$[esp+120]
	movss	DWORD PTR __R$[esp+120], xmm0
	movss	xmm0, DWORD PTR _mInvCamera$[esp+124]

; 476  : 	_U.set( mInvCamera._21, mInvCamera._22, mInvCamera._23 );
; 477  : 	_T.set( mInvCamera._31, mInvCamera._32, mInvCamera._33 );
; 478  : 	_P.set( mInvCamera._41, mInvCamera._42, mInvCamera._43 );
; 479  : 	Log("CCameraManager::Dump::vPosition  = ",_P);

	mov	esi, DWORD PTR __imp_?Log@@YAXPBDABU?$_vector3@M@@@Z
	movss	DWORD PTR __R$[esp+124], xmm0
	movss	xmm0, DWORD PTR _mInvCamera$[esp+128]
	movss	DWORD PTR __R$[esp+128], xmm0
	movss	xmm0, DWORD PTR _mInvCamera$[esp+136]
	movss	DWORD PTR __U$[esp+120], xmm0
	movss	xmm0, DWORD PTR _mInvCamera$[esp+140]
	movss	DWORD PTR __U$[esp+124], xmm0
	movss	xmm0, DWORD PTR _mInvCamera$[esp+144]
	movss	DWORD PTR __U$[esp+128], xmm0
	movss	xmm0, DWORD PTR _mInvCamera$[esp+152]
	movss	DWORD PTR __T$[esp+120], xmm0
	movss	xmm0, DWORD PTR _mInvCamera$[esp+156]
	movss	DWORD PTR __T$[esp+124], xmm0
	movss	xmm0, DWORD PTR _mInvCamera$[esp+160]
	movss	DWORD PTR __T$[esp+128], xmm0
	movss	xmm0, DWORD PTR _mInvCamera$[esp+168]
	movss	DWORD PTR __P$[esp+120], xmm0
	movss	xmm0, DWORD PTR _mInvCamera$[esp+172]
	lea	eax, DWORD PTR __P$[esp+120]
	push	eax
	movss	DWORD PTR __P$[esp+128], xmm0
	movss	xmm0, DWORD PTR _mInvCamera$[esp+180]
	push	OFFSET ??_C@_0CE@EPEEGAIB@CCameraManager?3?3Dump?3?3vPosition?5@
	movss	DWORD PTR __P$[esp+136], xmm0
	call	esi

; 480  : 	Log("CCameraManager::Dump::vDirection = ",_T);

	lea	ecx, DWORD PTR __T$[esp+128]
	push	ecx
	push	OFFSET ??_C@_0CE@GPCFDNJG@CCameraManager?3?3Dump?3?3vDirection@
	call	esi

; 481  : 	Log("CCameraManager::Dump::vNormal    = ",_U);

	lea	edx, DWORD PTR __U$[esp+136]
	push	edx
	push	OFFSET ??_C@_0CE@OAGGNCIH@CCameraManager?3?3Dump?3?3vNormal?5?5?5@
	call	esi

; 482  : 	Log("CCameraManager::Dump::vRight     = ",_R);

	lea	eax, DWORD PTR __R$[esp+144]
	push	eax
	push	OFFSET ??_C@_0CE@IAALBLBH@CCameraManager?3?3Dump?3?3vRight?5?5?5?5@
	call	esi
	add	esp, 32					; 00000020H

; 483  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?Dump@CCameraManager@@QAEXXZ ENDP			; CCameraManager::Dump
_TEXT	ENDS
PUBLIC	?GetPPEffector@CCameraManager@@QAEPAVCEffectorPP@@W4EEffectorPPType@@@Z ; CCameraManager::GetPPEffector
; Function compile flags: /Ogtpy
;	COMDAT ?GetPPEffector@CCameraManager@@QAEPAVCEffectorPP@@W4EEffectorPPType@@@Z
_TEXT	SEGMENT
_type$ = 8						; size = 4
?GetPPEffector@CCameraManager@@QAEPAVCEffectorPP@@W4EEffectorPPType@@@Z PROC ; CCameraManager::GetPPEffector, COMDAT
; _this$ = ecx

; 224  : { 

	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 225  : 	for (EffectorPPIt it=m_EffectorsPP.begin(); it!=m_EffectorsPP.end(); it++ )

	mov	eax, DWORD PTR [edi+84]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	mov	esi, eax
	mov	eax, DWORD PTR [edi+88]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 8
	cmp	esi, eax
	je	SHORT $LN2@GetPPEffec@4
	mov	ebx, DWORD PTR _type$[esp+8]
$LL4@GetPPEffec@4:

; 226  : 		if ((*it)->Type()==type) return *it;

	mov	eax, DWORD PTR [esi]
	cmp	DWORD PTR [eax+12], ebx
	je	SHORT $LN5@GetPPEffec@4
	mov	eax, DWORD PTR [edi+88]
	push	eax
	add	esi, 4
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 4
	cmp	esi, eax
	jne	SHORT $LL4@GetPPEffec@4
$LN2@GetPPEffec@4:

; 227  : 	return 0;

	xor	eax, eax
$LN5@GetPPEffec@4:
	pop	edi
	pop	esi
	pop	ebx

; 228  : }

	ret	4
?GetPPEffector@CCameraManager@@QAEPAVCEffectorPP@@W4EEffectorPPType@@@Z ENDP ; CCameraManager::GetPPEffector
_TEXT	ENDS
PUBLIC	?sub@SPPInfo@@QAEAAU1@ABU1@@Z			; SPPInfo::sub
; Function compile flags: /Ogtpy
;	COMDAT ?sub@SPPInfo@@QAEAAU1@ABU1@@Z
_TEXT	SEGMENT
_ppi$ = 8						; size = 4
?sub@SPPInfo@@QAEAAU1@ABU1@@Z PROC			; SPPInfo::sub, COMDAT
; _this$ = ecx

; 57   : {

	mov	eax, ecx

; 58   : 	blur		-= ppi.blur;

	mov	ecx, DWORD PTR _ppi$[esp-4]
	movss	xmm0, DWORD PTR [eax]
	subss	xmm0, DWORD PTR [ecx]
	movss	DWORD PTR [eax], xmm0

; 59   : 	gray		-= ppi.gray;

	movss	xmm0, DWORD PTR [eax+4]
	subss	xmm0, DWORD PTR [ecx+4]
	movss	DWORD PTR [eax+4], xmm0

; 60   : 	duality.h	-= ppi.duality.h; 

	movss	xmm0, DWORD PTR [eax+8]
	subss	xmm0, DWORD PTR [ecx+8]
	movss	DWORD PTR [eax+8], xmm0

; 61   : 	duality.v	-= ppi.duality.v;

	movss	xmm0, DWORD PTR [eax+12]
	subss	xmm0, DWORD PTR [ecx+12]
	movss	DWORD PTR [eax+12], xmm0

; 62   : 	color_base	-= ppi.color_base;

	movss	xmm0, DWORD PTR [eax+28]
	subss	xmm0, DWORD PTR [ecx+28]
	movss	DWORD PTR [eax+28], xmm0
	movss	xmm0, DWORD PTR [eax+32]
	subss	xmm0, DWORD PTR [ecx+32]
	movss	DWORD PTR [eax+32], xmm0
	movss	xmm0, DWORD PTR [eax+36]
	subss	xmm0, DWORD PTR [ecx+36]
	movss	DWORD PTR [eax+36], xmm0

; 63   : 	color_gray	-= ppi.color_gray;

	movss	xmm0, DWORD PTR [eax+40]
	subss	xmm0, DWORD PTR [ecx+40]
	movss	DWORD PTR [eax+40], xmm0
	movss	xmm0, DWORD PTR [eax+44]
	subss	xmm0, DWORD PTR [ecx+44]
	movss	DWORD PTR [eax+44], xmm0
	movss	xmm0, DWORD PTR [eax+48]
	subss	xmm0, DWORD PTR [ecx+48]
	movss	DWORD PTR [eax+48], xmm0

; 64   : 	color_add	-= ppi.color_add;

	movss	xmm0, DWORD PTR [eax+52]
	subss	xmm0, DWORD PTR [ecx+52]
	movss	DWORD PTR [eax+52], xmm0
	movss	xmm0, DWORD PTR [eax+56]
	subss	xmm0, DWORD PTR [ecx+56]
	movss	DWORD PTR [eax+56], xmm0
	movss	xmm0, DWORD PTR [eax+60]
	subss	xmm0, DWORD PTR [ecx+60]
	movss	DWORD PTR [eax+60], xmm0

; 65   : 	return *this;
; 66   : }

	ret	4
?sub@SPPInfo@@QAEAAU1@ABU1@@Z ENDP			; SPPInfo::sub
_TEXT	ENDS
PUBLIC	??_GCEffectorPP@@UAEPAXI@Z			; CEffectorPP::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GCEffectorPP@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCEffectorPP@@UAEPAXI@Z PROC				; CEffectorPP::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7SBaseEffector@@6B@
	je	SHORT $LN13@scalar@5
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN13@scalar@5:
	mov	eax, esi
	pop	esi
	ret	4
??_GCEffectorPP@@UAEPAXI@Z ENDP				; CEffectorPP::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1CEffectorCam@@UAE@XZ				; CEffectorCam::~CEffectorCam
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\effector.h
;	COMDAT ??1CEffectorCam@@UAE@XZ
_TEXT	SEGMENT
??1CEffectorCam@@UAE@XZ PROC				; CEffectorCam::~CEffectorCam, COMDAT
; _this$ = ecx

; 18   : 	virtual				~CEffectorCam	()									{};

	mov	DWORD PTR [ecx], OFFSET ??_7SBaseEffector@@6B@
	ret	0
??1CEffectorCam@@UAE@XZ ENDP				; CEffectorCam::~CEffectorCam
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\cameramanager.h
_TEXT	ENDS
;	COMDAT ??BSColor@SPPInfo@@QAEIXZ
_TEXT	SEGMENT
_a$250001 = -8						; size = 4
__r$ = -8						; size = 4
_a$250031 = -4						; size = 4
_a$250016 = -4						; size = 4
??BSColor@SPPInfo@@QAEIXZ PROC				; SPPInfo::SColor::operator unsigned int, COMDAT
; _this$ = edi

; 10   : 		IC operator u32()										{

	sub	esp, 8

; 11   : 			int		_r	= clampr	(iFloor(r*255.f+.5f),0,255);

	movss	xmm2, DWORD PTR [edi]
	movss	xmm0, DWORD PTR __real@437f0000
	movss	xmm1, DWORD PTR __real@3f000000
	mulss	xmm2, xmm0
	push	ebx
	addss	xmm2, xmm1
	push	esi
	movss	DWORD PTR _a$250001[esp+16], xmm2
	mov	esi, DWORD PTR _a$250001[esp+16]
	mov	eax, esi
	sar	eax, 23					; 00000017H
	and	eax, 255				; 000000ffH
	mov	edx, esi
	or	edx, -8388608				; ff800000H
	shl	edx, 8
	mov	ecx, 158				; 0000009eH
	sub	ecx, eax
	shr	edx, cl
	sub	ecx, 96					; 00000060H
	mov	eax, 1
	shl	eax, cl
	sub	eax, 1
	sar	eax, 8
	and	eax, esi
	neg	eax
	sbb	eax, eax
	add	eax, 1
	sar	esi, 31					; 0000001fH
	and	eax, esi
	add	ecx, 64					; 00000040H
	sub	edx, eax
	sar	ecx, 31					; 0000001fH
	and	edx, ecx
	xor	edx, esi
	jge	SHORT $LN8@operator@22
	mov	DWORD PTR __r$[esp+16], 0
	jmp	SHORT $LN5@operator@22
$LN8@operator@22:
	cmp	edx, 255				; 000000ffH
	mov	DWORD PTR __r$[esp+16], 255		; 000000ffH
	jg	SHORT $LN5@operator@22
	mov	DWORD PTR __r$[esp+16], edx
$LN5@operator@22:

; 12   : 			int		_g	= clampr	(iFloor(g*255.f+.5f),0,255);

	movss	xmm2, DWORD PTR [edi+4]
	mulss	xmm2, xmm0
	addss	xmm2, xmm1
	movss	DWORD PTR _a$250016[esp+16], xmm2
	mov	esi, DWORD PTR _a$250016[esp+16]
	mov	edx, esi
	sar	edx, 23					; 00000017H
	and	edx, 255				; 000000ffH
	mov	ecx, 158				; 0000009eH
	sub	ecx, edx
	mov	edx, esi
	or	edx, -8388608				; ff800000H
	shl	edx, 8
	shr	edx, cl
	sub	ecx, 96					; 00000060H
	mov	eax, 1
	shl	eax, cl
	sub	eax, 1
	sar	eax, 8
	and	eax, esi
	neg	eax
	sbb	eax, eax
	add	eax, 1
	sar	esi, 31					; 0000001fH
	and	eax, esi
	add	ecx, 64					; 00000040H
	sub	edx, eax
	sar	ecx, 31					; 0000001fH
	and	edx, ecx
	xor	edx, esi
	jge	SHORT $LN16@operator@22
	xor	ebx, ebx
	jmp	SHORT $LN13@operator@22
$LN16@operator@22:
	cmp	edx, 255				; 000000ffH
	mov	ebx, 255				; 000000ffH
	jg	SHORT $LN13@operator@22
	mov	ebx, edx
$LN13@operator@22:

; 13   : 			int		_b	= clampr	(iFloor(b*255.f+.5f),0,255);

	movss	xmm2, DWORD PTR [edi+8]
	mulss	xmm2, xmm0
	addss	xmm2, xmm1
	movss	DWORD PTR _a$250031[esp+16], xmm2
	mov	esi, DWORD PTR _a$250031[esp+16]
	mov	eax, esi
	sar	eax, 23					; 00000017H
	and	eax, 255				; 000000ffH
	mov	edx, esi
	or	edx, -8388608				; ff800000H
	shl	edx, 8
	mov	ecx, 158				; 0000009eH
	sub	ecx, eax
	shr	edx, cl
	sub	ecx, 96					; 00000060H
	mov	eax, 1
	shl	eax, cl
	sub	eax, 1
	sar	eax, 8
	and	eax, esi
	neg	eax
	sbb	eax, eax
	add	eax, 1
	sar	esi, 31					; 0000001fH
	and	eax, esi
	add	ecx, 64					; 00000040H
	sub	edx, eax
	sar	ecx, 31					; 0000001fH
	and	edx, ecx
	xor	edx, esi
	jge	SHORT $LN24@operator@22
	xor	edx, edx
	jmp	SHORT $LN22@operator@22
$LN24@operator@22:
	cmp	edx, 255				; 000000ffH
	jle	SHORT $LN22@operator@22
	mov	edx, 255				; 000000ffH
$LN22@operator@22:

; 14   : 			return color_rgba		(_r,_g,_b,0);

	xor	eax, eax
	mov	ah, BYTE PTR __r$[esp+16]
	movzx	ecx, dl
	pop	esi
	mov	al, bl
	pop	ebx
	shl	eax, 8
	or	eax, ecx

; 15   : 		}

	add	esp, 8
	ret	0
??BSColor@SPPInfo@@QAEIXZ ENDP				; SPPInfo::SColor::operator unsigned int
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_iterator.h
;	COMDAT ?base@?$reverse_iterator@U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@@stlp_std@@QBE?AU?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@2@XZ
_TEXT	SEGMENT
?base@?$reverse_iterator@U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@@stlp_std@@QBE?AU?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@2@XZ PROC ; stlp_std::reverse_iterator<stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> > >::base, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 75   :   iterator_type base() const { return current; }

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	ret	0
?base@?$reverse_iterator@U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@@stlp_std@@QBE?AU?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@2@XZ ENDP ; stlp_std::reverse_iterator<stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> > >::base
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?8U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@@stlp_std@@YA_NABV?$reverse_iterator@U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@@0@0@Z
_TEXT	SEGMENT
??$?8U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@@stlp_std@@YA_NABV?$reverse_iterator@U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@@0@0@Z PROC ; stlp_std::operator==<stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> > >, COMDAT
; ___x$ = ecx
; ___y$ = eax

; 116  : { return __x.base() == __y.base(); }

	mov	eax, DWORD PTR [eax]
	cmp	DWORD PTR [ecx], eax
	sete	al
	ret	0
??$?8U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@@stlp_std@@YA_NABV?$reverse_iterator@U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@@0@0@Z ENDP ; stlp_std::operator==<stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> > >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_algobase.c
_TEXT	ENDS
;	COMDAT ??$__find@U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@PAVCEffectorCam@@@priv@stlp_std@@YA?AU?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@01@U201@0ABQAVCEffectorCam@@ABUinput_iterator_tag@1@@Z
_TEXT	SEGMENT
___first$ = 8						; size = 4
___last$ = 12						; size = 4
___val$ = 16						; size = 4
??$__find@U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@PAVCEffectorCam@@@priv@stlp_std@@YA?AU?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@01@U201@0ABQAVCEffectorCam@@ABUinput_iterator_tag@1@@Z PROC ; stlp_std::priv::__find<stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> >,CEffectorCam *>, COMDAT
; ___$ReturnUdt$ = eax

; 191  :   while (__first != __last && !(*__first == __val)) ++__first;

	mov	ecx, DWORD PTR ___first$[esp-4]
	push	esi
	mov	esi, DWORD PTR ___last$[esp]
	cmp	ecx, esi
	setne	dl
	test	dl, dl
	je	SHORT $LN23@find@8
	mov	edx, DWORD PTR ___val$[esp]
	push	edi
	mov	edi, DWORD PTR [edx]
	npad	7
$LL2@find@8:
	cmp	DWORD PTR [ecx+8], edi
	je	SHORT $LN24@find@8
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, esi
	setne	dl
	test	dl, dl
	jne	SHORT $LL2@find@8
$LN24@find@8:
	pop	edi
$LN23@find@8:

; 192  :   return __first;

	mov	DWORD PTR [eax], ecx
	pop	esi

; 193  : }

	ret	0
??$__find@U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@PAVCEffectorCam@@@priv@stlp_std@@YA?AU?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@01@U201@0ABQAVCEffectorCam@@ABUinput_iterator_tag@1@@Z ENDP ; stlp_std::priv::__find<stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> >,CEffectorCam *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_iterator.h
_TEXT	ENDS
;	COMDAT ??$?9U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@@stlp_std@@YA_NABV?$reverse_iterator@U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@@0@0@Z
_TEXT	SEGMENT
??$?9U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@@stlp_std@@YA_NABV?$reverse_iterator@U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@@0@0@Z PROC ; stlp_std::operator!=<stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> > >, COMDAT
; ___x$ = edx
; ___y$ = eax

; 127  : { return !(__x == __y); }

	mov	eax, DWORD PTR [eax]
	xor	ecx, ecx
	cmp	DWORD PTR [edx], eax
	setne	cl
	mov	al, cl
	ret	0
??$?9U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@@stlp_std@@YA_NABV?$reverse_iterator@U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@@0@0@Z ENDP ; stlp_std::operator!=<stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> > >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_algobase.c
_TEXT	ENDS
;	COMDAT ??$find@U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@PAVCEffectorCam@@@stlp_std@@YA?AU?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@0@U120@0ABQAVCEffectorCam@@@Z
_TEXT	SEGMENT
___first$ = 8						; size = 4
___last$ = 12						; size = 4
___val$ = 16						; size = 4
??$find@U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@PAVCEffectorCam@@@stlp_std@@YA?AU?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@0@U120@0ABQAVCEffectorCam@@@Z PROC ; stlp_std::find<stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> >,CEffectorCam *>, COMDAT
; ___$ReturnUdt$ = eax

; 215  :   _STLP_DEBUG_CHECK(_STLP_PRIV __check_range(__first, __last))
; 216  :   return _STLP_PRIV __find(__first, __last, __val, _STLP_ITERATOR_CATEGORY(__first, _InputIter));

	mov	ecx, DWORD PTR ___first$[esp-4]
	push	esi
	mov	esi, DWORD PTR ___last$[esp]
	cmp	ecx, esi
	setne	dl
	test	dl, dl
	push	edi
	je	SHORT $LN34@find@9
	mov	edx, DWORD PTR ___val$[esp+4]
	mov	edi, DWORD PTR [edx]
	npad	7
$LL12@find@9:
	cmp	DWORD PTR [ecx+8], edi
	je	SHORT $LN34@find@9
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, esi
	setne	dl
	test	dl, dl
	jne	SHORT $LL12@find@9
$LN34@find@9:

; 217  : }

	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi
	ret	0
??$find@U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@PAVCEffectorCam@@@stlp_std@@YA?AU?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@0@U120@0ABQAVCEffectorCam@@@Z ENDP ; stlp_std::find<stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> >,CEffectorCam *>
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_iterator.h
_TEXT	ENDS
;	COMDAT ??0?$reverse_iterator@U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@@stlp_std@@QAE@U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@1@@Z
_TEXT	SEGMENT
___x$ = 8						; size = 4
??0?$reverse_iterator@U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@@stlp_std@@QAE@U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@1@@Z PROC ; stlp_std::reverse_iterator<stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> > >::reverse_iterator<stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> > >, COMDAT
; _this$ = eax

; 65   :   explicit reverse_iterator(iterator_type __x) : current(__x) {}

	mov	ecx, DWORD PTR ___x$[esp-4]
	mov	DWORD PTR [eax], ecx
	ret	4
??0?$reverse_iterator@U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@@stlp_std@@QAE@U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@1@@Z ENDP ; stlp_std::reverse_iterator<stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> > >::reverse_iterator<stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> > >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ??0?$vector@PAVCEffectorPP@@V?$xalloc@PAVCEffectorPP@@@@@stlp_std@@QAE@ABV?$xalloc@PAVCEffectorPP@@@@@Z
_TEXT	SEGMENT
??0?$vector@PAVCEffectorPP@@V?$xalloc@PAVCEffectorPP@@@@@stlp_std@@QAE@ABV?$xalloc@PAVCEffectorPP@@@@@Z PROC ; stlp_std::vector<CEffectorPP *,xalloc<CEffectorPP *> >::vector<CEffectorPP *,xalloc<CEffectorPP *> >, COMDAT
; _this$ = eax

; 106  :   explicit vector(const allocator_type& __a = allocator_type())

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$vector@PAVCEffectorPP@@V?$xalloc@PAVCEffectorPP@@@@@stlp_std@@QAE@ABV?$xalloc@PAVCEffectorPP@@@@@Z ENDP ; stlp_std::vector<CEffectorPP *,xalloc<CEffectorPP *> >::vector<CEffectorPP *,xalloc<CEffectorPP *> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_list.h
_TEXT	ENDS
;	COMDAT ??0?$_Impl_list@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAE@ABV?$xalloc@PAX@@@Z
_TEXT	SEGMENT
??0?$_Impl_list@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAE@ABV?$xalloc@PAX@@@Z PROC ; stlp_std::priv::_Impl_list<void *,xalloc<void *> >::_Impl_list<void *,xalloc<void *> >, COMDAT
; _this$ = eax

; 350  :     : _STLP_PRIV _List_base<_Tp, _Alloc>(__a) {}

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	mov	DWORD PTR [eax], eax
	mov	DWORD PTR [eax+4], eax
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Impl_list@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAE@ABV?$xalloc@PAX@@@Z ENDP ; stlp_std::priv::_Impl_list<void *,xalloc<void *> >::_Impl_list<void *,xalloc<void *> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_iterator.h
_TEXT	ENDS
;	COMDAT ??D?$reverse_iterator@U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@@stlp_std@@QBEAAPAVCEffectorCam@@XZ
_TEXT	SEGMENT
??D?$reverse_iterator@U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@@stlp_std@@QBEAAPAVCEffectorCam@@XZ PROC ; stlp_std::reverse_iterator<stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> > >::operator*, COMDAT
; _this$ = eax

; 77   :     _Iterator __tmp = current;
; 78   :     return *--__tmp;

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+4]
	add	eax, 8

; 79   :   }

	ret	0
??D?$reverse_iterator@U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@@stlp_std@@QBEAAPAVCEffectorCam@@XZ ENDP ; stlp_std::reverse_iterator<stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> > >::operator*
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_list.h
_TEXT	ENDS
;	COMDAT ??E?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@QAE?AU012@H@Z
_TEXT	SEGMENT
??E?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@QAE?AU012@H@Z PROC ; stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> >::operator++, COMDAT
; _this$ = edx
; ___$ReturnUdt$ = eax

; 127  :     _Self __tmp = *this;

	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 128  :     this->_M_incr();

	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [edx], ecx

; 129  :     return __tmp;
; 130  :   }

	ret	0
??E?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@QAE?AU012@H@Z ENDP ; stlp_std::priv::_List_iterator<CEffectorCam *,stlp_std::_Nonconst_traits<CEffectorCam *> >::operator++
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
_TEXT	ENDS
;	COMDAT ?erase@?$vector@PAVCEffectorPP@@V?$xalloc@PAVCEffectorPP@@@@@stlp_std@@QAEPAPAVCEffectorPP@@PAPAV3@@Z
_TEXT	SEGMENT
?erase@?$vector@PAVCEffectorPP@@V?$xalloc@PAVCEffectorPP@@@@@stlp_std@@QAEPAPAVCEffectorPP@@PAPAV3@@Z PROC ; stlp_std::vector<CEffectorPP *,xalloc<CEffectorPP *> >::erase, COMDAT
; _this$ = eax
; ___pos$ = edi

; 206  :   {return cast_traits::to_value_type_ptr(_M_impl.erase(cast_traits::to_storage_type_ptr(__pos)));}

	push	esi
	mov	esi, eax
	mov	eax, DWORD PTR [esi+4]
	lea	ecx, DWORD PTR [edi+4]
	cmp	ecx, eax
	je	SHORT $LN18@erase@39
	sub	eax, ecx
	je	SHORT $LN18@erase@39
	push	eax
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
$LN18@erase@39:
	add	DWORD PTR [esi+4], -4			; fffffffcH
	mov	esi, DWORD PTR [esi+4]
	push	esi
	call	??$_Destroy@PAX@stlp_std@@YAXPAPAX@Z	; stlp_std::_Destroy<void *>
	push	edi
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 8
	pop	esi
	ret	0
?erase@?$vector@PAVCEffectorPP@@V?$xalloc@PAVCEffectorPP@@@@@stlp_std@@QAEPAPAVCEffectorPP@@PAPAV3@@Z ENDP ; stlp_std::vector<CEffectorPP *,xalloc<CEffectorPP *> >::erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?back@?$vector@PAVCEffectorPP@@V?$xalloc@PAVCEffectorPP@@@@@stlp_std@@QAEAAPAVCEffectorPP@@XZ
_TEXT	SEGMENT
?back@?$vector@PAVCEffectorPP@@V?$xalloc@PAVCEffectorPP@@@@@stlp_std@@QAEAAPAVCEffectorPP@@XZ PROC ; stlp_std::vector<CEffectorPP *,xalloc<CEffectorPP *> >::back, COMDAT
; _this$ = eax

; 100  :   reference back()              { return cast_traits::to_value_type_ref(_M_impl.back()); }

	mov	eax, DWORD PTR [eax+4]
	sub	eax, 4
	ret	0
?back@?$vector@PAVCEffectorPP@@V?$xalloc@PAVCEffectorPP@@@@@stlp_std@@QAEAAPAVCEffectorPP@@XZ ENDP ; stlp_std::vector<CEffectorPP *,xalloc<CEffectorPP *> >::back
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_list.h
_TEXT	ENDS
;	COMDAT ?erase@?$list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@stlp_std@@QAE?AU?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@2@U342@@Z
_TEXT	SEGMENT
___pos$ = 8						; size = 4
?erase@?$list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@stlp_std@@QAE?AU?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@2@U342@@Z PROC ; stlp_std::list<CEffectorCam *,xalloc<CEffectorCam *> >::erase, COMDAT
; ___$ReturnUdt$ = ebx

; 233  :   { return iterator(_M_impl.erase(_BaseIte(__pos._M_node))._M_node); }

	push	esi
	mov	esi, DWORD PTR ___pos$[esp]
	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR [esi]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [edi+4], eax
	lea	eax, DWORD PTR [esi+8]
	push	eax
	call	??$_Destroy@PAX@stlp_std@@YAXPAPAX@Z	; stlp_std::_Destroy<void *>
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	add	esp, 4
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [ebx], edi
	pop	edi
	mov	eax, ebx
	pop	esi
	ret	4
?erase@?$list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@stlp_std@@QAE?AU?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@2@U342@@Z ENDP ; stlp_std::list<CEffectorCam *,xalloc<CEffectorCam *> >::erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?clear@?$list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@stlp_std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@stlp_std@@QAEXXZ PROC ; stlp_std::list<CEffectorCam *,xalloc<CEffectorCam *> >::clear, COMDAT
; _this$ = ebx

; 172  :   void clear() { _M_impl.clear(); }

	jmp	?clear@?$_List_base@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEXXZ ; stlp_std::priv::_List_base<void *,xalloc<void *> >::clear
?clear@?$list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@stlp_std@@QAEXXZ ENDP ; stlp_std::list<CEffectorCam *,xalloc<CEffectorCam *> >::clear
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?rend@?$list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@stlp_std@@QAE?AV?$reverse_iterator@U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@@2@XZ
_TEXT	SEGMENT
?rend@?$list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@stlp_std@@QAE?AV?$reverse_iterator@U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@@2@XZ PROC ; stlp_std::list<CEffectorCam *,xalloc<CEffectorCam *> >::rend, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 159  :   reverse_iterator rend()               { return reverse_iterator(begin()); }

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	ret	0
?rend@?$list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@stlp_std@@QAE?AV?$reverse_iterator@U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@@2@XZ ENDP ; stlp_std::list<CEffectorCam *,xalloc<CEffectorCam *> >::rend
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@stlp_std@@QAE?AU?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@2@XZ
_TEXT	SEGMENT
?end@?$list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@stlp_std@@QAE?AU?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@2@XZ PROC ; stlp_std::list<CEffectorCam *,xalloc<CEffectorCam *> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 153  :   iterator end()               { return iterator(_M_impl.end()._M_node); }

	mov	DWORD PTR [eax], ecx
	ret	0
?end@?$list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@stlp_std@@QAE?AU?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@2@XZ ENDP ; stlp_std::list<CEffectorCam *,xalloc<CEffectorCam *> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@stlp_std@@QAE@ABV?$xalloc@PAVCEffectorCam@@@@@Z
_TEXT	SEGMENT
??0?$list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@stlp_std@@QAE@ABV?$xalloc@PAVCEffectorCam@@@@@Z PROC ; stlp_std::list<CEffectorCam *,xalloc<CEffectorCam *> >::list<CEffectorCam *,xalloc<CEffectorCam *> >, COMDAT
; _this$ = eax

; 92   :   list(const allocator_type& __a = allocator_type())

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	mov	DWORD PTR [eax], eax
	mov	DWORD PTR [eax+4], eax
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@stlp_std@@QAE@ABV?$xalloc@PAVCEffectorCam@@@@@Z ENDP ; stlp_std::list<CEffectorCam *,xalloc<CEffectorCam *> >::list<CEffectorCam *,xalloc<CEffectorCam *> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_matrix.h
_TEXT	ENDS
;	COMDAT ?build_camera_dir@?$_matrix@M@@QAEAAU1@ABU?$_vector3@M@@00@Z
_TEXT	SEGMENT
_mag$305203 = -20					; size = 4
tv272 = -16						; size = 4
_vUp$ = -12						; size = 12
?build_camera_dir@?$_matrix@M@@QAEAAU1@ABU?$_vector3@M@@00@Z PROC ; _matrix<float>::build_camera_dir, COMDAT
; _this$ = esi
; _vFrom$ = ebx
; _vView$ = edi
; _vWorldUp$ = eax

; 457  : 	{

	sub	esp, 20					; 00000014H

; 458  : 		// Get the dot product, and calculate the projection of the z basis
; 459  : 		// vector3 onto the up vector3. The projection is the y basis vector3.
; 460  : 		T fDotProduct = vWorldUp.dotproduct( vView );

	movss	xmm4, DWORD PTR [eax+4]
	movss	xmm6, DWORD PTR [edi]
	movss	xmm5, DWORD PTR [eax]
	movss	xmm3, DWORD PTR [edi+4]
	movss	xmm2, DWORD PTR [eax+8]
	movss	xmm1, DWORD PTR [edi+8]
	movaps	xmm7, xmm5
	mulss	xmm7, xmm6
	movaps	xmm0, xmm4
	mulss	xmm0, xmm3
	addss	xmm7, xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, xmm1

; 461  : 
; 462  : 		Tvector vUp;
; 463  : 		vUp.mul	(vView, -fDotProduct).add(vWorldUp).normalize();

	addss	xmm7, xmm0
	movss	xmm0, DWORD PTR __real@80000000
	subss	xmm0, xmm7
	mulss	xmm1, xmm0
	addss	xmm2, xmm1
	mulss	xmm3, xmm0
	addss	xmm4, xmm3
	movss	DWORD PTR tv272[esp+20], xmm6
	mulss	xmm6, xmm0
	addss	xmm5, xmm6
	movaps	xmm0, xmm2
	mulss	xmm0, xmm2
	movaps	xmm1, xmm4
	mulss	xmm1, xmm4
	addss	xmm0, xmm1
	movaps	xmm1, xmm5
	mulss	xmm1, xmm5
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR __real@3f800000
	push	ecx
	divss	xmm1, xmm0
	movss	DWORD PTR _vUp$[esp+24], xmm5
	movss	DWORD PTR _vUp$[esp+28], xmm4
	movss	DWORD PTR _vUp$[esp+32], xmm2
	movss	DWORD PTR [esp], xmm1
	call	_sqrtf
	fstp	DWORD PTR _mag$305203[esp+24]

; 464  : 
; 465  : 		// The x basis vector3 is found simply with the cross product of the y
; 466  : 		// and z basis vectors
; 467  : 		Tvector vRight;
; 468  : 		vRight.crossproduct( vUp, vView );

	movss	xmm6, DWORD PTR [edi+8]
	movss	xmm4, DWORD PTR [edi+4]
	movss	xmm3, DWORD PTR _mag$305203[esp+24]
	movss	xmm7, DWORD PTR tv272[esp+24]
	movaps	xmm5, xmm6
	movaps	xmm1, xmm4
	movaps	xmm2, xmm3
	mulss	xmm2, DWORD PTR _vUp$[esp+24]
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR _vUp$[esp+28]
	mulss	xmm3, DWORD PTR _vUp$[esp+32]
	mulss	xmm1, xmm3
	mulss	xmm6, xmm2

; 469  : 
; 470  : 		// Start building the Device.mView. The first three rows contains the basis
; 471  : 		// vectors used to rotate the view to point at the lookat point
; 472  : 		_11 = vRight.x;  _12 = vUp.x;  _13 = vView.x;  _14 = 0.0f;

	movss	DWORD PTR [esi+4], xmm2
	mulss	xmm5, xmm0
	subss	xmm5, xmm1
	movss	DWORD PTR [esi], xmm5
	fld	DWORD PTR [edi]
	fstp	DWORD PTR [esi+8]
	movaps	xmm1, xmm7
	mulss	xmm1, xmm3
	subss	xmm1, xmm6
	xorps	xmm6, xmm6
	movss	DWORD PTR [esi+12], xmm6

; 473  : 		_21 = vRight.y;  _22 = vUp.y;  _23 = vView.y;  _24 = 0.0f;

	movss	DWORD PTR [esi+16], xmm1
	movss	DWORD PTR [esi+20], xmm0
	fld	DWORD PTR [edi+4]
	movss	DWORD PTR [esi+28], xmm6
	fstp	DWORD PTR [esi+24]
	mulss	xmm4, xmm2
	mulss	xmm7, xmm0
	subss	xmm4, xmm7

; 474  : 		_31 = vRight.z;  _32 = vUp.z;  _33 = vView.z;  _34 = 0.0f;

	movss	DWORD PTR [esi+32], xmm4
	movss	DWORD PTR [esi+36], xmm3
	fld	DWORD PTR [edi+8]
	movss	DWORD PTR [esi+44], xmm6
	fstp	DWORD PTR [esi+40]

; 475  : 
; 476  : 		// Do the translation values (rotations are still about the eyepoint)
; 477  : 		_41 = - vFrom.dotproduct(vRight);

	movss	xmm6, DWORD PTR [ebx]
	mulss	xmm4, DWORD PTR [ebx+8]
	mulss	xmm6, xmm5
	addss	xmm6, xmm4
	mulss	xmm1, DWORD PTR [ebx+4]
	addss	xmm6, xmm1
	movss	xmm1, DWORD PTR __real@80000000
	movaps	xmm4, xmm1
	subss	xmm4, xmm6
	movss	DWORD PTR [esi+48], xmm4

; 478  : 		_42 = - vFrom.dotproduct( vUp  );

	mulss	xmm0, DWORD PTR [ebx+4]
	movss	xmm4, DWORD PTR [ebx]
	mulss	xmm3, DWORD PTR [ebx+8]
	mulss	xmm4, xmm2
	addss	xmm4, xmm3
	addss	xmm4, xmm0
	movaps	xmm0, xmm1
	subss	xmm0, xmm4
	movss	DWORD PTR [esi+52], xmm0

; 479  : 		_43 = - vFrom.dotproduct(vView );

	movss	xmm0, DWORD PTR [edi+4]
	mulss	xmm0, DWORD PTR [ebx+4]
	movss	xmm2, DWORD PTR [ebx]
	mulss	xmm2, DWORD PTR [edi]
	addss	xmm0, xmm2
	movss	xmm2, DWORD PTR [ebx+8]
	mulss	xmm2, DWORD PTR [edi+8]
	addss	xmm0, xmm2
	subss	xmm1, xmm0

; 480  : 		_44 = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esi+56], xmm1
	movss	DWORD PTR [esi+60], xmm0

; 481  : 		return *this; 

	mov	eax, esi

; 482  : 	}

	add	esp, 24					; 00000018H
	ret	0
?build_camera_dir@?$_matrix@M@@QAEAAU1@ABU?$_vector3@M@@00@Z ENDP ; _matrix<float>::build_camera_dir
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\cameramanager.cpp
_TEXT	ENDS
;	COMDAT ?ProcessCameraEffector@CCameraManager@@MAE_NPAVCEffectorCam@@@Z
_TEXT	SEGMENT
_eff$ = 8						; size = 4
?ProcessCameraEffector@CCameraManager@@MAE_NPAVCEffectorCam@@@Z PROC ; CCameraManager::ProcessCameraEffector, COMDAT
; _this$ = ecx

; 327  : {

	push	ebx
	push	ebp
	push	esi
	push	edi

; 328  : 	bool res = false;
; 329  : 	if(eff->Valid() && eff->ProcessCam(m_cam_info))

	mov	edi, DWORD PTR _eff$[esp+12]
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+4]
	mov	esi, ecx
	mov	ecx, edi
	xor	bl, bl
	call	edx
	test	eax, eax
	je	SHORT $LN3@ProcessCam
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+8]
	lea	ecx, DWORD PTR [esi+4]
	push	ecx
	mov	ecx, edi
	call	edx
	test	eax, eax
	je	SHORT $LN3@ProcessCam

; 330  : 	{
; 331  : 		res = true;

	mov	al, 1

; 344  : 	}
; 345  : 	return res;
; 346  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
$LN3@ProcessCam:

; 332  : 	}else
; 333  : 	{
; 334  : 		if(eff->AllowProcessingIfInvalid())

	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+16]
	mov	ecx, edi
	call	edx
	test	eax, eax
	je	SHORT $LN1@ProcessCam

; 335  : 		{
; 336  : 			eff->ProcessIfInvalid(m_cam_info);

	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+12]
	lea	ecx, DWORD PTR [esi+4]
	push	ecx
	mov	ecx, edi
	call	edx

; 337  : 			res = true;

	mov	bl, 1
$LN1@ProcessCam:

; 338  : 		}
; 339  : 
; 340  : 		EffectorCamVec::iterator it = std::find(m_EffectorsCam.begin(), m_EffectorsCam.end(), eff);

	lea	eax, DWORD PTR [esi+68]
	mov	esi, DWORD PTR [eax]
	cmp	esi, eax
	setne	cl
	test	cl, cl
	je	SHORT $LN40@ProcessCam
	npad	3
$LL41@ProcessCam:
	cmp	DWORD PTR [esi+8], edi
	je	SHORT $LN40@ProcessCam
	mov	esi, DWORD PTR [esi]
	cmp	esi, eax
	setne	cl
	test	cl, cl
	jne	SHORT $LL41@ProcessCam
$LN40@ProcessCam:

; 341  : 
; 342  : 		m_EffectorsCam.erase(it);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [eax+4], ecx
	lea	eax, DWORD PTR [esi+8]
	push	eax
	call	??$_Destroy@PAX@stlp_std@@YAXPAPAX@Z	; stlp_std::_Destroy<void *>
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ebp, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	add	esp, 4
	push	esi
	call	ebp

; 343  : 		OnEffectorReleased	(eff);

	cmp	DWORD PTR [edi+4], 0
	jne	SHORT $LN96@ProcessCam
	cmp	DWORD PTR [edi+8], 0
	je	SHORT $LN98@ProcessCam
$LN96@ProcessCam:
	mov	ecx, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [edi+8]
	push	ecx
	call	edx
$LN98@ProcessCam:
	push	edi
	call	___RTCastToVoid
	mov	esi, eax
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax]
	add	esp, 4
	push	0
	mov	ecx, edi
	call	edx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	ebp

; 344  : 	}
; 345  : 	return res;
; 346  : }

	pop	edi
	pop	esi
	pop	ebp
	mov	al, bl
	pop	ebx
	ret	4
?ProcessCameraEffector@CCameraManager@@MAE_NPAVCEffectorCam@@@Z ENDP ; CCameraManager::ProcessCameraEffector
_TEXT	ENDS
PUBLIC	?RemovePPEffector@CCameraManager@@QAEXW4EEffectorPPType@@@Z ; CCameraManager::RemovePPEffector
; Function compile flags: /Ogtpy
;	COMDAT ?RemovePPEffector@CCameraManager@@QAEXW4EEffectorPPType@@@Z
_TEXT	SEGMENT
_type$ = 8						; size = 4
?RemovePPEffector@CCameraManager@@QAEXW4EEffectorPPType@@@Z PROC ; CCameraManager::RemovePPEffector, COMDAT
; _this$ = ecx

; 254  : {

	push	ebx
	mov	ebx, ecx

; 255  : 	for (EffectorPPIt it=m_EffectorsPP.begin(); it!=m_EffectorsPP.end(); it++ )

	mov	eax, DWORD PTR [ebx+84]
	push	esi
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	mov	esi, eax
	mov	eax, DWORD PTR [ebx+88]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 8
	cmp	esi, eax
	je	$LN3@RemovePPEf
	push	edi
	mov	edi, DWORD PTR _type$[esp+8]
$LL5@RemovePPEf:

; 256  : 		if ((*it)->Type()==type){ 

	mov	eax, DWORD PTR [esi]
	cmp	DWORD PTR [eax+12], edi
	je	SHORT $LN76@RemovePPEf
	mov	eax, DWORD PTR [ebx+88]
	push	eax
	add	esi, 4
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 4
	cmp	esi, eax
	jne	SHORT $LL5@RemovePPEf
	pop	edi
	pop	esi
	pop	ebx

; 263  : 			return;
; 264  : 		}
; 265  : }

	ret	4
$LN76@RemovePPEf:

; 257  : 			if ((*it)->FreeOnRemove())

	mov	edi, eax
	cmp	BYTE PTR [edi+16], 0
	je	SHORT $LN43@RemovePPEf

; 258  : 			{
; 259  : 				OnEffectorReleased		(*it);

	cmp	DWORD PTR [edi+4], 0
	jne	SHORT $LN35@RemovePPEf
	cmp	DWORD PTR [edi+8], 0
	je	SHORT $LN37@RemovePPEf
$LN35@RemovePPEf:
	mov	ecx, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [edi+8]
	push	ecx
	call	edx
$LN37@RemovePPEf:
	test	edi, edi
	je	SHORT $LN43@RemovePPEf
	push	ebp
	push	edi
	call	___RTCastToVoid
	mov	ebp, eax
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax]
	add	esp, 4
	push	0
	mov	ecx, edi
	call	edx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	ebp
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	pop	ebp
$LN43@RemovePPEf:

; 260  : //				xr_delete				(*it);
; 261  : 			}
; 262  : 			m_EffectorsPP.erase			(it);

	mov	eax, DWORD PTR [ebx+88]
	lea	ecx, DWORD PTR [esi+4]
	cmp	ecx, eax
	je	SHORT $LN65@RemovePPEf
	sub	eax, ecx
	je	SHORT $LN65@RemovePPEf
	push	eax
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
$LN65@RemovePPEf:
	add	DWORD PTR [ebx+88], -4			; fffffffcH
	mov	ebx, DWORD PTR [ebx+88]
	push	ebx
	call	??$_Destroy@PAX@stlp_std@@YAXPAPAX@Z	; stlp_std::_Destroy<void *>
	push	esi
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 8
	pop	edi
$LN3@RemovePPEf:
	pop	esi
	pop	ebx

; 263  : 			return;
; 264  : 		}
; 265  : }

	ret	4
?RemovePPEffector@CCameraManager@@QAEXW4EEffectorPPType@@@Z ENDP ; CCameraManager::RemovePPEffector
_TEXT	ENDS
PUBLIC	?RequestPPEffectorId@CCameraManager@@QAE?AW4EEffectorPPType@@XZ ; CCameraManager::RequestPPEffectorId
; Function compile flags: /Ogtpy
;	COMDAT ?RequestPPEffectorId@CCameraManager@@QAE?AW4EEffectorPPType@@XZ
_TEXT	SEGMENT
?RequestPPEffectorId@CCameraManager@@QAE?AW4EEffectorPPType@@XZ PROC ; CCameraManager::RequestPPEffectorId, COMDAT
; _this$ = ecx

; 239  : {

	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 240  : 	for ( EEffectorPPType	index	=	(EEffectorPPType)effCustomEffectorStartID;

	mov	ebx, 10000				; 00002710H
	npad	6
$LL3@RequestPPE:

; 241  : 							GetPPEffector(index);
; 242  : 							index	=	(EEffectorPPType)(index+1) ) { ; }

	mov	eax, DWORD PTR [edi+84]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	mov	esi, eax
	mov	eax, DWORD PTR [edi+88]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 8
	cmp	esi, eax
	je	SHORT $LN37@RequestPPE
	npad	5
$LL9@RequestPPE:
	mov	eax, DWORD PTR [esi]
	cmp	DWORD PTR [eax+12], ebx
	je	SHORT $LN32@RequestPPE
	mov	eax, DWORD PTR [edi+88]
	push	eax
	add	esi, 4
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 4
	cmp	esi, eax
	jne	SHORT $LL9@RequestPPE
$LN37@RequestPPE:
	pop	edi
	pop	esi

; 243  : 	return index;

	mov	eax, ebx
	pop	ebx

; 244  : }

	ret	0
$LN32@RequestPPE:

; 241  : 							GetPPEffector(index);
; 242  : 							index	=	(EEffectorPPType)(index+1) ) { ; }

	test	eax, eax
	je	SHORT $LN37@RequestPPE
	add	ebx, 1
	jmp	SHORT $LL3@RequestPPE
?RequestPPEffectorId@CCameraManager@@QAE?AW4EEffectorPPType@@XZ ENDP ; CCameraManager::RequestPPEffectorId
_TEXT	ENDS
PUBLIC	?RemoveCamEffector@CCameraManager@@QAEXW4ECamEffectorType@@@Z ; CCameraManager::RemoveCamEffector
; Function compile flags: /Ogtpy
;	COMDAT ?RemoveCamEffector@CCameraManager@@QAEXW4ECamEffectorType@@@Z
_TEXT	SEGMENT
_type$ = 8						; size = 4
?RemoveCamEffector@CCameraManager@@QAEXW4ECamEffectorType@@@Z PROC ; CCameraManager::RemoveCamEffector, COMDAT
; _this$ = ecx

; 214  : 	for (EffectorCamIt it=m_EffectorsCam.begin(); it!=m_EffectorsCam.end(); it++ )

	lea	eax, DWORD PTR [ecx+68]
	push	esi
	mov	esi, DWORD PTR [eax]
	cmp	esi, eax
	setne	cl
	test	cl, cl
	je	SHORT $LN87@RemoveCamE
	mov	edx, DWORD PTR _type$[esp]
$LL25@RemoveCamE:

; 215  : 		if ((*it)->eType==type)

	mov	ecx, DWORD PTR [esi+8]
	cmp	DWORD PTR [ecx+12], edx
	je	SHORT $LN99@RemoveCamE
	mov	esi, DWORD PTR [esi]
	cmp	esi, eax
	setne	cl
	test	cl, cl
	jne	SHORT $LL25@RemoveCamE
	pop	esi

; 219  : 			return;
; 220  : 		}
; 221  : }

	ret	4
$LN99@RemoveCamE:
	push	ebx
	push	edi

; 216  : 		{ 
; 217  : 			OnEffectorReleased	(*it);

	mov	edi, ecx
	cmp	DWORD PTR [edi+4], 0
	jne	SHORT $LN56@RemoveCamE
	cmp	DWORD PTR [edi+8], 0
	je	SHORT $LN58@RemoveCamE
$LN56@RemoveCamE:
	mov	edx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edi+8]
	push	edx
	call	eax
$LN58@RemoveCamE:
	test	edi, edi
	mov	ebx, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	je	SHORT $LN64@RemoveCamE
	push	ebp
	push	edi
	call	___RTCastToVoid
	mov	edx, DWORD PTR [edi]
	add	esp, 4
	mov	ebp, eax
	mov	eax, DWORD PTR [edx]
	push	0
	mov	ecx, edi
	call	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	ebp
	call	ebx
	pop	ebp
$LN64@RemoveCamE:

; 218  : 			m_EffectorsCam.erase(it);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [eax+4], ecx
	lea	eax, DWORD PTR [esi+8]
	push	eax
	call	??$_Destroy@PAX@stlp_std@@YAXPAPAX@Z	; stlp_std::_Destroy<void *>
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	add	esp, 4
	push	esi
	call	ebx
	pop	edi
	pop	ebx
$LN87@RemoveCamE:
	pop	esi

; 219  : 			return;
; 220  : 		}
; 221  : }

	ret	4
?RemoveCamEffector@CCameraManager@@QAEXW4ECamEffectorType@@@Z ENDP ; CCameraManager::RemoveCamEffector
_TEXT	ENDS
PUBLIC	?GetCamEffector@CCameraManager@@QAEPAVCEffectorCam@@W4ECamEffectorType@@@Z ; CCameraManager::GetCamEffector
; Function compile flags: /Ogtpy
;	COMDAT ?GetCamEffector@CCameraManager@@QAEPAVCEffectorCam@@W4ECamEffectorType@@@Z
_TEXT	SEGMENT
_type$ = 8						; size = 4
?GetCamEffector@CCameraManager@@QAEPAVCEffectorCam@@W4ECamEffectorType@@@Z PROC ; CCameraManager::GetCamEffector, COMDAT
; _this$ = ecx

; 181  : 	for (EffectorCamIt it=m_EffectorsCam.begin(); it!=m_EffectorsCam.end(); it++ )

	mov	eax, DWORD PTR [ecx+68]
	add	ecx, 68					; 00000044H
	cmp	eax, ecx
	setne	dl
	test	dl, dl
	push	esi
	je	SHORT $LN2@GetCamEffe
	mov	esi, DWORD PTR _type$[esp]
$LL25@GetCamEffe:

; 182  : 		if ((*it)->eType==type)

	mov	edx, DWORD PTR [eax+8]
	cmp	DWORD PTR [edx+12], esi
	je	SHORT $LN50@GetCamEffe
	mov	eax, DWORD PTR [eax]
	cmp	eax, ecx
	setne	dl
	test	dl, dl
	jne	SHORT $LL25@GetCamEffe
$LN2@GetCamEffe:

; 185  : 		}
; 186  : 	return 0;

	xor	eax, eax
	pop	esi

; 187  : }

	ret	4
$LN50@GetCamEffe:

; 183  : 		{
; 184  : 			return *it;

	mov	eax, edx
	pop	esi

; 187  : }

	ret	4
?GetCamEffector@CCameraManager@@QAEPAVCEffectorCam@@W4ECamEffectorType@@@Z ENDP ; CCameraManager::GetCamEffector
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$xr_list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@@QAE@XZ PROC ; xr_list<CEffectorCam *,xalloc<CEffectorCam *> >::xr_list<CEffectorCam *,xalloc<CEffectorCam *> >, COMDAT
; _this$ = eax
	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	mov	DWORD PTR [eax], eax
	mov	DWORD PTR [eax+4], eax
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$xr_list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@@QAE@XZ ENDP ; xr_list<CEffectorCam *,xalloc<CEffectorCam *> >::xr_list<CEffectorCam *,xalloc<CEffectorCam *> >
_TEXT	ENDS
PUBLIC	__real@3eaa7efa
PUBLIC	__real@41200000
PUBLIC	??0SPPInfo@@QAE@XZ				; SPPInfo::SPPInfo
;	COMDAT __real@3eaa7efa
; File d:\clearsky\sources\engine\xrengine\cameramanager.h
CONST	SEGMENT
__real@3eaa7efa DD 03eaa7efar			; 0.333
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\cameramanager.cpp
CONST	ENDS
;	COMDAT ??0SPPInfo@@QAE@XZ
_TEXT	SEGMENT
??0SPPInfo@@QAE@XZ PROC					; SPPInfo::SPPInfo, COMDAT
; _this$ = ecx

; 70   : 	blur = gray = duality.h = duality.v = 0;

	xorps	xmm0, xmm0

; 71   : 	noise.intensity=0; noise.grain = 1; noise.fps = 10;

	movss	xmm1, DWORD PTR __real@3f800000
	mov	eax, ecx
	movss	DWORD PTR [eax+20], xmm1
	movss	xmm1, DWORD PTR __real@41200000
	movss	DWORD PTR [eax+24], xmm1

; 72   : 	color_base.set	(.5f,	.5f,	.5f);

	movss	xmm1, DWORD PTR __real@3f000000
	movss	DWORD PTR [eax+12], xmm0
	movss	DWORD PTR [eax+8], xmm0
	movss	DWORD PTR [eax+4], xmm0
	movss	DWORD PTR [eax], xmm0
	movss	DWORD PTR [eax+16], xmm0
	movss	DWORD PTR [eax+28], xmm1
	movss	DWORD PTR [eax+32], xmm1
	movss	DWORD PTR [eax+36], xmm1

; 73   : 	color_gray.set	(.333f, .333f,	.333f);

	movss	xmm1, DWORD PTR __real@3eaa7efa
	movss	DWORD PTR [eax+40], xmm1
	movss	DWORD PTR [eax+44], xmm1
	movss	DWORD PTR [eax+48], xmm1
	xor	ecx, ecx

; 74   : 	color_add.set	(0.f,	0.f,	0.f);

	movss	DWORD PTR [eax+52], xmm0
	movss	DWORD PTR [eax+56], xmm0
	movss	DWORD PTR [eax+60], xmm0
	mov	DWORD PTR [eax+72], ecx
	mov	DWORD PTR [eax+76], ecx

; 75   : 	cm_influence	= 0.0f;

	movss	DWORD PTR [eax+64], xmm0

; 76   : 	cm_interpolate	= 0.0f;

	movss	DWORD PTR [eax+68], xmm0

; 77   : }

	ret	0
??0SPPInfo@@QAE@XZ ENDP					; SPPInfo::SPPInfo
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_ECEffectorPP@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_ECEffectorPP@@UAEPAXI@Z PROC				; CEffectorPP::`vector deleting destructor', COMDAT
; _this$ = ecx
	mov	dl, BYTE PTR ___flags$[esp-4]
	test	dl, 2
	push	esi
	mov	esi, ecx
	je	SHORT $LN3@vector@30
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	sub	eax, 1
	lea	ecx, DWORD PTR [esi+ecx*4]
	js	SHORT $LN6@vector@30
$LL7@vector@30:
	sub	ecx, 28					; 0000001cH
	sub	eax, 1
	mov	DWORD PTR [ecx], OFFSET ??_7SBaseEffector@@6B@
	jns	SHORT $LL7@vector@30
$LN6@vector@30:
	test	dl, 1
	je	SHORT $LN16@vector@30
	test	edi, edi
	je	SHORT $LN16@vector@30
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN16@vector@30:
	mov	eax, edi
	pop	edi
	pop	esi
	ret	4
$LN3@vector@30:
	test	dl, 1
	mov	DWORD PTR [esi], OFFSET ??_7SBaseEffector@@6B@
	je	SHORT $LN25@vector@30
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN25@vector@30:
	mov	eax, esi
	pop	esi
	ret	4
??_ECEffectorPP@@UAEPAXI@Z ENDP				; CEffectorPP::`vector deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_ECEffectorCam@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_ECEffectorCam@@UAEPAXI@Z PROC			; CEffectorCam::`vector deleting destructor', COMDAT
; _this$ = ecx
	mov	dl, BYTE PTR ___flags$[esp-4]
	test	dl, 2
	push	esi
	mov	esi, ecx
	je	SHORT $LN3@vector@31
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	lea	ecx, DWORD PTR [eax+eax*2]
	sub	eax, 1
	lea	ecx, DWORD PTR [esi+ecx*8]
	js	SHORT $LN6@vector@31
	npad	2
$LL7@vector@31:
	sub	ecx, 24					; 00000018H
	sub	eax, 1
	mov	DWORD PTR [ecx], OFFSET ??_7SBaseEffector@@6B@
	jns	SHORT $LL7@vector@31
$LN6@vector@31:
	test	dl, 1
	je	SHORT $LN16@vector@31
	test	edi, edi
	je	SHORT $LN16@vector@31
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN16@vector@31:
	mov	eax, edi
	pop	edi
	pop	esi
	ret	4
$LN3@vector@31:
	test	dl, 1
	mov	DWORD PTR [esi], OFFSET ??_7SBaseEffector@@6B@
	je	SHORT $LN25@vector@31
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN25@vector@31:
	mov	eax, esi
	pop	esi
	ret	4
??_ECEffectorCam@@UAEPAXI@Z ENDP			; CEffectorCam::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_GCEffectorCam@@UAEPAXI@Z			; CEffectorCam::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GCEffectorCam@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCEffectorCam@@UAEPAXI@Z PROC			; CEffectorCam::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7SBaseEffector@@6B@
	je	SHORT $LN13@scalar@27
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN13@scalar@27:
	mov	eax, esi
	pop	esi
	ret	4
??_GCEffectorCam@@UAEPAXI@Z ENDP			; CEffectorCam::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\_list.h
;	COMDAT ?push_back@?$_Impl_list@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEXABQAX@Z
_TEXT	SEGMENT
___x$ = 8						; size = 4
?push_back@?$_Impl_list@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEXABQAX@Z PROC ; stlp_std::priv::_Impl_list<void *,xalloc<void *> >::push_back, COMDAT
; _this$ = edi

; 499  :   void push_back (const_reference __x) { insert(end(), __x); }

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	push	12					; 0000000cH
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	mov	esi, eax
	mov	eax, DWORD PTR ___x$[esp]
	push	eax
	lea	ecx, DWORD PTR [esi+8]
	push	ecx
	call	??$_Copy_Construct@PAX@stlp_std@@YAXPAPAXABQAX@Z ; stlp_std::_Copy_Construct<void *>
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [esi], edi
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [eax], esi
	add	esp, 8
	mov	DWORD PTR [edi+4], esi
	pop	esi
	ret	4
?push_back@?$_Impl_list@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEXABQAX@Z ENDP ; stlp_std::priv::_Impl_list<void *,xalloc<void *> >::push_back
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?push_front@?$_Impl_list@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEXABQAX@Z
_TEXT	SEGMENT
___x$ = 8						; size = 4
?push_front@?$_Impl_list@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEXABQAX@Z PROC ; stlp_std::priv::_Impl_list<void *,xalloc<void *> >::push_front, COMDAT
; _this$ = eax

; 498  :   void push_front(const_reference __x) { insert(begin(), __x); }

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	push	edi
	mov	edi, DWORD PTR [eax]
	push	12					; 0000000cH
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	mov	ecx, DWORD PTR ___x$[esp+4]
	mov	esi, eax
	push	ecx
	lea	edx, DWORD PTR [esi+8]
	push	edx
	call	??$_Copy_Construct@PAX@stlp_std@@YAXPAPAXABQAX@Z ; stlp_std::_Copy_Construct<void *>
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [esi], edi
	mov	DWORD PTR [esi+4], eax
	add	esp, 8
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [edi+4], esi
	pop	edi
	pop	esi
	ret	4
?push_front@?$_Impl_list@PAXV?$xalloc@PAX@@@priv@stlp_std@@QAEXABQAX@Z ENDP ; stlp_std::priv::_Impl_list<void *,xalloc<void *> >::push_front
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ??0?$xr_vector@PAVCEffectorPP@@V?$xalloc@PAVCEffectorPP@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@PAVCEffectorPP@@V?$xalloc@PAVCEffectorPP@@@@@@QAE@XZ PROC ; xr_vector<CEffectorPP *,xalloc<CEffectorPP *> >::xr_vector<CEffectorPP *,xalloc<CEffectorPP *> >, COMDAT
; _this$ = eax

; 123  : 			xr_vector			()									: inherited	()					{}

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$xr_vector@PAVCEffectorPP@@V?$xalloc@PAVCEffectorPP@@@@@@QAE@XZ ENDP ; xr_vector<CEffectorPP *,xalloc<CEffectorPP *> >::xr_vector<CEffectorPP *,xalloc<CEffectorPP *> >
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_list.h
_TEXT	ENDS
;	COMDAT ?push_back@?$list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@stlp_std@@QAEXABQAVCEffectorCam@@@Z
_TEXT	SEGMENT
___x$ = 8						; size = 4
?push_back@?$list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@stlp_std@@QAEXABQAVCEffectorCam@@@Z PROC ; stlp_std::list<CEffectorCam *,xalloc<CEffectorCam *> >::push_back, COMDAT
; _this$ = edi

; 224  :   void push_back(const value_type& __x)  { _M_impl.push_back(cast_traits::to_storage_type_cref(__x)); }

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	push	12					; 0000000cH
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	mov	esi, eax
	mov	eax, DWORD PTR ___x$[esp]
	push	eax
	lea	ecx, DWORD PTR [esi+8]
	push	ecx
	call	??$_Copy_Construct@PAX@stlp_std@@YAXPAPAXABQAX@Z ; stlp_std::_Copy_Construct<void *>
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [esi], edi
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [eax], esi
	add	esp, 8
	mov	DWORD PTR [edi+4], esi
	pop	esi
	ret	4
?push_back@?$list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@stlp_std@@QAEXABQAVCEffectorCam@@@Z ENDP ; stlp_std::list<CEffectorCam *,xalloc<CEffectorCam *> >::push_back
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?push_front@?$list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@stlp_std@@QAEXABQAVCEffectorCam@@@Z
_TEXT	SEGMENT
___x$ = 8						; size = 4
?push_front@?$list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@stlp_std@@QAEXABQAVCEffectorCam@@@Z PROC ; stlp_std::list<CEffectorCam *,xalloc<CEffectorCam *> >::push_front, COMDAT
; _this$ = eax

; 223  :   void push_front(const value_type& __x) { _M_impl.push_front(cast_traits::to_storage_type_cref(__x)); }

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	push	edi
	mov	edi, DWORD PTR [eax]
	push	12					; 0000000cH
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	mov	ecx, DWORD PTR ___x$[esp+4]
	mov	esi, eax
	push	ecx
	lea	edx, DWORD PTR [esi+8]
	push	edx
	call	??$_Copy_Construct@PAX@stlp_std@@YAXPAPAXABQAX@Z ; stlp_std::_Copy_Construct<void *>
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [esi], edi
	mov	DWORD PTR [esi+4], eax
	add	esp, 8
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [edi+4], esi
	pop	edi
	pop	esi
	ret	4
?push_front@?$list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@stlp_std@@QAEXABQAVCEffectorCam@@@Z ENDP ; stlp_std::list<CEffectorCam *,xalloc<CEffectorCam *> >::push_front
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?back@?$list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@stlp_std@@QAEAAPAVCEffectorCam@@XZ
_TEXT	SEGMENT
?back@?$list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@stlp_std@@QAEAAPAVCEffectorCam@@XZ PROC ; stlp_std::list<CEffectorCam *,xalloc<CEffectorCam *> >::back, COMDAT
; _this$ = eax

; 168  :   reference back()              { return *(--end()); }

	mov	eax, DWORD PTR [eax+4]
	add	eax, 8
	ret	0
?back@?$list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@stlp_std@@QAEAAPAVCEffectorCam@@XZ ENDP ; stlp_std::list<CEffectorCam *,xalloc<CEffectorCam *> >::back
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?rbegin@?$list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@stlp_std@@QAE?AV?$reverse_iterator@U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@@2@XZ
_TEXT	SEGMENT
?rbegin@?$list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@stlp_std@@QAE?AV?$reverse_iterator@U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@@2@XZ PROC ; stlp_std::list<CEffectorCam *,xalloc<CEffectorCam *> >::rbegin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 156  :   reverse_iterator rbegin()             { return reverse_iterator(end()); }

	mov	DWORD PTR [eax], ecx
	ret	0
?rbegin@?$list@PAVCEffectorCam@@V?$xalloc@PAVCEffectorCam@@@@@stlp_std@@QAE?AV?$reverse_iterator@U?$_List_iterator@PAVCEffectorCam@@U?$_Nonconst_traits@PAVCEffectorCam@@@stlp_std@@@priv@stlp_std@@@2@XZ ENDP ; stlp_std::list<CEffectorCam *,xalloc<CEffectorCam *> >::rbegin
_TEXT	ENDS
PUBLIC	?ResetPP@CCameraManager@@SAXXZ			; CCameraManager::ResetPP
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\cameramanager.cpp
;	COMDAT ?ResetPP@CCameraManager@@SAXXZ
_TEXT	SEGMENT
$T378746 = -8						; size = 4
$T378745 = -4						; size = 4
?ResetPP@CCameraManager@@SAXXZ PROC			; CCameraManager::ResetPP, COMDAT

; 452  : {

	sub	esp, 8

; 453  : 	IRender_Target*		T	= ::Render->getTarget();

	mov	eax, DWORD PTR __imp_?Render@@3PAVIRender_interface@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+60]
	push	ebx
	push	esi
	push	edi
	call	eax

; 454  : 	T->set_duality_h		(pp_identity.duality.h);

	fld	DWORD PTR ?pp_identity@@3USPPInfo@@A+8
	mov	esi, eax
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+8]
	push	ecx
	mov	ecx, esi
	fstp	DWORD PTR [esp]
	call	eax

; 455  : 	T->set_duality_v		(pp_identity.duality.v);

	fld	DWORD PTR ?pp_identity@@3USPPInfo@@A+12
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+12]
	push	ecx
	mov	ecx, esi
	fstp	DWORD PTR [esp]
	call	eax

; 456  : 	T->set_blur				(pp_identity.blur);

	fld	DWORD PTR ?pp_identity@@3USPPInfo@@A
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	push	ecx
	mov	ecx, esi
	fstp	DWORD PTR [esp]
	call	eax

; 457  : 	T->set_gray				(pp_identity.gray);

	fld	DWORD PTR ?pp_identity@@3USPPInfo@@A+4
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	push	ecx
	mov	ecx, esi
	fstp	DWORD PTR [esp]
	call	eax

; 458  : 	T->set_noise			(pp_identity.noise.intensity);

	fld	DWORD PTR ?pp_identity@@3USPPInfo@@A+16
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+16]
	push	ecx
	mov	ecx, esi
	fstp	DWORD PTR [esp]
	call	eax

; 459  : 	T->set_noise_scale		(pp_identity.noise.grain);

	fld	DWORD PTR ?pp_identity@@3USPPInfo@@A+20
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+20]
	push	ecx
	mov	ecx, esi
	fstp	DWORD PTR [esp]
	call	eax

; 460  : 	T->set_noise_fps		(pp_identity.noise.fps);

	fld	DWORD PTR ?pp_identity@@3USPPInfo@@A+24
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+24]
	push	ecx
	mov	ecx, esi
	fstp	DWORD PTR [esp]
	call	eax

; 461  : 	T->set_color_base		(pp_identity.color_base);

	mov	ebx, DWORD PTR [esi]
	mov	edi, OFFSET ?pp_identity@@3USPPInfo@@A+28
	call	??BSColor@SPPInfo@@QAEIXZ		; SPPInfo::SColor::operator unsigned int
	mov	edx, DWORD PTR [ebx+28]
	push	eax
	mov	ecx, esi
	call	edx

; 462  : 	T->set_color_gray		(pp_identity.color_gray);

	mov	ebx, DWORD PTR [esi]
	mov	edi, OFFSET ?pp_identity@@3USPPInfo@@A+40
	call	??BSColor@SPPInfo@@QAEIXZ		; SPPInfo::SColor::operator unsigned int
	push	eax
	mov	eax, DWORD PTR [ebx+32]
	mov	ecx, esi
	call	eax

; 463  : 	T->set_color_add		(pp_identity.color_add);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+36]
	push	OFFSET ?pp_identity@@3USPPInfo@@A+52
	mov	ecx, esi
	call	eax

; 464  : 	T->set_cm_imfluence		(0.0f);

	fldz
	mov	edx, DWORD PTR [esi]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR [edx+48]
	mov	ecx, esi
	call	eax

; 465  : 	T->set_cm_interpolate	(1.0f);

	fld1
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+52]
	push	ecx
	mov	ecx, esi
	fstp	DWORD PTR [esp]
	call	eax

; 466  : 	T->set_cm_textures		("", "");

	mov	ecx, DWORD PTR __imp_?g_pStringContainer@@3PAVstr_container@@A
	mov	ecx, DWORD PTR [ecx]
	mov	edi, DWORD PTR __imp_?dock@str_container@@QAEPAUstr_value@@PBD@Z
	xor	ebx, ebx
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	DWORD PTR $T378745[esp+24], ebx
	call	edi
	cmp	eax, ebx
	je	SHORT $LN7@ResetPP
	add	DWORD PTR [eax], 1
$LN7@ResetPP:
	mov	ecx, DWORD PTR $T378745[esp+20]
	cmp	ecx, ebx
	je	SHORT $LN10@ResetPP
	add	DWORD PTR [ecx], -1
$LN10@ResetPP:
	mov	edx, DWORD PTR __imp_?g_pStringContainer@@3PAVstr_container@@A
	mov	DWORD PTR $T378745[esp+20], eax
	mov	DWORD PTR $T378746[esp+20], ebx
	mov	ecx, DWORD PTR [edx]
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	call	edi
	cmp	eax, ebx
	je	SHORT $LN16@ResetPP
	add	DWORD PTR [eax], 1
$LN16@ResetPP:
	mov	ecx, DWORD PTR $T378746[esp+20]
	cmp	ecx, ebx
	je	SHORT $LN19@ResetPP
	add	DWORD PTR [ecx], -1
$LN19@ResetPP:
	mov	DWORD PTR $T378746[esp+20], eax
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+56]
	lea	ecx, DWORD PTR $T378745[esp+20]
	push	ecx
	lea	edx, DWORD PTR $T378746[esp+24]
	push	edx
	mov	ecx, esi
	call	eax
	mov	eax, DWORD PTR $T378746[esp+20]
	cmp	eax, ebx
	je	SHORT $LN25@ResetPP
	add	DWORD PTR [eax], -1
	mov	ecx, DWORD PTR $T378746[esp+20]
	cmp	DWORD PTR [ecx], ebx
	jne	SHORT $LN25@ResetPP
	mov	DWORD PTR $T378746[esp+20], ebx
$LN25@ResetPP:
	mov	eax, DWORD PTR $T378745[esp+20]
	pop	edi
	pop	esi
	cmp	eax, ebx
	pop	ebx
	je	SHORT $LN31@ResetPP
	add	DWORD PTR [eax], -1
$LN31@ResetPP:

; 467  : }

	add	esp, 8
	ret	0
?ResetPP@CCameraManager@@SAXXZ ENDP			; CCameraManager::ResetPP
_TEXT	ENDS
PUBLIC	?ApplyDevice@CCameraManager@@QAEXM@Z		; CCameraManager::ApplyDevice
; Function compile flags: /Ogtpy
;	COMDAT ?ApplyDevice@CCameraManager@@QAEXM@Z
_TEXT	SEGMENT
__viewport_near$ = 8					; size = 4
?ApplyDevice@CCameraManager@@QAEXM@Z PROC		; CCameraManager::ApplyDevice, COMDAT
; _this$ = ecx

; 409  : {

	push	ebx
	push	ebp
	push	esi
	mov	ebp, ecx
	push	edi

; 410  : 	// Device params
; 411  : 	Device.mView.build_camera_dir(m_cam_info.p, m_cam_info.d, m_cam_info.n);

	lea	eax, DWORD PTR [ebp+28]
	lea	edi, DWORD PTR [ebp+16]
	lea	ebx, DWORD PTR [ebp+4]
	mov	esi, OFFSET ?Device@@3VCRenderDevice@@A+96
	call	?build_camera_dir@?$_matrix@M@@QAEAAU1@ABU?$_vector3@M@@00@Z ; _matrix<float>::build_camera_dir

; 412  : 
; 413  : 	Device.vCameraPosition.set	( m_cam_info.p );

	movss	xmm0, DWORD PTR [ebx]
	movss	DWORD PTR ?Device@@3VCRenderDevice@@A+48, xmm0
	movss	xmm0, DWORD PTR [ebx+4]
	movss	DWORD PTR ?Device@@3VCRenderDevice@@A+52, xmm0
	movss	xmm0, DWORD PTR [ebx+8]
	movss	DWORD PTR ?Device@@3VCRenderDevice@@A+56, xmm0

; 414  : 	Device.vCameraDirection.set	( m_cam_info.d );

	movss	xmm0, DWORD PTR [edi]
	movss	DWORD PTR ?Device@@3VCRenderDevice@@A+60, xmm0
	movss	xmm0, DWORD PTR [edi+4]
	movss	DWORD PTR ?Device@@3VCRenderDevice@@A+64, xmm0
	movss	xmm0, DWORD PTR [edi+8]
	movss	DWORD PTR ?Device@@3VCRenderDevice@@A+68, xmm0

; 415  : 	Device.vCameraTop.set		( m_cam_info.n );

	movss	xmm0, DWORD PTR [ebp+28]
	movss	DWORD PTR ?Device@@3VCRenderDevice@@A+72, xmm0
	movss	xmm0, DWORD PTR [ebp+32]
	movss	DWORD PTR ?Device@@3VCRenderDevice@@A+76, xmm0
	movss	xmm0, DWORD PTR [ebp+36]
	movss	DWORD PTR ?Device@@3VCRenderDevice@@A+80, xmm0

; 416  : 	Device.vCameraRight.set		( m_cam_info.r );

	movss	xmm0, DWORD PTR [ebp+40]
	movss	DWORD PTR ?Device@@3VCRenderDevice@@A+84, xmm0
	movss	xmm0, DWORD PTR [ebp+44]
	movss	DWORD PTR ?Device@@3VCRenderDevice@@A+88, xmm0
	movss	xmm0, DWORD PTR [ebp+48]
	movss	DWORD PTR ?Device@@3VCRenderDevice@@A+92, xmm0

; 417  : 
; 418  : 	// projection
; 419  : 	Device.fFOV					= m_cam_info.fFov;

	movss	xmm0, DWORD PTR [ebp+52]
	movss	DWORD PTR ?Device@@3VCRenderDevice@@A+492, xmm0

; 420  : 	Device.fASPECT				= m_cam_info.fAspect;

	movss	xmm0, DWORD PTR [ebp+60]
	movss	DWORD PTR ?Device@@3VCRenderDevice@@A+496, xmm0

; 421  : 	Device.mProject.build_projection(deg2rad(m_cam_info.fFov), m_cam_info.fAspect, _viewport_near, m_cam_info.fFar);

	fld	DWORD PTR [ebp+52]
	fmul	DWORD PTR __real@3c8efa35
	movss	xmm0, DWORD PTR [ebp+56]
	movss	xmm2, DWORD PTR __viewport_near$[esp+12]

; 422  : 
; 423  : 	if( g_pGamePersistent && g_pGamePersistent->m_pMainMenu->IsActive() )

	mov	eax, DWORD PTR ?g_pGamePersistent@@3PAVIGame_Persistent@@A ; g_pGamePersistent
	test	eax, eax
	fmul	DWORD PTR __real@3f000000
	movss	xmm3, DWORD PTR __real@3f800000
	movaps	xmm1, xmm0
	fptan
	subss	xmm1, xmm2
	divss	xmm0, xmm1
	movaps	xmm1, xmm0
	xorps	xmm0, xmm0
	fstp	ST(0)
	fld1
	fdivrp	ST(1), ST(0)
	fld	DWORD PTR [ebp+60]
	fmul	ST(0), ST(1)
	movss	DWORD PTR ?Device@@3VCRenderDevice@@A+200, xmm1
	mulss	xmm1, xmm2
	movss	xmm2, DWORD PTR __real@80000000
	subss	xmm2, xmm1
	fstp	DWORD PTR ?Device@@3VCRenderDevice@@A+160
	movss	DWORD PTR ?Device@@3VCRenderDevice@@A+164, xmm0
	movss	DWORD PTR ?Device@@3VCRenderDevice@@A+168, xmm0
	fstp	DWORD PTR ?Device@@3VCRenderDevice@@A+180
	movss	DWORD PTR ?Device@@3VCRenderDevice@@A+172, xmm0
	movss	DWORD PTR ?Device@@3VCRenderDevice@@A+176, xmm0
	movss	DWORD PTR ?Device@@3VCRenderDevice@@A+184, xmm0
	movss	DWORD PTR ?Device@@3VCRenderDevice@@A+188, xmm0
	movss	DWORD PTR ?Device@@3VCRenderDevice@@A+192, xmm0
	movss	DWORD PTR ?Device@@3VCRenderDevice@@A+196, xmm0
	movss	DWORD PTR ?Device@@3VCRenderDevice@@A+204, xmm3
	movss	DWORD PTR ?Device@@3VCRenderDevice@@A+208, xmm0
	movss	DWORD PTR ?Device@@3VCRenderDevice@@A+212, xmm0
	movss	DWORD PTR ?Device@@3VCRenderDevice@@A+216, xmm2
	movss	DWORD PTR ?Device@@3VCRenderDevice@@A+220, xmm0
	je	SHORT $LN76@ApplyDevic
	mov	eax, DWORD PTR [eax+1132]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+8]
	call	eax
	test	al, al
	je	SHORT $LN76@ApplyDevic

; 424  : 		ResetPP					();

	call	?ResetPP@CCameraManager@@SAXXZ		; CCameraManager::ResetPP
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 448  : 	}
; 449  : }

	ret	4

; 425  : 	else
; 426  : 	{
; 427  : 		pp_affected.validate		("apply device");

$LN76@ApplyDevic:

; 428  : 		// postprocess
; 429  : 		IRender_Target*		T		= ::Render->getTarget();

	mov	ecx, DWORD PTR __imp_?Render@@3PAVIRender_interface@@A
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+60]
	call	eax

; 430  : 		T->set_duality_h			(pp_affected.duality.h);

	fld	DWORD PTR [ebp+108]
	mov	esi, eax
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+8]
	push	ecx
	mov	ecx, esi
	fstp	DWORD PTR [esp]
	call	eax

; 431  : 		T->set_duality_v			(pp_affected.duality.v);

	fld	DWORD PTR [ebp+112]
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+12]
	push	ecx
	mov	ecx, esi
	fstp	DWORD PTR [esp]
	call	eax

; 432  : 		T->set_blur					(pp_affected.blur);

	fld	DWORD PTR [ebp+100]
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	push	ecx
	mov	ecx, esi
	fstp	DWORD PTR [esp]
	call	eax

; 433  : 		T->set_gray					(pp_affected.gray);

	fld	DWORD PTR [ebp+104]
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	push	ecx
	mov	ecx, esi
	fstp	DWORD PTR [esp]
	call	eax

; 434  : 		T->set_noise				(pp_affected.noise.intensity);

	fld	DWORD PTR [ebp+116]
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+16]
	push	ecx
	mov	ecx, esi
	fstp	DWORD PTR [esp]
	call	eax

; 435  : 
; 436  : 		clamp						(pp_affected.noise.grain,EPS_L,1000.0f);

	movss	xmm0, DWORD PTR [ebp+120]
	movss	xmm1, DWORD PTR _EPS_L
	comiss	xmm1, xmm0
	ja	SHORT $LN86@ApplyDevic
	movss	xmm1, DWORD PTR _fuzzy_update_novis
	comiss	xmm0, xmm1
	jbe	SHORT $LN79@ApplyDevic
$LN86@ApplyDevic:
	movss	DWORD PTR [ebp+120], xmm1
$LN79@ApplyDevic:

; 437  : 
; 438  : 		T->set_noise_scale			(pp_affected.noise.grain);

	mov	edx, DWORD PTR [esi]
	fld	DWORD PTR [ebp+120]
	mov	eax, DWORD PTR [edx+20]
	push	ecx
	mov	ecx, esi
	fstp	DWORD PTR [esp]
	call	eax

; 439  : 
; 440  : 		T->set_noise_fps			(pp_affected.noise.fps);

	fld	DWORD PTR [ebp+124]
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+24]
	push	ecx
	mov	ecx, esi
	fstp	DWORD PTR [esp]
	call	eax

; 441  : 		T->set_color_base			(pp_affected.color_base);

	mov	ebx, DWORD PTR [esi]
	lea	edi, DWORD PTR [ebp+128]
	call	??BSColor@SPPInfo@@QAEIXZ		; SPPInfo::SColor::operator unsigned int
	mov	edx, DWORD PTR [ebx+28]
	push	eax
	mov	ecx, esi
	call	edx

; 442  : 		T->set_color_gray			(pp_affected.color_gray);

	mov	ebx, DWORD PTR [esi]
	lea	edi, DWORD PTR [ebp+140]
	call	??BSColor@SPPInfo@@QAEIXZ		; SPPInfo::SColor::operator unsigned int
	push	eax
	mov	eax, DWORD PTR [ebx+32]
	mov	ecx, esi
	call	eax

; 443  : 		T->set_color_add			(pp_affected.color_add);

	mov	edx, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+36]
	lea	eax, DWORD PTR [ebp+152]
	push	eax
	mov	ecx, esi
	call	edx

; 444  : 
; 445  : 		T->set_cm_imfluence			(pp_affected.cm_influence);

	fld	DWORD PTR [ebp+164]
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+48]
	push	ecx
	mov	ecx, esi
	fstp	DWORD PTR [esp]
	call	edx

; 446  : 		T->set_cm_interpolate		(pp_affected.cm_interpolate);

	fld	DWORD PTR [ebp+168]
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+52]
	push	ecx
	mov	ecx, esi
	fstp	DWORD PTR [esp]
	call	edx

; 447  : 		T->set_cm_textures			(pp_affected.cm_tex1, pp_affected.cm_tex2);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+56]
	lea	ecx, DWORD PTR [ebp+176]
	push	ecx
	add	ebp, 172				; 000000acH
	push	ebp
	mov	ecx, esi
	call	edx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 448  : 	}
; 449  : }

	ret	4
?ApplyDevice@CCameraManager@@QAEXM@Z ENDP		; CCameraManager::ApplyDevice
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?UpdateCamEffectors@CCameraManager@@MAEXXZ
_TEXT	SEGMENT
tv363 = -16						; size = 4
_mag$379282 = -16					; size = 4
tv367 = -12						; size = 4
tv351 = -12						; size = 4
tv371 = -8						; size = 4
tv347 = -8						; size = 4
tv343 = -4						; size = 4
_mag$379296 = -4					; size = 4
?UpdateCamEffectors@CCameraManager@@MAEXXZ PROC		; CCameraManager::UpdateCamEffectors, COMDAT
; _this$ = ecx

; 349  : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	mov	esi, ecx

; 350  : 	if (m_EffectorsCam.empty()) 	return;

	lea	ebx, DWORD PTR [esi+68]
	cmp	DWORD PTR [ebx], ebx
	je	$LN111@UpdateCamE
	push	edi

; 351  : 	EffectorCamVec::reverse_iterator rit	= m_EffectorsCam.rbegin();

	mov	edi, ebx

; 352  : 	for(; rit!=m_EffectorsCam.rend(); ++rit)

	cmp	edi, DWORD PTR [ebx]
	sete	al
	test	al, al
	jne	SHORT $LN1@UpdateCamE
	npad	2
$LL35@UpdateCamE:

; 353  : 		ProcessCameraEffector(*rit);

	mov	ecx, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+8]
	push	edx
	mov	ecx, esi
	call	eax
	mov	edi, DWORD PTR [edi+4]
	cmp	edi, DWORD PTR [ebx]
	sete	al
	test	al, al
	je	SHORT $LL35@UpdateCamE
$LN1@UpdateCamE:

; 354  : 
; 355  : 	m_cam_info.d.normalize			();

	movss	xmm2, DWORD PTR [esi+16]
	movss	xmm1, DWORD PTR [esi+20]
	movss	xmm0, DWORD PTR [esi+24]
	movaps	xmm3, xmm2
	mulss	xmm3, xmm2
	movss	DWORD PTR tv351[esp+28], xmm2
	movaps	xmm2, xmm1
	mulss	xmm2, xmm1
	movss	DWORD PTR tv347[esp+28], xmm1
	movaps	xmm1, xmm0
	mulss	xmm1, xmm0
	movss	DWORD PTR tv343[esp+28], xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	addss	xmm3, xmm2
	addss	xmm3, xmm1
	push	ecx
	divss	xmm0, xmm3
	movss	DWORD PTR [esp], xmm0
	call	_sqrtf
	fstp	DWORD PTR _mag$379282[esp+32]
	movss	xmm1, DWORD PTR _mag$379282[esp+32]
	movss	xmm0, DWORD PTR tv351[esp+32]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+16], xmm0
	movss	xmm0, DWORD PTR tv347[esp+32]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+20], xmm0
	movss	xmm0, DWORD PTR tv343[esp+32]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+24], xmm0

; 356  : 	m_cam_info.n.normalize			();

	movss	xmm2, DWORD PTR [esi+28]
	movss	xmm1, DWORD PTR [esi+32]
	movss	xmm0, DWORD PTR [esi+36]
	movaps	xmm3, xmm2
	mulss	xmm3, xmm2
	movss	DWORD PTR tv371[esp+32], xmm2
	movaps	xmm2, xmm1
	mulss	xmm2, xmm1
	movss	DWORD PTR tv367[esp+32], xmm1
	movaps	xmm1, xmm0
	mulss	xmm1, xmm0
	movss	DWORD PTR tv363[esp+32], xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	addss	xmm3, xmm2
	addss	xmm3, xmm1
	divss	xmm0, xmm3
	movss	DWORD PTR [esp], xmm0
	call	_sqrtf
	fstp	DWORD PTR _mag$379296[esp+32]
	movss	xmm1, DWORD PTR _mag$379296[esp+32]
	movss	xmm0, DWORD PTR tv371[esp+32]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+28], xmm0
	movss	xmm0, DWORD PTR tv367[esp+32]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+32], xmm0
	movss	xmm0, DWORD PTR tv363[esp+32]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+36], xmm0

; 357  : 	m_cam_info.r.crossproduct		(m_cam_info.n,m_cam_info.d);

	movss	xmm0, DWORD PTR [esi+24]
	mulss	xmm0, DWORD PTR [esi+32]
	movss	xmm1, DWORD PTR [esi+20]
	mulss	xmm1, DWORD PTR [esi+36]
	subss	xmm0, xmm1
	movss	DWORD PTR [esi+40], xmm0
	movss	xmm0, DWORD PTR [esi+16]
	mulss	xmm0, DWORD PTR [esi+36]
	movss	xmm1, DWORD PTR [esi+28]
	mulss	xmm1, DWORD PTR [esi+24]
	subss	xmm0, xmm1
	movss	DWORD PTR [esi+44], xmm0
	movss	xmm0, DWORD PTR [esi+28]
	mulss	xmm0, DWORD PTR [esi+20]
	movss	xmm1, DWORD PTR [esi+16]
	mulss	xmm1, DWORD PTR [esi+32]
	subss	xmm0, xmm1
	movss	DWORD PTR [esi+48], xmm0

; 358  : 	m_cam_info.n.crossproduct		(m_cam_info.d,m_cam_info.r);

	movss	xmm0, DWORD PTR [esi+20]
	mulss	xmm0, DWORD PTR [esi+48]
	movss	xmm1, DWORD PTR [esi+44]
	add	esp, 4
	mulss	xmm1, DWORD PTR [esi+24]
	subss	xmm0, xmm1
	movss	DWORD PTR [esi+28], xmm0
	movss	xmm0, DWORD PTR [esi+40]
	mulss	xmm0, DWORD PTR [esi+24]
	movss	xmm1, DWORD PTR [esi+48]
	mulss	xmm1, DWORD PTR [esi+16]
	subss	xmm0, xmm1
	movss	DWORD PTR [esi+32], xmm0
	movss	xmm0, DWORD PTR [esi+44]
	movss	xmm1, DWORD PTR [esi+40]
	mulss	xmm0, DWORD PTR [esi+16]
	mulss	xmm1, DWORD PTR [esi+20]
	subss	xmm0, xmm1
	movss	DWORD PTR [esi+36], xmm0
	pop	edi
$LN111@UpdateCamE:
	pop	esi
	pop	ebx

; 359  : }

	add	esp, 16					; 00000010H
	ret	0
?UpdateCamEffectors@CCameraManager@@MAEXXZ ENDP		; CCameraManager::UpdateCamEffectors
_TEXT	ENDS
PUBLIC	?RequestCamEffectorId@CCameraManager@@QAE?AW4ECamEffectorType@@XZ ; CCameraManager::RequestCamEffectorId
; Function compile flags: /Ogtpy
;	COMDAT ?RequestCamEffectorId@CCameraManager@@QAE?AW4ECamEffectorType@@XZ
_TEXT	SEGMENT
?RequestCamEffectorId@CCameraManager@@QAE?AW4ECamEffectorType@@XZ PROC ; CCameraManager::RequestCamEffectorId, COMDAT
; _this$ = ecx

; 231  : {

	push	esi
	lea	esi, DWORD PTR [ecx+68]
	push	edi
	mov	edi, DWORD PTR [esi]

; 232  : 	for ( ECamEffectorType	index	=	(ECamEffectorType)effCustomEffectorStartID;

	mov	eax, 10000				; 00002710H
	npad	4
$LL3@RequestCam:

; 233  : 							GetCamEffector(index);
; 234  : 							index	=	(ECamEffectorType)(index+1) ) { ; }

	mov	ecx, edi
	cmp	ecx, esi
	setne	dl
	test	dl, dl
	je	SHORT $LN58@RequestCam
	npad	5
$LL30@RequestCam:
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+12], eax
	je	SHORT $LN56@RequestCam
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, esi
	setne	dl
	test	dl, dl
	jne	SHORT $LL30@RequestCam
$LN58@RequestCam:
	pop	edi
	pop	esi

; 235  : 	return index;
; 236  : }

	ret	0
$LN56@RequestCam:

; 233  : 							GetCamEffector(index);
; 234  : 							index	=	(ECamEffectorType)(index+1) ) { ; }

	test	edx, edx
	je	SHORT $LN58@RequestCam
	add	eax, 1
	jmp	SHORT $LL3@RequestCam
?RequestCamEffectorId@CCameraManager@@QAE?AW4ECamEffectorType@@XZ ENDP ; CCameraManager::RequestCamEffectorId
_TEXT	ENDS
PUBLIC	?UpdateDeffered@CCameraManager@@IAEXXZ		; CCameraManager::UpdateDeffered
; Function compile flags: /Ogtpy
;	COMDAT ?UpdateDeffered@CCameraManager@@IAEXXZ
_TEXT	SEGMENT
_it$ = -8						; size = 4
_this$ = -4						; size = 4
?UpdateDeffered@CCameraManager@@IAEXXZ PROC		; CCameraManager::UpdateDeffered, COMDAT
; _this$ = ecx

; 196  : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 197  : 	EffectorCamIt it		= m_EffectorsCam_added_deffered.begin();

	mov	ebx, DWORD PTR [edi+76]
	lea	esi, DWORD PTR [edi+76]

; 198  : 	EffectorCamIt it_e		= m_EffectorsCam_added_deffered.end();
; 199  : 	for (; it!=it_e; ++it)

	cmp	ebx, esi
	setne	al
	test	al, al
	mov	DWORD PTR _this$[esp+24], edi
	mov	DWORD PTR _it$[esp+24], ebx
	je	$LN3@UpdateDeff
	lea	ebp, DWORD PTR [edi+68]
	jmp	SHORT $LN34@UpdateDeff
	npad	7
$LL137@UpdateDeff:
	mov	ebx, DWORD PTR _it$[esp+24]
$LN34@UpdateDeff:

; 200  : 	{
; 201  : 		RemoveCamEffector			( (*it)->eType );

	mov	eax, DWORD PTR [ebx+8]
	mov	ecx, DWORD PTR [eax+12]
	add	ebx, 8
	push	ecx
	mov	ecx, edi
	call	?RemoveCamEffector@CCameraManager@@QAEXW4ECamEffectorType@@@Z ; CCameraManager::RemoveCamEffector

; 202  : 		
; 203  : 		if((*it)->AbsolutePositioning())

	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+20]
	call	eax
	test	al, al

; 204  : 			m_EffectorsCam.push_front(*it);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	12					; 0000000cH
	je	SHORT $LN2@UpdateDeff
	mov	edi, DWORD PTR [ebp]
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	mov	esi, eax
	lea	ecx, DWORD PTR [esi+8]
	push	ebx
	push	ecx
	call	??$_Copy_Construct@PAX@stlp_std@@YAXPAPAXABQAX@Z ; stlp_std::_Copy_Construct<void *>
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [esi], edi
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [edi+4], esi

; 205  : 		else

	mov	edi, DWORD PTR _this$[esp+32]
	jmp	SHORT $LN138@UpdateDeff
$LN2@UpdateDeff:

; 206  : 			m_EffectorsCam.push_back	(*it);

	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	mov	esi, eax
	lea	edx, DWORD PTR [esi+8]
	push	ebx
	push	edx
	call	??$_Copy_Construct@PAX@stlp_std@@YAXPAPAXABQAX@Z ; stlp_std::_Copy_Construct<void *>
	mov	eax, DWORD PTR [ebp+4]
	mov	DWORD PTR [esi], ebp
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [ebp+4], esi
$LN138@UpdateDeff:
	mov	eax, DWORD PTR _it$[esp+32]
	mov	eax, DWORD PTR [eax]
	add	esp, 8
	lea	esi, DWORD PTR [edi+76]
	cmp	eax, esi
	mov	DWORD PTR _it$[esp+24], eax
	setne	al
	test	al, al
	jne	$LL137@UpdateDeff
$LN3@UpdateDeff:

; 207  : 	}
; 208  : 
; 209  : 	m_EffectorsCam_added_deffered.clear	();

	mov	edi, DWORD PTR [esi]
	cmp	edi, esi
	je	SHORT $LN136@UpdateDeff
	mov	ebp, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	npad	6
$LL121@UpdateDeff:
	mov	ebx, edi
	mov	edi, DWORD PTR [edi]
	lea	ecx, DWORD PTR [ebx+8]
	push	ecx
	call	??$_Destroy@PAX@stlp_std@@YAXPAPAX@Z	; stlp_std::_Destroy<void *>
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	add	esp, 4
	push	ebx
	call	ebp
	cmp	edi, esi
	jne	SHORT $LL121@UpdateDeff
$LN136@UpdateDeff:

; 210  : }

	pop	edi
	mov	DWORD PTR [esi+4], esi
	mov	DWORD PTR [esi], esi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	0
?UpdateDeffered@CCameraManager@@IAEXXZ ENDP		; CCameraManager::UpdateDeffered
_TEXT	ENDS
PUBLIC	?AddCamEffector@CCameraManager@@QAEPAVCEffectorCam@@PAV2@@Z ; CCameraManager::AddCamEffector
; Function compile flags: /Ogtpy
;	COMDAT ?AddCamEffector@CCameraManager@@QAEPAVCEffectorCam@@PAV2@@Z
_TEXT	SEGMENT
_ef$ = 8						; size = 4
?AddCamEffector@CCameraManager@@QAEPAVCEffectorCam@@PAV2@@Z PROC ; CCameraManager::AddCamEffector, COMDAT
; _this$ = ecx

; 190  : {

	push	ebx
	push	esi
	push	edi
	mov	ebx, ecx

; 191  : 	m_EffectorsCam_added_deffered.push_back(ef);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	12					; 0000000cH
	lea	edi, DWORD PTR [ebx+76]
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	mov	esi, eax
	lea	eax, DWORD PTR _ef$[esp+8]
	push	eax
	lea	ecx, DWORD PTR [esi+8]
	push	ecx
	call	??$_Copy_Construct@PAX@stlp_std@@YAXPAPAXABQAX@Z ; stlp_std::_Copy_Construct<void *>
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [esi], edi
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [eax], esi
	add	esp, 8
	mov	DWORD PTR [edi+4], esi

; 192  : 	return m_EffectorsCam_added_deffered.back();

	mov	edx, DWORD PTR [ebx+80]
	mov	eax, DWORD PTR [edx+8]

; 193  : }

	pop	edi
	pop	esi
	pop	ebx
	ret	4
?AddCamEffector@CCameraManager@@QAEPAVCEffectorCam@@PAV2@@Z ENDP ; CCameraManager::AddCamEffector
_TEXT	ENDS
PUBLIC	??1CCameraManager@@UAE@XZ			; CCameraManager::~CCameraManager
; Function compile flags: /Ogtpy
;	COMDAT ??1CCameraManager@@UAE@XZ
_TEXT	SEGMENT
tv385 = -4						; size = 4
??1CCameraManager@@UAE@XZ PROC				; CCameraManager::~CCameraManager, COMDAT
; _this$ = ecx

; 172  : {

	push	ecx
	push	ebx
	push	ebp

; 173  : 	for (EffectorCamIt it=m_EffectorsCam.begin(); it!=m_EffectorsCam.end(); it++ )

	mov	ebp, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi+68]
	lea	ebx, DWORD PTR [edi+68]
	cmp	esi, ebx
	setne	al
	test	al, al
	mov	DWORD PTR [edi], OFFSET ??_7CCameraManager@@6B@
	mov	DWORD PTR tv385[esp+20], ebx
	je	SHORT $LN4@CCameraMan
$LL27@CCameraMan:

; 174  : 		xr_delete(*it);

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN5@CCameraMan
	push	eax
	call	___RTCastToVoid
	mov	ecx, DWORD PTR [esi+8]
	mov	ebx, eax
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	add	esp, 4
	push	0
	call	edx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	ebx
	call	ebp
	mov	ebx, DWORD PTR tv385[esp+20]
	mov	DWORD PTR [esi+8], 0
$LN5@CCameraMan:
	mov	esi, DWORD PTR [esi]
	cmp	esi, ebx
	setne	al
	test	al, al
	jne	SHORT $LL27@CCameraMan
$LN4@CCameraMan:

; 175  : 	for (EffectorPPIt it=m_EffectorsPP.begin(); it!=m_EffectorsPP.end(); it++ )

	mov	eax, DWORD PTR [edi+84]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	mov	esi, eax
	mov	eax, DWORD PTR [edi+88]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 8
	cmp	esi, eax
	je	SHORT $LN1@CCameraMan
	npad	3
$LL3@CCameraMan:

; 176  : 		xr_delete(*it);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@CCameraMan
	push	eax
	call	___RTCastToVoid
	mov	ecx, DWORD PTR [esi]
	mov	ebx, eax
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	add	esp, 4
	push	0
	call	edx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	ebx
	call	ebp
	mov	ebx, DWORD PTR tv385[esp+20]
	mov	DWORD PTR [esi], 0
$LN2@CCameraMan:
	mov	eax, DWORD PTR [edi+88]
	push	eax
	add	esi, 4
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	add	esp, 4
	cmp	esi, eax
	jne	SHORT $LL3@CCameraMan
$LN1@CCameraMan:

; 177  : }

	mov	eax, DWORD PTR [edi+176]
	xor	ecx, ecx
	cmp	eax, ecx
	je	SHORT $LN79@CCameraMan
	add	DWORD PTR [eax], -1
	mov	eax, DWORD PTR [edi+176]
	cmp	DWORD PTR [eax], ecx
	jne	SHORT $LN79@CCameraMan
	mov	DWORD PTR [edi+176], ecx
$LN79@CCameraMan:
	mov	eax, DWORD PTR [edi+172]
	cmp	eax, ecx
	je	SHORT $LN85@CCameraMan
	add	DWORD PTR [eax], -1
	mov	edx, DWORD PTR [edi+172]
	cmp	DWORD PTR [edx], ecx
	jne	SHORT $LN85@CCameraMan
	mov	DWORD PTR [edi+172], ecx
$LN85@CCameraMan:
	mov	eax, DWORD PTR [edi+84]
	cmp	eax, ecx
	je	SHORT $LN126@CCameraMan
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebp
$LN126@CCameraMan:
	mov	esi, DWORD PTR [edi+76]
	add	edi, 76					; 0000004cH
	cmp	esi, edi
	je	SHORT $LN137@CCameraMan
$LL138@CCameraMan:
	mov	ebx, esi
	mov	esi, DWORD PTR [esi]
	lea	eax, DWORD PTR [ebx+8]
	push	eax
	call	??$_Destroy@PAX@stlp_std@@YAXPAPAX@Z	; stlp_std::_Destroy<void *>
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	add	esp, 4
	push	ebx
	call	ebp
	cmp	esi, edi
	jne	SHORT $LL138@CCameraMan
	mov	ebx, DWORD PTR tv385[esp+20]
$LN137@CCameraMan:
	mov	DWORD PTR [edi], edi
	mov	DWORD PTR [edi+4], edi
	mov	esi, DWORD PTR [ebx]
	cmp	esi, ebx
	je	SHORT $LN177@CCameraMan
$LL159@CCameraMan:
	mov	edi, esi
	mov	esi, DWORD PTR [esi]
	lea	ecx, DWORD PTR [edi+8]
	push	ecx
	call	??$_Destroy@PAX@stlp_std@@YAXPAPAX@Z	; stlp_std::_Destroy<void *>
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	add	esp, 4
	push	edi
	call	ebp
	cmp	esi, ebx
	jne	SHORT $LL159@CCameraMan
$LN177@CCameraMan:
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [ebx+4], ebx
	mov	DWORD PTR [ebx], ebx
	pop	ebx
	pop	ecx
	ret	0
??1CCameraManager@@UAE@XZ ENDP				; CCameraManager::~CCameraManager
_TEXT	ENDS
PUBLIC	?lerp@SPPInfo@@QAEAAU1@ABU1@0M@Z		; SPPInfo::lerp
; Function compile flags: /Ogtpy
;	COMDAT ?lerp@SPPInfo@@QAEAAU1@ABU1@0M@Z
_TEXT	SEGMENT
_def$ = 8						; size = 4
_to$ = 12						; size = 4
_factor$ = 16						; size = 4
?lerp@SPPInfo@@QAEAAU1@ABU1@0M@Z PROC			; SPPInfo::lerp, COMDAT
; _this$ = ecx

; 103  : 	VERIFY(_valid(factor));
; 104  : 	SPPInfo& pp = *this;
; 105  : 	clamp(factor, 0.0f, 1.0f);

	xorps	xmm1, xmm1
	movss	xmm0, DWORD PTR _factor$[esp-4]
	comiss	xmm1, xmm0
	mov	eax, ecx
	ja	SHORT $LN35@lerp@2
	movss	xmm1, DWORD PTR __real@3f800000
	comiss	xmm0, xmm1
	jbe	SHORT $LN6@lerp@2
$LN35@lerp@2:
	movaps	xmm0, xmm1
$LN6@lerp@2:

; 106  : 
; 107  : 	pp.duality.h		+= def.duality.h		+ (to.duality.h			- def.duality.h)		* factor; 			

	mov	ecx, DWORD PTR _to$[esp-4]
	mov	edx, DWORD PTR _def$[esp-4]
	movss	xmm1, DWORD PTR [edx+8]
	movss	xmm2, DWORD PTR [ecx+8]
	subss	xmm2, xmm1
	mulss	xmm2, xmm0
	addss	xmm2, DWORD PTR [eax+8]
	addss	xmm2, xmm1
	movss	DWORD PTR [eax+8], xmm2

; 108  : 	pp.duality.v		+= def.duality.v		+ (to.duality.v			- def.duality.v)		* factor;

	movss	xmm1, DWORD PTR [edx+12]
	movss	xmm2, DWORD PTR [ecx+12]
	subss	xmm2, xmm1
	mulss	xmm2, xmm0
	addss	xmm2, DWORD PTR [eax+12]
	addss	xmm2, xmm1
	movss	DWORD PTR [eax+12], xmm2

; 109  : 	pp.gray				+= def.gray				+ (to.gray				- def.gray)				* factor;

	movss	xmm1, DWORD PTR [edx+4]
	movss	xmm2, DWORD PTR [ecx+4]
	subss	xmm2, xmm1
	mulss	xmm2, xmm0
	addss	xmm2, xmm1
	addss	xmm2, DWORD PTR [eax+4]
	movss	DWORD PTR [eax+4], xmm2

; 110  : 	pp.blur				+= def.blur				+ (to.blur				- def.blur)				* factor;

	movss	xmm1, DWORD PTR [edx]
	movss	xmm2, DWORD PTR [ecx]
	subss	xmm2, xmm1
	mulss	xmm2, xmm0
	addss	xmm2, xmm1
	addss	xmm2, DWORD PTR [eax]
	movss	DWORD PTR [eax], xmm2

; 111  : 	pp.noise.intensity	= to.noise.intensity;//	+ (to.noise.intensity	- def.noise.intensity)	* factor;

	fld	DWORD PTR [ecx+16]
	fstp	DWORD PTR [eax+16]
	push	esi

; 112  : 	pp.noise.grain		= to.noise.grain;//		+ (to.noise.grain		- def.noise.grain)		* factor;

	fld	DWORD PTR [ecx+20]
	push	edi
	fstp	DWORD PTR [eax+20]

; 113  : 	pp.noise.fps		= to.noise.fps; //		+ (to.noise.fps			- def.noise.fps)		* factor;	

	fld	DWORD PTR [ecx+24]
	fstp	DWORD PTR [eax+24]

; 114  : 
; 115  : 	pp.color_base.set	(
; 116  : 		def.color_base.r	+ (to.color_base.r - def.color_base.r) * factor, 
; 117  : 		def.color_base.g	+ (to.color_base.g - def.color_base.g) * factor, 
; 118  : 		def.color_base.b	+ (to.color_base.b - def.color_base.b) * factor
; 119  : 		);

	movss	xmm2, DWORD PTR [edx+32]
	movss	xmm1, DWORD PTR [ecx+32]
	movss	xmm3, DWORD PTR [edx+36]
	movss	xmm4, DWORD PTR [ecx+28]
	subss	xmm1, xmm2
	mulss	xmm1, xmm0
	addss	xmm1, xmm2
	movss	xmm2, DWORD PTR [ecx+36]
	subss	xmm2, xmm3
	mulss	xmm2, xmm0
	addss	xmm2, xmm3
	movss	xmm3, DWORD PTR [edx+28]
	movss	DWORD PTR [eax+32], xmm1
	movss	DWORD PTR [eax+36], xmm2
	subss	xmm4, xmm3
	mulss	xmm4, xmm0
	addss	xmm4, xmm3
	movss	DWORD PTR [eax+28], xmm4

; 120  : 
; 121  : 	pp.color_gray.set	(
; 122  : 		def.color_gray.r	+ (to.color_gray.r - def.color_gray.r) * factor, 
; 123  : 		def.color_gray.g	+ (to.color_gray.g - def.color_gray.g) * factor, 
; 124  : 		def.color_gray.b	+ (to.color_gray.b - def.color_gray.b) * factor
; 125  : 		);

	movss	xmm2, DWORD PTR [edx+44]
	movss	xmm1, DWORD PTR [ecx+44]
	movss	xmm3, DWORD PTR [edx+48]
	movss	xmm4, DWORD PTR [ecx+40]
	subss	xmm1, xmm2
	mulss	xmm1, xmm0
	addss	xmm1, xmm2
	movss	xmm2, DWORD PTR [ecx+48]
	subss	xmm2, xmm3
	mulss	xmm2, xmm0
	addss	xmm2, xmm3
	movss	xmm3, DWORD PTR [edx+40]
	movss	DWORD PTR [eax+44], xmm1
	subss	xmm4, xmm3
	movss	DWORD PTR [eax+48], xmm2
	mulss	xmm4, xmm0
	addss	xmm4, xmm3
	movss	DWORD PTR [eax+40], xmm4

; 126  : 
; 127  : 	pp.color_add.set	(
; 128  : 		def.color_add.r	+ (to.color_add.r - def.color_add.r) * factor, 
; 129  : 		def.color_add.g	+ (to.color_add.g - def.color_add.g) * factor, 
; 130  : 		def.color_add.b	+ (to.color_add.b - def.color_add.b) * factor
; 131  : 		);

	movss	xmm2, DWORD PTR [edx+56]
	movss	xmm1, DWORD PTR [ecx+56]
	movss	xmm3, DWORD PTR [edx+60]
	subss	xmm1, xmm2
	mulss	xmm1, xmm0
	addss	xmm1, xmm2
	movss	xmm2, DWORD PTR [ecx+60]
	movss	xmm4, DWORD PTR [ecx+52]
	subss	xmm2, xmm3
	mulss	xmm2, xmm0
	addss	xmm2, xmm3
	movss	xmm3, DWORD PTR [edx+52]
	subss	xmm4, xmm3
	mulss	xmm4, xmm0
	addss	xmm4, xmm3
	movss	DWORD PTR [eax+52], xmm4
	movss	DWORD PTR [eax+56], xmm1
	movss	DWORD PTR [eax+60], xmm2

; 132  : 
; 133  : 	pp.cm_tex1					= to.cm_tex1;

	mov	edi, DWORD PTR [ecx+72]
	test	edi, edi
	je	SHORT $LN19@lerp@2
	add	DWORD PTR [edi], 1
$LN19@lerp@2:
	mov	esi, DWORD PTR [eax+72]
	test	esi, esi
	je	SHORT $LN22@lerp@2
	add	DWORD PTR [esi], -1
	mov	esi, DWORD PTR [eax+72]
	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN22@lerp@2
	mov	DWORD PTR [eax+72], 0
$LN22@lerp@2:
	mov	DWORD PTR [eax+72], edi

; 134  : 	pp.cm_tex2					= to.cm_tex2;

	mov	edi, DWORD PTR [ecx+76]
	test	edi, edi
	je	SHORT $LN28@lerp@2
	add	DWORD PTR [edi], 1
$LN28@lerp@2:
	mov	esi, DWORD PTR [eax+76]
	test	esi, esi
	je	SHORT $LN31@lerp@2
	add	DWORD PTR [esi], -1
	mov	esi, DWORD PTR [eax+76]
	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN31@lerp@2
	mov	DWORD PTR [eax+76], 0
$LN31@lerp@2:
	mov	DWORD PTR [eax+76], edi

; 135  : 	pp.cm_influence				+= def.cm_influence	+ (to.cm_influence - def.cm_influence) * factor;

	movss	xmm1, DWORD PTR [edx+64]
	movss	xmm2, DWORD PTR [ecx+64]
	subss	xmm2, xmm1
	mulss	xmm2, xmm0
	addss	xmm2, xmm1
	addss	xmm2, DWORD PTR [eax+64]
	movss	DWORD PTR [eax+64], xmm2

; 136  : 	pp.cm_interpolate			+= def.cm_interpolate	+ (to.cm_interpolate - def.cm_interpolate) * factor;

	movss	xmm1, DWORD PTR [edx+68]
	movss	xmm2, DWORD PTR [ecx+68]
	subss	xmm2, xmm1
	mulss	xmm2, xmm0
	addss	xmm2, DWORD PTR [eax+68]
	pop	edi
	addss	xmm2, xmm1
	movss	DWORD PTR [eax+68], xmm2
	pop	esi

; 137  : 
; 138  : 	return *this;
; 139  : }

	ret	12					; 0000000cH
?lerp@SPPInfo@@QAEAAU1@ABU1@0M@Z ENDP			; SPPInfo::lerp
_TEXT	ENDS
PUBLIC	?add@SPPInfo@@QAEAAU1@ABU1@@Z			; SPPInfo::add
; Function compile flags: /Ogtpy
;	COMDAT ?add@SPPInfo@@QAEAAU1@ABU1@@Z
_TEXT	SEGMENT
_ppi$ = 8						; size = 4
?add@SPPInfo@@QAEAAU1@ABU1@@Z PROC			; SPPInfo::add, COMDAT
; _this$ = ecx

; 26   : {

	mov	eax, ecx

; 27   : 	blur			+= ppi.blur;

	mov	ecx, DWORD PTR _ppi$[esp-4]
	movss	xmm0, DWORD PTR [ecx]
	addss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [eax], xmm0

; 28   : 	gray			+= ppi.gray;

	movss	xmm0, DWORD PTR [ecx+4]
	addss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR [eax+4], xmm0

; 29   : 	duality.h		+= ppi.duality.h; 

	movss	xmm0, DWORD PTR [ecx+8]
	addss	xmm0, DWORD PTR [eax+8]
	movss	DWORD PTR [eax+8], xmm0

; 30   : 	duality.v		+= ppi.duality.v;

	movss	xmm0, DWORD PTR [ecx+12]
	addss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR [eax+12], xmm0

; 31   : 	
; 32   : 	noise.intensity	= _max(noise.intensity, ppi.noise.intensity);

	movss	xmm0, DWORD PTR [eax+16]
	movss	xmm1, DWORD PTR [ecx+16]
	comiss	xmm0, xmm1
	ja	SHORT $LN9@add
	movaps	xmm0, xmm1
$LN9@add:
	movss	DWORD PTR [eax+16], xmm0

; 33   : 	noise.grain		= _max(noise.grain, ppi.noise.grain);

	movss	xmm0, DWORD PTR [eax+20]
	movss	xmm1, DWORD PTR [ecx+20]
	comiss	xmm0, xmm1
	ja	SHORT $LN13@add
	movaps	xmm0, xmm1
$LN13@add:
	movss	DWORD PTR [eax+20], xmm0

; 34   : 	noise.fps		= _max(noise.fps, ppi.noise.fps);

	movss	xmm0, DWORD PTR [eax+24]
	movss	xmm1, DWORD PTR [ecx+24]
	comiss	xmm0, xmm1
	ja	SHORT $LN17@add
	movaps	xmm0, xmm1
$LN17@add:
	movss	DWORD PTR [eax+24], xmm0

; 35   : 	color_base		+= ppi.color_base;

	movss	xmm0, DWORD PTR [ecx+28]
	addss	xmm0, DWORD PTR [eax+28]
	movss	DWORD PTR [eax+28], xmm0
	movss	xmm0, DWORD PTR [ecx+32]
	addss	xmm0, DWORD PTR [eax+32]
	movss	DWORD PTR [eax+32], xmm0
	movss	xmm0, DWORD PTR [ecx+36]
	addss	xmm0, DWORD PTR [eax+36]
	movss	DWORD PTR [eax+36], xmm0

; 36   : 	color_gray		+= ppi.color_gray;

	movss	xmm0, DWORD PTR [ecx+40]
	addss	xmm0, DWORD PTR [eax+40]
	movss	DWORD PTR [eax+40], xmm0
	movss	xmm0, DWORD PTR [ecx+44]
	addss	xmm0, DWORD PTR [eax+44]
	movss	DWORD PTR [eax+44], xmm0
	movss	xmm0, DWORD PTR [ecx+48]
	addss	xmm0, DWORD PTR [eax+48]
	movss	DWORD PTR [eax+48], xmm0

; 37   : 	color_add		+= ppi.color_add;

	movss	xmm0, DWORD PTR [ecx+52]
	addss	xmm0, DWORD PTR [eax+52]
	movss	DWORD PTR [eax+52], xmm0
	movss	xmm0, DWORD PTR [ecx+56]
	addss	xmm0, DWORD PTR [eax+56]
	movss	DWORD PTR [eax+56], xmm0
	movss	xmm0, DWORD PTR [ecx+60]
	addss	xmm0, DWORD PTR [eax+60]
	movss	DWORD PTR [eax+60], xmm0

; 38   : 
; 39   : 	if(ppi.cm_tex1.size())

	mov	edx, DWORD PTR [ecx+72]
	test	edx, edx
	je	$LN3@add
	cmp	DWORD PTR [edx+4], 0
	je	$LN3@add

; 40   : 	{
; 41   : 		if(cm_tex1.size())

	mov	edx, DWORD PTR [eax+72]
	test	edx, edx
	push	esi
	je	SHORT $LN2@add
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $LN2@add

; 42   : 		{
; 43   : 			cm_tex2			= ppi.cm_tex1;

	mov	esi, DWORD PTR [ecx+72]
	test	esi, esi
	je	SHORT $LN34@add
	add	DWORD PTR [esi], 1
$LN34@add:
	mov	edx, DWORD PTR [eax+76]
	test	edx, edx
	je	SHORT $LN37@add
	add	DWORD PTR [edx], -1
	mov	edx, DWORD PTR [eax+76]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN37@add
	mov	DWORD PTR [eax+76], 0
$LN37@add:
	mov	DWORD PTR [eax+76], esi

; 44   : 			cm_interpolate	= 1.0f - cm_influence/(cm_influence+ppi.cm_influence);

	movss	xmm0, DWORD PTR [eax+64]
	movss	xmm1, DWORD PTR [ecx+64]
	addss	xmm1, xmm0
	divss	xmm0, xmm1
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movss	DWORD PTR [eax+68], xmm1

; 45   : 		}else

	jmp	SHORT $LN1@add
$LN2@add:

; 46   : 		{
; 47   : 			cm_tex1			= ppi.cm_tex1;

	mov	esi, DWORD PTR [ecx+72]
	test	esi, esi
	je	SHORT $LN43@add
	add	DWORD PTR [esi], 1
$LN43@add:
	mov	edx, DWORD PTR [eax+72]
	test	edx, edx
	je	SHORT $LN46@add
	add	DWORD PTR [edx], -1
	mov	edx, DWORD PTR [eax+72]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN46@add
	mov	DWORD PTR [eax+72], 0
$LN46@add:

; 48   : 			cm_influence	= ppi.cm_influence;
; 49   : 			cm_interpolate	= 0.0f;

	xorps	xmm0, xmm0
	mov	DWORD PTR [eax+72], esi
	fld	DWORD PTR [ecx+64]
	fstp	DWORD PTR [eax+64]
	movss	DWORD PTR [eax+68], xmm0
$LN1@add:

; 50   : 		}
; 51   : 		cm_influence		= _max(cm_influence, ppi.cm_influence);

	movss	xmm0, DWORD PTR [eax+64]
	movss	xmm1, DWORD PTR [ecx+64]
	comiss	xmm0, xmm1
	pop	esi
	ja	SHORT $LN53@add
	movaps	xmm0, xmm1
$LN53@add:
	movss	DWORD PTR [eax+64], xmm0
$LN3@add:

; 52   : 	}
; 53   : 	return			*this;
; 54   : }

	ret	4
?add@SPPInfo@@QAEAAU1@ABU1@@Z ENDP			; SPPInfo::add
_TEXT	ENDS
PUBLIC	??4CEffectorPP@@QAEAAV0@ABV0@@Z			; CEffectorPP::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4CEffectorPP@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4CEffectorPP@@QAEAAV0@ABV0@@Z PROC			; CEffectorPP::operator=, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	ecx, DWORD PTR ___that$[esp-4]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	dl, BYTE PTR [ecx+16]
	mov	BYTE PTR [eax+16], dl
	fld	DWORD PTR [ecx+20]
	fstp	DWORD PTR [eax+20]
	mov	cl, BYTE PTR [ecx+24]
	mov	BYTE PTR [eax+24], cl
	ret	4
??4CEffectorPP@@QAEAAV0@ABV0@@Z ENDP			; CEffectorPP::operator=
_TEXT	ENDS
PUBLIC	??0CEffectorPP@@QAE@XZ				; CEffectorPP::CEffectorPP
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\effectorpp.h
;	COMDAT ??0CEffectorPP@@QAE@XZ
_TEXT	SEGMENT
??0CEffectorPP@@QAE@XZ PROC				; CEffectorPP::CEffectorPP, COMDAT
; _this$ = ecx

; 15   : 						CEffectorPP		():bFreeOnRemove(true),fLifeTime(0.0f),bOverlap(true){};

	xorps	xmm0, xmm0
	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	cl, 1
	mov	DWORD PTR [eax], OFFSET ??_7CEffectorPP@@6B@
	mov	BYTE PTR [eax+16], cl
	movss	DWORD PTR [eax+20], xmm0
	mov	BYTE PTR [eax+24], cl
	ret	0
??0CEffectorPP@@QAE@XZ ENDP				; CEffectorPP::CEffectorPP
_TEXT	ENDS
PUBLIC	??4CEffectorCam@@QAEAAV0@ABV0@@Z		; CEffectorCam::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4CEffectorCam@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4CEffectorCam@@QAEAAV0@ABV0@@Z PROC			; CEffectorCam::operator=, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	ecx, DWORD PTR ___that$[esp-4]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	fld	DWORD PTR [ecx+16]
	fstp	DWORD PTR [eax+16]
	mov	cl, BYTE PTR [ecx+20]
	mov	BYTE PTR [eax+20], cl
	ret	4
??4CEffectorCam@@QAEAAV0@ABV0@@Z ENDP			; CEffectorCam::operator=
_TEXT	ENDS
PUBLIC	??0CEffectorCam@@QAE@XZ				; CEffectorCam::CEffectorCam
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\effector.h
;	COMDAT ??0CEffectorCam@@QAE@XZ
_TEXT	SEGMENT
??0CEffectorCam@@QAE@XZ PROC				; CEffectorCam::CEffectorCam, COMDAT
; _this$ = ecx

; 17   : 						CEffectorCam	()									{eType=(ECamEffectorType)0; fLifeTime=0.0f; bHudAffect=true;};

	xorps	xmm0, xmm0
	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax], OFFSET ??_7CEffectorCam@@6B@
	mov	DWORD PTR [eax+12], ecx
	movss	DWORD PTR [eax+16], xmm0
	mov	BYTE PTR [eax+20], 1
	ret	0
??0CEffectorCam@@QAE@XZ ENDP				; CEffectorCam::CEffectorCam
_TEXT	ENDS
PUBLIC	??0CEffectorCam@@QAE@W4ECamEffectorType@@M@Z	; CEffectorCam::CEffectorCam
; Function compile flags: /Ogtpy
;	COMDAT ??0CEffectorCam@@QAE@W4ECamEffectorType@@M@Z
_TEXT	SEGMENT
_type$ = 8						; size = 4
_tm$ = 12						; size = 4
??0CEffectorCam@@QAE@W4ECamEffectorType@@M@Z PROC	; CEffectorCam::CEffectorCam, COMDAT
; _this$ = ecx

; 16   : 						CEffectorCam	(ECamEffectorType type, float tm)	{eType=type; fLifeTime=tm; bHudAffect=true;};

	movss	xmm0, DWORD PTR _tm$[esp-4]
	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR _type$[esp-4]
	mov	DWORD PTR [eax], OFFSET ??_7CEffectorCam@@6B@
	mov	DWORD PTR [eax+12], ecx
	movss	DWORD PTR [eax+16], xmm0
	mov	BYTE PTR [eax+20], 1
	ret	8
??0CEffectorCam@@QAE@W4ECamEffectorType@@M@Z ENDP	; CEffectorCam::CEffectorCam
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\sdk\include\stlport\stl\pointers\_vector.h
;	COMDAT ?push_back@?$vector@PAVCEffectorPP@@V?$xalloc@PAVCEffectorPP@@@@@stlp_std@@QAEXABQAVCEffectorPP@@@Z
_TEXT	SEGMENT
?push_back@?$vector@PAVCEffectorPP@@V?$xalloc@PAVCEffectorPP@@@@@stlp_std@@QAEXABQAVCEffectorPP@@@Z PROC ; stlp_std::vector<CEffectorPP *,xalloc<CEffectorPP *> >::push_back, COMDAT
; _this$ = ecx
; ___x$ = eax

; 171  :   { _M_impl.push_back(cast_traits::to_storage_type_cref(__x)); }

	push	edi
	mov	edi, ecx
	mov	ecx, DWORD PTR [edi+4]
	cmp	ecx, DWORD PTR [edi+8]
	je	SHORT $LN8@push_back@49
	push	eax
	push	ecx
	call	??$_Copy_Construct@PAX@stlp_std@@YAXPAPAXABQAX@Z ; stlp_std::_Copy_Construct<void *>
	add	esp, 8
	add	DWORD PTR [edi+4], 4
	pop	edi
	ret	0
$LN8@push_back@49:
	push	1
	push	1
	push	ecx
	call	?_M_insert_overflow@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@AAEXPAPAXABQAXABU__true_type@3@I_N@Z ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::_M_insert_overflow
	pop	edi
	ret	0
?push_back@?$vector@PAVCEffectorPP@@V?$xalloc@PAVCEffectorPP@@@@@stlp_std@@QAEXABQAVCEffectorPP@@@Z ENDP ; stlp_std::vector<CEffectorPP *,xalloc<CEffectorPP *> >::push_back
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\cameramanager.cpp
_TEXT	ENDS
;	COMDAT ?UpdatePPEffectors@CCameraManager@@MAEXXZ
_TEXT	SEGMENT
_b$129817 = -85						; size = 1
__count$ = -84						; size = 4
_l_PPInf$129823 = -80					; size = 80
?UpdatePPEffectors@CCameraManager@@MAEXXZ PROC		; CCameraManager::UpdatePPEffectors, COMDAT
; _this$ = ecx

; 362  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 88					; 00000058H
	push	ebx
	mov	ebx, ecx

; 363  : 	pp_affected.validate		("before applying pp");
; 364  : 
; 365  : 	int		_count	= 0;
; 366  : 	if(m_EffectorsPP.size()) 

	mov	eax, DWORD PTR [ebx+88]
	sub	eax, DWORD PTR [ebx+84]
	push	ebp
	test	eax, -4					; fffffffcH
	push	esi
	push	edi
	mov	DWORD PTR __count$[esp+104], 0

; 367  : 	{
; 368  : 		bool b = false;
; 369  : 		pp_affected = pp_identity;

	push	OFFSET ?pp_identity@@3USPPInfo@@A	; pp_identity
	je	$LN12@UpdatePPEf
	lea	esi, DWORD PTR [ebx+100]
	mov	ecx, esi
	mov	BYTE PTR _b$129817[esp+108], 0
	call	??4SPPInfo@@QAEAAU0@ABU0@@Z

; 370  : 		for(int i = m_EffectorsPP.size()-1; i >= 0; --i) 

	mov	ebp, DWORD PTR [ebx+88]
	sub	ebp, DWORD PTR [ebx+84]
	sar	ebp, 2
	sub	ebp, 1
	js	$LN220@UpdatePPEf
	npad	2
$LL11@UpdatePPEf:

; 371  : 		{
; 372  : 			CEffectorPP* eff	= m_EffectorsPP[i];

	mov	eax, DWORD PTR [ebx+84]
	push	eax
	call	?cv_ptr@?$_VoidCastTraitsAux@PAXPAX@priv@stlp_std@@SAPAPAXPAPAX@Z ; stlp_std::priv::_VoidCastTraitsAux<void *,void *>::cv_ptr
	mov	edi, DWORD PTR [eax+ebp*4]
	add	esp, 4

; 373  : 			SPPInfo l_PPInf		= pp_zero;

	push	OFFSET ?pp_zero@@3USPPInfo@@A		; pp_zero
	lea	ecx, DWORD PTR _l_PPInf$129823[esp+108]
	call	??0SPPInfo@@QAE@ABU0@@Z

; 374  : 			if(eff->Valid() && eff->Process(l_PPInf))

	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, edi
	call	eax
	test	eax, eax
	je	$LN8@UpdatePPEf
	mov	edx, DWORD PTR [edi]
	mov	edx, DWORD PTR [edx+4]
	lea	eax, DWORD PTR _l_PPInf$129823[esp+104]
	push	eax
	mov	ecx, edi
	call	edx
	test	eax, eax
	je	$LN8@UpdatePPEf

; 375  : 			{
; 376  : 				++_count;

	add	DWORD PTR __count$[esp+104], 1

; 377  : 				if(!b)

	cmp	BYTE PTR _b$129817[esp+104], 0
	jne	$LN98@UpdatePPEf

; 378  : 				{
; 379  : 					pp_affected.add		(l_PPInf);

	lea	eax, DWORD PTR _l_PPInf$129823[esp+104]
	push	eax
	mov	ecx, esi
	call	?add@SPPInfo@@QAEAAU1@ABU1@@Z		; SPPInfo::add

; 380  : 					pp_affected.sub		(pp_identity);

	movss	xmm0, DWORD PTR [esi]
	subss	xmm0, DWORD PTR ?pp_identity@@3USPPInfo@@A
	movss	DWORD PTR [esi], xmm0
	movss	xmm0, DWORD PTR [esi+4]
	subss	xmm0, DWORD PTR ?pp_identity@@3USPPInfo@@A+4
	movss	DWORD PTR [esi+4], xmm0
	movss	xmm0, DWORD PTR [esi+8]
	subss	xmm0, DWORD PTR ?pp_identity@@3USPPInfo@@A+8
	movss	DWORD PTR [esi+8], xmm0
	movss	xmm0, DWORD PTR [esi+12]
	subss	xmm0, DWORD PTR ?pp_identity@@3USPPInfo@@A+12
	movss	DWORD PTR [esi+12], xmm0
	movss	xmm0, DWORD PTR [esi+28]
	subss	xmm0, DWORD PTR ?pp_identity@@3USPPInfo@@A+28
	movss	DWORD PTR [esi+28], xmm0
	movss	xmm0, DWORD PTR [esi+32]
	subss	xmm0, DWORD PTR ?pp_identity@@3USPPInfo@@A+32
	movss	DWORD PTR [esi+32], xmm0
	movss	xmm0, DWORD PTR [esi+36]
	subss	xmm0, DWORD PTR ?pp_identity@@3USPPInfo@@A+36
	movss	DWORD PTR [esi+36], xmm0
	movss	xmm0, DWORD PTR [esi+40]
	subss	xmm0, DWORD PTR ?pp_identity@@3USPPInfo@@A+40
	movss	DWORD PTR [esi+40], xmm0
	movss	xmm0, DWORD PTR [esi+44]
	subss	xmm0, DWORD PTR ?pp_identity@@3USPPInfo@@A+44
	movss	DWORD PTR [esi+44], xmm0
	movss	xmm0, DWORD PTR [esi+48]
	subss	xmm0, DWORD PTR ?pp_identity@@3USPPInfo@@A+48
	movss	DWORD PTR [esi+48], xmm0
	movss	xmm0, DWORD PTR [esi+52]
	subss	xmm0, DWORD PTR ?pp_identity@@3USPPInfo@@A+52
	movss	DWORD PTR [esi+52], xmm0
	movss	xmm0, DWORD PTR [esi+56]
	subss	xmm0, DWORD PTR ?pp_identity@@3USPPInfo@@A+56
	movss	DWORD PTR [esi+56], xmm0
	movss	xmm0, DWORD PTR [esi+60]
	subss	xmm0, DWORD PTR ?pp_identity@@3USPPInfo@@A+60
	movss	DWORD PTR [esi+60], xmm0

; 381  : 					pp_affected.validate("in cycle");

$LN98@UpdatePPEf:

; 382  : 				}
; 383  : 				if(!eff->bOverlap)

	cmp	BYTE PTR [edi+24], 0
	jne	SHORT $LN5@UpdatePPEf

; 384  : 				{
; 385  : 					b				= true;
; 386  : 					pp_affected		= l_PPInf;

	lea	ecx, DWORD PTR _l_PPInf$129823[esp+104]
	push	ecx
	mov	ecx, esi
	mov	BYTE PTR _b$129817[esp+108], 1
	call	??4SPPInfo@@QAEAAU0@ABU0@@Z

; 387  : 				}
; 388  : 			}else 

	jmp	SHORT $LN5@UpdatePPEf
$LN8@UpdatePPEf:

; 389  : 				RemovePPEffector	(eff->Type());

	mov	edx, DWORD PTR [edi+12]
	push	edx
	mov	ecx, ebx
	call	?RemovePPEffector@CCameraManager@@QAEXW4EEffectorPPType@@@Z ; CCameraManager::RemovePPEffector
$LN5@UpdatePPEf:

; 390  : 		}

	mov	eax, DWORD PTR _l_PPInf$129823[esp+180]
	test	eax, eax
	je	SHORT $LN154@UpdatePPEf
	add	DWORD PTR [eax], -1
	mov	eax, DWORD PTR _l_PPInf$129823[esp+180]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN154@UpdatePPEf
	mov	DWORD PTR _l_PPInf$129823[esp+180], 0
$LN154@UpdatePPEf:
	mov	eax, DWORD PTR _l_PPInf$129823[esp+176]
	test	eax, eax
	je	SHORT $LN10@UpdatePPEf
	add	DWORD PTR [eax], -1
$LN10@UpdatePPEf:

; 370  : 		for(int i = m_EffectorsPP.size()-1; i >= 0; --i) 

	sub	ebp, 1
	jns	$LL11@UpdatePPEf

; 391  : 		if (0==_count)	

	cmp	DWORD PTR __count$[esp+104], 0
	jne	SHORT $LN2@UpdatePPEf
$LN220@UpdatePPEf:

; 392  : 			pp_affected				= pp_identity;

	push	OFFSET ?pp_identity@@3USPPInfo@@A	; pp_identity
	mov	ecx, esi

; 393  : 		else			
; 394  : 			pp_affected.normalize	();

	jmp	SHORT $LN222@UpdatePPEf
$LN12@UpdatePPEf:

; 395  : 	} else 
; 396  : 	{
; 397  : 		pp_affected					= pp_identity;

	lea	ecx, DWORD PTR [ebx+100]
$LN222@UpdatePPEf:
	call	??4SPPInfo@@QAEAAU0@ABU0@@Z
$LN2@UpdatePPEf:

; 398  : 	}
; 399  : 
; 400  : 	if( !positive(pp_affected.noise.grain) ) 

	mov	ecx, DWORD PTR [ebx+120]
	shr	ecx, 31					; 0000001fH
	not	ecx
	test	cl, 1
	jne	SHORT $LN215@UpdatePPEf

; 401  : 		pp_affected.noise.grain		= pp_identity.noise.grain;

	movss	xmm0, DWORD PTR ?pp_identity@@3USPPInfo@@A+20
	movss	DWORD PTR [ebx+120], xmm0

; 402  : 	
; 403  : 	pp_affected.validate			("after applying pp");

$LN215@UpdatePPEf:

; 404  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdatePPEffectors@CCameraManager@@MAEXXZ ENDP		; CCameraManager::UpdatePPEffectors
_TEXT	ENDS
PUBLIC	?Update@CCameraManager@@QAEXABU?$_vector3@M@@00MMMI@Z ; CCameraManager::Update
; Function compile flags: /Ogtpy
;	COMDAT ?Update@CCameraManager@@QAEXABU?$_vector3@M@@00MMMI@Z
_TEXT	SEGMENT
_mag$449971 = 8						; size = 4
_mag$449957 = 8						; size = 4
_P$ = 8							; size = 4
tv545 = 12						; size = 4
tv526 = 12						; size = 4
_D$ = 12						; size = 4
tv541 = 16						; size = 4
tv522 = 16						; size = 4
_N$ = 16						; size = 4
_fFOV_Dest$ = 20					; size = 4
_fASPECT_Dest$ = 24					; size = 4
_fFAR_Dest$ = 28					; size = 4
tv537 = 32						; size = 4
tv518 = 32						; size = 4
_flags$ = 32						; size = 4
?Update@CCameraManager@@QAEXABU?$_vector3@M@@00MMMI@Z PROC ; CCameraManager::Update, COMDAT
; _this$ = ecx

; 282  : #ifdef DEBUG
; 283  : 	if (!Device.Paused()) {
; 284  : 		VERIFY				(dbg_upd_frame!=Device.dwFrame);// already updated !!!
; 285  : 		dbg_upd_frame		= Device.dwFrame;
; 286  : 	}
; 287  : #endif // DEBUG
; 288  : 	// camera
; 289  : 	if (flags&CCameraBase::flPositionRigid)

	movss	xmm3, DWORD PTR __real@3f800000

; 290  : 		m_cam_info.p.set		(P);

	mov	eax, DWORD PTR _P$[esp-4]
	push	esi
	mov	esi, ecx
	mov	cl, BYTE PTR _flags$[esp]
	test	cl, 2
	je	SHORT $LN5@Update@2
	fld	DWORD PTR [eax]
	fstp	DWORD PTR [esi+4]
	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [esi+8]
	fld	DWORD PTR [eax+8]
	fstp	DWORD PTR [esi+12]

; 291  : 	else

	jmp	SHORT $LN10@Update@2
$LN5@Update@2:

; 292  : 		m_cam_info.p.inertion	(P,	psCamInert);

	movss	xmm1, DWORD PTR ?psCamInert@@3MA
	movss	xmm2, DWORD PTR [esi+4]
	mulss	xmm2, xmm1
	movaps	xmm0, xmm3
	subss	xmm0, xmm1
	movaps	xmm4, xmm0
	mulss	xmm4, DWORD PTR [eax]
	addss	xmm2, xmm4
	movss	xmm4, DWORD PTR [esi+8]
	movss	DWORD PTR [esi+4], xmm2
	movss	xmm2, DWORD PTR [eax+4]
	mulss	xmm2, xmm0
	mulss	xmm4, xmm1
	mulss	xmm1, DWORD PTR [esi+12]
	addss	xmm2, xmm4
	movss	DWORD PTR [esi+8], xmm2
	movss	xmm2, DWORD PTR [eax+8]
	mulss	xmm2, xmm0
	addss	xmm2, xmm1
	movss	DWORD PTR [esi+12], xmm2
$LN10@Update@2:

; 293  : 	if (flags&CCameraBase::flDirectionRigid)

	test	cl, 4

; 294  : 	{
; 295  : 		m_cam_info.d.set		(D);

	mov	eax, DWORD PTR _D$[esp]
	je	SHORT $LN3@Update@2
	fld	DWORD PTR [eax]
	fstp	DWORD PTR [esi+16]
	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [esi+20]
	fld	DWORD PTR [eax+8]

; 296  : 		m_cam_info.n.set		(N);

	mov	eax, DWORD PTR _N$[esp]
	fstp	DWORD PTR [esi+24]
	fld	DWORD PTR [eax]
	fstp	DWORD PTR [esi+28]
	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [esi+32]
	fld	DWORD PTR [eax+8]
	fstp	DWORD PTR [esi+36]

; 297  : 	}else{

	jmp	$LN18@Update@2
$LN3@Update@2:

; 298  : 		m_cam_info.d.inertion	(D,	psCamInert);

	movss	xmm1, DWORD PTR ?psCamInert@@3MA
	movss	xmm2, DWORD PTR [eax]
	movss	xmm4, DWORD PTR [esi+16]
	mulss	xmm4, xmm1
	movaps	xmm0, xmm3
	subss	xmm0, xmm1
	mulss	xmm2, xmm0
	addss	xmm2, xmm4
	movss	xmm4, DWORD PTR [esi+20]
	movss	DWORD PTR [esi+16], xmm2
	movss	xmm2, DWORD PTR [eax+4]
	mulss	xmm2, xmm0
	mulss	xmm4, xmm1
	mulss	xmm1, DWORD PTR [esi+24]
	addss	xmm2, xmm4
	movss	DWORD PTR [esi+20], xmm2
	movss	xmm2, DWORD PTR [eax+8]

; 299  : 		m_cam_info.n.inertion	(N,	psCamInert);

	mov	eax, DWORD PTR _N$[esp]
	mulss	xmm2, xmm0
	addss	xmm2, xmm1
	movss	DWORD PTR [esi+24], xmm2
	movss	xmm1, DWORD PTR ?psCamInert@@3MA
	movss	xmm4, DWORD PTR [eax]
	movss	xmm2, DWORD PTR [esi+28]
	mulss	xmm2, xmm1
	movaps	xmm0, xmm3
	subss	xmm0, xmm1
	mulss	xmm4, xmm0
	addss	xmm2, xmm4
	movss	DWORD PTR [esi+28], xmm2
	movss	xmm2, DWORD PTR [eax+4]
	mulss	xmm2, xmm0
	movaps	xmm4, xmm1
	mulss	xmm4, DWORD PTR [esi+32]
	addss	xmm2, xmm4
	movss	DWORD PTR [esi+32], xmm2
	movss	xmm2, DWORD PTR [eax+8]
	mulss	xmm2, xmm0
	movss	xmm0, DWORD PTR [esi+36]
	mulss	xmm0, xmm1
	addss	xmm2, xmm0
	movss	DWORD PTR [esi+36], xmm2
$LN18@Update@2:

; 300  : 	}
; 301  : 	
; 302  : 	// Normalize
; 303  : 	m_cam_info.d.normalize	();

	movss	xmm2, DWORD PTR [esi+16]
	movss	xmm1, DWORD PTR [esi+20]
	movss	xmm0, DWORD PTR [esi+24]
	movaps	xmm4, xmm2
	mulss	xmm4, xmm2
	movss	DWORD PTR tv526[esp], xmm2
	movaps	xmm2, xmm1
	mulss	xmm2, xmm1
	movss	DWORD PTR tv522[esp], xmm1
	movaps	xmm1, xmm0
	addss	xmm4, xmm2
	mulss	xmm1, xmm0
	addss	xmm4, xmm1
	push	ecx
	divss	xmm3, xmm4
	movss	DWORD PTR tv518[esp+4], xmm0
	movss	DWORD PTR [esp], xmm3
	call	_sqrtf
	fstp	DWORD PTR _mag$449957[esp+4]
	movss	xmm1, DWORD PTR _mag$449957[esp+4]
	movss	xmm0, DWORD PTR tv526[esp+4]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+16], xmm0
	movss	xmm0, DWORD PTR tv522[esp+4]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+20], xmm0
	movss	xmm0, DWORD PTR tv518[esp+4]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+24], xmm0

; 304  : 	m_cam_info.n.normalize	();

	movss	xmm2, DWORD PTR [esi+28]
	movss	xmm1, DWORD PTR [esi+32]
	movss	xmm0, DWORD PTR [esi+36]
	movaps	xmm3, xmm2
	mulss	xmm3, xmm2
	movss	DWORD PTR tv545[esp+4], xmm2
	movaps	xmm2, xmm1
	mulss	xmm2, xmm1
	movss	DWORD PTR tv541[esp+4], xmm1
	movaps	xmm1, xmm0
	mulss	xmm1, xmm0
	movss	DWORD PTR tv537[esp+4], xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	addss	xmm3, xmm2
	addss	xmm3, xmm1
	divss	xmm0, xmm3
	movss	DWORD PTR [esp], xmm0
	call	_sqrtf
	fstp	DWORD PTR _mag$449971[esp+4]
	movss	xmm1, DWORD PTR _mag$449971[esp+4]
	movss	xmm0, DWORD PTR tv545[esp+4]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+28], xmm0
	movss	xmm0, DWORD PTR tv541[esp+4]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+32], xmm0
	movss	xmm0, DWORD PTR tv537[esp+4]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+36], xmm0

; 305  : 	m_cam_info.r.crossproduct	(m_cam_info.n, m_cam_info.d);

	movss	xmm0, DWORD PTR [esi+32]
	mulss	xmm0, DWORD PTR [esi+24]
	movss	xmm1, DWORD PTR [esi+20]
	mulss	xmm1, DWORD PTR [esi+36]
	subss	xmm0, xmm1
	movss	DWORD PTR [esi+40], xmm0
	movss	xmm0, DWORD PTR [esi+16]
	mulss	xmm0, DWORD PTR [esi+36]
	movss	xmm1, DWORD PTR [esi+24]
	mulss	xmm1, DWORD PTR [esi+28]
	subss	xmm0, xmm1
	movss	DWORD PTR [esi+44], xmm0
	movss	xmm0, DWORD PTR [esi+20]
	mulss	xmm0, DWORD PTR [esi+28]
	movss	xmm1, DWORD PTR [esi+16]
	mulss	xmm1, DWORD PTR [esi+32]
	subss	xmm0, xmm1
	movss	DWORD PTR [esi+48], xmm0

; 306  : 	m_cam_info.n.crossproduct	(m_cam_info.d, m_cam_info.r);

	movss	xmm1, DWORD PTR [esi+44]
	mulss	xmm0, DWORD PTR [esi+20]
	mulss	xmm1, DWORD PTR [esi+24]
	add	esp, 4
	subss	xmm0, xmm1

; 307  : 
; 308  : 	float aspect				= Device.fHeight_2/Device.fWidth_2;
; 309  : 	float src					= 10*Device.fTimeDelta;	clamp(src,0.f,1.f);

	xorps	xmm2, xmm2
	movss	DWORD PTR [esi+28], xmm0
	movss	xmm0, DWORD PTR [esi+40]
	mulss	xmm0, DWORD PTR [esi+24]
	movss	xmm1, DWORD PTR [esi+48]
	mulss	xmm1, DWORD PTR [esi+16]
	subss	xmm0, xmm1
	movss	DWORD PTR [esi+32], xmm0
	movss	xmm0, DWORD PTR [esi+16]
	mulss	xmm0, DWORD PTR [esi+44]
	movss	xmm1, DWORD PTR [esi+20]
	mulss	xmm1, DWORD PTR [esi+40]
	subss	xmm0, xmm1
	movss	DWORD PTR [esi+36], xmm0
	movss	xmm0, DWORD PTR ?Device@@3VCRenderDevice@@A+28
	mulss	xmm0, DWORD PTR __real@41200000
	comiss	xmm2, xmm0
	movss	xmm1, DWORD PTR ?Device@@3VCRenderDevice@@A+864
	divss	xmm1, DWORD PTR ?Device@@3VCRenderDevice@@A+860
	jbe	SHORT $LN44@Update@2
	movaps	xmm0, xmm2
	movss	xmm2, DWORD PTR __real@3f800000
	jmp	SHORT $LN42@Update@2
$LN44@Update@2:
	movss	xmm2, DWORD PTR __real@3f800000
	comiss	xmm0, xmm2
	jbe	SHORT $LN42@Update@2
	movaps	xmm0, xmm2
$LN42@Update@2:

; 310  : 	float dst					= 1-src;
; 311  : 	m_cam_info.fFov				= m_cam_info.fFov*dst		+ fFOV_Dest*src;

	movss	xmm3, DWORD PTR [esi+52]

; 312  : 	m_cam_info.fFar				= m_cam_info.fFar*dst		+ fFAR_Dest*src;
; 313  : 	m_cam_info.fAspect			= m_cam_info.fAspect*dst	+ (fASPECT_Dest*aspect)*src;

	mulss	xmm1, DWORD PTR _fASPECT_Dest$[esp]

; 314  : 	m_cam_info.dont_apply			= false;
; 315  : 
; 316  : 	UpdateCamEffectors			();

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	subss	xmm2, xmm0
	mulss	xmm3, xmm2
	movaps	xmm4, xmm0
	mulss	xmm4, DWORD PTR _fFOV_Dest$[esp]
	addss	xmm3, xmm4
	movss	DWORD PTR [esi+52], xmm3
	movss	xmm3, DWORD PTR [esi+56]
	mulss	xmm3, xmm2
	mulss	xmm2, DWORD PTR [esi+60]
	movaps	xmm4, xmm0
	mulss	xmm4, DWORD PTR _fFAR_Dest$[esp]
	mulss	xmm1, xmm0
	addss	xmm3, xmm4
	addss	xmm1, xmm2
	mov	ecx, esi
	movss	DWORD PTR [esi+56], xmm3
	movss	DWORD PTR [esi+60], xmm1
	mov	BYTE PTR [esi+64], 0
	call	edx

; 317  : 
; 318  : 	UpdatePPEffectors			();

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+4]
	mov	ecx, esi
	call	edx

; 319  : 
; 320  : 	if (false==m_cam_info.dont_apply && m_bAutoApply)

	cmp	BYTE PTR [esi+64], 0
	jne	SHORT $LN1@Update@2
	cmp	BYTE PTR [esi+96], 0
	je	SHORT $LN1@Update@2

; 321  : 			ApplyDevice		(VIEWPORT_NEAR);

	fld	DWORD PTR __real@3e4ccccd
	push	ecx
	mov	ecx, esi
	fstp	DWORD PTR [esp]
	call	?ApplyDevice@CCameraManager@@QAEXM@Z	; CCameraManager::ApplyDevice
$LN1@Update@2:

; 322  : 
; 323  : 	UpdateDeffered			();

	mov	ecx, esi
	call	?UpdateDeffered@CCameraManager@@IAEXXZ	; CCameraManager::UpdateDeffered
	pop	esi

; 324  : }

	ret	28					; 0000001cH
?Update@CCameraManager@@QAEXABU?$_vector3@M@@00MMMI@Z ENDP ; CCameraManager::Update
_TEXT	ENDS
PUBLIC	?UpdateFromCamera@CCameraManager@@QAEXPBVCCameraBase@@@Z ; CCameraManager::UpdateFromCamera
; Function compile flags: /Ogtpy
;	COMDAT ?UpdateFromCamera@CCameraManager@@QAEXPBVCCameraBase@@@Z
_TEXT	SEGMENT
_C$ = 8							; size = 4
?UpdateFromCamera@CCameraManager@@QAEXPBVCCameraBase@@@Z PROC ; CCameraManager::UpdateFromCamera, COMDAT
; _this$ = ecx

; 277  : 	Update(C->vPosition,C->vDirection,C->vNormal, C->f_fov, C->f_aspect, g_pGamePersistent->Environment().CurrentEnv->far_plane, C->m_Flags.flags); 

	mov	eax, DWORD PTR _C$[esp-4]
	mov	edx, DWORD PTR [eax+32]
	push	edx
	mov	edx, DWORD PTR ?g_pGamePersistent@@3PAVIGame_Persistent@@A ; g_pGamePersistent
	mov	edx, DWORD PTR [edx+1128]
	mov	edx, DWORD PTR [edx+120]
	fld	DWORD PTR [edx+56]
	sub	esp, 12					; 0000000cH
	fstp	DWORD PTR [esp+8]
	lea	edx, DWORD PTR [eax+100]
	fld	DWORD PTR [eax+116]
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR [eax+112]
	fstp	DWORD PTR [esp]
	push	edx
	lea	edx, DWORD PTR [eax+88]
	push	edx
	add	eax, 76					; 0000004cH
	push	eax
	call	?Update@CCameraManager@@QAEXABU?$_vector3@M@@00MMMI@Z ; CCameraManager::Update

; 278  : }

	ret	4
?UpdateFromCamera@CCameraManager@@QAEXPBVCCameraBase@@@Z ENDP ; CCameraManager::UpdateFromCamera
_TEXT	ENDS
PUBLIC	?AddPPEffector@CCameraManager@@QAEPAVCEffectorPP@@PAV2@@Z ; CCameraManager::AddPPEffector
; Function compile flags: /Ogtpy
;	COMDAT ?AddPPEffector@CCameraManager@@QAEPAVCEffectorPP@@PAV2@@Z
_TEXT	SEGMENT
_ef$ = 8						; size = 4
?AddPPEffector@CCameraManager@@QAEPAVCEffectorPP@@PAV2@@Z PROC ; CCameraManager::AddPPEffector, COMDAT
; _this$ = ecx

; 248  : 	RemovePPEffector				(ef->Type());

	mov	eax, DWORD PTR _ef$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [eax+12]
	push	edi
	push	ecx
	mov	ecx, esi
	call	?RemovePPEffector@CCameraManager@@QAEXW4EEffectorPPType@@@Z ; CCameraManager::RemovePPEffector

; 249  : 	m_EffectorsPP.push_back			(ef);

	mov	eax, DWORD PTR [esi+88]
	cmp	eax, DWORD PTR [esi+92]
	lea	edi, DWORD PTR [esi+84]
	je	SHORT $LN12@AddPPEffec
	lea	edx, DWORD PTR _ef$[esp+4]
	push	edx
	push	eax
	call	??$_Copy_Construct@PAX@stlp_std@@YAXPAPAXABQAX@Z ; stlp_std::_Copy_Construct<void *>
	add	esp, 8
	add	DWORD PTR [edi+4], 4

; 250  : 	return m_EffectorsPP.back		();

	mov	eax, DWORD PTR [esi+88]
	mov	eax, DWORD PTR [eax-4]
	pop	edi
	pop	esi

; 251  : }

	ret	4

; 249  : 	m_EffectorsPP.push_back			(ef);

$LN12@AddPPEffec:
	push	1
	push	1
	push	eax
	lea	eax, DWORD PTR _ef$[esp+16]
	call	?_M_insert_overflow@?$_Impl_vector@PAXV?$xalloc@PAX@@@priv@stlp_std@@AAEXPAPAXABQAXABU__true_type@3@I_N@Z ; stlp_std::priv::_Impl_vector<void *,xalloc<void *> >::_M_insert_overflow

; 250  : 	return m_EffectorsPP.back		();

	mov	ecx, DWORD PTR [esi+88]
	mov	eax, DWORD PTR [ecx-4]
	pop	edi
	pop	esi

; 251  : }

	ret	4
?AddPPEffector@CCameraManager@@QAEPAVCEffectorPP@@PAV2@@Z ENDP ; CCameraManager::AddPPEffector
_TEXT	ENDS
PUBLIC	??0CCameraManager@@QAE@_N@Z			; CCameraManager::CCameraManager
; Function compile flags: /Ogtpy
;	COMDAT ??0CCameraManager@@QAE@_N@Z
_TEXT	SEGMENT
_bApplyOnUpdate$ = 8					; size = 1
??0CCameraManager@@QAE@_N@Z PROC			; CCameraManager::CCameraManager, COMDAT
; _this$ = ecx

; 142  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	ecx
	xorps	xmm0, xmm0
	movss	xmm3, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@42b40000
	movss	xmm2, DWORD PTR __real@3eaa7efa
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CCameraManager@@6B@
	movss	DWORD PTR [esi+4], xmm0
	movss	DWORD PTR [esi+8], xmm0
	movss	DWORD PTR [esi+12], xmm0
	movss	DWORD PTR [esi+24], xmm3
	movss	DWORD PTR [esi+16], xmm0
	movss	DWORD PTR [esi+20], xmm0
	movss	DWORD PTR [esi+32], xmm3
	movss	DWORD PTR [esi+28], xmm0
	movss	DWORD PTR [esi+36], xmm0
	movss	DWORD PTR [esi+52], xmm1
	movss	DWORD PTR [esi+60], xmm3
	mov	BYTE PTR [esi+65], 1
	movss	xmm1, DWORD PTR __real@42c80000
	movss	DWORD PTR [esi+56], xmm1
	movss	xmm1, DWORD PTR __real@41200000
	lea	ecx, DWORD PTR [esi+100]
	xor	edx, edx
	mov	BYTE PTR [esi+64], dl
	lea	eax, DWORD PTR [esi+68]
	mov	DWORD PTR [eax], eax
	mov	DWORD PTR [eax+4], eax
	lea	eax, DWORD PTR [esi+76]
	mov	DWORD PTR [eax], eax
	mov	DWORD PTR [eax+4], eax
	movss	DWORD PTR [ecx+24], xmm1
	movss	xmm1, DWORD PTR __real@3f000000
	movss	DWORD PTR [ecx+20], xmm3
	movss	DWORD PTR [ecx+12], xmm0
	movss	DWORD PTR [ecx+8], xmm0
	movss	DWORD PTR [ecx+4], xmm0
	movss	DWORD PTR [ecx], xmm0
	movss	DWORD PTR [ecx+16], xmm0
	movss	DWORD PTR [ecx+28], xmm1
	movss	DWORD PTR [ecx+32], xmm1
	movss	DWORD PTR [ecx+36], xmm1

; 143  : #ifdef DEBUG
; 144  : 	dbg_upd_frame					= 0;
; 145  : #endif
; 146  : 
; 147  : 	m_bAutoApply					= bApplyOnUpdate;

	mov	al, BYTE PTR _bApplyOnUpdate$[ebp]
	movss	DWORD PTR [ecx+40], xmm2
	movss	DWORD PTR [ecx+44], xmm2
	movss	DWORD PTR [ecx+48], xmm2
	mov	DWORD PTR [esi+84], edx
	mov	DWORD PTR [esi+88], edx
	mov	DWORD PTR [esi+92], edx
	movss	DWORD PTR [ecx+52], xmm0
	movss	DWORD PTR [ecx+56], xmm0
	movss	DWORD PTR [ecx+60], xmm0
	mov	DWORD PTR [ecx+72], edx
	mov	DWORD PTR [ecx+76], edx
	movss	DWORD PTR [ecx+64], xmm0
	movss	DWORD PTR [ecx+68], xmm0
	mov	BYTE PTR [esi+96], al

; 148  : 
; 149  : 	pp_identity.blur				= 0;
; 150  : 	pp_identity.gray				= 0;
; 151  : 	pp_identity.duality.h			= 0; 
; 152  : 	pp_identity.duality.v			= 0;
; 153  : 	pp_identity.noise.intensity		= 0;	
; 154  : 	pp_identity.noise.grain			= 1.0f;	

	movss	DWORD PTR ?pp_identity@@3USPPInfo@@A+20, xmm3

; 155  : 	pp_identity.noise.fps			= 30;

	movss	xmm3, DWORD PTR _SAMPLE_FPS
	movss	DWORD PTR ?pp_identity@@3USPPInfo@@A, xmm0
	movss	DWORD PTR ?pp_identity@@3USPPInfo@@A+4, xmm0
	movss	DWORD PTR ?pp_identity@@3USPPInfo@@A+8, xmm0
	movss	DWORD PTR ?pp_identity@@3USPPInfo@@A+12, xmm0
	movss	DWORD PTR ?pp_identity@@3USPPInfo@@A+16, xmm0
	movss	DWORD PTR ?pp_identity@@3USPPInfo@@A+24, xmm3

; 156  : 	pp_identity.color_base.set		(.5f,	.5f,	.5f);

	movss	DWORD PTR ?pp_identity@@3USPPInfo@@A+28, xmm1
	movss	DWORD PTR ?pp_identity@@3USPPInfo@@A+32, xmm1
	movss	DWORD PTR ?pp_identity@@3USPPInfo@@A+36, xmm1

; 157  : 	pp_identity.color_gray.set		(.333f,	.333f,	.333f);

	movss	DWORD PTR ?pp_identity@@3USPPInfo@@A+40, xmm2
	movss	DWORD PTR ?pp_identity@@3USPPInfo@@A+44, xmm2
	movss	DWORD PTR ?pp_identity@@3USPPInfo@@A+48, xmm2

; 158  : 	pp_identity.color_add.set		(0,		0,		0);

	movss	DWORD PTR ?pp_identity@@3USPPInfo@@A+52, xmm0
	movss	DWORD PTR ?pp_identity@@3USPPInfo@@A+56, xmm0
	movss	DWORD PTR ?pp_identity@@3USPPInfo@@A+60, xmm0

; 159  : 
; 160  : 	pp_zero.blur = pp_zero.gray		= pp_zero.duality.h = pp_zero.duality.v = 0.0f;

	movss	DWORD PTR ?pp_zero@@3USPPInfo@@A+12, xmm0
	movss	DWORD PTR ?pp_zero@@3USPPInfo@@A+8, xmm0
	movss	DWORD PTR ?pp_zero@@3USPPInfo@@A+4, xmm0
	movss	DWORD PTR ?pp_zero@@3USPPInfo@@A, xmm0

; 161  : 	pp_zero.noise.intensity			=0;

	movss	DWORD PTR ?pp_zero@@3USPPInfo@@A+16, xmm0

; 162  : 	pp_zero.noise.grain				= 0.0f;	

	movss	DWORD PTR ?pp_zero@@3USPPInfo@@A+20, xmm0

; 163  : 	pp_zero.noise.fps				= 0.0f;

	movss	DWORD PTR ?pp_zero@@3USPPInfo@@A+24, xmm0

; 164  : 	pp_zero.color_base.set			(0,0,0);
; 165  : 	pp_zero.color_gray.set			(0,0,0);
; 166  : 	pp_zero.color_add.set			(0,0,0);
; 167  : 
; 168  : 	pp_affected						= pp_identity;

	push	OFFSET ?pp_identity@@3USPPInfo@@A	; pp_identity
	movss	DWORD PTR ?pp_zero@@3USPPInfo@@A+28, xmm0
	movss	DWORD PTR ?pp_zero@@3USPPInfo@@A+32, xmm0
	movss	DWORD PTR ?pp_zero@@3USPPInfo@@A+36, xmm0
	movss	DWORD PTR ?pp_zero@@3USPPInfo@@A+40, xmm0
	movss	DWORD PTR ?pp_zero@@3USPPInfo@@A+44, xmm0
	movss	DWORD PTR ?pp_zero@@3USPPInfo@@A+48, xmm0
	movss	DWORD PTR ?pp_zero@@3USPPInfo@@A+52, xmm0
	movss	DWORD PTR ?pp_zero@@3USPPInfo@@A+56, xmm0
	movss	DWORD PTR ?pp_zero@@3USPPInfo@@A+60, xmm0
	call	??4SPPInfo@@QAEAAU0@ABU0@@Z

; 169  : }

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??0CCameraManager@@QAE@_N@Z ENDP			; CCameraManager::CCameraManager
_TEXT	ENDS
PUBLIC	??0CEffectorPP@@QAE@ABV0@@Z			; CEffectorPP::CEffectorPP
; Function compile flags: /Ogtpy
;	COMDAT ??0CEffectorPP@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0CEffectorPP@@QAE@ABV0@@Z PROC			; CEffectorPP::CEffectorPP, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	ecx, DWORD PTR ___that$[esp-4]
	mov	DWORD PTR [eax], OFFSET ??_7SBaseEffector@@6B@
	xor	edx, edx
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax], OFFSET ??_7CEffectorPP@@6B@
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	dl, BYTE PTR [ecx+16]
	mov	BYTE PTR [eax+16], dl
	fld	DWORD PTR [ecx+20]
	fstp	DWORD PTR [eax+20]
	mov	cl, BYTE PTR [ecx+24]
	mov	BYTE PTR [eax+24], cl
	ret	4
??0CEffectorPP@@QAE@ABV0@@Z ENDP			; CEffectorPP::CEffectorPP
_TEXT	ENDS
PUBLIC	??0CEffectorCam@@QAE@ABV0@@Z			; CEffectorCam::CEffectorCam
; Function compile flags: /Ogtpy
;	COMDAT ??0CEffectorCam@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0CEffectorCam@@QAE@ABV0@@Z PROC			; CEffectorCam::CEffectorCam, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	ecx, DWORD PTR ___that$[esp-4]
	mov	DWORD PTR [eax], OFFSET ??_7SBaseEffector@@6B@
	xor	edx, edx
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax], OFFSET ??_7CEffectorCam@@6B@
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	fld	DWORD PTR [ecx+16]
	fstp	DWORD PTR [eax+16]
	mov	cl, BYTE PTR [ecx+20]
	mov	BYTE PTR [eax+20], cl
	ret	4
??0CEffectorCam@@QAE@ABV0@@Z ENDP			; CEffectorCam::CEffectorCam
PUBLIC	?pp_identity@@3USPPInfo@@A			; pp_identity
?pp_identity@@3USPPInfo@@A DD 000000000r	; 0	; pp_identity
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	041200000r			; 10
	DD	03f000000r			; 0.5
	DD	03f000000r			; 0.5
	DD	03f000000r			; 0.5
	DD	03eaa7efar			; 0.333
	DD	03eaa7efar			; 0.333
	DD	03eaa7efar			; 0.333
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
; Function compile flags: /Ogtpy
;	COMDAT ??__Epp_identity@@YAXXZ
text$yc	SEGMENT
??__Epp_identity@@YAXXZ PROC				; `dynamic initializer for 'pp_identity'', COMDAT

; 22   : SPPInfo		pp_identity;

	push	OFFSET ??__Fpp_identity@@YAXXZ		; `dynamic atexit destructor for 'pp_identity''
	call	_atexit
	pop	ecx
	ret	0
??__Epp_identity@@YAXXZ ENDP				; `dynamic initializer for 'pp_identity''
text$yc	ENDS
PUBLIC	?pp_zero@@3USPPInfo@@A				; pp_zero
	ORG $+8
?pp_zero@@3USPPInfo@@A DD 000000000r		; 0	; pp_zero
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	041200000r			; 10
	DD	03f000000r			; 0.5
	DD	03f000000r			; 0.5
	DD	03f000000r			; 0.5
	DD	03eaa7efar			; 0.333
	DD	03eaa7efar			; 0.333
	DD	03eaa7efar			; 0.333
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
; Function compile flags: /Ogtpy
;	COMDAT ??__Epp_zero@@YAXXZ
text$yc	SEGMENT
??__Epp_zero@@YAXXZ PROC				; `dynamic initializer for 'pp_zero'', COMDAT

; 23   : SPPInfo		pp_zero;

	push	OFFSET ??__Fpp_zero@@YAXXZ		; `dynamic atexit destructor for 'pp_zero''
	call	_atexit
	pop	ecx
	ret	0
??__Epp_zero@@YAXXZ ENDP				; `dynamic initializer for 'pp_zero''
; Function compile flags: /Ogtpy
;	COMDAT ??__Fpp_zero@@YAXXZ
text$yd	SEGMENT
??__Fpp_zero@@YAXXZ PROC				; `dynamic atexit destructor for 'pp_zero'', COMDAT
	mov	eax, DWORD PTR ?pp_zero@@3USPPInfo@@A+76
	xor	ecx, ecx
	cmp	eax, ecx
	je	SHORT $LN7@dynamic@5
	add	DWORD PTR [eax], -1
	mov	eax, DWORD PTR ?pp_zero@@3USPPInfo@@A+76
	cmp	DWORD PTR [eax], ecx
	jne	SHORT $LN7@dynamic@5
	mov	DWORD PTR ?pp_zero@@3USPPInfo@@A+76, ecx
$LN7@dynamic@5:
	mov	eax, DWORD PTR ?pp_zero@@3USPPInfo@@A+72
	cmp	eax, ecx
	je	SHORT $LN13@dynamic@5
	add	DWORD PTR [eax], -1
	mov	edx, DWORD PTR ?pp_zero@@3USPPInfo@@A+72
	cmp	DWORD PTR [edx], ecx
	jne	SHORT $LN13@dynamic@5
	mov	DWORD PTR ?pp_zero@@3USPPInfo@@A+72, ecx
$LN13@dynamic@5:
	ret	0
??__Fpp_zero@@YAXXZ ENDP				; `dynamic atexit destructor for 'pp_zero''
; Function compile flags: /Ogtpy
text$yd	ENDS
;	COMDAT ??__Fpp_identity@@YAXXZ
text$yd	SEGMENT
??__Fpp_identity@@YAXXZ PROC				; `dynamic atexit destructor for 'pp_identity'', COMDAT
	mov	eax, DWORD PTR ?pp_identity@@3USPPInfo@@A+76
	xor	ecx, ecx
	cmp	eax, ecx
	je	SHORT $LN7@dynamic@6
	add	DWORD PTR [eax], -1
	mov	eax, DWORD PTR ?pp_identity@@3USPPInfo@@A+76
	cmp	DWORD PTR [eax], ecx
	jne	SHORT $LN7@dynamic@6
	mov	DWORD PTR ?pp_identity@@3USPPInfo@@A+76, ecx
$LN7@dynamic@6:
	mov	eax, DWORD PTR ?pp_identity@@3USPPInfo@@A+72
	cmp	eax, ecx
	je	SHORT $LN13@dynamic@6
	add	DWORD PTR [eax], -1
	mov	edx, DWORD PTR ?pp_identity@@3USPPInfo@@A+72
	cmp	DWORD PTR [edx], ecx
	jne	SHORT $LN13@dynamic@6
	mov	DWORD PTR ?pp_identity@@3USPPInfo@@A+72, ecx
$LN13@dynamic@6:
	ret	0
??__Fpp_identity@@YAXXZ ENDP				; `dynamic atexit destructor for 'pp_identity''
_pp_identity$initializer$ DD FLAT:??__Epp_identity@@YAXXZ
_pp_zero$initializer$ DD FLAT:??__Epp_zero@@YAXXZ
END

; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	D:\CLEARSKY\sources\engine\xrEngine\xrTheora_Surface.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_ECTheoraSurface@@UAEPAXI@Z			; CTheoraSurface::`vector deleting destructor'
PUBLIC	??_R4CTheoraSurface@@6B@			; CTheoraSurface::`RTTI Complete Object Locator'
PUBLIC	??_R3CTheoraSurface@@8				; CTheoraSurface::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CTheoraSurface@@8				; CTheoraSurface::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CTheoraSurface@@8			; CTheoraSurface::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCTheoraSurface@@@8			; CTheoraSurface `RTTI Type Descriptor'
PUBLIC	??R?$xr_special_free@$00VCTheoraStream@@@@QAEXAAPAVCTheoraStream@@@Z ; xr_special_free<1,CTheoraStream>::operator()
PUBLIC	??$xr_delete@VCTheoraStream@@@@YAXAAPAVCTheoraStream@@@Z ; xr_delete<CTheoraStream>
PUBLIC	??$xr_new@VCTheoraStream@@@@YAPAVCTheoraStream@@XZ ; xr_new<CTheoraStream>
PUBLIC	?btwLowestBitMask@@YAII@Z			; btwLowestBitMask
PUBLIC	?btwPow2_Ceil@@YAII@Z				; btwPow2_Ceil
PUBLIC	??_C@_06FCLBCFNB@?$CDalpha?$AA@			; `string'
PUBLIC	??_C@_0BF@INPOMKOH@CTheoraSurface?3?3Load?$AA@	; `string'
PUBLIC	??_C@_0DJ@HGCCDCCA@D?3?2CLEARSKY?2sources?2engine?2xrEng@ ; `string'
PUBLIC	??_C@_0BB@ICMLCGMB@Device?4m_pRender?$AA@	; `string'
PUBLIC	??_7CTheoraSurface@@6B@				; CTheoraSurface::`vftable'
;	COMDAT ?ignore_always@?BL@??Load@CTheoraSurface@@QAEHPBD@Z@4_NA
_BSS	SEGMENT
?ignore_always@?BL@??Load@CTheoraSurface@@QAEHPBD@Z@4_NA DB 01H DUP (?) ; `CTheoraSurface::Load'::`27'::ignore_always
;	COMDAT ??_7CTheoraSurface@@6B@
CONST	SEGMENT
??_7CTheoraSurface@@6B@ DD FLAT:??_R4CTheoraSurface@@6B@ ; CTheoraSurface::`vftable'
	DD	FLAT:??_ECTheoraSurface@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4CTheoraSurface@@6B@
rdata$r	SEGMENT
??_R4CTheoraSurface@@6B@ DD 00H				; CTheoraSurface::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCTheoraSurface@@@8
	DD	FLAT:??_R3CTheoraSurface@@8
rdata$r	ENDS
;	COMDAT ??_R3CTheoraSurface@@8
rdata$r	SEGMENT
??_R3CTheoraSurface@@8 DD 00H				; CTheoraSurface::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CTheoraSurface@@8
rdata$r	ENDS
;	COMDAT ??_R2CTheoraSurface@@8
rdata$r	SEGMENT
??_R2CTheoraSurface@@8 DD FLAT:??_R1A@?0A@EA@CTheoraSurface@@8 ; CTheoraSurface::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CTheoraSurface@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CTheoraSurface@@8 DD FLAT:??_R0?AVCTheoraSurface@@@8 ; CTheoraSurface::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CTheoraSurface@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCTheoraSurface@@@8
_DATA	SEGMENT
??_R0?AVCTheoraSurface@@@8 DD FLAT:??_7type_info@@6B@	; CTheoraSurface `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCTheoraSurface@@', 00H
_DATA	ENDS
;	COMDAT ?K@?3??DecompressFrame@CTheoraSurface@@QAEXPAIIAAH@Z@4MB
CONST	SEGMENT
?K@?3??DecompressFrame@CTheoraSurface@@QAEXPAIIAAH@Z@4MB DD 03f5bdbd3r ; 0.858823 ; `CTheoraSurface::DecompressFrame'::`4'::K
CONST	ENDS
;	COMDAT ??_C@_0BB@ICMLCGMB@Device?4m_pRender?$AA@
CONST	SEGMENT
??_C@_0BB@ICMLCGMB@Device?4m_pRender?$AA@ DB 'Device.m_pRender', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@HGCCDCCA@D?3?2CLEARSKY?2sources?2engine?2xrEng@
CONST	SEGMENT
??_C@_0DJ@HGCCDCCA@D?3?2CLEARSKY?2sources?2engine?2xrEng@ DB 'D:\CLEARSKY'
	DB	'\sources\engine\xrEngine\xrTheora_Surface.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@INPOMKOH@CTheoraSurface?3?3Load?$AA@
CONST	SEGMENT
??_C@_0BF@INPOMKOH@CTheoraSurface?3?3Load?$AA@ DB 'CTheoraSurface::Load', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06FCLBCFNB@?$CDalpha?$AA@
CONST	SEGMENT
??_C@_06FCLBCFNB@?$CDalpha?$AA@ DB '#alpha', 00H	; `string'
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\_bitwise.h
;	COMDAT ?btwLowestBitMask@@YAII@Z
_TEXT	SEGMENT
?btwLowestBitMask@@YAII@Z PROC				; btwLowestBitMask, COMDAT
; _x$ = ecx

; 36   : IC	u32		btwLowestBitMask(u32 x)		{   return x & ~(x-1);	}

	lea	eax, DWORD PTR [ecx-1]
	not	eax
	and	eax, ecx
	ret	0
?btwLowestBitMask@@YAII@Z ENDP				; btwLowestBitMask
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?btwPow2_Ceil@@YAII@Z
_TEXT	SEGMENT
?btwPow2_Ceil@@YAII@Z PROC				; btwPow2_Ceil, COMDAT
; _v$ = ecx

; 51   : 	u32 i = btwLowestBitMask(v);

	lea	eax, DWORD PTR [ecx-1]
	not	eax
	and	eax, ecx

; 52   : 	while(i < v) i <<= 1;

	cmp	eax, ecx
	jae	SHORT $LN1@btwPow2_Ce
	npad	5
$LL2@btwPow2_Ce:
	add	eax, eax
	cmp	eax, ecx
	jb	SHORT $LL2@btwPow2_Ce
$LN1@btwPow2_Ce:

; 53   : 	return i;
; 54   : }

	ret	0
?btwPow2_Ceil@@YAII@Z ENDP				; btwPow2_Ceil
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\xrmemory_subst_msvc.h
_TEXT	ENDS
;	COMDAT ??R?$xr_special_free@$00VCTheoraStream@@@@QAEXAAPAVCTheoraStream@@@Z
_TEXT	SEGMENT
??R?$xr_special_free@$00VCTheoraStream@@@@QAEXAAPAVCTheoraStream@@@Z PROC ; xr_special_free<1,CTheoraStream>::operator(), COMDAT
; _ptr$ = esi

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	mov	eax, DWORD PTR [esi]
	push	edi
	push	eax
	call	___RTCastToVoid

; 133  : 		ptr->~T			();

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	add	esp, 4
	mov	edi, eax
	mov	eax, DWORD PTR [edx]
	push	0
	call	eax

; 134  : 		Memory.mem_free	(_real_ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	pop	edi

; 135  : 	}

	ret	0
??R?$xr_special_free@$00VCTheoraStream@@@@QAEXAAPAVCTheoraStream@@@Z ENDP ; xr_special_free<1,CTheoraStream>::operator()
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$xr_delete@VCTheoraStream@@@@YAXAAPAVCTheoraStream@@@Z
_TEXT	SEGMENT
??$xr_delete@VCTheoraStream@@@@YAXAAPAVCTheoraStream@@@Z PROC ; xr_delete<CTheoraStream>, COMDAT
; _ptr$ = esi

; 151  : 	if (ptr) 

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN1@xr_delete@3
	push	edi

; 152  : 	{
; 153  : 		xr_special_free<is_polymorphic<T>::result,T>()(ptr);

	push	eax
	call	___RTCastToVoid
	mov	ecx, DWORD PTR [esi]
	mov	edi, eax
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	add	esp, 4
	push	0
	call	edx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 154  : 		ptr = NULL;

	mov	DWORD PTR [esi], 0
	pop	edi
$LN1@xr_delete@3:

; 155  : 	}
; 156  : }

	ret	0
??$xr_delete@VCTheoraStream@@@@YAXAAPAVCTheoraStream@@@Z ENDP ; xr_delete<CTheoraStream>
_TEXT	ENDS
PUBLIC	?Height@CTheoraSurface@@QAEI_N@Z		; CTheoraSurface::Height
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\xrtheora_surface.cpp
;	COMDAT ?Height@CTheoraSurface@@QAEI_N@Z
_TEXT	SEGMENT
_bRealSize$ = 8						; size = 1
?Height@CTheoraSurface@@QAEI_N@Z PROC			; CTheoraSurface::Height, COMDAT
; _this$ = ecx

; 166  : //	return				m_rgb->t_info.frame_height;
; 167  : 
; 168  : 	if(bRealSize)

	cmp	BYTE PTR _bRealSize$[esp-4], 0
	je	SHORT $LN2@Height

; 169  : 		return				m_rgb->t_info.frame_height;

	mov	eax, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax+428]

; 172  : 
; 173  : }

	ret	4
$LN2@Height:

; 170  : 	else
; 171  : 		return btwPow2_Ceil((u32)m_rgb->t_info.frame_height);;

	mov	ecx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx+428]
	lea	eax, DWORD PTR [ecx-1]
	not	eax
	and	eax, ecx
	cmp	eax, ecx
	jae	SHORT $LN1@Height
$LL6@Height:
	add	eax, eax
	cmp	eax, ecx
	jb	SHORT $LL6@Height
$LN1@Height:

; 172  : 
; 173  : }

	ret	4
?Height@CTheoraSurface@@QAEI_N@Z ENDP			; CTheoraSurface::Height
_TEXT	ENDS
PUBLIC	?Width@CTheoraSurface@@QAEI_N@Z			; CTheoraSurface::Width
; Function compile flags: /Ogtpy
;	COMDAT ?Width@CTheoraSurface@@QAEI_N@Z
_TEXT	SEGMENT
_bRealSize$ = 8						; size = 1
?Width@CTheoraSurface@@QAEI_N@Z PROC			; CTheoraSurface::Width, COMDAT
; _this$ = ecx

; 155  : //	return				m_rgb->t_info.frame_width;
; 156  : 
; 157  : 	if(bRealSize)

	cmp	BYTE PTR _bRealSize$[esp-4], 0
	je	SHORT $LN2@Width

; 158  : 		return				m_rgb->t_info.frame_width;

	mov	eax, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax+424]

; 161  : 
; 162  : }

	ret	4
$LN2@Width:

; 159  : 	else
; 160  : 		return btwPow2_Ceil((u32)m_rgb->t_info.frame_width);

	mov	ecx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx+424]
	lea	eax, DWORD PTR [ecx-1]
	not	eax
	and	eax, ecx
	cmp	eax, ecx
	jae	SHORT $LN1@Width
$LL6@Width:
	add	eax, eax
	cmp	eax, ecx
	jb	SHORT $LL6@Width
$LN1@Width:

; 161  : 
; 162  : }

	ret	4
?Width@CTheoraSurface@@QAEI_N@Z ENDP			; CTheoraSurface::Width
_TEXT	ENDS
PUBLIC	?Play@CTheoraSurface@@QAEXHI@Z			; CTheoraSurface::Play
; Function compile flags: /Ogtpy
;	COMDAT ?Play@CTheoraSurface@@QAEXHI@Z
_TEXT	SEGMENT
__looped$ = 8						; size = 4
__time$ = 12						; size = 4
?Play@CTheoraSurface@@QAEXHI@Z PROC			; CTheoraSurface::Play, COMDAT
; _this$ = ecx

; 49   : 	playing				= TRUE;
; 50   : 	looped				= _looped;

	mov	eax, DWORD PTR __looped$[esp-4]

; 51   : 	tm_start			= _time;

	mov	edx, DWORD PTR __time$[esp-4]
	mov	DWORD PTR [ecx+36], 1
	mov	DWORD PTR [ecx+40], eax
	mov	DWORD PTR [ecx+12], edx

; 52   : 	prefetch			= -2;

	mov	DWORD PTR [ecx+32], -2			; fffffffeH

; 53   : }

	ret	8
?Play@CTheoraSurface@@QAEXHI@Z ENDP			; CTheoraSurface::Play
_TEXT	ENDS
PUBLIC	?Valid@CTheoraSurface@@QAEHXZ			; CTheoraSurface::Valid
; Function compile flags: /Ogtpy
;	COMDAT ?Valid@CTheoraSurface@@QAEHXZ
_TEXT	SEGMENT
?Valid@CTheoraSurface@@QAEHXZ PROC			; CTheoraSurface::Valid, COMDAT
; _this$ = ecx

; 44   : 	return				ready;

	mov	eax, DWORD PTR [ecx+24]

; 45   : }

	ret	0
?Valid@CTheoraSurface@@QAEHXZ ENDP			; CTheoraSurface::Valid
_TEXT	ENDS
PUBLIC	??1CTheoraSurface@@UAE@XZ			; CTheoraSurface::~CTheoraSurface
; Function compile flags: /Ogtpy
;	COMDAT ??1CTheoraSurface@@UAE@XZ
_TEXT	SEGMENT
??1CTheoraSurface@@UAE@XZ PROC				; CTheoraSurface::~CTheoraSurface, COMDAT
; _this$ = ecx

; 27   : {

	push	ebx

; 28   : 	xr_delete			(m_rgb);

	mov	ebx, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CTheoraSurface@@6B@
	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	push	edi
	je	SHORT $LN3@CTheoraSur
	push	eax
	call	___RTCastToVoid
	mov	ecx, DWORD PTR [esi+4]
	mov	edi, eax
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	add	esp, 4
	push	0
	call	edx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edi
	call	ebx
	mov	DWORD PTR [esi+4], 0
$LN3@CTheoraSur:

; 29   : 	xr_delete			(m_alpha);

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN8@CTheoraSur
	push	eax
	call	___RTCastToVoid
	mov	ecx, DWORD PTR [esi+8]
	mov	edi, eax
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	add	esp, 4
	push	0
	call	edx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edi
	call	ebx
	mov	DWORD PTR [esi+8], 0
$LN8@CTheoraSur:
	pop	edi
	pop	esi
	pop	ebx

; 30   : #ifdef SDL_OUTPUT
; 31   : 	SDL_Quit			();
; 32   : #endif
; 33   : }

	ret	0
??1CTheoraSurface@@UAE@XZ ENDP				; CTheoraSurface::~CTheoraSurface
_TEXT	ENDS
PUBLIC	??0CTheoraSurface@@QAE@XZ			; CTheoraSurface::CTheoraSurface
; Function compile flags: /Ogtpy
;	COMDAT ??0CTheoraSurface@@QAE@XZ
_TEXT	SEGMENT
??0CTheoraSurface@@QAE@XZ PROC				; CTheoraSurface::CTheoraSurface, COMDAT
; _this$ = ecx

; 6    : {

	mov	eax, ecx

; 7    : 	ready				= FALSE;

	xor	ecx, ecx
	mov	DWORD PTR [eax], OFFSET ??_7CTheoraSurface@@6B@
	mov	DWORD PTR [eax+24], ecx

; 8    : 	// streams
; 9    : 	m_rgb				= 0;

	mov	DWORD PTR [eax+4], ecx

; 10   : 	m_alpha				= 0;

	mov	DWORD PTR [eax+8], ecx

; 11   : 	// timing
; 12   : 	tm_play				= 0;

	mov	DWORD PTR [eax+16], ecx

; 13   : 	tm_total			= 0;

	mov	DWORD PTR [eax+20], ecx

; 14   : 	// sdl
; 15   : #ifdef SDL_OUTPUT
; 16   : 	sdl_screen			= 0;
; 17   : 	sdl_yuv_overlay		= 0;
; 18   : #endif
; 19   : 	// controls
; 20   : 	playing				= FALSE;

	mov	DWORD PTR [eax+36], ecx

; 21   : 	looped				= FALSE;

	mov	DWORD PTR [eax+40], ecx

; 22   : 	bShaderYUV2RGB		= TRUE;

	mov	DWORD PTR [eax+28], 1

; 23   : 	prefetch			= -2;

	mov	DWORD PTR [eax+32], -2			; fffffffeH

; 24   : }

	ret	0
??0CTheoraSurface@@QAE@XZ ENDP				; CTheoraSurface::CTheoraSurface
_TEXT	ENDS
PUBLIC	??4CTheoraSurface@@QAEAAV0@ABV0@@Z		; CTheoraSurface::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4CTheoraSurface@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4CTheoraSurface@@QAEAAV0@ABV0@@Z PROC			; CTheoraSurface::operator=, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	ecx, DWORD PTR ___that$[esp-4]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], edx
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], edx
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+32], edx
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax+36], edx
	mov	ecx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+40], ecx
	ret	4
??4CTheoraSurface@@QAEAAV0@ABV0@@Z ENDP			; CTheoraSurface::operator=
_TEXT	ENDS
PUBLIC	??0CTheoraSurface@@QAE@ABV0@@Z			; CTheoraSurface::CTheoraSurface
; Function compile flags: /Ogtpy
;	COMDAT ??0CTheoraSurface@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0CTheoraSurface@@QAE@ABV0@@Z PROC			; CTheoraSurface::CTheoraSurface, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	ecx, DWORD PTR ___that$[esp-4]
	mov	DWORD PTR [eax], OFFSET ??_7CTheoraSurface@@6B@
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], edx
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], edx
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+32], edx
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax+36], edx
	mov	ecx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+40], ecx
	ret	4
??0CTheoraSurface@@QAE@ABV0@@Z ENDP			; CTheoraSurface::CTheoraSurface
_TEXT	ENDS
PUBLIC	?IsPlaying@CTheoraSurface@@QAEHXZ		; CTheoraSurface::IsPlaying
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\xrtheora_surface.h
;	COMDAT ?IsPlaying@CTheoraSurface@@QAEHXZ
_TEXT	SEGMENT
?IsPlaying@CTheoraSurface@@QAEHXZ PROC			; CTheoraSurface::IsPlaying, COMDAT
; _this$ = ecx

; 52   : 	BOOL				IsPlaying			()					{return playing;}

	mov	eax, DWORD PTR [ecx+36]
	ret	0
?IsPlaying@CTheoraSurface@@QAEHXZ ENDP			; CTheoraSurface::IsPlaying
_TEXT	ENDS
PUBLIC	?Pause@CTheoraSurface@@QAEXH@Z			; CTheoraSurface::Pause
; Function compile flags: /Ogtpy
;	COMDAT ?Pause@CTheoraSurface@@QAEXH@Z
_TEXT	SEGMENT
__pause$ = 8						; size = 4
?Pause@CTheoraSurface@@QAEXH@Z PROC			; CTheoraSurface::Pause, COMDAT
; _this$ = ecx

; 50   : 	void				Pause				(BOOL _pause)		{playing=!_pause;}

	xor	eax, eax
	cmp	DWORD PTR __pause$[esp-4], eax
	sete	al
	mov	DWORD PTR [ecx+36], eax
	ret	4
?Pause@CTheoraSurface@@QAEXH@Z ENDP			; CTheoraSurface::Pause
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrcore\xrmemory_subst_msvc.h
;	COMDAT ??$xr_new@VCTheoraStream@@@@YAPAVCTheoraStream@@XZ
_TEXT	SEGMENT
??$xr_new@VCTheoraStream@@@@YAPAVCTheoraStream@@XZ PROC	; xr_new<CTheoraStream>, COMDAT

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	624					; 00000270H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 69   : 	return new (ptr) T();

	test	eax, eax
	je	SHORT $LN3@xr_new@2
	mov	ecx, eax
	jmp	??0CTheoraStream@@QAE@XZ		; CTheoraStream::CTheoraStream
$LN3@xr_new@2:
	xor	eax, eax

; 70   : }

	ret	0
??$xr_new@VCTheoraStream@@@@YAPAVCTheoraStream@@XZ ENDP	; xr_new<CTheoraStream>
_TEXT	ENDS
PUBLIC	?Reset@CTheoraSurface@@IAEXXZ			; CTheoraSurface::Reset
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\xrtheora_surface.cpp
;	COMDAT ?Reset@CTheoraSurface@@IAEXXZ
_TEXT	SEGMENT
?Reset@CTheoraSurface@@IAEXXZ PROC			; CTheoraSurface::Reset, COMDAT
; _this$ = ecx

; 36   : {

	push	esi
	mov	esi, ecx

; 37   : 	if (m_rgb)			m_rgb->Reset	();

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN2@Reset
	call	?Reset@CTheoraStream@@QAEXXZ		; CTheoraStream::Reset
$LN2@Reset:

; 38   : 	if (m_alpha)		m_alpha->Reset	();

	mov	ecx, DWORD PTR [esi+8]
	test	ecx, ecx
	je	SHORT $LN5@Reset
	call	?Reset@CTheoraStream@@QAEXXZ		; CTheoraStream::Reset
$LN5@Reset:

; 39   : 	tm_play				= 0;

	mov	DWORD PTR [esi+16], 0
	pop	esi

; 40   : }

	ret	0
?Reset@CTheoraSurface@@IAEXXZ ENDP			; CTheoraSurface::Reset
_TEXT	ENDS
PUBLIC	??_GCTheoraSurface@@UAEPAXI@Z			; CTheoraSurface::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GCTheoraSurface@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCTheoraSurface@@UAEPAXI@Z PROC			; CTheoraSurface::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CTheoraSurface@@UAE@XZ		; CTheoraSurface::~CTheoraSurface
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN10@scalar@3
	test	esi, esi
	je	SHORT $LN10@scalar@3
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN10@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_GCTheoraSurface@@UAEPAXI@Z ENDP			; CTheoraSurface::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?Stop@CTheoraSurface@@QAEXXZ			; CTheoraSurface::Stop
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\xrtheora_surface.h
;	COMDAT ?Stop@CTheoraSurface@@QAEXXZ
_TEXT	SEGMENT
?Stop@CTheoraSurface@@QAEXXZ PROC			; CTheoraSurface::Stop, COMDAT
; _this$ = ecx

; 51   : 	void				Stop				()					{playing=FALSE;Reset();}

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	mov	DWORD PTR [esi+36], 0
	je	SHORT $LN4@Stop
	call	?Reset@CTheoraStream@@QAEXXZ		; CTheoraStream::Reset
$LN4@Stop:
	mov	ecx, DWORD PTR [esi+8]
	test	ecx, ecx
	je	SHORT $LN7@Stop
	call	?Reset@CTheoraStream@@QAEXXZ		; CTheoraStream::Reset
$LN7@Stop:
	mov	DWORD PTR [esi+16], 0
	pop	esi
	ret	0
?Stop@CTheoraSurface@@QAEXXZ ENDP			; CTheoraSurface::Stop
PUBLIC	__real@3f950a8b
PUBLIC	?DecompressFrame@CTheoraSurface@@QAEXPAIIAAH@Z	; CTheoraSurface::DecompressFrame
;	COMDAT __real@3f950a8b
; File d:\clearsky\sources\engine\xrcore\_color.h
CONST	SEGMENT
__real@3f950a8b DD 03f950a8br			; 1.16438
; Function compile flags: /Ogtpy
; File d:\clearsky\sources\engine\xrengine\xrtheora_surface.cpp
CONST	ENDS
;	COMDAT ?DecompressFrame@CTheoraSurface@@QAEXPAIIAAH@Z
_TEXT	SEGMENT
_width$ = -52						; size = 4
_height$ = -48						; size = 4
tv969 = -44						; size = 4
_h$115690 = -44						; size = 4
_yuv_alpha$ = -40					; size = 4
tv240 = -36						; size = 4
_Y1$115732 = -36					; size = 4
_Y$115695 = -36						; size = 4
_yuv_rgb$ = -32						; size = 4
_y_h$115724 = -28					; size = 4
_U$115696 = -28						; size = 4
_buff_step$115722 = -24					; size = 4
_V$115697 = -24						; size = 4
_y10$115741 = -20					; size = 4
_U$115731 = -20						; size = 4
tv1126 = -16						; size = 4
_V$115733 = -16						; size = 4
tv1077 = -12						; size = 4
tv1121 = -8						; size = 4
_y11$115742 = -4					; size = 4
_Y$115754 = 8						; size = 4
_pos$115688 = 8						; size = 4
_data$ = 8						; size = 4
_h$115750 = 12						; size = 4
_uv_h$115725 = 12					; size = 4
__width$ = 12						; size = 4
_a$291855 = 16						; size = 4
__pos$ = 16						; size = 4
?DecompressFrame@CTheoraSurface@@QAEXPAIIAAH@Z PROC	; CTheoraSurface::DecompressFrame, COMDAT
; _this$ = ecx

; 176  : {

	sub	esp, 52					; 00000034H

; 177  : 	VERIFY		(m_rgb);
; 178  : 	yuv_buffer*	yuv_rgb		= m_rgb->CurrentFrame();

	mov	eax, DWORD PTR [ecx+4]

; 179  : 	yuv_buffer*	yuv_alpha	= m_alpha?m_alpha->CurrentFrame():0;

	mov	edx, DWORD PTR [ecx+8]
	push	ebx
	push	ebp
	xor	ebp, ebp
	cmp	edx, ebp
	push	esi
	lea	ebx, DWORD PTR [eax+564]
	push	edi
	mov	DWORD PTR _yuv_rgb$[esp+68], ebx
	je	SHORT $LN28@Decompress
	add	edx, 564				; 00000234H
	mov	DWORD PTR _yuv_alpha$[esp+68], edx
	jmp	SHORT $LN29@Decompress
$LN28@Decompress:
	mov	DWORD PTR _yuv_alpha$[esp+68], ebp
$LN29@Decompress:

; 180  : 
; 181  : 	u32 width				= Width(true);
; 182  : 	u32 height				= Height(true);
; 183  : 
; 184  : 	static const float K = 0.256788f + 0.504129f + 0.097906f;
; 185  : 
; 186  : 	// we use ffmpeg2theora for encoding, so only OC_PF_420 valid
; 187  : 	u32 pixelformat			= m_rgb->t_info.pixelformat;
; 188  : 
; 189  : 	// rgb
; 190  : 	if (yuv_rgb){

	cmp	ebx, ebp
	mov	esi, DWORD PTR [eax+424]
	mov	edx, DWORD PTR [eax+428]
	mov	edi, DWORD PTR _data$[esp+64]
	mov	DWORD PTR _width$[esp+68], esi
	mov	DWORD PTR _height$[esp+68], edx
	je	$LN22@Decompress

; 191  : 		yuv_buffer&	yuv	= *yuv_rgb;
; 192  : 
; 193  : 		u32 pos = 0;
; 194  : 
; 195  : 		if( ! bShaderYUV2RGB ) {

	cmp	DWORD PTR [ecx+28], ebp
	mov	DWORD PTR _pos$115688[esp+64], ebp
	jne	$LN21@Decompress

; 196  : 			for (u32 h=0; h<height; ++h) {

	xor	ecx, ecx
	cmp	edx, ebp
	mov	DWORD PTR _h$115690[esp+68], ecx
	jbe	$LN112@Decompress
	jmp	SHORT $LN20@Decompress
	npad	6
$LL108@Decompress:
	mov	ecx, DWORD PTR _h$115690[esp+68]
$LN20@Decompress:

; 197  : 
; 198  : 				u32 uv_stride_add = yuv.uv_stride * ( h >> 1 );
; 199  : 				u8* Y		= yuv.y + yuv.y_stride * h;

	mov	edx, DWORD PTR [ebx+8]

; 200  : 				u8* U		= yuv.u + uv_stride_add;

	mov	ebp, DWORD PTR [ebx+28]
	imul	edx, ecx
	add	edx, DWORD PTR [ebx+24]
	mov	eax, ecx

; 201  : 				u8* V		= yuv.v + uv_stride_add;

	mov	ecx, DWORD PTR [ebx+32]
	shr	eax, 1
	imul	eax, DWORD PTR [ebx+20]
	add	ebp, eax
	add	ecx, eax

; 202  : 
; 203  : 				for (u32 w=0; w<width; ++w) {

	xor	esi, esi
	cmp	DWORD PTR _width$[esp+68], esi
	mov	DWORD PTR _Y$115695[esp+68], edx
	mov	DWORD PTR _U$115696[esp+68], ebp
	mov	DWORD PTR _V$115697[esp+68], ecx
	jbe	$LN15@Decompress
	jmp	SHORT $LN17@Decompress
	npad	7
$LL107@Decompress:
	mov	ecx, DWORD PTR _V$115697[esp+68]
	mov	ebp, DWORD PTR _U$115696[esp+68]
	mov	edx, DWORD PTR _Y$115695[esp+68]
$LN17@Decompress:

; 204  : 
; 205  : 					u32 uv_idx = w >> 1;
; 206  : 					u8 y	= Y[ w ];
; 207  : 					u8 u	= U[ uv_idx ];
; 208  : 					u8 v	= V[ uv_idx ];
; 209  : 
; 210  : 					int C	= y - 16;

	movzx	edx, BYTE PTR [esi+edx]
	mov	eax, esi
	shr	eax, 1

; 211  : 					int D	= u - 128;
; 212  : 					int E	= v - 128;

	movzx	ecx, BYTE PTR [eax+ecx]
	movzx	ebp, BYTE PTR [eax+ebp]
	sub	ecx, 128				; 00000080H
	sub	edx, 16					; 00000010H

; 213  : 
; 214  : 					int R	= clampr(( 298 * C           + 409 * E + 128) >> 8,0,255);

	mov	eax, ecx
	imul	edx, 298				; 0000012aH
	imul	eax, 409				; 00000199H
	lea	eax, DWORD PTR [eax+edx+128]
	sub	ebp, 128				; 00000080H
	sar	eax, 8
	jns	SHORT $LN57@Decompress
	xor	eax, eax
	jmp	SHORT $LN55@Decompress
$LN57@Decompress:
	cmp	eax, 255				; 000000ffH
	jle	SHORT $LN55@Decompress
	mov	eax, 255				; 000000ffH
$LN55@Decompress:

; 215  : 					int G	= clampr(( 298 * C - 100 * D - 208 * E + 128) >> 8,0,255);

	imul	ecx, 208				; 000000d0H
	mov	ebx, ebp
	imul	ebx, -100				; ffffff9cH
	sub	ebx, ecx
	lea	ecx, DWORD PTR [ebx+edx+128]
	sar	ecx, 8
	jns	SHORT $LN63@Decompress
	xor	ecx, ecx
	jmp	SHORT $LN61@Decompress
$LN63@Decompress:
	cmp	ecx, 255				; 000000ffH
	jle	SHORT $LN61@Decompress
	mov	ecx, 255				; 000000ffH
$LN61@Decompress:

; 216  : 					int B	= clampr(( 298 * C + 516 * D           + 128) >> 8,0,255);

	imul	ebp, 516				; 00000204H
	lea	edx, DWORD PTR [edx+ebp+128]
	sar	edx, 8
	jns	SHORT $LN69@Decompress
	xor	edx, edx
	jmp	SHORT $LN67@Decompress
$LN69@Decompress:
	cmp	edx, 255				; 000000ffH
	jle	SHORT $LN67@Decompress
	mov	edx, 255				; 000000ffH
$LN67@Decompress:

; 217  : 
; 218  : 					data[pos] = color_rgba(R,G,B,255);

	or	eax, -256				; ffffff00H
	movzx	ecx, cl
	shl	eax, 8
	or	eax, ecx
	mov	ecx, DWORD PTR _pos$115688[esp+64]
	movzx	edx, dl
	shl	eax, 8
	or	eax, edx
	mov	DWORD PTR [edi+ecx*4], eax

; 219  : 
; 220  : 					pos++;

	add	ecx, 1
	add	esi, 1
	cmp	esi, DWORD PTR _width$[esp+68]
	mov	DWORD PTR _pos$115688[esp+64], ecx
	jb	$LL107@Decompress

; 202  : 
; 203  : 				for (u32 w=0; w<width; ++w) {

	mov	ebx, DWORD PTR _yuv_rgb$[esp+68]
$LN15@Decompress:

; 221  : 				}
; 222  : 				pos += _width;

	mov	eax, DWORD PTR __width$[esp+64]
	add	DWORD PTR _pos$115688[esp+64], eax
	mov	eax, DWORD PTR _h$115690[esp+68]
	add	eax, 1
	cmp	eax, DWORD PTR _height$[esp+68]
	mov	DWORD PTR _h$115690[esp+68], eax
	jb	$LL108@Decompress

; 223  : 			}

	jmp	$LN113@Decompress
$LN21@Decompress:

; 224  : 		} else {
; 225  : 
; 226  : 			u32 buff_step = width + _width;

	mov	ecx, DWORD PTR __width$[esp+64]
	add	esi, ecx

; 227  : 			u32 buff_double_step = buff_step << 1;
; 228  : 
; 229  : 			for ( u32 y_h = 0 , uv_h = 0 ; y_h < height ; y_h += 2 , ++uv_h , pos += buff_double_step ) {

	test	edx, edx
	mov	DWORD PTR _buff_step$115722[esp+68], esi
	mov	DWORD PTR _y_h$115724[esp+68], ebp
	mov	DWORD PTR _uv_h$115725[esp+64], ebp
	jbe	$LN112@Decompress
$LL109@Decompress:

; 230  : 
; 231  : 				u32 uv_stride_add = yuv.uv_stride * uv_h;
; 232  : 				u8* Y0		= yuv.y + yuv.y_stride * y_h;

	mov	ecx, DWORD PTR [ebx+8]
	mov	esi, DWORD PTR [ebx+20]
	imul	esi, DWORD PTR _uv_h$115725[esp+64]

; 233  : 				u8* U		= yuv.u + uv_stride_add;

	mov	edx, DWORD PTR [ebx+28]
	mov	eax, ecx
	imul	eax, ebp
	add	eax, DWORD PTR [ebx+24]
	add	edx, esi
	mov	DWORD PTR _U$115731[esp+68], edx

; 234  : 				u8* Y1		= Y0 + yuv.y_stride;

	lea	edx, DWORD PTR [ecx+eax]

; 235  : 				u8* V		= yuv.v + uv_stride_add;

	mov	ecx, DWORD PTR [ebx+32]
	add	ecx, esi

; 236  : 
; 237  : 				for ( u32 y_w = 0 , uv_w = 0 ; y_w < width ; y_w += 2 , ++uv_w ) {

	cmp	DWORD PTR _width$[esp+68], 0
	mov	DWORD PTR _Y1$115732[esp+68], edx
	mov	DWORD PTR _V$115733[esp+68], ecx
	jbe	$LN12@Decompress
	mov	ebp, DWORD PTR _pos$115688[esp+64]
	mov	esi, eax
	sub	esi, DWORD PTR _Y1$115732[esp+68]
	sub	eax, ebp
	mov	DWORD PTR tv1121[esp+68], eax
	mov	eax, DWORD PTR _U$115731[esp+68]
	mov	ebx, ecx
	sub	eax, ebx
	mov	DWORD PTR tv1126[esp+68], eax
	mov	eax, DWORD PTR _width$[esp+68]
	add	eax, -1
	shr	eax, 1
	add	edx, 1
	add	eax, 1
	mov	DWORD PTR tv969[esp+68], ebx
	lea	ecx, DWORD PTR [ebp*4]
	mov	DWORD PTR tv1077[esp+68], esi
	mov	DWORD PTR tv240[esp+68], eax
	npad	9
$LL104@Decompress:

; 238  : 
; 239  : 					u32 y00	= Y0[ y_w ] << 16;
; 240  : 					u32 y01	= Y0[ y_w + 1 ] << 16;

	mov	eax, DWORD PTR tv1077[esp+68]
	movzx	esi, BYTE PTR [edx+eax]

; 241  : 
; 242  : 					u32 y10	= Y1[ y_w ] << 16;

	movzx	eax, BYTE PTR [edx-1]
	shl	eax, 16					; 00000010H
	mov	DWORD PTR _y10$115741[esp+68], eax

; 243  : 					u32 y11	= Y1[ y_w + 1 ] << 16;

	movzx	eax, BYTE PTR [edx]
	shl	eax, 16					; 00000010H
	mov	DWORD PTR _y11$115742[esp+68], eax

; 244  : 
; 245  : 					u8 u	= U[ uv_w ];
; 246  : 					u8 v	= V[ uv_w ];
; 247  : 
; 248  : 					u32 idx = pos + y_w;
; 249  : 
; 250  : 					u32 common_part = 255 << 24 | u << 8 | v;

	mov	eax, DWORD PTR tv1126[esp+68]
	movzx	eax, BYTE PTR [ebx+eax]
	movzx	ebx, BYTE PTR [ebx]
	or	eax, -65536				; ffff0000H
	shl	eax, 8
	or	eax, ebx

; 251  : 
; 252  : 					data[ idx ]			= ( common_part | y00 );

	mov	ebx, DWORD PTR tv1121[esp+68]
	movzx	ebx, BYTE PTR [ebx+ebp]
	shl	ebx, 16					; 00000010H
	or	ebx, eax
	mov	DWORD PTR [ecx+edi], ebx
	shl	esi, 16					; 00000010H

; 253  : 					data[ idx + 1 ]		= ( common_part | y01 );

	mov	ebx, eax
	or	ebx, esi

; 254  : 
; 255  : 					idx += buff_step;

	mov	esi, DWORD PTR _buff_step$115722[esp+68]
	mov	DWORD PTR [ecx+edi+4], ebx

; 256  : 
; 257  : 					data[ idx ]			= ( common_part | y10 );

	mov	ebx, eax
	or	ebx, DWORD PTR _y10$115741[esp+68]

; 258  : 					data[ idx + 1 ]		= ( common_part | y11 );

	or	eax, DWORD PTR _y11$115742[esp+68]
	lea	esi, DWORD PTR [ecx+esi*4]
	mov	DWORD PTR [esi+edi], ebx
	mov	ebx, DWORD PTR tv969[esp+68]
	add	ebx, 1
	add	ecx, 8
	add	edx, 2
	add	ebp, 2
	sub	DWORD PTR tv240[esp+68], 1
	mov	DWORD PTR [esi+edi+4], eax
	mov	DWORD PTR tv969[esp+68], ebx
	jne	SHORT $LL104@Decompress
	mov	ebx, DWORD PTR _yuv_rgb$[esp+68]
	mov	ebp, DWORD PTR _y_h$115724[esp+68]
$LN12@Decompress:
	mov	eax, DWORD PTR _buff_step$115722[esp+68]
	add	DWORD PTR _uv_h$115725[esp+64], 1
	add	eax, eax
	add	DWORD PTR _pos$115688[esp+64], eax
	add	ebp, 2
	cmp	ebp, DWORD PTR _height$[esp+68]
	mov	DWORD PTR _y_h$115724[esp+68], ebp
	jb	$LL109@Decompress
$LN113@Decompress:

; 227  : 			u32 buff_double_step = buff_step << 1;
; 228  : 
; 229  : 			for ( u32 y_h = 0 , uv_h = 0 ; y_h < height ; y_h += 2 , ++uv_h , pos += buff_double_step ) {

	mov	edx, DWORD PTR _height$[esp+68]
$LN112@Decompress:

; 259  : 				}				
; 260  : 			}
; 261  : 		}
; 262  : 		_pos = pos;

	mov	ecx, DWORD PTR __pos$[esp+64]
	mov	eax, DWORD PTR _pos$115688[esp+64]
	mov	DWORD PTR [ecx], eax
$LN22@Decompress:

; 263  : 	}
; 264  : 
; 265  : 	// alpha
; 266  : 	if (yuv_alpha)

	mov	esi, DWORD PTR _yuv_alpha$[esp+68]
	test	esi, esi
	je	$LN4@Decompress

; 267  : 	{
; 268  : 		yuv_buffer&	yuv			= *yuv_alpha;
; 269  : 		u32 pos					= 0;
; 270  : 		for (u32 h=0; h<height; ++h)

	xor	ecx, ecx
	xor	ebp, ebp
	test	edx, edx
	mov	DWORD PTR _h$115750[esp+64], ecx
	jbe	$LN4@Decompress
	movss	xmm0, DWORD PTR __real@3f950a8b
	jmp	SHORT $LN6@Decompress
	npad	4
$LL111@Decompress:
	mov	esi, DWORD PTR _yuv_alpha$[esp+68]
$LN6@Decompress:

; 271  : 		{
; 272  : 			u8* Y		= yuv.y+yuv.y_stride*h;

	mov	eax, DWORD PTR [esi+8]
	imul	eax, ecx
	add	eax, DWORD PTR [esi+24]

; 273  : 			for (u32 w=0; w<width; ++w)

	xor	ebx, ebx
	cmp	DWORD PTR _width$[esp+68], ebx
	mov	DWORD PTR _Y$115754[esp+64], eax
	jbe	$LN5@Decompress
	jmp	SHORT $LN3@Decompress
	npad	1
$LL106@Decompress:
	mov	eax, DWORD PTR _Y$115754[esp+64]
$LN3@Decompress:

; 274  : 			{
; 275  : 				u8 y			= Y[w];
; 276  : 				u32& clr		= data[++pos];
; 277  : 				clr				= subst_alpha(clr,iFloor(float((y-16))/K));

	movzx	ecx, BYTE PTR [ebx+eax]
	sub	ecx, 16					; 00000010H
	cvtsi2ss xmm1, ecx
	mulss	xmm1, xmm0
	movss	DWORD PTR _a$291855[esp+64], xmm1
	mov	esi, DWORD PTR _a$291855[esp+64]
	mov	edx, esi
	sar	edx, 23					; 00000017H
	and	edx, 255				; 000000ffH
	mov	ecx, 158				; 0000009eH
	sub	ecx, edx
	mov	edx, esi
	or	edx, -8388608				; ff800000H
	shl	edx, 8
	shr	edx, cl
	sub	ecx, 96					; 00000060H
	mov	eax, 1
	shl	eax, cl
	add	ebp, 1
	sub	eax, 1
	sar	eax, 8
	and	eax, esi
	neg	eax
	sbb	eax, eax
	add	eax, 1
	sar	esi, 31					; 0000001fH
	and	eax, esi
	sub	edx, eax
	mov	eax, DWORD PTR [edi+ebp*4]
	add	ecx, 64					; 00000040H
	shl	edx, 24					; 00000018H
	sar	ecx, 31					; 0000001fH
	shl	ecx, 24					; 00000018H
	and	edx, ecx
	shl	esi, 24					; 00000018H
	xor	edx, esi
	and	eax, 16777215				; 00ffffffH
	or	edx, eax
	add	ebx, 1
	cmp	ebx, DWORD PTR _width$[esp+68]
	mov	DWORD PTR [edi+ebp*4], edx
	jb	$LL106@Decompress
	mov	ecx, DWORD PTR _h$115750[esp+64]
	mov	edx, DWORD PTR _height$[esp+68]
$LN5@Decompress:
	add	ecx, 1
	cmp	ecx, edx
	mov	DWORD PTR _h$115750[esp+64], ecx
	jb	$LL111@Decompress
$LN4@Decompress:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 278  : 			}
; 279  : 		}
; 280  : 	}
; 281  : }

	add	esp, 52					; 00000034H
	ret	12					; 0000000cH
?DecompressFrame@CTheoraSurface@@QAEXPAIIAAH@Z ENDP	; CTheoraSurface::DecompressFrame
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_ECTheoraSurface@@UAEPAXI@Z
_TEXT	SEGMENT
$T291985 = -8						; size = 4
tv162 = -4						; size = 4
___flags$ = 8						; size = 4
??_ECTheoraSurface@@UAEPAXI@Z PROC			; CTheoraSurface::`vector deleting destructor', COMDAT
; _this$ = ecx
	sub	esp, 8
	test	BYTE PTR ___flags$[esp+4], 2
	push	edi
	mov	edi, ecx
	je	$LN3@vector@23
	mov	eax, DWORD PTR [edi-4]
	push	ebx
	lea	ecx, DWORD PTR [edi-4]
	push	ebp
	mov	ebp, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	push	esi
	mov	esi, eax
	imul	esi, 44					; 0000002cH
	add	esi, edi
	sub	eax, 1
	mov	DWORD PTR tv162[esp+24], ecx
	mov	DWORD PTR $T291985[esp+24], eax
	mov	ebx, 0
	js	SHORT $LN6@vector@23
	npad	7
$LL7@vector@23:
	sub	esi, 44					; 0000002cH
	mov	DWORD PTR [esi], OFFSET ??_7CTheoraSurface@@6B@
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, ebx
	je	SHORT $LN12@vector@23
	push	eax
	call	___RTCastToVoid
	mov	ecx, DWORD PTR [esi+4]
	mov	edi, eax
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	add	esp, 4
	push	ebx
	call	edx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edi
	call	ebp
	mov	DWORD PTR [esi+4], ebx
$LN12@vector@23:
	mov	eax, DWORD PTR [esi+8]
	cmp	eax, ebx
	je	SHORT $LN17@vector@23
	push	eax
	call	___RTCastToVoid
	mov	ecx, DWORD PTR [esi+8]
	mov	edi, eax
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	add	esp, 4
	push	ebx
	call	edx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edi
	call	ebp
	mov	DWORD PTR [esi+8], ebx
$LN17@vector@23:
	sub	DWORD PTR $T291985[esp+24], 1
	jns	SHORT $LL7@vector@23
	mov	ecx, DWORD PTR tv162[esp+24]
$LN6@vector@23:
	test	BYTE PTR ___flags$[esp+20], 1
	je	SHORT $LN24@vector@23
	cmp	ecx, ebx
	je	SHORT $LN24@vector@23
	push	ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	ebp
$LN24@vector@23:
	mov	eax, DWORD PTR tv162[esp+24]
	pop	esi
	pop	ebp
	pop	ebx
	pop	edi
	add	esp, 8
	ret	4
$LN3@vector@23:
	call	??1CTheoraSurface@@UAE@XZ		; CTheoraSurface::~CTheoraSurface
	test	BYTE PTR ___flags$[esp+8], 1
	je	SHORT $LN29@vector@23
	test	edi, edi
	je	SHORT $LN29@vector@23
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN29@vector@23:
	mov	eax, edi
	pop	edi
	add	esp, 8
	ret	4
??_ECTheoraSurface@@UAEPAXI@Z ENDP			; CTheoraSurface::`vector deleting destructor'
PUBLIC	?Update@CTheoraSurface@@QAEHI@Z			; CTheoraSurface::Update
; Function compile flags: /Ogtpy
;	COMDAT ?Update@CTheoraSurface@@QAEHI@Z
_TEXT	SEGMENT
__time$ = 8						; size = 4
?Update@CTheoraSurface@@QAEHI@Z PROC			; CTheoraSurface::Update, COMDAT
; _this$ = ecx

; 56   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	ebx
	push	esi
	mov	esi, ecx

; 57   : 	VERIFY				(Valid());
; 58   : 	BOOL redraw			= FALSE;
; 59   : 	
; 60   : 	if(prefetch<0) //fake. first updated frame is data loading

	mov	eax, DWORD PTR [esi+32]
	xor	ebx, ebx
	test	eax, eax
	jge	SHORT $LN10@Update@3

; 61   : 	{
; 62   : 		++prefetch;

	add	eax, 1
	mov	DWORD PTR [esi+32], eax

; 63   : 		if(prefetch==0)

	jne	SHORT $LN9@Update@3

; 64   : 			tm_start		= _time;

	mov	eax, DWORD PTR __time$[ebp]
	mov	DWORD PTR [esi+12], eax
$LN9@Update@3:

; 65   : 
; 66   : 		tm_play				= 0;

	mov	DWORD PTR [esi+16], ebx

; 67   : 	}else

	jmp	SHORT $LN7@Update@3
$LN10@Update@3:

; 68   : 	{
; 69   : 		if(playing)

	cmp	DWORD PTR [esi+36], ebx
	je	SHORT $LN1@Update@3

; 70   : 			tm_play			= _time-tm_start;

	mov	ecx, DWORD PTR __time$[ebp]
	sub	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+16], ecx
$LN7@Update@3:

; 71   : 	}
; 72   : 	if (playing)

	cmp	DWORD PTR [esi+36], ebx
	je	SHORT $LN1@Update@3

; 73   : 	{
; 74   : 		if (tm_play>=tm_total)

	mov	eax, DWORD PTR [esi+20]
	cmp	DWORD PTR [esi+16], eax
	jb	SHORT $LN3@Update@3

; 75   : 		{ 
; 76   : 			if (looped)

	cmp	DWORD PTR [esi+40], ebx
	je	SHORT $LN4@Update@3

; 77   : 			{
; 78   : 				tm_start = tm_start+tm_total;
; 79   : 				Reset	();

	mov	ecx, DWORD PTR [esi+4]
	add	DWORD PTR [esi+12], eax
	test	ecx, ecx
	je	SHORT $LN17@Update@3
	call	?Reset@CTheoraStream@@QAEXXZ		; CTheoraStream::Reset
$LN17@Update@3:
	mov	ecx, DWORD PTR [esi+8]
	test	ecx, ecx
	je	SHORT $LN16@Update@3
	call	?Reset@CTheoraStream@@QAEXXZ		; CTheoraStream::Reset
$LN16@Update@3:
	mov	DWORD PTR [esi+16], ebx
$LN3@Update@3:

; 83   : 				return	FALSE;
; 84   : 			}
; 85   : 		}
; 86   : 		if (m_rgb)		redraw|=m_rgb->Decode	(tm_play);

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN2@Update@3
	mov	edx, DWORD PTR [esi+16]
	push	edx
	call	?Decode@CTheoraStream@@QAEHI@Z		; CTheoraStream::Decode
	mov	ebx, eax
$LN2@Update@3:

; 87   : 		if (m_alpha)	redraw|=m_alpha->Decode	(tm_play);

	mov	ecx, DWORD PTR [esi+8]
	test	ecx, ecx
	je	SHORT $LN1@Update@3
	mov	eax, DWORD PTR [esi+16]
	push	eax
	call	?Decode@CTheoraStream@@QAEHI@Z		; CTheoraStream::Decode
	or	ebx, eax
$LN1@Update@3:

; 88   : 	}
; 89   : 
; 90   : 	return redraw;

	mov	eax, ebx

; 91   : } 

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN4@Update@3:

; 80   : 			}else
; 81   : 			{
; 82   : 				Stop	();

	mov	ecx, esi
	call	?Stop@CTheoraSurface@@QAEXXZ		; CTheoraSurface::Stop

; 91   : } 

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Update@CTheoraSurface@@QAEHI@Z ENDP			; CTheoraSurface::Update
PUBLIC	?Load@CTheoraSurface@@QAEHPBD@Z			; CTheoraSurface::Load
; Function compile flags: /Ogtpy
;	COMDAT ?Load@CTheoraSurface@@QAEHPBD@Z
_TEXT	SEGMENT
_res$ = -1044						; size = 4
_alpha$115628 = -1040					; size = 520
_ext$115629 = -520					; size = 520
_fname$ = 8						; size = 4
?Load@CTheoraSurface@@QAEHPBD@Z PROC			; CTheoraSurface::Load, COMDAT
; _this$ = ecx

; 94   : {

	sub	esp, 1044				; 00000414H
	push	ebx
	push	esi
	mov	esi, ecx

; 95   : 	VERIFY				(FALSE==ready);
; 96   : 	m_rgb				= xr_new<CTheoraStream>();

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	624					; 00000270H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	xor	ebx, ebx
	cmp	eax, ebx
	je	SHORT $LN22@Load@15
	mov	ecx, eax
	call	??0CTheoraStream@@QAE@XZ		; CTheoraStream::CTheoraStream
	jmp	SHORT $LN23@Load@15
$LN22@Load@15:
	xor	eax, eax
$LN23@Load@15:
	push	ebp
	push	edi

; 97   : 	BOOL res			= m_rgb->Load(fname);

	mov	edi, DWORD PTR _fname$[esp+1056]
	push	edi
	mov	ecx, eax
	mov	DWORD PTR [esi+4], eax
	call	?Load@CTheoraStream@@QAEHPBD@Z		; CTheoraStream::Load

; 98   : 	if (res){

	cmp	eax, ebx
	mov	DWORD PTR _res$[esp+1060], eax
	je	$LN10@Load@15

; 99   : 		string_path		alpha,ext;
; 100  : 		xr_strcpy			(alpha,fname);

	mov	ebp, DWORD PTR __imp__strncpy_s
	push	520					; 00000208H
	push	edi
	lea	eax, DWORD PTR _alpha$115628[esp+1068]
	push	520					; 00000208H
	push	eax
	call	ebp

; 101  : 		pstr pext		= strext(alpha);

	lea	ecx, DWORD PTR _alpha$115628[esp+1076]
	push	46					; 0000002eH
	push	ecx
	call	DWORD PTR __imp__strrchr
	mov	edi, eax
	add	esp, 24					; 00000018H

; 102  : 		if (pext){	

	cmp	edi, ebx
	je	SHORT $LN13@Load@15

; 103  : 			xr_strcpy		(ext,pext);

	push	520					; 00000208H
	push	edi
	lea	edx, DWORD PTR _ext$115629[esp+1068]
	push	520					; 00000208H
	push	edx
	call	ebp
	add	esp, 16					; 00000010H

; 104  : 			*pext		= 0;

	mov	BYTE PTR [edi], bl
$LN13@Load@15:

; 105  : 		}
; 106  : 		strconcat		(sizeof(alpha),alpha,alpha,"#alpha",ext);

	lea	eax, DWORD PTR _ext$115629[esp+1060]
	push	eax
	push	OFFSET ??_C@_06FCLBCFNB@?$CDalpha?$AA@
	lea	ecx, DWORD PTR _alpha$115628[esp+1068]
	push	ecx
	mov	edx, ecx
	push	edx
	push	520					; 00000208H
	call	DWORD PTR __imp_?strconcat@@YAPADHPADPBD11@Z

; 107  : 		if (FS.exist(alpha)){

	mov	ecx, DWORD PTR __imp_?xr_FS@@3PAVCLocatorAPI@@A
	mov	ecx, DWORD PTR [ecx]
	add	esp, 20					; 00000014H
	lea	eax, DWORD PTR _alpha$115628[esp+1060]
	push	eax
	call	DWORD PTR __imp_?exist@CLocatorAPI@@QAEPBUfile@1@PBD@Z
	test	eax, eax
	je	$LN11@Load@15

; 108  : 			m_alpha		= xr_new<CTheoraStream>	();

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	624					; 00000270H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	cmp	eax, ebx
	je	SHORT $LN38@Load@15
	mov	ecx, eax
	call	??0CTheoraStream@@QAE@XZ		; CTheoraStream::CTheoraStream
	jmp	SHORT $LN39@Load@15
$LN38@Load@15:
	xor	eax, eax
$LN39@Load@15:

; 109  : 			if (!m_alpha->Load(alpha))	res = FALSE;

	lea	edx, DWORD PTR _alpha$115628[esp+1060]
	push	edx
	mov	ecx, eax
	mov	DWORD PTR [esi+8], eax
	call	?Load@CTheoraStream@@QAEHPBD@Z		; CTheoraStream::Load
	test	eax, eax
	jne	$LN11@Load@15
	mov	DWORD PTR _res$[esp+1060], ebx
$LN10@Load@15:

; 132  : 		xr_delete		(m_rgb);

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, ebx
	mov	ebp, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	je	SHORT $LN46@Load@15
	push	eax
	call	___RTCastToVoid
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx]
	add	esp, 4
	mov	edi, eax
	mov	eax, DWORD PTR [edx]
	push	ebx
	call	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edi
	call	ebp
	mov	DWORD PTR [esi+4], ebx
$LN46@Load@15:

; 133  : 		xr_delete		(m_alpha);

	mov	eax, DWORD PTR [esi+8]
	cmp	eax, ebx
	je	SHORT $LN51@Load@15
	push	eax
	call	___RTCastToVoid
	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [ecx]
	add	esp, 4
	mov	edi, eax
	mov	eax, DWORD PTR [edx]
	push	ebx
	call	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edi
	call	ebp
	mov	DWORD PTR [esi+8], ebx
$LN51@Load@15:

; 134  : 	}
; 135  : 	if(res){

	mov	eax, DWORD PTR _res$[esp+1060]
	cmp	eax, ebx
	pop	edi
	pop	ebp
	je	SHORT $LN5@Load@15

; 136  : 		//	TODO: get shader version here for theora surface
; 137  : 		//VERIFY(0);
; 138  : 		
; 139  : 		//u32		v_dev	= CAP_VERSION(HW.Caps.raster_major, HW.Caps.raster_minor);
; 140  : 		//u32		v_need	= CAP_VERSION(2,0);
; 141  : 		//bShaderYUV2RGB = (v_dev>=v_need);
; 142  : #ifndef _EDITOR
; 143  : 		R_ASSERT(Device.m_pRender);

	cmp	BYTE PTR ?ignore_always@?BL@??Load@CTheoraSurface@@QAEHPBD@Z@4_NA, bl
	jne	SHORT $LN3@Load@15
	cmp	DWORD PTR ?Device@@3VCRenderDevice@@A+868, ebx
	jne	SHORT $LN3@Load@15
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?BL@??Load@CTheoraSurface@@QAEHPBD@Z@4_NA
	push	OFFSET ??_C@_0BF@INPOMKOH@CTheoraSurface?3?3Load?$AA@
	push	143					; 0000008fH
	push	OFFSET ??_C@_0DJ@HGCCDCCA@D?3?2CLEARSKY?2sources?2engine?2xrEng@
	push	OFFSET ??_C@_0BB@ICMLCGMB@Device?4m_pRender?$AA@
	call	DWORD PTR __imp_?fail@xrDebug@@QAEXPBD0H0AA_N@Z
$LN3@Load@15:

; 144  : 		bShaderYUV2RGB = Device.m_pRender->HWSupportsShaderYUV2RGB();

	mov	ecx, DWORD PTR ?Device@@3VCRenderDevice@@A+868
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+88]
	call	eax
	movzx	ecx, al

; 145  : #else	//	_EDITOR
; 146  : 		bShaderYUV2RGB = false;
; 147  : #endif	//	_EDITOR
; 148  : 
; 149  : 	}
; 150  : 	return				res;

	mov	eax, DWORD PTR _res$[esp+1052]
	mov	DWORD PTR [esi+28], ecx
$LN5@Load@15:
	pop	esi
	pop	ebx

; 151  : }

	add	esp, 1044				; 00000414H
	ret	4
$LN11@Load@15:

; 110  : 		}
; 111  : 	}
; 112  : 	if (res){
; 113  : #ifdef DEBUG
; 114  : 		if (m_alpha){
; 115  : 			VERIFY		(m_rgb->tm_total==m_alpha->tm_total);
; 116  : 			VERIFY		(m_rgb->t_info.frame_width==m_alpha->t_info.frame_width);
; 117  : 			VERIFY		(m_rgb->t_info.frame_height==m_alpha->t_info.frame_height);
; 118  : 			VERIFY		(m_rgb->t_info.pixelformat==m_alpha->t_info.pixelformat);
; 119  : 		}
; 120  : #endif
; 121  : //.		VERIFY3			(btwIsPow2(m_rgb->t_info.frame_width)&&btwIsPow2(m_rgb->t_info.frame_height),"Invalid size.",fname);
; 122  : 		tm_total		= m_rgb->tm_total;

	mov	ecx, DWORD PTR [esi+4]

; 123  : 		VERIFY			(0!=tm_total);
; 124  : 		// reset playback
; 125  : 		Reset			();

	cmp	ecx, ebx
	mov	eax, DWORD PTR [ecx+608]
	mov	DWORD PTR [esi+20], eax
	je	SHORT $LN43@Load@15
	call	?Reset@CTheoraStream@@QAEXXZ		; CTheoraStream::Reset
$LN43@Load@15:
	mov	ecx, DWORD PTR [esi+8]
	cmp	ecx, ebx
	je	SHORT $LN42@Load@15
	call	?Reset@CTheoraStream@@QAEXXZ		; CTheoraStream::Reset
$LN42@Load@15:
	mov	DWORD PTR [esi+16], ebx

; 126  : 		// open SDL video
; 127  : #ifdef SDL_OUTPUT
; 128  : 		open_sdl_video	();
; 129  : #endif
; 130  : 		ready			= TRUE;

	mov	DWORD PTR [esi+24], 1

; 131  : 	}else{

	jmp	$LN51@Load@15
?Load@CTheoraSurface@@QAEHPBD@Z ENDP			; CTheoraSurface::Load
END
